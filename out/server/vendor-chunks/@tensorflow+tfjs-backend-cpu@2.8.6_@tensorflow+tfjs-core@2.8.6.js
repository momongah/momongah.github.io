"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tensorflow+tfjs-backend-cpu@2.8.6_@tensorflow+tfjs-core@2.8.6";
exports.ids = ["vendor-chunks/@tensorflow+tfjs-backend-cpu@2.8.6_@tensorflow+tfjs-core@2.8.6"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@tensorflow+tfjs-backend-cpu@2.8.6_@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-backend-cpu/dist/tf-backend-cpu.node.js":
/*!*****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tensorflow+tfjs-backend-cpu@2.8.6_@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-backend-cpu/dist/tf-backend-cpu.node.js ***!
  \*****************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar tfjsCore = __webpack_require__(/*! @tensorflow/tfjs-core */ \"(ssr)/./node_modules/.pnpm/@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-core/dist/tf-core.node.js\");\nvar seedrandom = __webpack_require__(/*! seedrandom */ \"(ssr)/./node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/index.js\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction assertNotComplex(tensor, opName) {\n    if (!Array.isArray(tensor)) {\n        tensor = [tensor];\n    }\n    tensor.forEach(function (t) {\n        if (t != null) {\n            tfjsCore.util.assert(t.dtype !== 'complex64', function () { return opName + \" does not support complex64 tensors in the CPU backend.\"; });\n        }\n    });\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar whereImpl = tfjsCore.kernel_impls.whereImpl;\nvar MathBackendCPU = /** @class */ (function (_super) {\n    __extends(MathBackendCPU, _super);\n    function MathBackendCPU() {\n        var _this = _super.call(this) || this;\n        _this.blockSize = 48;\n        _this.firstUse = true;\n        _this.data = new tfjsCore.DataStorage(_this, tfjsCore.engine());\n        return _this;\n    }\n    MathBackendCPU.prototype.write = function (values, shape, dtype) {\n        if (this.firstUse) {\n            this.firstUse = false;\n            if (tfjsCore.env().get('IS_NODE')) {\n                tfjsCore.backend_util.warn('\\n============================\\n' +\n                    'Hi there ðŸ‘‹. Looks like you are running TensorFlow.js in ' +\n                    'Node.js. To speed things up dramatically, install our node ' +\n                    'backend, which binds to TensorFlow C++, by running ' +\n                    'npm i @tensorflow/tfjs-node, ' +\n                    'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' +\n                    'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' +\n                    'suffix for CUDA) at the start of your program. ' +\n                    'Visit https://github.com/tensorflow/tfjs-node for more details.' +\n                    '\\n============================');\n            }\n        }\n        var dataId = {};\n        this.data.set(dataId, { values: values, dtype: dtype, refCount: 1 });\n        return dataId;\n    };\n    /**\n     * Create a data bucket in cpu backend.\n     * @param shape Shape of the `TensorInfo`.\n     * @param dtype DType of the `TensorInfo`.\n     * @param values The value of the `TensorInfo` stored as a flattened array.\n     */\n    MathBackendCPU.prototype.makeTensorInfo = function (shape, dtype, values) {\n        var outId;\n        if (dtype === 'string' && values != null && values.length > 0 &&\n            tfjsCore.util.isString(values[0])) {\n            var encodedValues = values.map(function (d) { return tfjsCore.util.encodeString(d); });\n            outId = this.write(encodedValues, shape, dtype);\n        }\n        else {\n            outId = this.write(values, shape, dtype);\n        }\n        return { dataId: outId, shape: shape, dtype: dtype };\n    };\n    /** Increase refCount of a `TensorData`. */\n    MathBackendCPU.prototype.incRef = function (dataId) {\n        var tensorData = this.data.get(dataId);\n        tensorData.refCount++;\n    };\n    /** Decrease refCount of a `TensorData`. */\n    MathBackendCPU.prototype.decRef = function (dataId) {\n        if (this.data.has(dataId)) {\n            var tensorData = this.data.get(dataId);\n            tensorData.refCount--;\n        }\n    };\n    MathBackendCPU.prototype.move = function (dataId, values, shape, dtype) {\n        this.data.set(dataId, { values: values, dtype: dtype, refCount: 1 });\n    };\n    MathBackendCPU.prototype.numDataIds = function () {\n        return this.data.numDataIds();\n    };\n    MathBackendCPU.prototype.read = function (dataId) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.readSync(dataId)];\n            });\n        });\n    };\n    MathBackendCPU.prototype.readSync = function (dataId) {\n        var _a = this.data.get(dataId), dtype = _a.dtype, complexTensorInfos = _a.complexTensorInfos;\n        if (dtype === 'complex64') {\n            var realValues = this.readSync(complexTensorInfos.real.dataId);\n            var imagValues = this.readSync(complexTensorInfos.imag.dataId);\n            return tfjsCore.backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        return this.data.get(dataId).values;\n    };\n    MathBackendCPU.prototype.bufferSync = function (t) {\n        var data = this.readSync(t.dataId);\n        var decodedData = data;\n        if (t.dtype === 'string') {\n            try {\n                // Decode the bytes into string.\n                decodedData = data.map(function (d) { return tfjsCore.util.decodeString(d); });\n            }\n            catch (_a) {\n                throw new Error('Failed to decode encoded string bytes into utf-8');\n            }\n        }\n        return tfjsCore.buffer(t.shape, t.dtype, decodedData);\n    };\n    MathBackendCPU.prototype.makeOutput = function (values, shape, dtype) {\n        var dataId = this.write(values, shape, dtype);\n        return tfjsCore.engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    };\n    MathBackendCPU.prototype.disposeData = function (dataId) {\n        if (this.data.has(dataId)) {\n            var complexTensorInfos = this.data.get(dataId).complexTensorInfos;\n            if (complexTensorInfos != null) {\n                this.disposeData(complexTensorInfos.real.dataId);\n                this.disposeData(complexTensorInfos.imag.dataId);\n            }\n            this.data.delete(dataId);\n        }\n    };\n    MathBackendCPU.prototype.disposeIntermediateTensorInfo = function (tensorInfo) {\n        var dataId = tensorInfo.dataId;\n        if (this.data.has(dataId)) {\n            var tensorData = this.data.get(dataId);\n            tensorData.refCount--;\n            if (tensorData.refCount < 1) {\n                this.disposeData(dataId);\n            }\n        }\n    };\n    MathBackendCPU.prototype.time = function (f) {\n        return __awaiter(this, void 0, void 0, function () {\n            var start, kernelMs;\n            return __generator(this, function (_a) {\n                start = tfjsCore.util.now();\n                f();\n                kernelMs = tfjsCore.util.now() - start;\n                return [2 /*return*/, { kernelMs: kernelMs }];\n            });\n        });\n    };\n    MathBackendCPU.prototype.memory = function () {\n        return {\n            // Unreliable due to automatic gc. The numbers above are cumulative.\n            unreliable: true,\n            reasons: ['The reported memory is an upper bound. Due to automatic garbage ' +\n                    'collection, the true allocated memory may be less.']\n        };\n    };\n    MathBackendCPU.prototype.where = function (condition) {\n        assertNotComplex([condition], 'where');\n        var condVals = this.readSync(condition.dataId);\n        return whereImpl(condition.shape, condVals);\n    };\n    MathBackendCPU.prototype.dispose = function () { };\n    MathBackendCPU.prototype.floatPrecision = function () {\n        return 32;\n    };\n    /** Returns the smallest representable number.  */\n    MathBackendCPU.prototype.epsilon = function () {\n        return _super.prototype.epsilon.call(this);\n    };\n    return MathBackendCPU;\n}(tfjsCore.KernelBackend));\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction simpleAbsImpl(vals) {\n    var resultValues = new Float32Array(vals.length);\n    for (var i = 0; i < vals.length; ++i) {\n        resultValues[i] = Math.abs(vals[i]);\n    }\n    return resultValues;\n}\nvar abs = function (args) {\n    var x = args.inputs.x;\n    var cpuBackend = args.backend;\n    assertNotComplex(x, 'abs');\n    var resultValues = new Float32Array(tfjsCore.util.sizeFromShape(x.shape));\n    var values = cpuBackend.data.get(x.dataId).values;\n    resultValues = simpleAbsImpl(values);\n    return cpuBackend.makeOutput(resultValues, x.shape, 'float32');\n};\nvar absConfig = {\n    kernelName: tfjsCore.Abs,\n    backendName: 'cpu',\n    kernelFunc: abs,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Template that creates implementation for binary ops. Supports broadcast.\n */\nfunction createSimpleBinaryKernelImpl(op) {\n    return function (aShape, bShape, aVals, bVals, dtype) {\n        var newShape = tfjsCore.backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        var resultRank = newShape.length;\n        var resultStrides = tfjsCore.util.computeStrides(newShape);\n        var resultSize = tfjsCore.util.sizeFromShape(newShape);\n        var result = tfjsCore.util.getTypedArrayFromDType(dtype, resultSize);\n        var aRank = aShape.length;\n        var bRank = bShape.length;\n        var aStrides = tfjsCore.util.computeStrides(aShape);\n        var bStrides = tfjsCore.util.computeStrides(bShape);\n        var aBroadcastDims = tfjsCore.backend_util.getBroadcastDims(aShape, newShape);\n        var bBroadcastDims = tfjsCore.backend_util.getBroadcastDims(bShape, newShape);\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (var i = 0; i < result.length; ++i) {\n                result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n            }\n        }\n        else {\n            var _loop_1 = function (i) {\n                var loc = tfjsCore.util.indexToLoc(i, resultRank, resultStrides);\n                var aLoc = loc.slice(-aRank);\n                aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });\n                var aIndex = tfjsCore.util.locToIndex(aLoc, aRank, aStrides);\n                var bLoc = loc.slice(-bRank);\n                bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });\n                var bIndex = tfjsCore.util.locToIndex(bLoc, bRank, bStrides);\n                result[i] = op(aVals[aIndex], bVals[bIndex]);\n            };\n            for (var i = 0; i < result.length; ++i) {\n                _loop_1(i);\n            }\n        }\n        return [result, newShape];\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction complex(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var real = inputs.real, imag = inputs.imag;\n    var realVals = backend.data.get(real.dataId).values;\n    var imagVals = backend.data.get(imag.dataId).values;\n    var complexInfo = backend.makeTensorInfo(real.shape, 'complex64');\n    var complex = backend.data.get(complexInfo.dataId);\n    // The complex tensor owns the underlying real and imag tensorInfos, only the\n    // complex tensor tracks refCount, when complexData is disposed the\n    // underlying tensorData will be disposed.\n    complex.complexTensorInfos = {\n        real: backend.makeTensorInfo(real.shape, 'float32', realVals),\n        imag: backend.makeTensorInfo(imag.shape, 'float32', imagVals)\n    };\n    return complexInfo;\n}\nvar complexConfig = {\n    kernelName: tfjsCore.Complex,\n    backendName: 'cpu',\n    kernelFunc: complex\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Generates a tensorInfo with all zeros value.\n * @param backend cpu backend.\n * @param shape Shape for the zeros tensor.\n * @param dtype Optional. If set, the result has this dtype.\n */\nfunction zeros(backend, shape, dtype) {\n    if (dtype === void 0) { dtype = 'float32'; }\n    if (dtype === 'complex64') {\n        var real = zeros(backend, shape, 'float32');\n        var imag = zeros(backend, shape, 'float32');\n        return complex({ inputs: { real: real, imag: imag }, backend: backend });\n    }\n    var values = tfjsCore.util.makeZerosTypedArray(tfjsCore.util.sizeFromShape(shape), dtype);\n    return backend.makeTensorInfo(shape, dtype, values);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction identity(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    backend.incRef(x.dataId);\n    return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };\n}\nvar identityConfig = {\n    kernelName: tfjsCore.Identity,\n    backendName: 'cpu',\n    kernelFunc: identity\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction real(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var input = inputs.input;\n    var real = backend.data.get(input.dataId).complexTensorInfos.real;\n    var realVal = backend.data.get(real.dataId).values;\n    // When complex tensor is disposed, its underlying parts will be disposed too.\n    // Make new tensor out of the real value of the complex. This makes sure the\n    // value is still accessible even if complex tensor is disposed.\n    return backend.makeTensorInfo(real.shape, real.dtype, realVal);\n}\nvar realConfig = {\n    kernelName: tfjsCore.Real,\n    backendName: 'cpu',\n    kernelFunc: real\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction cast(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var dtype = attrs.dtype;\n    // Casting to complex64.\n    if (dtype === 'complex64') {\n        if (x.dtype === 'complex64') {\n            return identity({ inputs: { x: x }, backend: backend });\n        }\n        var zerosTensorInfo = zeros(backend, x.shape, x.dtype);\n        var floatX = cast({ inputs: { x: x }, backend: backend, attrs: { dtype: 'float32' } });\n        var result = complex({ inputs: { real: floatX, imag: zerosTensorInfo }, backend: backend });\n        backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n        backend.disposeIntermediateTensorInfo(floatX);\n        return result;\n    }\n    // Casting from complex64\n    if (x.dtype === 'complex64') {\n        var realPart = real({ inputs: { input: x }, backend: backend });\n        var result = cast({ inputs: { x: realPart }, backend: backend, attrs: { dtype: dtype } });\n        backend.disposeIntermediateTensorInfo(realPart);\n        return result;\n    }\n    if (!tfjsCore.util.hasEncodingLoss(x.dtype, dtype)) {\n        // We don't change the underlying data, since we cast to higher\n        // precision.\n        var result = identity({ inputs: { x: x }, backend: backend });\n        return { dataId: result.dataId, shape: result.shape, dtype: dtype };\n    }\n    if (dtype === 'int32') {\n        var values = backend.data.get(x.dataId).values;\n        var resultValues = Int32Array.from(values);\n        return backend.makeTensorInfo(x.shape, 'int32', resultValues);\n    }\n    if (dtype === 'bool') {\n        // This is essentially the result of notEqual(x, 0). We avoid using\n        // kernel notEqual to avoid circular dependency, i.e. binary_utils ->\n        // cast -> notEqual -> binary_utils.\n        var xVals = backend.data.get(x.dataId).values;\n        var zero = tfjsCore.util.toTypedArray([0], x.dtype);\n        var _a = createSimpleBinaryKernelImpl(function (a, b) { return (a !== b) ? 1 : 0; })(x.shape, [], xVals, zero, 'bool'), resultData = _a[0], resultShape = _a[1];\n        return backend.makeTensorInfo(resultShape, 'bool', resultData);\n    }\n    throw new Error(\"Error in Cast: failed to cast \" + x.dtype + \" to \" + dtype);\n}\nvar castConfig = {\n    kernelName: tfjsCore.Cast,\n    backendName: 'cpu',\n    kernelFunc: cast\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param name Kernel name.\n * @param binaryKernelImpl A `SimpleBinaryKernelImpl` for the kernel.\n * @param binaryKernelComplexImpl Optional. If exists, represents a\n *     `ComplexBinaryKernelImpl` for the kernel, will be used when input dtype\n *     is `complex64`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nfunction binaryKernelFunc(name, simpleImpl, complexImpl, dtype) {\n    if (complexImpl == null) {\n        return function (_a) {\n            var inputs = _a.inputs, backend = _a.backend;\n            var _b = inputs, a = _b.a, b = _b.b;\n            var cpuBackend = backend;\n            assertNotComplex([a, b], name);\n            var aVals = cpuBackend.data.get(a.dataId).values;\n            var bVals = cpuBackend.data.get(b.dataId).values;\n            var $dtype = dtype || a.dtype;\n            var _c = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype), resultData = _c[0], resultShape = _c[1];\n            return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);\n        };\n    }\n    return function (_a) {\n        var inputs = _a.inputs, backend = _a.backend;\n        var _b = inputs, a = _b.a, b = _b.b;\n        var cpuBackend = backend;\n        if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n            var $aComplex = cast({ inputs: { x: a }, backend: cpuBackend, attrs: { dtype: 'complex64' } });\n            var $aComplexVals = cpuBackend.data.get($aComplex.dataId);\n            var aReal = $aComplexVals.complexTensorInfos.real;\n            var aImag = $aComplexVals.complexTensorInfos.imag;\n            var aRealVals = cpuBackend.data.get(aReal.dataId).values;\n            var aImagVals = cpuBackend.data.get(aImag.dataId).values;\n            var $bComplex = cast({ inputs: { x: b }, backend: cpuBackend, attrs: { dtype: 'complex64' } });\n            var $bComplexVals = cpuBackend.data.get($bComplex.dataId);\n            var bReal = $bComplexVals.complexTensorInfos.real;\n            var bImag = $bComplexVals.complexTensorInfos.imag;\n            var bRealVals = cpuBackend.data.get(bReal.dataId).values;\n            var bImagVals = cpuBackend.data.get(bImag.dataId).values;\n            var _c = complexImpl(a.shape, b.shape, aRealVals, aImagVals, bRealVals, bImagVals), resultRealData = _c[0], resultImagData = _c[1], resultShape = _c[2];\n            var resultReal = cpuBackend.makeTensorInfo(resultShape, 'float32', resultRealData);\n            var resultImag = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImagData);\n            var result = complex({ inputs: { real: resultReal, imag: resultImag }, backend: cpuBackend });\n            cpuBackend.disposeIntermediateTensorInfo($aComplex);\n            cpuBackend.disposeIntermediateTensorInfo($bComplex);\n            cpuBackend.disposeIntermediateTensorInfo(resultReal);\n            cpuBackend.disposeIntermediateTensorInfo(resultImag);\n            return result;\n        }\n        else {\n            var aVals = cpuBackend.data.get(a.dataId).values;\n            var bVals = cpuBackend.data.get(b.dataId).values;\n            var $dtype = dtype || a.dtype;\n            var _d = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype), resultData = _d[0], resultShape = _d[1];\n            return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);\n        }\n    };\n}\n/**\n * Template that creates the complex type implementation for binary ops.\n * Supports broadcast.\n */\nfunction createComplexBinaryKernelImpl(op) {\n    return function (aShape, bShape, aRealVals, aImagVals, bRealVals, bImagVals) {\n        var resultShape = tfjsCore.backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        var resultSize = tfjsCore.util.sizeFromShape(resultShape);\n        var resultRank = resultShape.length;\n        var resultStrides = tfjsCore.util.computeStrides(resultShape);\n        var resultRealVals = tfjsCore.util.getTypedArrayFromDType('float32', resultSize);\n        var resultImagVals = tfjsCore.util.getTypedArrayFromDType('float32', resultSize);\n        var aBroadcastDims = tfjsCore.backend_util.getBroadcastDims(aShape, resultShape);\n        var bBroadcastDims = tfjsCore.backend_util.getBroadcastDims(bShape, resultShape);\n        var aVals = tfjsCore.backend_util.mergeRealAndImagArrays(aRealVals, aImagVals);\n        var bVals = tfjsCore.backend_util.mergeRealAndImagArrays(bRealVals, bImagVals);\n        var aRank = aShape.length;\n        var aStrides = tfjsCore.util.computeStrides(aShape);\n        var bRank = bShape.length;\n        var bStrides = tfjsCore.util.computeStrides(bShape);\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (var i = 0; i < resultRealVals.length; i++) {\n                var aIdx = i % aVals.length;\n                var bIdx = i % bVals.length;\n                var result = op(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);\n                resultRealVals[i] = result.real;\n                resultImagVals[i] = result.imag;\n            }\n        }\n        else {\n            var _loop_1 = function (i) {\n                var loc = tfjsCore.util.indexToLoc(i, resultRank, resultStrides);\n                var aLoc = loc.slice(-aRank);\n                aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });\n                var aIndex = tfjsCore.util.locToIndex(aLoc, aRank, aStrides);\n                var bLoc = loc.slice(-bRank);\n                bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });\n                var bIndex = tfjsCore.util.locToIndex(bLoc, bRank, bStrides);\n                var opResult = op(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);\n                resultRealVals[i] = opResult.real;\n                resultImagVals[i] = opResult.imag;\n            };\n            for (var i = 0; i < resultRealVals.length; i++) {\n                _loop_1(i);\n            }\n        }\n        return [resultRealVals, resultImagVals, resultShape];\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar addImpl = createSimpleBinaryKernelImpl((function (a, b) { return a + b; }));\nvar addComplexImpl = createComplexBinaryKernelImpl((function (aReal, aImag, bReal, bImag) {\n    return { real: aReal + bReal, imag: aImag + bImag };\n}));\nvar add = binaryKernelFunc(tfjsCore.Add, addImpl, addComplexImpl);\nvar addConfig = {\n    kernelName: tfjsCore.Add,\n    backendName: 'cpu',\n    kernelFunc: add\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction bincountImpl(xVals, weightsVals, weightsDtype, weightsShape, size) {\n    var weightsSize = tfjsCore.util.sizeFromShape(weightsShape);\n    var outVals = tfjsCore.util.makeZerosTypedArray(size, weightsDtype);\n    for (var i = 0; i < xVals.length; i++) {\n        var value = xVals[i];\n        if (value < 0) {\n            throw new Error('Input x must be non-negative!');\n        }\n        if (value >= size) {\n            continue;\n        }\n        if (weightsSize > 0) {\n            outVals[value] += weightsVals[i];\n        }\n        else {\n            outVals[value] += 1;\n        }\n    }\n    return outVals;\n}\nfunction bincountReduceImpl(xBuf, weightsBuf, size, binaryOutput) {\n    if (binaryOutput === void 0) { binaryOutput = false; }\n    var numRows = xBuf.shape[0];\n    var numCols = xBuf.shape[1];\n    var outBuf = tfjsCore.buffer([numRows, size], weightsBuf.dtype);\n    for (var i = 0; i < numRows; i++) {\n        for (var j = 0; j < numCols; j++) {\n            var value = xBuf.get(i, j);\n            if (value < 0) {\n                throw new Error('Input x must be non-negative!');\n            }\n            if (value >= size) {\n                continue;\n            }\n            if (binaryOutput) {\n                outBuf.set(1, i, value);\n            }\n            else {\n                if (weightsBuf.size > 0) {\n                    outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j), i, value);\n                }\n                else {\n                    outBuf.set(outBuf.get(i, value) + 1, i, value);\n                }\n            }\n        }\n    }\n    return outBuf;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Template that creates implementation for unary op.\n */\nfunction createSimpleUnaryImpl(op) {\n    return function (values, dtype, attrs) {\n        var newValues = tfjsCore.util.getTypedArrayFromDType(dtype, values.length);\n        for (var i = 0; i < values.length; ++i) {\n            newValues[i] = op(values[i], attrs);\n        }\n        return newValues;\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param name Kernel name.\n * @param op A `SimpleUnaryOperation` for the kernel.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the input. This is mainly used in certain\n *     kernels that return bool type, such as isFinite, isInf, etc.\n */\nfunction unaryKernelFunc(name, op, dtype) {\n    return function (_a) {\n        var inputs = _a.inputs, attrs = _a.attrs, backend = _a.backend;\n        var x = inputs.x;\n        assertNotComplex(x, name);\n        if (x.dtype === 'string' || dtype === 'string') {\n            throw new Error('unaryKernelFunc does not support string input/output');\n        }\n        var cpuBackend = backend;\n        var values = cpuBackend.data.get(x.dataId).values;\n        var xSize = tfjsCore.util.sizeFromShape(x.shape);\n        var $dtype = dtype || x.dtype;\n        var newValues = tfjsCore.util.getArrayFromDType($dtype, xSize);\n        for (var i = 0; i < xSize; ++i) {\n            newValues[i] = op(values[i], attrs);\n        }\n        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);\n    };\n}\n/**\n * Template that creates a `KernelFunc` for unary ops from the given\n * `SimpleUnaryImpl`..\n * @param name Kernel name.\n * @param unaryImpl A `SimpleUnaryImpl` that implements the op.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the input. This is mainly used in certain\n *     kernels that return bool type, such as isFinite, isInf, etc.\n */\nfunction unaryKernelFuncFromImpl(name, unaryImpl, dtype) {\n    return function (_a) {\n        var inputs = _a.inputs, attrs = _a.attrs, backend = _a.backend;\n        var x = inputs.x;\n        assertNotComplex(x, name);\n        if (x.dtype === 'string' || dtype === 'string') {\n            throw new Error('unaryKernelFunc does not support string input/output');\n        }\n        var cpuBackend = backend;\n        var values = cpuBackend.data.get(x.dataId).values;\n        var $dtype = dtype || x.dtype;\n        var newValues = unaryImpl(values, $dtype, attrs);\n        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ceilImpl = createSimpleUnaryImpl(function (xi) { return Math.ceil(xi); });\nvar ceil = unaryKernelFuncFromImpl(tfjsCore.Ceil, ceilImpl);\nvar ceilConfig = {\n    kernelName: tfjsCore.Ceil,\n    backendName: 'cpu',\n    kernelFunc: ceil,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction concatImpl(inputs, outShape, dtype, simplyConcat) {\n    var outVals = tfjsCore.util.getArrayFromDType(dtype, tfjsCore.util.sizeFromShape(outShape));\n    if (simplyConcat && dtype !== 'string') {\n        // Use built-in TypedArray.set() method for speed.\n        var offset_1 = 0;\n        inputs.forEach(function (input) {\n            var size = tfjsCore.util.sizeFromShape(input.shape);\n            outVals.set(input.vals, offset_1);\n            offset_1 += size;\n        });\n    }\n    else {\n        var colOffset_1 = 0;\n        inputs.forEach(function (input) {\n            var decodedData = dtype === 'string' ?\n                tfjsCore.backend_util.fromUint8ToStringArray(input.vals) :\n                input.vals;\n            var tIdx = 0;\n            for (var row = 0; row < input.shape[0]; ++row) {\n                var resIdx = row * outShape[1] + colOffset_1;\n                for (var col = 0; col < input.shape[1]; ++col) {\n                    outVals[resIdx + col] = decodedData[tIdx++];\n                }\n            }\n            colOffset_1 += input.shape[1];\n        });\n    }\n    return outVals;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar expImpl = createSimpleUnaryImpl(function (xi) { return Math.exp(xi); });\nvar exp = unaryKernelFuncFromImpl(tfjsCore.Exp, expImpl);\nvar expConfig = {\n    kernelName: tfjsCore.Exp,\n    backendName: 'cpu',\n    kernelFunc: exp,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar expm1Impl = createSimpleUnaryImpl(function (xi) { return Math.expm1(xi); });\nvar expm1 = unaryKernelFuncFromImpl(tfjsCore.Expm1, expm1Impl);\nvar expm1Config = {\n    kernelName: tfjsCore.Expm1,\n    backendName: 'cpu',\n    kernelFunc: expm1,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar floorImpl = createSimpleUnaryImpl(function (xi) { return Math.floor(xi); });\nvar floor = unaryKernelFuncFromImpl(tfjsCore.Floor, floorImpl);\nvar floorConfig = {\n    kernelName: tfjsCore.Floor,\n    backendName: 'cpu',\n    kernelFunc: floor,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction gatherV2Impl(xBuf, indicesBuf, flattenOutputShape) {\n    var outBuf = tfjsCore.buffer(flattenOutputShape, xBuf.dtype);\n    for (var i = 0; i < outBuf.size; ++i) {\n        var newLoc = outBuf.indexToLoc(i);\n        var originalLoc = newLoc.slice();\n        var batchIdx = originalLoc[0];\n        var indicesIdx = originalLoc[2];\n        var indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);\n        originalLoc[2] = indicesBuf.values[indicesIndex];\n        var originalIndex = xBuf.locToIndex(originalLoc);\n        outBuf.values[i] = xBuf.values[originalIndex];\n    }\n    return outBuf;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar greaterImpl = createSimpleBinaryKernelImpl(function (a, b) { return (a > b) ? 1 : 0; });\nvar greater = binaryKernelFunc(tfjsCore.Greater, greaterImpl, null /* complexImpl */, 'bool');\nvar greaterConfig = {\n    kernelName: tfjsCore.Greater,\n    backendName: 'cpu',\n    kernelFunc: greater\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar lessImpl = createSimpleBinaryKernelImpl(function (a, b) { return (a < b) ? 1 : 0; });\nvar less = binaryKernelFunc(tfjsCore.Less, lessImpl, null /* complexImpl */, 'bool');\nvar lessConfig = {\n    kernelName: tfjsCore.Less,\n    backendName: 'cpu',\n    kernelFunc: less\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction linSpaceImpl(start, stop, num) {\n    var step = (stop - start) / (num - 1);\n    var values = tfjsCore.util.makeZerosTypedArray(num, 'float32');\n    values[0] = start;\n    for (var i = 1; i < values.length; i++) {\n        values[i] = values[i - 1] + step;\n    }\n    return values;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar logImpl = createSimpleUnaryImpl(function (xi) { return Math.log(xi); });\nvar log = unaryKernelFuncFromImpl(tfjsCore.Log, logImpl);\nvar logConfig = {\n    kernelName: tfjsCore.Log,\n    backendName: 'cpu',\n    kernelFunc: log,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxImpl(aVals, reduceSize, outShape, dtype) {\n    var vals = tfjsCore.util.getTypedArrayFromDType(dtype, tfjsCore.util.sizeFromShape(outShape));\n    for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var max = aVals[offset];\n        for (var j = 0; j < reduceSize; ++j) {\n            var value = aVals[offset + j];\n            if (value > max) {\n                max = value;\n            }\n        }\n        vals[i] = max;\n    }\n    return vals;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar maximumImpl = createSimpleBinaryKernelImpl((function (aValue, bValue) { return Math.max(aValue, bValue); }));\nvar maximum = binaryKernelFunc(tfjsCore.Maximum, maximumImpl);\nvar maximumConfig = {\n    kernelName: tfjsCore.Maximum,\n    backendName: 'cpu',\n    kernelFunc: maximum\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar minimumImpl = createSimpleBinaryKernelImpl((function (aValue, bValue) { return Math.min(aValue, bValue); }));\nvar minimum = binaryKernelFunc(tfjsCore.Minimum, minimumImpl);\nvar minimumConfig = {\n    kernelName: tfjsCore.Minimum,\n    backendName: 'cpu',\n    kernelFunc: minimum\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar multiplyImpl = createSimpleBinaryKernelImpl((function (aValue, bValue) { return aValue * bValue; }));\nvar multiplyComplexImpl = createComplexBinaryKernelImpl((function (aReal, aImag, bReal, bImag) {\n    return {\n        real: aReal * bReal - aImag * bImag,\n        imag: aReal * bImag + aImag * bReal\n    };\n}));\nvar multiply = binaryKernelFunc(tfjsCore.Multiply, multiplyImpl, multiplyComplexImpl);\nvar multiplyConfig = {\n    kernelName: tfjsCore.Multiply,\n    backendName: 'cpu',\n    kernelFunc: multiply\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction negImpl(xVals, xShape, xDtype) {\n    var minusOne = tfjsCore.util.createScalarValue(-1, xDtype);\n    return multiplyImpl([], xShape, minusOne, xVals, xDtype);\n}\nfunction neg(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    assertNotComplex(x, 'neg');\n    var xVals = backend.data.get(x.dataId).values;\n    var _a = negImpl(xVals, x.shape, x.dtype), res = _a[0], newShape = _a[1];\n    return backend.makeTensorInfo(newShape, x.dtype, res);\n}\nvar negConfig = {\n    kernelName: tfjsCore.Neg,\n    backendName: 'cpu',\n    kernelFunc: neg\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar notEqualImpl = createSimpleBinaryKernelImpl((function (a, b) { return (a !== b) ? 1 : 0; }));\nvar notEqual = binaryKernelFunc(tfjsCore.NotEqual, notEqualImpl, null /* complexOp */, 'bool');\nvar notEqualConfig = {\n    kernelName: tfjsCore.NotEqual,\n    backendName: 'cpu',\n    kernelFunc: notEqual\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction transposeImpl(xVals, xShape, dtype, perm, newShape) {\n    var xRank = xShape.length;\n    var xSize = tfjsCore.util.sizeFromShape(xShape);\n    var xStrides = tfjsCore.util.computeStrides(xShape);\n    var newStrides = tfjsCore.util.computeStrides(newShape);\n    var result = tfjsCore.util.getTypedArrayFromDType(dtype, tfjsCore.util.sizeFromShape(newShape));\n    for (var i = 0; i < xSize; ++i) {\n        var loc = tfjsCore.util.indexToLoc(i, xRank, xStrides);\n        // Permute location.\n        var newLoc = new Array(loc.length);\n        for (var i_1 = 0; i_1 < newLoc.length; i_1++) {\n            newLoc[i_1] = loc[perm[i_1]];\n        }\n        var newIndex = tfjsCore.util.locToIndex(newLoc, xRank, newStrides);\n        result[newIndex] = xVals[i];\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction transpose(args) {\n    var inputs = args.inputs, attrs = args.attrs, backend = args.backend;\n    var x = inputs.x;\n    var perm = attrs.perm;\n    assertNotComplex(x, 'transpose');\n    var xRank = x.shape.length;\n    var newShape = new Array(xRank);\n    for (var i = 0; i < newShape.length; i++) {\n        newShape[i] = x.shape[perm[i]];\n    }\n    var values = backend.data.get(x.dataId).values;\n    var result = transposeImpl(values, x.shape, x.dtype, perm, newShape);\n    var dataId = backend.write(result, newShape, x.dtype);\n    return { dataId: dataId, shape: newShape, dtype: x.dtype };\n}\nvar transposeConfig = {\n    kernelName: tfjsCore.Transpose,\n    backendName: 'cpu',\n    kernelFunc: transpose\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction prodImpl(xShape, xDtype, xVals, reductionAxes) {\n    var _a = tfjsCore.backend_util.computeOutAndReduceShapes(xShape, reductionAxes), outShape = _a[0], reduceShape = _a[1];\n    var outDtype = tfjsCore.upcastType(xDtype, 'int32');\n    var outVals = tfjsCore.util.makeZerosTypedArray(tfjsCore.util.sizeFromShape(outShape), outDtype);\n    var reduceSize = tfjsCore.util.sizeFromShape(reduceShape);\n    for (var i = 0; i < outVals.length; ++i) {\n        var offset = i * reduceSize;\n        var prod_1 = 1;\n        for (var j = 0; j < reduceSize; ++j) {\n            prod_1 *= xVals[offset + j];\n        }\n        outVals[i] = prod_1;\n    }\n    return { outVals: outVals, outShape: outShape, outDtype: outDtype };\n}\nfunction prod(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, keepDims = attrs.keepDims;\n    assertNotComplex(x, 'prod');\n    var xRank = x.shape.length;\n    var axes = tfjsCore.util.parseAxisParam(axis, x.shape);\n    var permutation = tfjsCore.backend_util.getAxesPermutation(axes, xRank);\n    var reductionAxes = axes;\n    var permutedX = x;\n    var intermediateTensorInfos = [];\n    if (permutation != null) {\n        permutedX = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutation } });\n        intermediateTensorInfos.push(permutedX);\n        reductionAxes = tfjsCore.backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n    }\n    var xVals = backend.data.get(permutedX.dataId).values;\n    var _a = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes), outVals = _a.outVals, outShape = _a.outShape, outDtype = _a.outDtype;\n    var resultShape = outShape;\n    if (keepDims) {\n        resultShape = tfjsCore.backend_util.expandShapeToKeepDim(outShape, axes);\n    }\n    intermediateTensorInfos.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\nvar prodConfig = {\n    kernelName: tfjsCore.Prod,\n    backendName: 'cpu',\n    kernelFunc: prod\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction rangeImpl(start, stop, step, dtype) {\n    var sameStartStop = start === stop;\n    var increasingRangeNegativeStep = start < stop && step < 0;\n    var decreasingRangePositiveStep = stop < start && step > 1;\n    if (sameStartStop || increasingRangeNegativeStep ||\n        decreasingRangePositiveStep) {\n        return tfjsCore.util.makeZerosTypedArray(0, dtype);\n    }\n    var numElements = Math.abs(Math.ceil((stop - start) / step));\n    var values = tfjsCore.util.makeZerosTypedArray(numElements, dtype);\n    if (stop < start && step === 1) {\n        // Auto adjust the step's sign if it hasn't been set\n        // (or was set to 1)\n        step = -1;\n    }\n    values[0] = start;\n    for (var i = 1; i < values.length; i++) {\n        values[i] = values[i - 1] + step;\n    }\n    return values;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar rsqrtImpl = createSimpleUnaryImpl(function (xi) { return 1 / Math.sqrt(xi); });\nvar rsqrt = unaryKernelFuncFromImpl(tfjsCore.Rsqrt, rsqrtImpl);\nvar rsqrtConfig = {\n    kernelName: tfjsCore.Rsqrt,\n    backendName: 'cpu',\n    kernelFunc: rsqrt,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction sliceImpl(vals, begin, size, shape, dtype) {\n    var isContinous = tfjsCore.slice_util.isSliceContinous(shape, begin, size);\n    var length = tfjsCore.util.sizeFromShape(size);\n    var xStrides = tfjsCore.util.computeStrides(shape);\n    if (isContinous) {\n        var flatOffset = tfjsCore.slice_util.computeFlatOffset(begin, xStrides);\n        if (dtype === 'string') {\n            return vals.slice(flatOffset, flatOffset + length);\n        }\n        return vals.subarray(flatOffset, flatOffset + length);\n    }\n    var decodedData = dtype === 'string' ?\n        tfjsCore.backend_util.fromUint8ToStringArray(vals) :\n        vals;\n    var inBuf = tfjsCore.buffer(shape, dtype, decodedData);\n    var outBuf = tfjsCore.buffer(size, dtype);\n    for (var i = 0; i < outBuf.size; ++i) {\n        var outLoc = outBuf.indexToLoc(i);\n        var inLoc = outLoc.map(function (idx, j) { return idx + begin[j]; });\n        outBuf.set.apply(outBuf, [inBuf.get.apply(inBuf, inLoc)].concat(outLoc));\n    }\n    if (dtype === 'string') {\n        return tfjsCore.backend_util.fromStringArrayToUint8(outBuf.values);\n    }\n    return outBuf.values;\n}\nfunction slice(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var begin = attrs.begin, size = attrs.size;\n    assertNotComplex(x, 'slice');\n    var _a = tfjsCore.slice_util.parseSliceParams(x, begin, size), $begin = _a[0], $size = _a[1];\n    tfjsCore.slice_util.assertParamsValid(x, $begin, $size);\n    var vals = backend.data.get(x.dataId).values;\n    var outVals = sliceImpl(vals, $begin, $size, x.shape, x.dtype);\n    return backend.makeTensorInfo($size, x.dtype, outVals);\n}\nvar sliceConfig = {\n    kernelName: tfjsCore.Slice,\n    backendName: 'cpu',\n    kernelFunc: slice\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar squaredDifferenceImpl = createSimpleBinaryKernelImpl((function (a, b) {\n    var diff = a - b;\n    return diff * diff;\n}));\nvar squaredDifference = binaryKernelFunc(tfjsCore.SquaredDifference, squaredDifferenceImpl);\nvar squaredDifferenceConfig = {\n    kernelName: tfjsCore.SquaredDifference,\n    backendName: 'cpu',\n    kernelFunc: squaredDifference\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction stridedSliceImpl(outShape, xBuf, strides, begin) {\n    var outBuf = tfjsCore.buffer(outShape, xBuf.dtype);\n    for (var i = 0; i < outBuf.size; i++) {\n        var loc = outBuf.indexToLoc(i);\n        var newLoc = new Array(loc.length);\n        for (var j = 0; j < newLoc.length; j++) {\n            newLoc[j] = loc[j] * strides[j] + begin[j];\n        }\n        outBuf.set.apply(outBuf, [xBuf.get.apply(xBuf, newLoc)].concat(loc));\n    }\n    return outBuf;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar subImpl = createSimpleBinaryKernelImpl((function (aValue, bValue) { return aValue - bValue; }));\nvar subComplexImpl = createComplexBinaryKernelImpl((function (aReal, aImag, bReal, bImag) {\n    return { real: aReal - bReal, imag: aImag - bImag };\n}));\nvar sub = binaryKernelFunc(tfjsCore.Sub, subImpl, subComplexImpl);\nvar subConfig = {\n    kernelName: tfjsCore.Sub,\n    backendName: 'cpu',\n    kernelFunc: sub\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * An implementation of the tile kernel shared between webgl and cpu for string\n * tensors only.\n */\nfunction tileImpl(xBuf, reps) {\n    var newShape = new Array(xBuf.rank);\n    for (var i = 0; i < newShape.length; i++) {\n        newShape[i] = xBuf.shape[i] * reps[i];\n    }\n    var result = tfjsCore.buffer(newShape, xBuf.dtype);\n    for (var i = 0; i < result.values.length; ++i) {\n        var newLoc = result.indexToLoc(i);\n        var originalLoc = new Array(xBuf.rank);\n        for (var j = 0; j < originalLoc.length; j++) {\n            originalLoc[j] = newLoc[j] % xBuf.shape[j];\n        }\n        var originalIndex = xBuf.locToIndex(originalLoc);\n        result.values[i] = xBuf.values[originalIndex];\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction topKImpl(x, xShape, xDtype, k, sorted) {\n    // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n    var lastDim = xShape[xShape.length - 1];\n    var _a = [x.length / lastDim, lastDim], batch = _a[0], size = _a[1];\n    var allTopKVals = tfjsCore.util.getTypedArrayFromDType(xDtype, batch * k);\n    var allTopKIndices = tfjsCore.util.getTypedArrayFromDType('int32', batch * k);\n    for (var b = 0; b < batch; b++) {\n        var offset = b * size;\n        var vals = x.subarray(offset, offset + size);\n        var valAndInd = [];\n        for (var i = 0; i < vals.length; i++) {\n            valAndInd.push({ value: vals[i], index: i });\n        }\n        valAndInd.sort(function (a, b) { return b.value - a.value; });\n        var outOffset = b * k;\n        var topKVals = allTopKVals.subarray(outOffset, outOffset + k);\n        var topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);\n        for (var i = 0; i < k; i++) {\n            topKVals[i] = valAndInd[i].value;\n            topKIndices[i] = valAndInd[i].index;\n        }\n    }\n    // Reshape back to the original input shape, except that the last\n    // dimension is k.\n    var outputShape = xShape.slice();\n    outputShape[outputShape.length - 1] = k;\n    return [\n        tfjsCore.buffer(outputShape, xDtype, allTopKVals),\n        tfjsCore.buffer(outputShape, 'int32', allTopKIndices)\n    ];\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction uniqueImpl(values, axis, shape, dtype) {\n    // Normalize and validate axis.\n    var $axis = tfjsCore.util.parseAxisParam(axis, shape)[0];\n    // Calculate the new shape that is suitable for extracting data along the\n    // given axis.\n    //\n    // The rank is 3.\n    // The size of the 1st dimension is the size of all the axes < the given axis.\n    // The size of the 2nd dimension is the same as the size of the given axis.\n    // The size of the 3rd dimension is the size of all the axes > the given axis.\n    //\n    // For example, for a 4D tensor with shape=[2, 3, 5, 4] and axis=2, the\n    // newShape would be: [2*3, 5, 4].\n    //\n    // Note that this is not the final output shape. This will be the shape for an\n    // intermediate TensorBuffer (see inputBuffer below) to allow us to extract\n    // values along the given axis. To demonstrate how it works, consider the\n    // following example:\n    //\n    // Input: a 3D tensor, with shape [1, 2, 3]\n    // [\n    //   [\n    //      [1,2,3],\n    //      [4,5,6]\n    //   ]\n    // ]\n    // Axis: 2 (the last axis).\n    // Along axis 2, we expect to extract 3 tensors: [1,4], [2,5], [3,6].\n    //\n    // For this example, newShape would be: [2, 3, 1], where 2 is calculated from\n    // 1*2. The re-shaped data would look like:\n    //\n    // [\n    //   [\n    //     [1], [2], [3]\n    //   ],\n    //   [\n    //     [4], [5], [6]\n    //   ]\n    // ]\n    //\n    // Then, we can construct a 3-level nested loop by the following dimension\n    // order to extract the values along the axis (dimension1):\n    // i: dimension1       // 0,1,2 (newShape[1])\n    //   m: dimension0     // 0,1   (newShape[0])\n    //     n: dimension2   // 0     (newShape[2])\n    //\n    //                       m, i, n\n    //                      ---------\n    // Iteration 0: data at [0, 0, 0] => \"1\"\n    // Iteration 1: data at [1, 0, 0] => \"4\"\n    // We got [1,4].\n    // Iteration 2: data at [0, 1, 0] => \"2\"\n    // Iteration 3: data at [1, 1, 0] => \"5\"\n    // We got [2,5].\n    // Iteration 4: data at [0, 2, 0] => \"3\"\n    // Iteration 5: data at [1, 2, 0] => \"6\"\n    // We got [3,6].\n    var newShape = [1, shape[0], 1];\n    for (var i = 0; i < $axis; i++) {\n        newShape[0] *= shape[i];\n    }\n    newShape[1] = shape[$axis];\n    for (var i = $axis + 1; i < shape.length; i++) {\n        newShape[2] *= shape[i];\n    }\n    // A map from unique elements (their string representations) to their values\n    // in \"indices\" (below).\n    var uniqueElements = {};\n    // The indices of each unique element in the original tensor along the given\n    // axis. It is 1D and has the same size as the given axis.\n    var indices = new Int32Array(shape[$axis]);\n    // Create a buffer so we can easily extract value at a given location.\n    var inputBuffer = new tfjsCore.TensorBuffer(newShape, dtype, values);\n    // The indices along the given axis that have unique elements. This is a\n    // de-duped version of \"indices\" above.\n    var uniqueIndices = [];\n    var is1DTensor = newShape[0] === 1 && newShape[2] === 1;\n    for (var i = 0; i < shape[$axis]; i++) {\n        // Extract values along the axis.\n        var element = void 0;\n        if (is1DTensor) {\n            // Fast path for 1D tensor input.\n            element = values[i].toString();\n        }\n        else {\n            var axisValues = [];\n            for (var m = 0; m < newShape[0]; m++) {\n                for (var n = 0; n < newShape[2]; n++) {\n                    axisValues.push(inputBuffer.get(m, i, n));\n                }\n            }\n            element = axisValues.join(',');\n        }\n        // Dedup and update various indices.\n        if (uniqueElements[element] !== undefined) {\n            indices[i] = uniqueElements[element];\n        }\n        else {\n            var uniqueIndex = Object.keys(uniqueElements).length;\n            uniqueElements[element] = uniqueIndex;\n            indices[i] = uniqueIndex;\n            uniqueIndices.push(i);\n        }\n    }\n    // Now we know where each of the unique elements are located along the axis\n    // (uniqueIndices). Extract them from input buffer and store them in the\n    // output buffer.\n    var outputTmpShape = newShape.slice();\n    outputTmpShape[1] = Object.keys(uniqueElements).length;\n    var outputBuffer = new tfjsCore.TensorBuffer(outputTmpShape, dtype);\n    uniqueIndices.forEach(function (uniqueElementIndex, i) {\n        for (var m = 0; m < newShape[0]; m++) {\n            for (var n = 0; n < newShape[2]; n++) {\n                outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);\n            }\n        }\n    });\n    // The output shape can be calculated from the input shape with the size of\n    // the given axis replaced by the number of unique elements along that axis.\n    var outputShape = shape.slice();\n    outputShape[$axis] = outputTmpShape[1];\n    return {\n        outputValues: outputBuffer.values,\n        outputShape: outputShape,\n        indices: indices,\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar shared = {\n    __proto__: null,\n    simpleAbsImpl: simpleAbsImpl,\n    addImpl: addImpl,\n    bincountImpl: bincountImpl,\n    bincountReduceImpl: bincountReduceImpl,\n    ceilImpl: ceilImpl,\n    concatImpl: concatImpl,\n    expImpl: expImpl,\n    expm1Impl: expm1Impl,\n    floorImpl: floorImpl,\n    gatherV2Impl: gatherV2Impl,\n    greaterImpl: greaterImpl,\n    lessImpl: lessImpl,\n    linSpaceImpl: linSpaceImpl,\n    logImpl: logImpl,\n    maxImpl: maxImpl,\n    maximumImpl: maximumImpl,\n    minimumImpl: minimumImpl,\n    multiplyImpl: multiplyImpl,\n    negImpl: negImpl,\n    notEqualImpl: notEqualImpl,\n    prodImpl: prodImpl,\n    rangeImpl: rangeImpl,\n    rsqrtImpl: rsqrtImpl,\n    sliceImpl: sliceImpl,\n    squaredDifferenceImpl: squaredDifferenceImpl,\n    stridedSliceImpl: stridedSliceImpl,\n    subImpl: subImpl,\n    tileImpl: tileImpl,\n    topKImpl: topKImpl,\n    transposeImpl: transposeImpl,\n    uniqueImpl: uniqueImpl\n};\n\n/** @license See the LICENSE file. */\n// This code is auto-generated, do not modify this file!\nvar version = '2.8.6';\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Side effects for default initialization of MathBackendCPU\ntfjsCore.registerBackend('cpu', function () { return new MathBackendCPU(); }, 1 /* priority */);\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar elu = unaryKernelFunc(tfjsCore.Elu, function (xi) { return xi >= 0 ? xi : (Math.exp(xi) - 1); });\nvar eluConfig = {\n    kernelName: tfjsCore.Elu,\n    backendName: 'cpu',\n    kernelFunc: elu,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction leakyRelu(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var alpha = attrs.alpha;\n    assertNotComplex([x], 'leakyRelu');\n    var xSize = tfjsCore.util.sizeFromShape(x.shape);\n    var xVals = backend.data.get(x.dataId).values;\n    var outVals = tfjsCore.util.getTypedArrayFromDType('float32', xSize);\n    for (var i = 0; i < xVals.length; i++) {\n        outVals[i] = xVals[i] < 0 ? alpha * xVals[i] : xVals[i];\n    }\n    return backend.makeTensorInfo(x.shape, 'float32', outVals);\n}\nvar leakyReluConfig = {\n    kernelName: tfjsCore.LeakyRelu,\n    backendName: 'cpu',\n    kernelFunc: leakyRelu\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar preluImpl = createSimpleBinaryKernelImpl(function (xValue, aValue) { return xValue < 0 ? aValue * xValue : xValue; });\nfunction prelu(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x, alpha = inputs.alpha;\n    assertNotComplex([x, alpha], 'prelu');\n    var aVals = backend.data.get(x.dataId).values;\n    var bVals = backend.data.get(alpha.dataId).values;\n    var _a = preluImpl(x.shape, alpha.shape, aVals, bVals, x.dtype), resultData = _a[0], resultShape = _a[1];\n    return backend.makeTensorInfo(resultShape, x.dtype, resultData);\n}\nvar preluConfig = {\n    kernelName: tfjsCore.Prelu,\n    backendName: 'cpu',\n    kernelFunc: prelu,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar relu = unaryKernelFunc(tfjsCore.Relu, function (xi) { return Math.max(0, xi); });\nvar reluConfig = {\n    kernelName: tfjsCore.Relu,\n    backendName: 'cpu',\n    kernelFunc: relu,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar relu6 = unaryKernelFunc(tfjsCore.Relu6, function (xi) { return Math.min(Math.max(0, xi), 6); });\nvar relu6Config = {\n    kernelName: tfjsCore.Relu6,\n    backendName: 'cpu',\n    kernelFunc: relu6,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction applyActivation(backend, x, activation, preluActivationWeights, leakyreluAlpha) {\n    if (activation === 'linear') {\n        return identity({ inputs: { x: x }, backend: backend });\n    }\n    else if (activation === 'relu') {\n        return relu({ inputs: { x: x }, backend: backend });\n    }\n    else if (activation === 'elu') {\n        return elu({ inputs: { x: x }, backend: backend });\n    }\n    else if (activation === 'relu6') {\n        return relu6({ inputs: { x: x }, backend: backend });\n    }\n    else if (activation === 'prelu') {\n        return prelu({ inputs: { x: x, alpha: preluActivationWeights }, backend: backend });\n    }\n    else if (activation === 'leakyrelu') {\n        return leakyRelu({ inputs: { x: x }, backend: backend, attrs: { alpha: leakyreluAlpha } });\n    }\n    throw new Error(\"Activation \" + activation + \" has not been implemented for the CPU backend.\");\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction reshape(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var shape = attrs.shape;\n    var xSize = tfjsCore.util.sizeFromShape(x.shape);\n    var $shape = tfjsCore.util.inferFromImplicitShape(shape, xSize);\n    var $xSize = tfjsCore.util.sizeFromShape($shape);\n    tfjsCore.util.assert(xSize === $xSize, function () { return \"The new shape (\" + $shape + \") has \" + $xSize + \" elements and the old \" +\n        (\"shape (\" + x.shape + \") has \" + xSize + \" elements. The new shape and old \") +\n        \"shape must have the same number of elements.\"; });\n    backend.incRef(x.dataId);\n    var xData = backend.data.get(x.dataId);\n    if (xData.complexTensorInfos != null) {\n        var real = xData.complexTensorInfos.real;\n        var imag = xData.complexTensorInfos.imag;\n        real.shape = $shape;\n        imag.shape = $shape;\n    }\n    return { dataId: x.dataId, shape: $shape, dtype: x.dtype };\n}\nvar reshapeConfig = {\n    kernelName: tfjsCore.Reshape,\n    backendName: 'cpu',\n    kernelFunc: reshape\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction batchMatMul(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var a = inputs.a, b = inputs.b;\n    var transposeA = attrs.transposeA, transposeB = attrs.transposeB;\n    assertNotComplex([a, b], 'matMul');\n    var aRank = a.shape.length;\n    var bRank = b.shape.length;\n    var innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n    var innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n    var outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n    var outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n    var outerDimsA = a.shape.slice(0, -2);\n    var outerDimsB = b.shape.slice(0, -2);\n    var batchDimA = tfjsCore.util.sizeFromShape(outerDimsA);\n    var batchDimB = tfjsCore.util.sizeFromShape(outerDimsB);\n    var batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;\n    tfjsCore.util.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, function () { return \"Error in matMul: the input batch dimensions must either be the \" +\n        \"same or at least one input batch dimension must be 1. Got input \" +\n        (\"batch dimensions of (\" + outerDimsA + \") and (\" + outerDimsB + \").\"); });\n    var outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);\n    var outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n    tfjsCore.util.assert(innerShapeA === innerShapeB, function () { return \"Error in matMul: inner shapes (\" + innerShapeA + \") and (\" +\n        (innerShapeB + \") of Tensors with shapes \" + a.shape + \" and \") +\n        (b.shape + \" and transposeA=\" + transposeA) +\n        (\" and transposeB=\" + transposeB + \" must match.\"); });\n    var a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] :\n        [batchDimA, outerShapeA, innerShapeA];\n    var b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] :\n        [batchDimB, innerShapeB, outerShapeB];\n    // The rest of the implementation is designed to operate on rank-3 tensors\n    var a3d = reshape({ inputs: { x: a }, backend: backend, attrs: { shape: a3dShape } });\n    var b3d = reshape({ inputs: { x: b }, backend: backend, attrs: { shape: b3dShape } });\n    var sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n    var leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];\n    var rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];\n    var batchDim = Math.max(batchDimA, batchDimB);\n    var a3dValues = backend.data.get(a3d.dataId).values;\n    var b3dValues = backend.data.get(b3d.dataId).values;\n    var a3dStrides = tfjsCore.util.computeStrides(a3d.shape);\n    var b3dStrides = tfjsCore.util.computeStrides(b3d.shape);\n    var _a = transposeA ?\n        [a3dStrides[0], 1, a3dStrides[1]] :\n        [a3dStrides[0], a3dStrides[1], 1], aBatch = _a[0], aOuterStep = _a[1], aInnerStep = _a[2];\n    var _b = transposeB ?\n        [1, b3dStrides[1], b3dStrides[0]] :\n        [b3dStrides[1], 1, b3dStrides[0]], bInnerStep = _b[0], bOuterStep = _b[1], bBatch = _b[2];\n    var size = leftDim * rightDim;\n    var result = tfjsCore.buffer([batchDim, leftDim, rightDim], a3d.dtype);\n    var resVals = result.values;\n    var blockSize = backend.blockSize;\n    for (var bi = 0; bi < batchDim; bi++) {\n        for (var i0 = 0; i0 < leftDim; i0 += blockSize) {\n            for (var j0 = 0; j0 < rightDim; j0 += blockSize) {\n                for (var k0 = 0; k0 < sharedDim; k0 += blockSize) {\n                    // for when blockSize doesn't evenly divide the input\n                    var iBlock = Math.min(i0 + blockSize, leftDim);\n                    var jBlock = Math.min(j0 + blockSize, rightDim);\n                    var kBlock = Math.min(k0 + blockSize, sharedDim);\n                    for (var i = i0; i < iBlock; i++) {\n                        for (var j = j0; j < jBlock; j++) {\n                            var sum = 0.0;\n                            for (var k = k0; k < kBlock; k++) {\n                                var batchOffsetA = Math.min(bi, batchDimA - 1) * aBatch;\n                                var batchOffsetB = Math.min(bi, batchDimB - 1) * bBatch;\n                                var aVal = a3dValues[batchOffsetA + i * aOuterStep + k * aInnerStep];\n                                var bVal = b3dValues[k * bInnerStep + j * bOuterStep + batchOffsetB];\n                                sum += aVal * bVal;\n                            }\n                            resVals[bi * size + (i * rightDim + j)] += sum;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    backend.disposeIntermediateTensorInfo(a3d);\n    backend.disposeIntermediateTensorInfo(b3d);\n    // set correct shape on output.\n    return backend.makeTensorInfo(outShape, result.dtype, result.values);\n}\nvar batchMatMulConfig = {\n    kernelName: tfjsCore.BatchMatMul,\n    backendName: 'cpu',\n    kernelFunc: batchMatMul,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction _fusedMatMul(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var a = inputs.a, b = inputs.b, bias = inputs.bias, preluActivationWeights = inputs.preluActivationWeights;\n    var transposeA = attrs.transposeA, transposeB = attrs.transposeB, activation = attrs.activation, leakyreluAlpha = attrs.leakyreluAlpha;\n    var current;\n    var addRes;\n    var activationRes;\n    var intermediates = [];\n    var matMulRes = batchMatMul({ inputs: { a: a, b: b }, attrs: { transposeA: transposeA, transposeB: transposeB }, backend: backend });\n    current = matMulRes;\n    if (bias) {\n        addRes = add({ inputs: { a: current, b: bias }, backend: backend });\n        intermediates.push(current);\n        current = addRes;\n    }\n    if (activation) {\n        activationRes = applyActivation(backend, current, activation, preluActivationWeights, leakyreluAlpha);\n        intermediates.push(current);\n        current = activationRes;\n    }\n    for (var _i = 0, intermediates_1 = intermediates; _i < intermediates_1.length; _i++) {\n        var i = intermediates_1[_i];\n        backend.disposeIntermediateTensorInfo(i);\n    }\n    return current;\n}\nvar _fusedMatMulConfig = {\n    kernelName: tfjsCore._FusedMatMul,\n    backendName: 'cpu',\n    kernelFunc: _fusedMatMul,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar acos = unaryKernelFunc(tfjsCore.Acos, function (xi) { return Math.acos(xi); });\nvar acosConfig = {\n    kernelName: tfjsCore.Acos,\n    backendName: 'cpu',\n    kernelFunc: acos,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar acosh = unaryKernelFunc(tfjsCore.Acosh, function (xi) { return Math.acosh(xi); });\nvar acoshConfig = {\n    kernelName: tfjsCore.Acosh,\n    backendName: 'cpu',\n    kernelFunc: acosh,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction addN(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var tensors = inputs;\n    assertNotComplex(inputs, 'addN');\n    var vals = tensors.map(function (t) { return backend.data.get(t.dataId).values; });\n    var outBuf = tfjsCore.buffer(tensors[0].shape, tensors[0].dtype);\n    var outVals = outBuf.values;\n    for (var i = 0; i < tensors.length; i++) {\n        var currVals = vals[i];\n        for (var j = 0; j < outVals.length; j++) {\n            outVals[j] += currVals[j];\n        }\n    }\n    return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);\n}\nvar addNConfig = {\n    kernelName: tfjsCore.AddN,\n    backendName: 'cpu',\n    kernelFunc: addN\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction all(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, keepDims = attrs.keepDims;\n    assertNotComplex(x, 'all');\n    var origAxes = tfjsCore.util.parseAxisParam(axis, x.shape);\n    var axes = origAxes;\n    var permutedAxes = tfjsCore.backend_util.getAxesPermutation(axes, x.shape.length);\n    var $x = x;\n    if (permutedAxes != null) {\n        $x = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutedAxes } });\n        axes = tfjsCore.backend_util.getInnerMostAxes(axes.length, x.shape.length);\n    }\n    tfjsCore.backend_util.assertAxesAreInnerMostDims('all', axes, $x.shape.length);\n    var _a = tfjsCore.backend_util.computeOutAndReduceShapes($x.shape, axes), outShape = _a[0], reduceShape = _a[1];\n    var reduceSize = tfjsCore.util.sizeFromShape(reduceShape);\n    var vals = tfjsCore.util.makeZerosTypedArray(tfjsCore.util.sizeFromShape(outShape), $x.dtype);\n    var aVals = backend.data.get($x.dataId).values;\n    for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var all_1 = aVals[offset];\n        for (var j = 0; j < reduceSize; ++j) {\n            var value = aVals[offset + j];\n            all_1 = all_1 && value;\n        }\n        vals[i] = all_1;\n    }\n    if (permutedAxes != null) {\n        backend.disposeIntermediateTensorInfo($x);\n    }\n    var result = backend.makeTensorInfo(outShape, $x.dtype, vals);\n    if (keepDims) {\n        var expandedShape = tfjsCore.backend_util.expandShapeToKeepDim(outShape, origAxes);\n        var reshapedResult = reshape({ inputs: { x: result }, backend: backend, attrs: { shape: expandedShape } });\n        backend.disposeIntermediateTensorInfo(result);\n        return reshapedResult;\n    }\n    return result;\n}\nvar allConfig = {\n    kernelName: tfjsCore.All,\n    backendName: 'cpu',\n    kernelFunc: all\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction any(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, keepDims = attrs.keepDims;\n    assertNotComplex(x, 'any');\n    var origAxes = tfjsCore.util.parseAxisParam(axis, x.shape);\n    var axes = origAxes;\n    var permutedAxes = tfjsCore.backend_util.getAxesPermutation(axes, x.shape.length);\n    var $x = x;\n    if (permutedAxes != null) {\n        $x = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutedAxes } });\n        axes = tfjsCore.backend_util.getInnerMostAxes(axes.length, x.shape.length);\n    }\n    tfjsCore.backend_util.assertAxesAreInnerMostDims('any', axes, $x.shape.length);\n    var _a = tfjsCore.backend_util.computeOutAndReduceShapes($x.shape, axes), outShape = _a[0], reduceShape = _a[1];\n    var reduceSize = tfjsCore.util.sizeFromShape(reduceShape);\n    var vals = tfjsCore.util.makeZerosTypedArray(tfjsCore.util.sizeFromShape(outShape), $x.dtype);\n    var aVals = backend.data.get($x.dataId).values;\n    for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var anyVal = aVals[offset];\n        for (var j = 0; j < reduceSize; ++j) {\n            var value = aVals[offset + j];\n            anyVal = anyVal || value;\n        }\n        vals[i] = anyVal;\n    }\n    if (permutedAxes != null) {\n        backend.disposeIntermediateTensorInfo($x);\n    }\n    var result = backend.makeTensorInfo(outShape, $x.dtype, vals);\n    if (keepDims) {\n        var expandedShape = tfjsCore.backend_util.expandShapeToKeepDim(outShape, origAxes);\n        var reshapedResult = reshape({ inputs: { x: result }, backend: backend, attrs: { shape: expandedShape } });\n        backend.disposeIntermediateTensorInfo(result);\n        return reshapedResult;\n    }\n    return result;\n}\nvar anyConfig = {\n    kernelName: tfjsCore.Any,\n    backendName: 'cpu',\n    kernelFunc: any\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction argMax(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis;\n    assertNotComplex(x, 'argMax');\n    var axes = tfjsCore.util.parseAxisParam(axis, x.shape);\n    var permutedAxes = tfjsCore.backend_util.getAxesPermutation(axes, x.shape.length);\n    var $x = x;\n    var intermediateTensorInfos = [];\n    if (permutedAxes != null) {\n        $x = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutedAxes } });\n        intermediateTensorInfos.push($x);\n        axes = tfjsCore.backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n    }\n    axes = [axes[0]];\n    tfjsCore.backend_util.assertAxesAreInnerMostDims('argMax', axes, $x.shape.length);\n    var _a = tfjsCore.backend_util.computeOutAndReduceShapes($x.shape, axes), outShape = _a[0], reduceShape = _a[1];\n    var outSize = tfjsCore.util.sizeFromShape(outShape);\n    var vals = tfjsCore.util.makeZerosTypedArray(outSize, 'int32');\n    var reduceSize = tfjsCore.util.sizeFromShape(reduceShape);\n    var aVals = backend.data.get($x.dataId).values;\n    for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var max = aVals[offset];\n        var maxIndex = 0;\n        for (var j = 0; j < reduceSize; ++j) {\n            var value = aVals[offset + j];\n            if (value > max) {\n                max = value;\n                maxIndex = j;\n            }\n        }\n        vals[i] = maxIndex;\n    }\n    intermediateTensorInfos.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return backend.makeTensorInfo(outShape, 'int32', vals);\n}\nvar argMaxConfig = {\n    kernelName: tfjsCore.ArgMax,\n    backendName: 'cpu',\n    kernelFunc: argMax\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction argMin(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis;\n    assertNotComplex(x, 'argMin');\n    var axes = tfjsCore.util.parseAxisParam(axis, x.shape);\n    var permutedAxes = tfjsCore.backend_util.getAxesPermutation(axes, x.shape.length);\n    var $x = x;\n    var intermediateTensorInfos = [];\n    if (permutedAxes != null) {\n        $x = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutedAxes } });\n        intermediateTensorInfos.push($x);\n        axes = tfjsCore.backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n    }\n    axes = [axes[0]];\n    tfjsCore.backend_util.assertAxesAreInnerMostDims('argMin', axes, $x.shape.length);\n    var _a = tfjsCore.backend_util.computeOutAndReduceShapes($x.shape, axes), outShape = _a[0], reduceShape = _a[1];\n    var outSize = tfjsCore.util.sizeFromShape(outShape);\n    var vals = tfjsCore.util.makeZerosTypedArray(outSize, 'int32');\n    var reduceSize = tfjsCore.util.sizeFromShape(reduceShape);\n    var aVals = backend.data.get($x.dataId).values;\n    for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var min = aVals[offset];\n        var minIndex = 0;\n        for (var j = 0; j < reduceSize; ++j) {\n            var value = aVals[offset + j];\n            if (value < min) {\n                min = value;\n                minIndex = j;\n            }\n        }\n        vals[i] = minIndex;\n    }\n    intermediateTensorInfos.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return backend.makeTensorInfo(outShape, 'int32', vals);\n}\nvar argMinConfig = {\n    kernelName: tfjsCore.ArgMin,\n    backendName: 'cpu',\n    kernelFunc: argMin\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar asin = unaryKernelFunc(tfjsCore.Asin, function (xi) { return Math.asin(xi); });\nvar asinConfig = {\n    kernelName: tfjsCore.Asin,\n    backendName: 'cpu',\n    kernelFunc: asin,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar asinh = unaryKernelFunc(tfjsCore.Asinh, function (xi) { return Math.asinh(xi); });\nvar asinhConfig = {\n    kernelName: tfjsCore.Asinh,\n    backendName: 'cpu',\n    kernelFunc: asinh,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar atan = unaryKernelFunc(tfjsCore.Atan, function (xi) { return Math.atan(xi); });\nvar atanConfig = {\n    kernelName: tfjsCore.Atan,\n    backendName: 'cpu',\n    kernelFunc: atan,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar atan2Impl = createSimpleBinaryKernelImpl(function (aValue, bValue) { return Math.atan2(aValue, bValue); });\nvar atan2 = binaryKernelFunc(tfjsCore.Atan2, atan2Impl);\nvar atan2Config = {\n    kernelName: tfjsCore.Atan2,\n    backendName: 'cpu',\n    kernelFunc: atan2,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar atanh = unaryKernelFunc(tfjsCore.Atanh, function (xi) { return Math.atanh(xi); });\nvar atanhConfig = {\n    kernelName: tfjsCore.Atanh,\n    backendName: 'cpu',\n    kernelFunc: atanh,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction pool(xValues, xShape, dtype, strides, convInfo, poolType) {\n    var strideHeight = convInfo.strideHeight;\n    var strideWidth = convInfo.strideWidth;\n    var dilationHeight = convInfo.dilationHeight;\n    var dilationWidth = convInfo.dilationWidth;\n    var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    var padTop = convInfo.padInfo.top;\n    var padLeft = convInfo.padInfo.left;\n    var initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n        Number.POSITIVE_INFINITY);\n    var output = tfjsCore.buffer(convInfo.outShape, dtype);\n    var outputVals = output.values;\n    var outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n    var outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n    var outputColStrides = convInfo.outShape[3];\n    for (var b = 0; b < convInfo.batchSize; ++b) {\n        var outputBatchOffset = b * outputBatchStrides;\n        var inputBatchOffset = b * strides[0];\n        for (var d = 0; d < convInfo.inChannels; ++d) {\n            for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n                var xRCorner = yR * strideHeight - padTop;\n                var xRMin = Math.max(0, xRCorner);\n                var xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n                var outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n                for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n                    var xCCorner = yC * strideWidth - padLeft;\n                    var xCMin = Math.max(0, xCCorner);\n                    var xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n                    var minMaxValue = initialValue;\n                    var avgValue = 0;\n                    var count = 0;\n                    for (var xR = xRMin; xR < xRMax; xR += dilationHeight) {\n                        var xROffset = inputBatchOffset + xR * strides[1];\n                        for (var xC = xCMin; xC < xCMax; xC += dilationWidth) {\n                            var xCOffset = xROffset + xC * strides[2];\n                            var pixel = xValues[xCOffset + d];\n                            if ((poolType === 'max' && pixel > minMaxValue)) {\n                                minMaxValue = pixel;\n                            }\n                            else if (poolType === 'avg') {\n                                avgValue += pixel;\n                                count++;\n                            }\n                        }\n                        if (isNaN(minMaxValue)) {\n                            break;\n                        }\n                    }\n                    var outputOffset = outputRowOffset + yC * outputColStrides + d;\n                    outputVals[outputOffset] =\n                        poolType === 'avg' ? avgValue / count : minMaxValue;\n                }\n            }\n        }\n    }\n    return output;\n}\nfunction maxPoolPositions(xValues, xShape, dtype, convInfo, flattenPositions, includeBatchInIndex) {\n    if (flattenPositions === void 0) { flattenPositions = false; }\n    if (includeBatchInIndex === void 0) { includeBatchInIndex = false; }\n    var maxPositions = tfjsCore.buffer(convInfo.outShape, 'int32');\n    var strideHeight = convInfo.strideHeight;\n    var strideWidth = convInfo.strideWidth;\n    var dilationHeight = convInfo.dilationHeight;\n    var dilationWidth = convInfo.dilationWidth;\n    var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    var padTop = convInfo.padInfo.top;\n    var padLeft = convInfo.padInfo.left;\n    var xBuf = tfjsCore.buffer(xShape, dtype, xValues);\n    for (var b = 0; b < convInfo.batchSize; ++b) {\n        for (var d = 0; d < convInfo.inChannels; ++d) {\n            for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n                var xRCorner = yR * strideHeight - padTop;\n                var xRMin = xRCorner;\n                while (xRMin < 0) {\n                    xRMin += dilationHeight;\n                }\n                // const xRMin = Math.max(0, xRCorner);\n                var xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n                for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n                    var xCCorner = yC * strideWidth - padLeft;\n                    var xCMin = xCCorner;\n                    while (xCMin < 0) {\n                        xCMin += dilationWidth;\n                    }\n                    var xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n                    var maxValue = Number.NEGATIVE_INFINITY;\n                    var maxPosition = -1;\n                    for (var xR = xRMin; xR < xRMax; xR += dilationHeight) {\n                        var wR = xR - xRCorner;\n                        for (var xC = xCMin; xC < xCMax; xC += dilationWidth) {\n                            var wC = xC - xCCorner;\n                            var pixel = xBuf.get(b, xR, xC, d);\n                            if (pixel > maxValue) {\n                                maxValue = pixel;\n                                if (flattenPositions) {\n                                    maxPosition = includeBatchInIndex ?\n                                        ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) *\n                                            convInfo.inChannels +\n                                            d :\n                                        (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                                }\n                                else {\n                                    maxPosition = wR * effectiveFilterWidth + wC;\n                                }\n                            }\n                        }\n                    }\n                    maxPositions.set(maxPosition, b, yR, yC, d);\n                }\n            }\n        }\n    }\n    return maxPositions;\n}\nfunction pool3d(xValues, xShape, dtype, strides, convInfo, poolType) {\n    var strideDepth = convInfo.strideDepth;\n    var strideHeight = convInfo.strideHeight;\n    var strideWidth = convInfo.strideWidth;\n    var dilationDepth = convInfo.dilationDepth;\n    var dilationHeight = convInfo.dilationHeight;\n    var dilationWidth = convInfo.dilationWidth;\n    var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    var padFront = convInfo.padInfo.front;\n    var padTop = convInfo.padInfo.top;\n    var padLeft = convInfo.padInfo.left;\n    var initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n        Number.POSITIVE_INFINITY);\n    var output = tfjsCore.buffer(convInfo.outShape, dtype);\n    var outputVals = output.values;\n    var outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] *\n        convInfo.outShape[3] * convInfo.outShape[4];\n    var outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n    var outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n    var outputColStrides = convInfo.outShape[4];\n    for (var batch = 0; batch < convInfo.batchSize; ++batch) {\n        var outputBatchOffset = batch * outputBatchStrides;\n        var inputBatchOffset = batch * strides[0];\n        for (var channel = 0; channel < convInfo.inChannels; ++channel) {\n            for (var yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                var xDepthCorner = yDepth * strideDepth - padFront;\n                var xDepthMin = xDepthCorner;\n                while (xDepthMin < 0) {\n                    xDepthMin += dilationDepth;\n                }\n                var xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                var outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n                for (var yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                    var xRowCorner = yRow * strideHeight - padTop;\n                    var xRowMin = xRowCorner;\n                    while (xRowMin < 0) {\n                        xRowMin += dilationHeight;\n                    }\n                    var xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                    var outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n                    for (var yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                        var xColCorner = yCol * strideWidth - padLeft;\n                        var xColMin = xColCorner;\n                        while (xColMin < 0) {\n                            xColMin += dilationWidth;\n                        }\n                        var xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                        // Shader code begins\n                        var outputColOffset = outputRowOffset + yCol * outputColStrides;\n                        var minMaxValue = initialValue;\n                        var avgValue = 0;\n                        var count = 0;\n                        for (var xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                            var xDepthOffset = inputBatchOffset + xDepth * strides[1];\n                            for (var xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                var xRowOffset = xDepthOffset + xRow * strides[2];\n                                for (var xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                    var xColOffset = xRowOffset + xCol * strides[3];\n                                    var pixel = xValues[xColOffset + channel];\n                                    if ((poolType === 'max' && pixel > minMaxValue)) {\n                                        minMaxValue = pixel;\n                                    }\n                                    else if (poolType === 'avg') {\n                                        avgValue += pixel;\n                                        count++;\n                                    }\n                                    if (isNaN(minMaxValue)) {\n                                        break;\n                                    }\n                                }\n                                if (isNaN(minMaxValue)) {\n                                    break;\n                                }\n                            }\n                            if (isNaN(minMaxValue)) {\n                                break;\n                            }\n                        }\n                        var outputOffset = outputColOffset + channel;\n                        outputVals[outputOffset] =\n                            poolType === 'avg' ? avgValue / count : minMaxValue;\n                    }\n                }\n            }\n        }\n    }\n    return output;\n}\nfunction maxPool3dPositions(xBuf, convInfo) {\n    var maxPositions = tfjsCore.buffer(convInfo.outShape, 'int32');\n    var strideDepth = convInfo.strideDepth;\n    var strideHeight = convInfo.strideHeight;\n    var strideWidth = convInfo.strideWidth;\n    var dilationDepth = convInfo.dilationDepth;\n    var dilationHeight = convInfo.dilationHeight;\n    var dilationWidth = convInfo.dilationWidth;\n    var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    var padFront = convInfo.padInfo.front;\n    var padTop = convInfo.padInfo.top;\n    var padLeft = convInfo.padInfo.left;\n    for (var batch = 0; batch < convInfo.batchSize; ++batch) {\n        for (var channel = 0; channel < convInfo.inChannels; ++channel) {\n            for (var yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                var xDepthCorner = yDepth * strideDepth - padFront;\n                var xDepthMin = xDepthCorner;\n                while (xDepthMin < 0) {\n                    xDepthMin += dilationDepth;\n                }\n                var xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                for (var yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                    var xRowCorner = yRow * strideHeight - padTop;\n                    var xRowMin = xRowCorner;\n                    while (xRowMin < 0) {\n                        xRowMin += dilationHeight;\n                    }\n                    var xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                    for (var yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                        var xColCorner = yCol * strideWidth - padLeft;\n                        var xColMin = xColCorner;\n                        while (xColMin < 0) {\n                            xColMin += dilationWidth;\n                        }\n                        var xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                        // Shader code begins\n                        var maxValue = Number.NEGATIVE_INFINITY;\n                        var maxPosition = -1;\n                        for (var xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                            var wDepth = xDepth - xDepthCorner;\n                            for (var xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                var wRow = xRow - xRowCorner;\n                                for (var xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                    var wCol = xCol - xColCorner;\n                                    var pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n                                    if (pixel >= maxValue) {\n                                        maxValue = pixel;\n                                        maxPosition =\n                                            wDepth * effectiveFilterHeight * effectiveFilterWidth +\n                                                wRow * effectiveFilterHeight + wCol;\n                                    }\n                                }\n                            }\n                        }\n                        maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n                    }\n                }\n            }\n        }\n    }\n    return maxPositions;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction avgPool(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    assertNotComplex(x, 'avgPool');\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode;\n    var dilations = 1;\n    tfjsCore.util.assert(tfjsCore.backend_util.eitherStridesOrDilationsAreOne(strides, dilations), function () { return 'Error in avgPool: Either strides or dilations must be 1. ' +\n        (\"Got strides \" + strides + \" and dilations '\" + dilations + \"'\"); });\n    var convInfo = tfjsCore.backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    var res;\n    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n        tfjsCore.util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n        res = identity({ inputs: { x: x }, backend: backend });\n    }\n    else {\n        var xValues = backend.data.get(x.dataId).values;\n        var strides_1 = tfjsCore.util.computeStrides(x.shape);\n        var buffer = pool(xValues, x.shape, x.dtype, strides_1, convInfo, 'avg');\n        res = backend.makeTensorInfo(convInfo.outShape, x.dtype, buffer.values);\n    }\n    return res;\n}\nvar avgPoolConfig = {\n    kernelName: tfjsCore.AvgPool,\n    backendName: 'cpu',\n    kernelFunc: avgPool\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction avgPool3D(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode, dataFormat = attrs.dataFormat, dilations = attrs.dilations;\n    assertNotComplex(x, 'avgPool3d');\n    var $dilations = dilations;\n    if ($dilations == null) {\n        $dilations = [1, 1, 1];\n    }\n    var convInfo = tfjsCore.backend_util.computePool3DInfo(x.shape, filterSize, strides, $dilations, pad, dimRoundingMode, dataFormat);\n    var xValues = backend.data.get(x.dataId).values;\n    var outBuf = pool3d(xValues, x.shape, x.dtype, tfjsCore.util.computeStrides(x.shape), convInfo, 'avg');\n    return backend.makeTensorInfo(outBuf.shape, 'float32', outBuf.values);\n}\nvar avgPool3DConfig = {\n    kernelName: tfjsCore.AvgPool3D,\n    backendName: 'cpu',\n    kernelFunc: avgPool3D\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction avgPool3DGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, input = inputs.input;\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dilations = attrs.dilations, dimRoundingMode = attrs.dimRoundingMode;\n    assertNotComplex([dy, input], 'avgPool3DGrad');\n    var convInfo = tfjsCore.backend_util.computePool3DInfo(input.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    var strideDepth = convInfo.strideDepth;\n    var strideHeight = convInfo.strideHeight;\n    var strideWidth = convInfo.strideWidth;\n    var filterDepth = convInfo.filterDepth;\n    var filterHeight = convInfo.filterHeight;\n    var filterWidth = convInfo.filterWidth;\n    var dilationDepth = convInfo.dilationDepth;\n    var dilationHeight = convInfo.dilationHeight;\n    var dilationWidth = convInfo.dilationWidth;\n    var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    var padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n    var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    var dx = tfjsCore.buffer(input.shape, 'float32');\n    var avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n    var dyBuf = backend.bufferSync(dy);\n    for (var batch = 0; batch < convInfo.batchSize; ++batch) {\n        for (var channel = 0; channel < convInfo.inChannels; ++channel) {\n            for (var dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n                for (var dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n                    for (var dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n                        // Shader code begins.\n                        var dyDepthCorner = dxDepth - padFront;\n                        var dyRowCorner = dxRow - padTop;\n                        var dyColCorner = dxCol - padLeft;\n                        var dotProd = 0;\n                        for (var wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                            var dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n                            if (dyDepth < 0 || dyDepth >= convInfo.outDepth ||\n                                Math.floor(dyDepth) !== dyDepth) {\n                                continue;\n                            }\n                            for (var wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                                var dyRow = (dyRowCorner + wRow) / strideHeight;\n                                if (dyRow < 0 || dyRow >= convInfo.outHeight ||\n                                    Math.floor(dyRow) !== dyRow) {\n                                    continue;\n                                }\n                                for (var wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                                    var dyCol = (dyColCorner + wCol) / strideWidth;\n                                    if (dyCol < 0 || dyCol >= convInfo.outWidth ||\n                                        Math.floor(dyCol) !== dyCol) {\n                                        continue;\n                                    }\n                                    var pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                    dotProd += pixel;\n                                }\n                            }\n                        }\n                        dx.set(dotProd * avgMultiplier, batch, dxDepth, dxRow, dxCol, channel);\n                    }\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);\n}\nvar avgPool3DGradConfig = {\n    kernelName: tfjsCore.AvgPool3DGrad,\n    backendName: 'cpu',\n    kernelFunc: avgPool3DGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction avgPoolGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, input = inputs.input;\n    var x = input;\n    assertNotComplex([dy, input], 'avgPoolGrad');\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad;\n    var convInfo = tfjsCore.backend_util.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */, pad);\n    var strideHeight = convInfo.strideHeight;\n    var strideWidth = convInfo.strideWidth;\n    var filterHeight = convInfo.filterHeight;\n    var filterWidth = convInfo.filterWidth;\n    var dilationHeight = convInfo.dilationHeight;\n    var dilationWidth = convInfo.dilationWidth;\n    var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n    var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    var dx = tfjsCore.buffer(x.shape, 'float32');\n    var avgMultiplier = 1 / (filterHeight * filterWidth);\n    var dyData = backend.data.get(dy.dataId).values;\n    var dyBuf = tfjsCore.buffer(dy.shape, 'float32', dyData);\n    for (var b = 0; b < convInfo.batchSize; ++b) {\n        for (var d = 0; d < convInfo.inChannels; ++d) {\n            for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {\n                for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {\n                    // Shader code begins.\n                    var dyRCorner = dxR - padTop;\n                    var dyCCorner = dxC - padLeft;\n                    var dotProd = 0;\n                    for (var wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {\n                        var dyR = (dyRCorner + wR) / strideHeight;\n                        if (dyR < 0 || dyR >= convInfo.outHeight ||\n                            Math.floor(dyR) !== dyR) {\n                            continue;\n                        }\n                        for (var wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {\n                            var dyC = (dyCCorner + wC) / strideWidth;\n                            if (dyC < 0 || dyC >= convInfo.outWidth ||\n                                Math.floor(dyC) !== dyC) {\n                                continue;\n                            }\n                            var pixel = dyBuf.get(b, dyR, dyC, d);\n                            dotProd += pixel;\n                        }\n                    }\n                    dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);\n}\nvar avgPoolGradConfig = {\n    kernelName: tfjsCore.AvgPoolGrad,\n    backendName: 'cpu',\n    kernelFunc: avgPoolGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction batchNorm(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, scale = inputs.scale, offset = inputs.offset, mean = inputs.mean, variance = inputs.variance;\n    tfjsCore.util.assert(mean.shape.length === variance.shape.length, function () { return 'Batch normalization gradient requires mean and variance to have ' +\n        'equal ranks.'; });\n    tfjsCore.util.assert(offset == null || mean.shape.length === offset.shape.length, function () { return 'Batch normalization gradient requires mean and offset to have ' +\n        'equal ranks.'; });\n    tfjsCore.util.assert(scale == null || mean.shape.length === scale.shape.length, function () { return 'Batch normalization gradient requires mean and scale to have ' +\n        'equal ranks.'; });\n    assertNotComplex([x, mean, variance, scale, offset], 'batchNorm');\n    var varianceEpsilon = attrs.varianceEpsilon;\n    if (varianceEpsilon == null) {\n        varianceEpsilon = 0.001;\n    }\n    var xVals = backend.data.get(x.dataId).values;\n    var mVals = backend.data.get(mean.dataId).values;\n    var varVals = backend.data.get(variance.dataId).values;\n    var sVals = scale ? backend.data.get(scale.dataId).values :\n        new Float32Array([1]);\n    var offVals = offset ?\n        backend.data.get(offset.dataId).values :\n        new Float32Array([0]);\n    var outVals = new Float32Array(xVals.length);\n    var offValsLength = offVals.length;\n    var sValsLength = sVals.length;\n    var varValsLength = varVals.length;\n    var mValsLength = mVals.length;\n    var offi = 0;\n    var mi = 0;\n    var si = 0;\n    var vi = 0;\n    for (var i = 0; i < xVals.length; ++i) {\n        outVals[i] = offVals[offi++] +\n            (xVals[i] - mVals[mi++]) * sVals[si++] /\n                Math.sqrt(varVals[vi++] + varianceEpsilon);\n        if (offi >= offValsLength) {\n            offi = 0;\n        }\n        if (mi >= mValsLength) {\n            mi = 0;\n        }\n        if (si >= sValsLength) {\n            si = 0;\n        }\n        if (vi >= varValsLength) {\n            vi = 0;\n        }\n    }\n    return backend.makeTensorInfo(x.shape, x.dtype, outVals);\n}\nvar batchNormConfig = {\n    kernelName: tfjsCore.FusedBatchNorm,\n    backendName: 'cpu',\n    kernelFunc: batchNorm,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction batchToSpaceND(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var blockShape = attrs.blockShape, crops = attrs.crops;\n    assertNotComplex([x], 'batchToSpaceND');\n    var prod = blockShape.reduce(function (a, b) { return a * b; });\n    var reshaped = tfjsCore.backend_util.getReshaped(x.shape, blockShape, prod);\n    var permuted = tfjsCore.backend_util.getPermuted(reshaped.length, blockShape.length);\n    var reshapedPermuted = tfjsCore.backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n    var sliceBeginCoords = tfjsCore.backend_util.getSliceBeginCoords(crops, blockShape.length);\n    var sliceSize = tfjsCore.backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n    var xReshaped = reshape({ inputs: { x: x }, backend: backend, attrs: { shape: reshaped } });\n    var xTransposed = transpose({ inputs: { x: xReshaped }, backend: backend, attrs: { perm: permuted } });\n    var xTransposedReshaped = reshape({ inputs: { x: xTransposed }, backend: backend, attrs: { shape: reshapedPermuted } });\n    var result = slice({\n        inputs: { x: xTransposedReshaped },\n        backend: backend,\n        attrs: { begin: sliceBeginCoords, size: sliceSize }\n    });\n    backend.disposeIntermediateTensorInfo(xReshaped);\n    backend.disposeIntermediateTensorInfo(xTransposed);\n    backend.disposeIntermediateTensorInfo(xTransposedReshaped);\n    return result;\n}\nvar batchToSpaceNDConfig = {\n    kernelName: tfjsCore.BatchToSpaceND,\n    backendName: 'cpu',\n    kernelFunc: batchToSpaceND\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction bincount(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, weights = inputs.weights;\n    var size = attrs.size;\n    var xVals = backend.data.get(x.dataId).values;\n    var weightsVals = backend.data.get(weights.dataId).values;\n    var outVals = bincountImpl(xVals, weightsVals, weights.dtype, weights.shape, size);\n    return backend.makeTensorInfo([size], weights.dtype, outVals);\n}\nvar bincountConfig = {\n    kernelName: tfjsCore.Bincount,\n    backendName: 'cpu',\n    kernelFunc: bincount\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar clip = unaryKernelFunc(tfjsCore.ClipByValue, function (xi, attrs) {\n    var clipAttrs = attrs;\n    if (xi > clipAttrs.clipValueMax) {\n        return clipAttrs.clipValueMax;\n    }\n    return xi < clipAttrs.clipValueMin ? clipAttrs.clipValueMin : xi;\n});\nvar clipConfig = {\n    kernelName: tfjsCore.ClipByValue,\n    backendName: 'cpu',\n    kernelFunc: clip,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar complexAbs = function (args) {\n    var x = args.inputs.x;\n    var cpuBackend = args.backend;\n    var resultValues = new Float32Array(tfjsCore.util.sizeFromShape(x.shape));\n    var complexVals = cpuBackend.data.get(x.dataId);\n    var real = complexVals.complexTensorInfos.real;\n    var imag = complexVals.complexTensorInfos.imag;\n    var realVals = cpuBackend.data.get(real.dataId).values;\n    var imagVals = cpuBackend.data.get(imag.dataId).values;\n    for (var i = 0; i < realVals.length; i++) {\n        var real_1 = realVals[i];\n        var imag_1 = imagVals[i];\n        resultValues[i] = Math.hypot(real_1, imag_1);\n    }\n    return cpuBackend.makeOutput(resultValues, x.shape, 'float32');\n};\nvar complexAbsConfig = {\n    kernelName: tfjsCore.ComplexAbs,\n    backendName: 'cpu',\n    kernelFunc: complexAbs,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction imag(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var input = inputs.input;\n    var imag = backend.data.get(input.dataId).complexTensorInfos.imag;\n    var imagVal = backend.data.get(imag.dataId).values;\n    // When complex tensor is disposed, its underlying parts will be disposed too.\n    // Make new tensor out of the imag value of the complex. This makes sure the\n    // value is still accessible even if complex tensor is disposed.\n    return backend.makeTensorInfo(imag.shape, imag.dtype, imagVal);\n}\nvar imagConfig = {\n    kernelName: tfjsCore.Imag,\n    backendName: 'cpu',\n    kernelFunc: imag\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction concat(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var axis = attrs.axis;\n    var $axis = tfjsCore.util.parseAxisParam(axis, inputs[0].shape)[0];\n    var outShape = tfjsCore.backend_util.computeOutShape(inputs.map(function (t) { return t.shape; }), $axis);\n    if (tfjsCore.util.sizeFromShape(outShape) === 0) {\n        return backend.makeTensorInfo(outShape, inputs[0].dtype, []);\n    }\n    // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n    var $inputs = inputs.filter(function (t) { return tfjsCore.util.sizeFromShape(t.shape) > 0; });\n    if ($inputs.length === 1) {\n        return identity({ inputs: { x: $inputs[0] }, backend: backend });\n    }\n    var shapes = $inputs.map(function (t) { return t.shape; });\n    tfjsCore.backend_util.assertParamsConsistent(shapes, $axis);\n    if ($inputs[0].dtype === 'complex64') {\n        var reals = $inputs.map(function (t) { return real({ inputs: { input: t }, backend: backend }); });\n        var imags = $inputs.map(function (t) { return imag({ inputs: { input: t }, backend: backend }); });\n        var realConcated = concat({ inputs: reals, backend: backend, attrs: { axis: $axis } });\n        var imagConcated = concat({ inputs: imags, backend: backend, attrs: { axis: $axis } });\n        var result = complex({ inputs: { real: realConcated, imag: imagConcated }, backend: backend });\n        reals.forEach(function (r) { return backend.disposeIntermediateTensorInfo(r); });\n        imags.forEach(function (i) { return backend.disposeIntermediateTensorInfo(i); });\n        backend.disposeIntermediateTensorInfo(realConcated);\n        backend.disposeIntermediateTensorInfo(imagConcated);\n        return result;\n    }\n    // Any concat of n-dimensional tensors across any axis can be reduced to\n    // a concatenation of two-dimensional tensors across the axis 1 by first\n    // partitioning the axes of the original tensors into those less than the\n    // axis to be concatenated and the rest. Then reshape the tensors\n    // into a two-dimensional tensor by collapsing these two sets of axes and\n    // concatenate the resulting matrices across the axis 1, finally reshaping\n    // the result to have the proper shape.\n    var inputs2D = $inputs.map(function (t) {\n        var innerSize = tfjsCore.util.sizeFromShape(t.shape.slice($axis));\n        var shape = [-1, innerSize];\n        return reshape({ inputs: { x: t }, backend: backend, attrs: { shape: shape } });\n    });\n    var inputsValShapes = inputs2D.map(function (t) {\n        return { vals: backend.data.get(t.dataId).values, shape: t.shape };\n    });\n    // Concats 2d tensors along axis=1.\n    outShape =\n        tfjsCore.backend_util.computeOutShape(inputs2D.map(function (t) { return t.shape; }), 1 /* axis */);\n    var simplyConcat = inputs2D[0].shape[0] === 1;\n    var outVals = concatImpl(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);\n    var finalOutShape = tfjsCore.backend_util.computeOutShape($inputs.map(function (t) { return t.shape; }), $axis);\n    var outInfo = backend.makeTensorInfo(finalOutShape, inputs[0].dtype, outVals);\n    inputs2D.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return outInfo;\n}\nvar concatConfig = {\n    kernelName: tfjsCore.Concat,\n    backendName: 'cpu',\n    kernelFunc: concat\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv2D(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, filter = inputs.filter;\n    var strides = attrs.strides, pad = attrs.pad, dataFormat = attrs.dataFormat, dilations = attrs.dilations, dimRoundingMode = attrs.dimRoundingMode;\n    assertNotComplex([x, filter], 'conv2d');\n    var $dataFormat = tfjsCore.backend_util.convertConv2DDataFormat(dataFormat);\n    var convInfo = tfjsCore.backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false /* depthwise */, $dataFormat);\n    var filterHeight = convInfo.filterHeight;\n    var filterWidth = convInfo.filterWidth;\n    var dilationHeight = convInfo.dilationHeight;\n    var dilationWidth = convInfo.dilationWidth;\n    var padLeft = convInfo.padInfo.left;\n    var padTop = convInfo.padInfo.top;\n    var isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    var y = new tfjsCore.TensorBuffer(convInfo.outShape, x.dtype);\n    var xStrides = tfjsCore.util.computeStrides(x.shape);\n    var filterStrides = tfjsCore.util.computeStrides(filter.shape);\n    var xBatchStride = xStrides[0];\n    var xRowStride = isChannelsLast ? xStrides[1] : xStrides[2];\n    var xColStride = isChannelsLast ? xStrides[2] : 1;\n    var xChannelStride = isChannelsLast ? 1 : xStrides[1];\n    var yBatchStride = y.strides[0];\n    var yRowStride = isChannelsLast ? y.strides[1] : y.strides[2];\n    var yColStride = isChannelsLast ? y.strides[2] : 1;\n    var yChannelStride = isChannelsLast ? 1 : y.strides[1];\n    var xVals = backend.data.get(x.dataId).values;\n    var wVals = backend.data.get(filter.dataId).values;\n    var yVals = y.values;\n    for (var b = 0; b < convInfo.batchSize; ++b) {\n        var xOffset1 = b * xBatchStride;\n        var yOffset1 = b * yBatchStride;\n        for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n            var yOffset2 = yOffset1 + yR * yRowStride;\n            var xRCorner = yR * convInfo.strideHeight - padTop;\n            for (var wR = 0; wR < filterHeight; ++wR) {\n                var xR = xRCorner + wR * dilationHeight;\n                if (xR < 0 || xR >= convInfo.inHeight) {\n                    continue;\n                }\n                var wOffset1 = wR * filterStrides[0];\n                var xOffset2 = xOffset1 + xR * xRowStride;\n                for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n                    var yOffset3 = yOffset2 + yC * yColStride;\n                    var xCCorner = yC * convInfo.strideWidth - padLeft;\n                    for (var wC = 0; wC < filterWidth; ++wC) {\n                        var xC = xCCorner + wC * dilationWidth;\n                        if (xC < 0 || xC >= convInfo.inWidth) {\n                            continue;\n                        }\n                        var wOffset2 = wOffset1 + wC * filterStrides[1];\n                        var xOffset3 = xOffset2 + xC * xColStride;\n                        var wOffset3 = wOffset2;\n                        for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                            var xVal = xVals[xOffset3 + d1 * xChannelStride];\n                            for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                                yVals[yOffset3 + d2 * yChannelStride] +=\n                                    xVal * wVals[wOffset3 + d2];\n                            }\n                            wOffset3 += convInfo.outChannels;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(y.shape, y.dtype, yVals);\n}\nvar conv2DConfig = {\n    kernelName: tfjsCore.Conv2D,\n    backendName: 'cpu',\n    kernelFunc: conv2D\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv2DBackpropFilter(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, dy = inputs.dy;\n    var strides = attrs.strides, pad = attrs.pad, dataFormat = attrs.dataFormat, dimRoundingMode = attrs.dimRoundingMode, filterShape = attrs.filterShape;\n    assertNotComplex([x, dy], 'conv2dBackpropFilter');\n    var $dataFormat = tfjsCore.backend_util.convertConv2DDataFormat(dataFormat);\n    var convInfo = tfjsCore.backend_util.computeConv2DInfo(x.shape, filterShape, strides, 1 /* dilations */, pad, dimRoundingMode, false /* depthwise */, $dataFormat);\n    var strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth;\n    var isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    var dW = new tfjsCore.TensorBuffer(convInfo.filterShape, 'float32');\n    var leftPad = convInfo.padInfo.left;\n    var topPad = convInfo.padInfo.top;\n    var xVals = backend.data.get(x.dataId).values;\n    var dyVals = backend.data.get(dy.dataId).values;\n    var xBuf = new tfjsCore.TensorBuffer(x.shape, x.dtype, xVals);\n    var dyBuf = new tfjsCore.TensorBuffer(dy.shape, dy.dtype, dyVals);\n    for (var wR = 0; wR < filterHeight; ++wR) {\n        var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n        var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n        for (var wC = 0; wC < filterWidth; ++wC) {\n            var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n            var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                    var dotProd = 0;\n                    for (var b = 0; b < convInfo.batchSize; ++b) {\n                        for (var yR = yRMin; yR < yRMax; ++yR) {\n                            var xR = wR + yR * strideHeight - topPad;\n                            for (var yC = yCMin; yC < yCMax; ++yC) {\n                                var xC = wC + yC * strideWidth - leftPad;\n                                if (isChannelsLast) {\n                                    dotProd += xBuf.get(b, xR, xC, d1) *\n                                        dyBuf.get(b, yR, yC, d2);\n                                }\n                                else {\n                                    dotProd += xBuf.get(b, d1, xR, xC) *\n                                        dyBuf.get(b, d2, yR, yC);\n                                }\n                            }\n                        }\n                    }\n                    dW.set(dotProd, wR, wC, d1, d2);\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(dW.shape, dW.dtype, dW.values);\n}\nvar conv2DBackpropFilterConfig = {\n    kernelName: tfjsCore.Conv2DBackpropFilter,\n    backendName: 'cpu',\n    kernelFunc: conv2DBackpropFilter\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv2DBackpropInput(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, filter = inputs.filter;\n    var inputShape = attrs.inputShape, strides = attrs.strides, pad = attrs.pad, dataFormat = attrs.dataFormat, dimRoundingMode = attrs.dimRoundingMode;\n    assertNotComplex([dy, filter], 'conv2dBackpropInput');\n    var filterStrides = tfjsCore.util.computeStrides(filter.shape);\n    var dyStrides = tfjsCore.util.computeStrides(dy.shape);\n    var $dataFormat = tfjsCore.backend_util.convertConv2DDataFormat(dataFormat);\n    var convInfo = tfjsCore.backend_util.computeConv2DInfo(inputShape, filter.shape, strides, 1 /* dilations */, pad, dimRoundingMode, false, $dataFormat);\n    var dx = new tfjsCore.TensorBuffer(convInfo.inShape, 'float32');\n    var dxValues = dx.values;\n    var dyValues = backend.data.get(dy.dataId).values;\n    var fltValues = backend.data.get(filter.dataId).values;\n    var fltS0 = filterStrides[0], fltS1 = filterStrides[1], fltS2 = filterStrides[2];\n    var batchSize = convInfo.batchSize, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels, inHeight = convInfo.inHeight, inWidth = convInfo.inWidth, outChannels = convInfo.outChannels, outHeight = convInfo.outHeight, outWidth = convInfo.outWidth, strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth;\n    $dataFormat = convInfo.dataFormat;\n    var topPad = filterHeight - 1 - convInfo.padInfo.top;\n    var leftPad = filterWidth - 1 - convInfo.padInfo.left;\n    var isChannelsLast = $dataFormat === 'channelsLast';\n    var xBatchStride = dx.strides[0];\n    var xRowStride = isChannelsLast ? dx.strides[1] : dx.strides[2];\n    var xColStride = isChannelsLast ? dx.strides[2] : 1;\n    var xChannelStride = isChannelsLast ? 1 : dx.strides[1];\n    var yBatchStride = dyStrides[0];\n    var yRowStride = isChannelsLast ? dyStrides[1] : dyStrides[2];\n    var yColStride = isChannelsLast ? dyStrides[2] : 1;\n    var yChannelStride = isChannelsLast ? 1 : dyStrides[1];\n    for (var b = 0; b < batchSize; ++b) {\n        for (var d1 = 0; d1 < inChannels; ++d1) {\n            for (var xR = 0; xR < inHeight; ++xR) {\n                var xRCorner = xR - topPad;\n                var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n                var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n                for (var xC = 0; xC < inWidth; ++xC) {\n                    var xCCorner = xC - leftPad;\n                    var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                    var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n                    var dotProd = 0;\n                    for (var yR = xRMin; yR < yRMax; ++yR) {\n                        var wR = yR * strideHeight - xRCorner;\n                        for (var yC = xCMin; yC < yCMax; ++yC) {\n                            var wC = yC * strideWidth - xCCorner;\n                            var dyOffset = yBatchStride * b + yRowStride * yR + yColStride * yC;\n                            var fltOffset = fltS0 * (filterHeight - 1 - wR) +\n                                fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;\n                            for (var d2 = 0; d2 < outChannels; ++d2) {\n                                var pixel = dyValues[dyOffset + yChannelStride * d2];\n                                var weight = fltValues[fltOffset + d2];\n                                dotProd += pixel * weight;\n                            }\n                        }\n                    }\n                    var dxOffset = xBatchStride * b + xRowStride * xR +\n                        xColStride * xC + xChannelStride * d1;\n                    dxValues[dxOffset] = dotProd;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);\n}\nvar conv2DBackpropInputConfig = {\n    kernelName: tfjsCore.Conv2DBackpropInput,\n    backendName: 'cpu',\n    kernelFunc: conv2DBackpropInput\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv3D(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, filter = inputs.filter;\n    var strides = attrs.strides, pad = attrs.pad, dilations = attrs.dilations;\n    assertNotComplex([x, filter], 'conv3d');\n    var convInfo = tfjsCore.backend_util.computeConv3DInfo(x.shape, filter.shape, strides, dilations, pad);\n    var filterDepth = convInfo.filterDepth, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, dilationDepth = convInfo.dilationDepth, dilationHeight = convInfo.dilationHeight, dilationWidth = convInfo.dilationWidth, padInfo = convInfo.padInfo;\n    var padFront = padInfo.front;\n    var padLeft = padInfo.left;\n    var padTop = padInfo.top;\n    var y = new tfjsCore.TensorBuffer(convInfo.outShape, x.dtype);\n    var xVals = backend.data.get(x.dataId).values;\n    var wVals = backend.data.get(filter.dataId).values;\n    var yVals = y.values;\n    var xStrides = tfjsCore.util.computeStrides(x.shape);\n    var filterStrides = tfjsCore.util.computeStrides(filter.shape);\n    for (var b = 0; b < convInfo.batchSize; ++b) {\n        var xOffset1 = b * xStrides[0];\n        var yOffset1 = b * y.strides[0];\n        for (var yF = 0; yF < convInfo.outDepth; ++yF) {\n            var yOffset2 = yOffset1 + yF * y.strides[1];\n            var xFCorner = yF * convInfo.strideDepth - padFront;\n            for (var wF = 0; wF < filterDepth; ++wF) {\n                var xF = xFCorner + wF * dilationDepth;\n                if (xF < 0 || xF >= convInfo.inDepth) {\n                    continue;\n                }\n                var wOffset1 = wF * filterStrides[0];\n                var xOffset2 = xOffset1 + xF * xStrides[1];\n                for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n                    var yOffset3 = yOffset2 + yR * y.strides[2];\n                    var xRCorner = yR * convInfo.strideHeight - padTop;\n                    for (var wR = 0; wR < filterHeight; ++wR) {\n                        var xR = xRCorner + wR * dilationHeight;\n                        if (xR < 0 || xR >= convInfo.inHeight) {\n                            continue;\n                        }\n                        var wOffset2 = wOffset1 + wR * filterStrides[1];\n                        var xOffset3 = xOffset2 + xR * xStrides[2];\n                        for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n                            var yOffset4 = yOffset3 + yC * convInfo.outChannels;\n                            var xCCorner = yC * convInfo.strideWidth - padLeft;\n                            for (var wC = 0; wC < filterWidth; ++wC) {\n                                var xC = xCCorner + wC * dilationWidth;\n                                if (xC < 0 || xC >= convInfo.inWidth) {\n                                    continue;\n                                }\n                                var wOffset3 = wOffset2 + wC * filterStrides[2];\n                                var xOffset4 = xOffset3 + xC * convInfo.inChannels;\n                                var wOffset4 = wOffset3;\n                                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                                    var xVal = xVals[xOffset4 + d1];\n                                    for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                                        yVals[yOffset4 + d2] += xVal * wVals[wOffset4 + d2];\n                                    }\n                                    wOffset4 += convInfo.outChannels;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(y.shape, y.dtype, y.values);\n}\nvar conv3DConfig = {\n    kernelName: tfjsCore.Conv3D,\n    backendName: 'cpu',\n    kernelFunc: conv3D\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv3DBackpropFilterV2(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, dy = inputs.dy;\n    var strides = attrs.strides, pad = attrs.pad, filterShape = attrs.filterShape;\n    assertNotComplex([x, dy], 'conv3dBackpropFilterV2');\n    var xStrides = tfjsCore.util.computeStrides(x.shape);\n    var dyStrides = tfjsCore.util.computeStrides(dy.shape);\n    var convInfo = tfjsCore.backend_util.computeConv3DInfo(x.shape, filterShape, strides, 1 /* dilations */, pad);\n    var strideDepth = convInfo.strideDepth;\n    var strideHeight = convInfo.strideHeight;\n    var strideWidth = convInfo.strideWidth;\n    var filterDepth = convInfo.filterDepth;\n    var filterHeight = convInfo.filterHeight;\n    var filterWidth = convInfo.filterWidth;\n    var dw = new tfjsCore.TensorBuffer(convInfo.filterShape, 'float32');\n    var dwValues = dw.values;\n    var _a = dw.strides, dwS0 = _a[0], dwS1 = _a[1], dwS2 = _a[2], dwS3 = _a[3];\n    var dyValues = backend.data.get(dy.dataId).values;\n    var dyS0 = dyStrides[0], dyS1 = dyStrides[1], dyS2 = dyStrides[2], dyS3 = dyStrides[3];\n    var xValues = backend.data.get(x.dataId).values;\n    var xS0 = xStrides[0], xS1 = xStrides[1], xS2 = xStrides[2], xS3 = xStrides[3];\n    var frontPad = convInfo.padInfo.front;\n    var leftPad = convInfo.padInfo.left;\n    var topPad = convInfo.padInfo.top;\n    for (var wF = 0; wF < filterDepth; ++wF) {\n        var yFMin = Math.max(0, Math.ceil((frontPad - wF) / strideDepth));\n        var yFMax = Math.min(convInfo.outDepth, (convInfo.inDepth + frontPad - wF) / strideDepth);\n        var wOffset1 = wF * dwS0;\n        for (var wR = 0; wR < filterHeight; ++wR) {\n            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n            var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n            var wOffset2 = wR * dwS1 + wOffset1;\n            for (var wC = 0; wC < filterWidth; ++wC) {\n                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n                var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n                var wOffset3 = wC * dwS2 + wOffset2;\n                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                    var wOffset4 = d1 * dwS3 + wOffset3;\n                    for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                        var dotProd = 0;\n                        for (var b = 0; b < convInfo.batchSize; ++b) {\n                            var xOffset1 = b * xS0;\n                            var yOffset1 = b * dyS0;\n                            for (var yF = yFMin; yF < yFMax; ++yF) {\n                                var xF = wF + yF * strideDepth - frontPad;\n                                var xOffset2 = xF * xS1 + xOffset1;\n                                var yOffset2 = yF * dyS1 + yOffset1;\n                                for (var yR = yRMin; yR < yRMax; ++yR) {\n                                    var xR = wR + yR * strideHeight - topPad;\n                                    var xOffset3 = xR * xS2 + xOffset2;\n                                    var yOffset3 = yR * dyS2 + yOffset2;\n                                    for (var yC = yCMin; yC < yCMax; ++yC) {\n                                        var xC = wC + yC * strideWidth - leftPad;\n                                        var xOffset4 = xC * xS3 + xOffset3;\n                                        var yOffset4 = yC * dyS3 + yOffset3;\n                                        dotProd += xValues[xOffset4 + d1] * dyValues[yOffset4 + d2];\n                                    }\n                                }\n                            }\n                        }\n                        dwValues[wOffset4 + d2] = dotProd;\n                    }\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(dw.shape, dw.dtype, dw.values);\n}\nvar conv3DBackpropFilterV2Config = {\n    kernelName: tfjsCore.Conv3DBackpropFilterV2,\n    backendName: 'cpu',\n    kernelFunc: conv3DBackpropFilterV2\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv3DBackpropInputV2(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, filter = inputs.filter;\n    var pad = attrs.pad, strides = attrs.strides, inputShape = attrs.inputShape;\n    assertNotComplex([dy], 'conv3dBackpropInputV2');\n    var dyStrides = tfjsCore.util.computeStrides(dy.shape);\n    var filterStrides = tfjsCore.util.computeStrides(filter.shape);\n    var convInfo = tfjsCore.backend_util.computeConv3DInfo(inputShape, filter.shape, strides, 1 /* dilations */, pad);\n    var dx = new tfjsCore.TensorBuffer(convInfo.inShape, 'float32');\n    var dxValues = dx.values;\n    var _a = dx.strides, dxS0 = _a[0], dxS1 = _a[1], dxS2 = _a[2], dxS3 = _a[3];\n    var dyValues = backend.data.get(dy.dataId).values;\n    var dyS0 = dyStrides[0], dyS1 = dyStrides[1], dyS2 = dyStrides[2], dyS3 = dyStrides[3];\n    var fltValues = backend.data.get(filter.dataId).values;\n    var fltS0 = filterStrides[0], fltS1 = filterStrides[1], fltS2 = filterStrides[2], fltS3 = filterStrides[3];\n    var batchSize = convInfo.batchSize, filterDepth = convInfo.filterDepth, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels, inDepth = convInfo.inDepth, inHeight = convInfo.inHeight, inWidth = convInfo.inWidth, outChannels = convInfo.outChannels, outDepth = convInfo.outDepth, outHeight = convInfo.outHeight, outWidth = convInfo.outWidth, strideDepth = convInfo.strideDepth, strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth;\n    var frontPad = filterDepth - 1 - convInfo.padInfo.front;\n    var topPad = filterHeight - 1 - convInfo.padInfo.top;\n    var leftPad = filterWidth - 1 - convInfo.padInfo.left;\n    for (var b = 0; b < batchSize; ++b) {\n        for (var d1 = 0; d1 < inChannels; ++d1) {\n            // Frames of depth\n            for (var xF = 0; xF < inDepth; ++xF) {\n                var xFCorner = xF - frontPad;\n                var xFMin = Math.max(0, Math.ceil(xFCorner / strideDepth));\n                var yFMax = Math.min(outDepth, (filterDepth + xFCorner) / strideDepth);\n                // Rows as per standard 2d matrix notation\n                for (var xR = 0; xR < inHeight; ++xR) {\n                    var xRCorner = xR - topPad;\n                    var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n                    var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n                    // Columns as per standard 2d matrix notation\n                    for (var xC = 0; xC < inWidth; ++xC) {\n                        var xCCorner = xC - leftPad;\n                        var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                        var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n                        var dotProd = 0;\n                        for (var yF = xFMin; yF < yFMax; ++yF) {\n                            var wF = yF * strideDepth - xFCorner;\n                            for (var yR = xRMin; yR < yRMax; ++yR) {\n                                var wR = yR * strideHeight - xRCorner;\n                                for (var yC = xCMin; yC < yCMax; ++yC) {\n                                    var wC = yC * strideWidth - xCCorner;\n                                    var dyOffset = dyS0 * b + dyS1 * yF + dyS2 * yR + dyS3 * yC;\n                                    var fltOffset = fltS0 * (filterDepth - 1 - wF) +\n                                        fltS1 * (filterHeight - 1 - wR) +\n                                        fltS2 * (filterWidth - 1 - wC) + fltS3 * d1;\n                                    for (var d2 = 0; d2 < outChannels; ++d2) {\n                                        var pixel = dyValues[dyOffset + d2];\n                                        var weight = fltValues[fltOffset + d2];\n                                        dotProd += pixel * weight;\n                                    }\n                                }\n                            }\n                        }\n                        dxValues[dxS0 * b + dxS1 * xF + dxS2 * xR + dxS3 * xC + d1] =\n                            dotProd;\n                    }\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);\n}\nvar conv3DBackpropInputV2Config = {\n    kernelName: tfjsCore.Conv3DBackpropInputV2,\n    backendName: 'cpu',\n    kernelFunc: conv3DBackpropInputV2\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar cos = unaryKernelFunc(tfjsCore.Cos, function (xi) { return Math.cos(xi); });\nvar cosConfig = {\n    kernelName: tfjsCore.Cos,\n    backendName: 'cpu',\n    kernelFunc: cos,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar cosh = unaryKernelFunc(tfjsCore.Cosh, function (xi) { return Math.cosh(xi); });\nvar coshConfig = {\n    kernelName: tfjsCore.Cosh,\n    backendName: 'cpu',\n    kernelFunc: cosh,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction cropAndResize(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var image = inputs.image, boxes = inputs.boxes, boxInd = inputs.boxInd;\n    var cropSize = attrs.cropSize, method = attrs.method, extrapolationValue = attrs.extrapolationValue;\n    var _a = image.shape, batch = _a[0], imageHeight = _a[1], imageWidth = _a[2], numChannels = _a[3];\n    var numBoxes = boxes.shape[0];\n    var cropHeight = cropSize[0], cropWidth = cropSize[1];\n    var output = tfjsCore.buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n    var boxVals = backend.data.get(boxes.dataId).values;\n    var boxIndVals = backend.data.get(boxInd.dataId).values;\n    var imageVals = backend.data.get(image.dataId).values;\n    var inStride = tfjsCore.util.computeStrides(image.shape); // to calculate flat indexes into image\n    var outStride = tfjsCore.util.computeStrides(output.shape); // to calculate flat indexes into output\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n    for (var b = 0; b < numBoxes; b++) {\n        var startInd = b * 4;\n        var y1 = boxVals[startInd];\n        var x1 = boxVals[startInd + 1];\n        var y2 = boxVals[startInd + 2];\n        var x2 = boxVals[startInd + 3];\n        var bInd = boxIndVals[b];\n        if (bInd >= batch) {\n            continue;\n        }\n        var heightScale = (cropHeight > 1) ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;\n        var widthScale = (cropWidth > 1) ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n        for (var y = 0; y < cropHeight; y++) {\n            var yInd = (cropHeight > 1) ?\n                y1 * (imageHeight - 1) + y * (heightScale) :\n                0.5 * (y1 + y2) * (imageHeight - 1);\n            if (yInd < 0 || yInd > imageHeight - 1) {\n                for (var x = 0; x < cropWidth; x++) {\n                    for (var c = 0; c < numChannels; c++) {\n                        var ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                        output.values[ind] = extrapolationValue;\n                    }\n                }\n                continue;\n            }\n            if (method === 'bilinear') {\n                var topInd = Math.floor(yInd);\n                var bottomInd = Math.ceil(yInd);\n                var yLerp = yInd - topInd;\n                for (var x = 0; x < cropWidth; x++) {\n                    var xInd = (cropWidth > 1) ?\n                        x1 * (imageWidth - 1) + x * widthScale :\n                        0.5 * (x1 + x2) * (imageWidth - 1);\n                    if (xInd < 0 || xInd > imageWidth - 1) {\n                        for (var c = 0; c < numChannels; c++) {\n                            var ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[ind] = extrapolationValue;\n                        }\n                        continue;\n                    }\n                    var leftInd = Math.floor(xInd);\n                    var rightInd = Math.ceil(xInd);\n                    var xLerp = xInd - leftInd;\n                    for (var c = 0; c < numChannels; c++) {\n                        var ind = c + leftInd * inStride[2] + topInd * inStride[1] +\n                            bInd * inStride[0];\n                        var topLeft = imageVals[ind];\n                        ind = c + rightInd * inStride[2] + topInd * inStride[1] +\n                            bInd * inStride[0];\n                        var topRight = imageVals[ind];\n                        ind = c + leftInd * inStride[2] + bottomInd * inStride[1] +\n                            bInd * inStride[0];\n                        var bottomLeft = imageVals[ind];\n                        ind = c + rightInd * inStride[2] + bottomInd * inStride[1] +\n                            bInd * inStride[0];\n                        var bottomRight = imageVals[ind];\n                        var top_1 = topLeft + (topRight - topLeft) * xLerp;\n                        var bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n                        ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                        output.values[ind] = top_1 + ((bottom - top_1) * yLerp);\n                    }\n                }\n            }\n            else { // method == \"nearest\"\n                for (var x = 0; x < cropWidth; ++x) {\n                    var xInd = (cropWidth > 1) ?\n                        x1 * (imageWidth - 1) + x * widthScale :\n                        0.5 * (x1 + x2) * (imageWidth - 1);\n                    if (xInd < 0 || xInd > imageWidth - 1) {\n                        for (var c = 0; c < numChannels; c++) {\n                            var ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[ind] = extrapolationValue;\n                        }\n                        continue;\n                    }\n                    var closestX = Math.round(xInd);\n                    var closestY = Math.round(yInd);\n                    for (var c = 0; c < numChannels; c++) {\n                        var inInd = c + closestX * inStride[2] + closestY * inStride[1] +\n                            bInd * inStride[0];\n                        var outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                        output.values[outInd] = imageVals[inInd];\n                    }\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(output.shape, output.dtype, output.values);\n}\nvar cropAndResizeConfig = {\n    kernelName: tfjsCore.CropAndResize,\n    backendName: 'cpu',\n    kernelFunc: cropAndResize\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction cumsum(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, exclusive = attrs.exclusive, reverse = attrs.reverse;\n    assertNotComplex(x, 'cumsum');\n    var permutation = tfjsCore.backend_util.getAxesPermutation([axis], x.shape.length);\n    var $x = x;\n    if (permutation != null) {\n        $x = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutation } });\n    }\n    var permutedAxis = tfjsCore.backend_util.getInnerMostAxes(1, x.shape.length)[0];\n    if (permutedAxis !== $x.shape.length - 1) {\n        throw new Error(\"backend.cumsum in CPU expects an inner-most \" +\n            (\"axis=\" + ($x.shape.length - 1) + \" but got axis=\" + permutedAxis));\n    }\n    var resultDtype = tfjsCore.upcastType($x.dtype, 'int32');\n    var vals = tfjsCore.util.makeZerosTypedArray(tfjsCore.util.sizeFromShape($x.shape), resultDtype);\n    var aVals = backend.data.get($x.dataId).values;\n    var finalDim = $x.shape[$x.shape.length - 1];\n    var indexAdjuster = reverse ?\n        function (i, j) { return i + finalDim - j - 1; } :\n        function (i, j) { return i + j; };\n    for (var i = 0; i < aVals.length; i += finalDim) {\n        for (var j = 0; j < finalDim; j++) {\n            var idx = indexAdjuster(i, j);\n            if (j === 0) {\n                vals[idx] = exclusive ? 0 : aVals[idx];\n            }\n            else {\n                var prevIdx = indexAdjuster(i, j - 1);\n                vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] :\n                    aVals[idx] + vals[prevIdx];\n            }\n        }\n    }\n    var result = backend.makeTensorInfo($x.shape, resultDtype, vals);\n    if (permutation != null) {\n        var reversePermutation = tfjsCore.backend_util.getUndoAxesPermutation(permutation);\n        var reverseTransposedResult = transpose({ inputs: { x: result }, backend: backend, attrs: { perm: reversePermutation } });\n        backend.disposeIntermediateTensorInfo(result);\n        backend.disposeIntermediateTensorInfo($x);\n        return reverseTransposedResult;\n    }\n    return result;\n}\nvar cumsumConfig = {\n    kernelName: tfjsCore.Cumsum,\n    backendName: 'cpu',\n    kernelFunc: cumsum\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction denseBincount(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, weights = inputs.weights;\n    var size = attrs.size, binaryOutput = attrs.binaryOutput;\n    if (x.shape.length === 1) {\n        var xVals = backend.data.get(x.dataId).values;\n        var weightsVals = backend.data.get(weights.dataId).values;\n        var outVals = bincountImpl(xVals, weightsVals, weights.dtype, weights.shape, size);\n        return backend.makeTensorInfo([size], weights.dtype, outVals);\n    }\n    else if (x.shape.length === 2) {\n        var xBuf = backend.bufferSync(x);\n        var weightsBuf = backend.bufferSync(weights);\n        var outBuf = bincountReduceImpl(xBuf, weightsBuf, size, binaryOutput);\n        return backend.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);\n    }\n    throw new Error(\"Error in denseBincount: input must be at most rank 2, but got rank\" +\n        (x.shape.length + \".\"));\n}\nvar denseBincountConfig = {\n    kernelName: tfjsCore.DenseBincount,\n    backendName: 'cpu',\n    kernelFunc: denseBincount\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction depthToSpace(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var blockSize = attrs.blockSize, dataFormat = attrs.dataFormat;\n    tfjsCore.util.assert(dataFormat === 'NHWC', function () { return \"Only NHWC dataFormat supported on CPU for depthToSpace. Got \" + dataFormat; });\n    tfjsCore.util.assert(blockSize > 1, function () { return \"blockSize should be > 1 for depthToSpace, but was: \" + blockSize; });\n    var batchSize = x.shape[0];\n    var inputHeight = x.shape[1];\n    var inputWidth = x.shape[2];\n    var inputDepth = x.shape[3];\n    var outputHeight = inputHeight * blockSize;\n    var outputWidth = inputWidth * blockSize;\n    var outputDepth = inputDepth / (blockSize * blockSize);\n    var xValues = backend.data.get(x.dataId).values;\n    var result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);\n    var outputIdx = 0;\n    for (var b = 0; b < batchSize; ++b) {\n        for (var h = 0; h < outputHeight; ++h) {\n            var inH = Math.floor(h / blockSize);\n            var offsetH = (h % blockSize);\n            for (var w = 0; w < outputWidth; ++w) {\n                var inW = Math.floor(w / blockSize);\n                var offsetW = (w % blockSize);\n                var offsetD = (offsetH * blockSize + offsetW) * outputDepth;\n                for (var d = 0; d < outputDepth; ++d) {\n                    var inD = d + offsetD;\n                    var inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b));\n                    result[outputIdx++] = xValues[inputIdx];\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo([batchSize, outputHeight, outputWidth, outputDepth], x.dtype, result);\n}\nvar depthToSpaceConfig = {\n    kernelName: tfjsCore.DepthToSpace,\n    backendName: 'cpu',\n    kernelFunc: depthToSpace\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction depthwiseConv2dNative(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, filter = inputs.filter;\n    var strides = attrs.strides, pad = attrs.pad, dilations = attrs.dilations, dimRoundingMode = attrs.dimRoundingMode;\n    assertNotComplex([x, filter], 'depthwiseConv2DNative');\n    var xStrides = tfjsCore.util.computeStrides(x.shape);\n    var filterStrides = tfjsCore.util.computeStrides(filter.shape);\n    var $dilations = dilations;\n    if ($dilations == null) {\n        $dilations = [1, 1];\n    }\n    tfjsCore.util.assert(tfjsCore.backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), function () { return 'Error in depthwiseConv2d: Either strides or dilations must be ' +\n        (\"1. Got strides \" + strides + \" and dilations '\" + $dilations + \"'\"); });\n    var convInfo = tfjsCore.backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true /* depthwise */);\n    var filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, dilationHeight = convInfo.dilationHeight, dilationWidth = convInfo.dilationWidth, padInfo = convInfo.padInfo;\n    var padLeft = padInfo.left;\n    var padTop = padInfo.top;\n    var chMul = convInfo.outChannels / convInfo.inChannels;\n    var y = new tfjsCore.TensorBuffer(convInfo.outShape, x.dtype);\n    var xVals = backend.data.get(x.dataId).values;\n    var wVals = backend.data.get(filter.dataId).values;\n    var yVals = y.values;\n    for (var b = 0; b < convInfo.batchSize; ++b) {\n        var xOffset1 = b * xStrides[0];\n        var yOffset1 = b * y.strides[0];\n        for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n            var yOffset2 = yOffset1 + yR * y.strides[1];\n            var xRCorner = yR * convInfo.strideHeight - padLeft;\n            for (var wR = 0; wR < filterHeight; ++wR) {\n                var xR = xRCorner + wR * dilationHeight;\n                if (xR < 0 || xR >= convInfo.inHeight) {\n                    continue;\n                }\n                var wOffset1 = wR * filterStrides[0];\n                var xOffset2 = xOffset1 + xR * xStrides[1];\n                for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n                    var yOffset3 = yOffset2 + yC * y.strides[2];\n                    var xCCorner = yC * convInfo.strideWidth - padTop;\n                    for (var wC = 0; wC < filterWidth; ++wC) {\n                        var xC = xCCorner + wC * dilationWidth;\n                        if (xC < 0 || xC >= convInfo.inWidth) {\n                            continue;\n                        }\n                        var wOffset2 = wOffset1 + wC * filterStrides[1];\n                        var xOffset3 = xOffset2 + xC * convInfo.inChannels;\n                        var yOffset4 = yOffset3;\n                        var wOffset3 = wOffset2;\n                        for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                            var xVal = xVals[xOffset3 + d1];\n                            for (var q = 0; q < chMul; ++q) {\n                                yVals[yOffset4 + q] += xVal * wVals[wOffset3 + q];\n                            }\n                            yOffset4 += chMul;\n                            wOffset3 += chMul;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(y.shape, y.dtype, y.values);\n}\nvar depthwiseConv2dNativeConfig = {\n    kernelName: tfjsCore.DepthwiseConv2dNative,\n    backendName: 'cpu',\n    kernelFunc: depthwiseConv2dNative\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction depthwiseConv2dNativeBackpropFilter(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, dy = inputs.dy;\n    var strides = attrs.strides, dilations = attrs.dilations, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode, filterShape = attrs.filterShape;\n    assertNotComplex([x, dy], 'depthwiseConv2dNativeBackpropFilter');\n    var convInfo = tfjsCore.backend_util.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);\n    var strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth;\n    var dW = new tfjsCore.TensorBuffer(convInfo.filterShape, 'float32');\n    var leftPad = convInfo.padInfo.left;\n    var topPad = convInfo.padInfo.top;\n    var chMul = convInfo.outChannels / convInfo.inChannels;\n    var xVals = backend.data.get(x.dataId).values;\n    var xBuf = new tfjsCore.TensorBuffer(x.shape, x.dtype, xVals);\n    var dyVals = backend.data.get(dy.dataId).values;\n    var dyBuf = new tfjsCore.TensorBuffer(dy.shape, dy.dtype, dyVals);\n    for (var wR = 0; wR < filterHeight; ++wR) {\n        var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n        var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n        for (var wC = 0; wC < filterWidth; ++wC) {\n            var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n            var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n            for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                var d1 = Math.trunc(d2 / chMul);\n                var dm = d2 % chMul;\n                var dotProd = 0;\n                for (var b = 0; b < convInfo.batchSize; ++b) {\n                    for (var yR = yRMin; yR < yRMax; ++yR) {\n                        var xR = wR + yR * strideHeight - topPad;\n                        for (var yC = yCMin; yC < yCMax; ++yC) {\n                            var xC = wC + yC * strideWidth - leftPad;\n                            dotProd += xBuf.get(b, xR, xC, d1) *\n                                dyBuf.get(b, yR, yC, d2);\n                        }\n                    }\n                }\n                dW.set(dotProd, wR, wC, d1, dm);\n            }\n        }\n    }\n    return backend.makeTensorInfo(dW.shape, dW.dtype, dW.values);\n}\nvar depthwiseConv2dNativeBackpropFilterConfig = {\n    kernelName: tfjsCore.DepthwiseConv2dNativeBackpropFilter,\n    backendName: 'cpu',\n    kernelFunc: depthwiseConv2dNativeBackpropFilter\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction depthwiseConv2dNativeBackpropInput(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, filter = inputs.filter;\n    var strides = attrs.strides, dilations = attrs.dilations, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode, inputShape = attrs.inputShape;\n    assertNotComplex([dy, filter], 'depthwiseConv2DNativeBackpropInput');\n    var dyStrides = tfjsCore.util.computeStrides(dy.shape);\n    var filterStrides = tfjsCore.util.computeStrides(filter.shape);\n    var convInfo = tfjsCore.backend_util.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);\n    var dx = new tfjsCore.TensorBuffer(convInfo.inShape, 'float32');\n    var dxValues = dx.values;\n    var _a = dx.strides, dxS0 = _a[0], dxS1 = _a[1], dxS2 = _a[2];\n    var dyValues = backend.data.get(dy.dataId).values;\n    var dyS0 = dyStrides[0], dyS1 = dyStrides[1], dyS2 = dyStrides[2];\n    var fltValues = backend.data.get(filter.dataId).values;\n    var fltS0 = filterStrides[0], fltS1 = filterStrides[1], fltS2 = filterStrides[2];\n    var batchSize = convInfo.batchSize, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels, inHeight = convInfo.inHeight, inWidth = convInfo.inWidth, outChannels = convInfo.outChannels, outHeight = convInfo.outHeight, outWidth = convInfo.outWidth, strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth;\n    var topPad = filterHeight - 1 - convInfo.padInfo.top;\n    var leftPad = filterWidth - 1 - convInfo.padInfo.left;\n    var chMul = outChannels / inChannels;\n    for (var b = 0; b < batchSize; ++b) {\n        for (var d1 = 0; d1 < inChannels; ++d1) {\n            for (var xR = 0; xR < inHeight; ++xR) {\n                var xRCorner = xR - topPad;\n                var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n                var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n                for (var xC = 0; xC < inWidth; ++xC) {\n                    var xCCorner = xC - leftPad;\n                    var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                    var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n                    var dotProd = 0;\n                    for (var yR = xRMin; yR < yRMax; ++yR) {\n                        var wR = yR * strideHeight - xRCorner;\n                        for (var yC = xCMin; yC < yCMax; ++yC) {\n                            var wC = yC * strideWidth - xCCorner;\n                            var dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;\n                            var fltOffset = fltS0 * (filterHeight - 1 - wR) +\n                                fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;\n                            for (var dm = 0; dm < chMul; ++dm) {\n                                var d2 = d1 * chMul + dm;\n                                var pixel = dyValues[dyOffset + d2];\n                                var weight = fltValues[fltOffset + dm];\n                                dotProd += pixel * weight;\n                            }\n                        }\n                    }\n                    dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);\n}\nvar depthwiseConv2dNativeBackpropInputConfig = {\n    kernelName: tfjsCore.DepthwiseConv2dNativeBackpropInput,\n    backendName: 'cpu',\n    kernelFunc: depthwiseConv2dNativeBackpropInput\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction diag(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    var xSize = tfjsCore.util.sizeFromShape(x.shape);\n    var xVals = backend.data.get(x.dataId).values;\n    var outBuf = tfjsCore.buffer([xSize, xSize], x.dtype);\n    var vals = outBuf.values;\n    for (var i = 0; i < xVals.length; i++) {\n        vals[i * xSize + i] = xVals[i];\n    }\n    var outShape = x.shape.concat(x.shape);\n    return backend.makeTensorInfo(outShape, outBuf.dtype, outBuf.values);\n}\nvar diagConfig = {\n    kernelName: tfjsCore.Diag,\n    backendName: 'cpu',\n    kernelFunc: diag\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar dilation2dConfig = {\n    kernelName: tfjsCore.Dilation2D,\n    backendName: 'cpu',\n    kernelFunc: function (_a) {\n        var inputs = _a.inputs, backend = _a.backend, attrs = _a.attrs;\n        var _b = inputs, x = _b.x, filter = _b.filter;\n        var _c = attrs, strides = _c.strides, pad = _c.pad, dilations = _c.dilations;\n        var cpuBackend = backend;\n        var xVals = cpuBackend.data.get(x.dataId).values;\n        var xRank = x.shape.length;\n        var filterVals = cpuBackend.data.get(filter.dataId).values;\n        var filterRank = filter.shape.length;\n        var _d = tfjsCore.backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */, dilations), batchSize = _d.batchSize, inHeight = _d.inHeight, inWidth = _d.inWidth, inChannels = _d.inChannels, outHeight = _d.outHeight, outWidth = _d.outWidth, padInfo = _d.padInfo, strideHeight = _d.strideHeight, strideWidth = _d.strideWidth, filterHeight = _d.filterHeight, filterWidth = _d.filterWidth, dilationHeight = _d.dilationHeight, dilationWidth = _d.dilationWidth, outShape = _d.outShape;\n        var outSize = tfjsCore.util.sizeFromShape(outShape);\n        var outRank = outShape.length;\n        var outputVals = tfjsCore.util.getArrayFromDType(x.dtype, outSize);\n        // Upsampling the input by fill in `dilation size - 1` values between each\n        // input value.\n        // This implementation follows the TF c++ implementation:\n        // https://github.com/tensorflow/tensorflow/blob/d9a3a849edc198e90172bc58eb293de457f9d986/tensorflow/core/kernels/dilation_ops.cc\n        for (var b = 0; b < batchSize; ++b) {\n            for (var hOut = 0; hOut < outHeight; ++hOut) {\n                var hBeg = hOut * strideHeight - padInfo.top;\n                for (var wOut = 0; wOut < outWidth; ++wOut) {\n                    var wBeg = wOut * strideWidth - padInfo.left;\n                    for (var d = 0; d < inChannels; ++d) {\n                        var curVal = Number.MIN_SAFE_INTEGER;\n                        for (var h = 0; h < filterHeight; ++h) {\n                            var hIn = hBeg + h * dilationHeight;\n                            if (hIn >= 0 && hIn < inHeight) {\n                                for (var w = 0; w < filterWidth; ++w) {\n                                    var wIn = wBeg + w * dilationWidth;\n                                    if (wIn >= 0 && wIn < inWidth) {\n                                        var xIndex = tfjsCore.util.locToIndex([b, hIn, wIn, d], xRank, tfjsCore.util.computeStrides(x.shape));\n                                        var filterIndex = tfjsCore.util.locToIndex([h, w, d], filterRank, tfjsCore.util.computeStrides(filter.shape));\n                                        var val = xVals[xIndex] + filterVals[filterIndex];\n                                        if (val > curVal) {\n                                            curVal = val;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        var outputIndex = tfjsCore.util.locToIndex([b, hOut, wOut, d], outRank, tfjsCore.util.computeStrides(outShape));\n                        outputVals[outputIndex] = curVal;\n                    }\n                }\n            }\n        }\n        var dataId = cpuBackend.write(tfjsCore.util.toTypedArray(outputVals, x.dtype), outShape, x.dtype);\n        return { dataId: dataId, shape: outShape, dtype: x.dtype };\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar dilation2dBackpropFilterConfig = {\n    kernelName: tfjsCore.Dilation2DBackpropFilter,\n    backendName: 'cpu',\n    kernelFunc: function (_a) {\n        var inputs = _a.inputs, backend = _a.backend, attrs = _a.attrs;\n        var _b = inputs, x = _b.x, filter = _b.filter, dy = _b.dy;\n        var _c = attrs, strides = _c.strides, pad = _c.pad, dilations = _c.dilations;\n        var cpuBackend = backend;\n        var $x = tfjsCore.util.toNestedArray(x.shape, cpuBackend.data.get(x.dataId).values);\n        var $filter = tfjsCore.util.toNestedArray(filter.shape, cpuBackend.data.get(filter.dataId).values);\n        var _d = tfjsCore.backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */, dilations), batchSize = _d.batchSize, inHeight = _d.inHeight, inWidth = _d.inWidth, inChannels = _d.inChannels, outHeight = _d.outHeight, outWidth = _d.outWidth, padInfo = _d.padInfo, strideHeight = _d.strideHeight, strideWidth = _d.strideWidth, filterHeight = _d.filterHeight, filterWidth = _d.filterWidth, dilationHeight = _d.dilationHeight, dilationWidth = _d.dilationWidth, outShape = _d.outShape;\n        tfjsCore.util.assert(dy.rank === outShape.length, function () { return \"Error in \" + tfjsCore.Dilation2DBackpropFilter + \", dy \" +\n            (\"must have the same rank as output \" + outShape.length + \", but got \") +\n            (\"\" + dy.rank); });\n        var $dy = tfjsCore.util.toNestedArray(outShape, cpuBackend.data.get(dy.dataId).values);\n        // The computed filter gradients has the same dimensions as the filter:\n        // [filterHeight, filterWidth, depth]\n        var gradients = tfjsCore.util.makeZerosNestedTypedArray(filter.shape, filter.dtype);\n        // In the case of multiple argmax branches, we only back-propagate along the\n        // last branch, i.e., the one with largest value of `h * filter_cols + w`,\n        // similarly to the max-pooling backward routines.\n        // This implementation follows the TF c++ implementation:\n        // https://github.com/tensorflow/tensorflow/blob/d9a3a849edc198e90172bc58eb293de457f9d986/tensorflow/core/kernels/dilation_ops.cc\n        for (var b = 0; b < batchSize; ++b) {\n            for (var hOut = 0; hOut < outHeight; ++hOut) {\n                var hBeg = hOut * strideHeight - padInfo.top;\n                for (var wOut = 0; wOut < outWidth; ++wOut) {\n                    var wBeg = wOut * strideWidth - padInfo.left;\n                    for (var d = 0; d < inChannels; ++d) {\n                        var curVal = Number.MIN_SAFE_INTEGER;\n                        var hMax = 0;\n                        var wMax = 0;\n                        for (var h = 0; h < filterHeight; ++h) {\n                            var hIn = hBeg + h * dilationHeight;\n                            if (hIn >= 0 && hIn < inHeight) {\n                                for (var w = 0; w < filterWidth; ++w) {\n                                    var wIn = wBeg + w * dilationWidth;\n                                    if (wIn >= 0 && wIn < inWidth) {\n                                        var val = $x[b][hIn][wIn][d] + $filter[h][w][d];\n                                        if (val > curVal) {\n                                            curVal = val;\n                                            hMax = h;\n                                            wMax = w;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        gradients[hMax][wMax][d] += $dy[b][hOut][wOut][d];\n                    }\n                }\n            }\n        }\n        var dataId = cpuBackend.write(tfjsCore.util.toTypedArray(gradients, x.dtype), filter.shape, filter.dtype);\n        return { dataId: dataId, shape: filter.shape, dtype: filter.dtype };\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar dilation2dBackpropInputConfig = {\n    kernelName: tfjsCore.Dilation2DBackpropInput,\n    backendName: 'cpu',\n    kernelFunc: function (_a) {\n        var inputs = _a.inputs, backend = _a.backend, attrs = _a.attrs;\n        var _b = inputs, x = _b.x, filter = _b.filter, dy = _b.dy;\n        var _c = attrs, strides = _c.strides, pad = _c.pad, dilations = _c.dilations;\n        var cpuBackend = backend;\n        var $x = tfjsCore.util.toNestedArray(x.shape, cpuBackend.data.get(x.dataId).values);\n        var $filter = tfjsCore.util.toNestedArray(filter.shape, cpuBackend.data.get(filter.dataId).values);\n        var _d = tfjsCore.backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */, dilations), batchSize = _d.batchSize, inHeight = _d.inHeight, inWidth = _d.inWidth, inChannels = _d.inChannels, outHeight = _d.outHeight, outWidth = _d.outWidth, padInfo = _d.padInfo, strideHeight = _d.strideHeight, strideWidth = _d.strideWidth, filterHeight = _d.filterHeight, filterWidth = _d.filterWidth, dilationHeight = _d.dilationHeight, dilationWidth = _d.dilationWidth, outShape = _d.outShape;\n        tfjsCore.util.assert(dy.rank === outShape.length, function () { return \"Error in \" + tfjsCore.Dilation2DBackpropInput + \", dy \" +\n            (\"must have the same rank as output \" + outShape.length + \", but got \") +\n            (\"\" + dy.rank); });\n        var $dy = tfjsCore.util.toNestedArray(outShape, cpuBackend.data.get(dy.dataId).values);\n        // The computed gradients has the same dimensions as the input:\n        // [batch, inputHeight, inputCols, inChannel]\n        var gradients = tfjsCore.util.makeZerosNestedTypedArray(x.shape, x.dtype);\n        // In the case of multiple argmax branches, we only back-propagate along the\n        // last branch, i.e., the one with largest value of `h * filter_cols + w`,\n        // similarly to the max-pooling backward routines.\n        // This implementation follows the TF c++ implementation:\n        // https://github.com/tensorflow/tensorflow/blob/d9a3a849edc198e90172bc58eb293de457f9d986/tensorflow/core/kernels/dilation_ops.cc\n        for (var b = 0; b < batchSize; ++b) {\n            for (var hOut = 0; hOut < outHeight; ++hOut) {\n                var hBeg = hOut * strideHeight - padInfo.top;\n                for (var wOut = 0; wOut < outWidth; ++wOut) {\n                    var wBeg = wOut * strideWidth - padInfo.left;\n                    for (var d = 0; d < inChannels; ++d) {\n                        var curVal = Number.MIN_SAFE_INTEGER;\n                        var hInMax = (hBeg < 0) ? 0 : hBeg;\n                        var wInMax = (wBeg < 0) ? 0 : wBeg;\n                        for (var h = 0; h < filterHeight; ++h) {\n                            var hIn = hBeg + h * dilationHeight;\n                            if (hIn >= 0 && hIn < inHeight) {\n                                for (var w = 0; w < filterWidth; ++w) {\n                                    var wIn = wBeg + w * dilationWidth;\n                                    if (wIn >= 0 && wIn < inWidth) {\n                                        var val = $x[b][hIn][wIn][d] + $filter[h][w][d];\n                                        if (val > curVal) {\n                                            curVal = val;\n                                            hInMax = hIn;\n                                            wInMax = wIn;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        gradients[b][hInMax][wInMax][d] += $dy[b][hOut][wOut][d];\n                    }\n                }\n            }\n        }\n        var dataId = cpuBackend.write(tfjsCore.util.toTypedArray(gradients, x.dtype), x.shape, x.dtype);\n        return { dataId: dataId, shape: x.shape, dtype: x.dtype };\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction eluGrad(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var dy = inputs.dy, y = inputs.y;\n    assertNotComplex([dy, y], 'eluGrad');\n    var resultValues = new Float32Array(tfjsCore.util.sizeFromShape(y.shape));\n    var values = backend.data.get(y.dataId).values;\n    var dyValues = backend.data.get(dy.dataId).values;\n    for (var i = 0; i < values.length; ++i) {\n        var v = values[i];\n        if (v >= 1) {\n            resultValues[i] = dyValues[i];\n        }\n        else {\n            resultValues[i] = dyValues[i] * (v + 1);\n        }\n    }\n    return backend.makeTensorInfo(y.shape, 'float32', resultValues);\n}\nvar eluGradConfig = {\n    kernelName: tfjsCore.EluGrad,\n    backendName: 'cpu',\n    kernelFunc: eluGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar equalImpl = createSimpleBinaryKernelImpl(function (a, b) { return (a === b) ? 1 : 0; });\nvar equal = binaryKernelFunc(tfjsCore.Equal, equalImpl, null /* complexImpl */, 'bool');\nvar equalConfig = {\n    kernelName: tfjsCore.Equal,\n    backendName: 'cpu',\n    kernelFunc: equal\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar p = tfjsCore.backend_util.ERF_P;\nvar a1 = tfjsCore.backend_util.ERF_A1;\nvar a2 = tfjsCore.backend_util.ERF_A2;\nvar a3 = tfjsCore.backend_util.ERF_A3;\nvar a4 = tfjsCore.backend_util.ERF_A4;\nvar a5 = tfjsCore.backend_util.ERF_A5;\nvar erf = unaryKernelFunc(tfjsCore.Erf, function (xi) {\n    var sign = Math.sign(xi);\n    var v = Math.abs(xi);\n    var t = 1.0 / (1.0 + p * v);\n    return sign *\n        (1.0 -\n            (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t *\n                Math.exp(-v * v));\n});\nvar erfConfig = {\n    kernelName: tfjsCore.Erf,\n    backendName: 'cpu',\n    kernelFunc: erf,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction expandDims(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var input = inputs.input;\n    var dim = attrs.dim;\n    var inputRank = input.shape.length;\n    var newShape = input.shape.slice();\n    var $dim = dim;\n    if (dim < 0) {\n        // Negative value is counted from the tail of rank.\n        tfjsCore.util.assert(-(inputRank + 1) <= dim, function () { return \"Axis must be in the interval [\" + -(inputRank + 1) + \", \" + inputRank + \"]\"; });\n        $dim = inputRank + dim + 1;\n    }\n    newShape.splice($dim, 0, 1);\n    return reshape({ inputs: { x: input }, backend: backend, attrs: { shape: newShape } });\n}\nvar expandDimsConfig = {\n    kernelName: tfjsCore.ExpandDims,\n    backendName: 'cpu',\n    kernelFunc: expandDims\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar realDivImpl = createSimpleBinaryKernelImpl(function (a, b) { return a / b; });\nvar div = binaryKernelFunc(tfjsCore.RealDiv, realDivImpl);\nvar realDivConfig = {\n    kernelName: tfjsCore.RealDiv,\n    backendName: 'cpu',\n    kernelFunc: div\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Calculate FFT of inner most elements of batch tensor.\n */\nfunction fftBatch(input, inverse, cpuBackend) {\n    var inputShape = input.shape;\n    var batch = inputShape[0];\n    var innerDim = inputShape[1];\n    var inputVals = cpuBackend.data.get(input.dataId);\n    var real2D = inputVals.complexTensorInfos.real;\n    var imag2D = inputVals.complexTensorInfos.imag;\n    // Collects real and imaginary values separately.\n    var resultShape = [batch, innerDim];\n    var resultSize = tfjsCore.util.sizeFromShape(resultShape);\n    var resultReal = tfjsCore.util.getTypedArrayFromDType('float32', resultSize);\n    var resultImag = tfjsCore.util.getTypedArrayFromDType('float32', resultSize);\n    for (var b = 0; b < batch; b++) {\n        // TODO: Support slice ops for complex type.\n        var r = slice({\n            inputs: { x: real2D },\n            backend: cpuBackend,\n            attrs: { begin: [b, 0], size: [1, innerDim] }\n        });\n        var i = slice({\n            inputs: { x: imag2D },\n            backend: cpuBackend,\n            attrs: { begin: [b, 0], size: [1, innerDim] }\n        });\n        var input_1 = complex({ inputs: { real: r, imag: i }, backend: cpuBackend });\n        // Run FFT by batch element.\n        var _a = fftImpl(input_1, inverse, cpuBackend), real_1 = _a.real, imag_1 = _a.imag;\n        var res = tfjsCore.backend_util.mergeRealAndImagArrays(real_1, imag_1);\n        for (var d = 0; d < innerDim; d++) {\n            var c = tfjsCore.backend_util.getComplexWithIndex(res, d);\n            resultReal[b * innerDim + d] = c.real;\n            resultImag[b * innerDim + d] = c.imag;\n        }\n        cpuBackend.disposeIntermediateTensorInfo(r);\n        cpuBackend.disposeIntermediateTensorInfo(i);\n        cpuBackend.disposeIntermediateTensorInfo(input_1);\n    }\n    var $realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);\n    var $imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);\n    var result = complex({ inputs: { real: $realInfo, imag: $imagInfo }, backend: cpuBackend });\n    cpuBackend.disposeIntermediateTensorInfo($realInfo);\n    cpuBackend.disposeIntermediateTensorInfo($imagInfo);\n    return result;\n}\nfunction fftImpl(input, inverse, cpuBackend) {\n    var inputSize = tfjsCore.util.sizeFromShape(input.shape);\n    var inputVals = cpuBackend.data.get(input.dataId);\n    var realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;\n    var imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;\n    if (isExponentOf2(inputSize)) {\n        var result = fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);\n        var resultShape = [input.shape[0], input.shape[1]];\n        if (inverse) {\n            var realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);\n            var imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);\n            var sizeInfo = cpuBackend.makeTensorInfo([], 'float32', tfjsCore.util.createScalarValue(inputSize, 'float32'));\n            var sizeInfoCopy = identity({ inputs: { x: sizeInfo }, backend: cpuBackend });\n            var divRealInfo = realDivConfig.kernelFunc({ inputs: { a: realInfo, b: sizeInfo }, backend: cpuBackend });\n            var divImagInfo = realDivConfig.kernelFunc({ inputs: { a: imagInfo, b: sizeInfoCopy }, backend: cpuBackend });\n            var divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;\n            var divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;\n            cpuBackend.disposeIntermediateTensorInfo(realInfo);\n            cpuBackend.disposeIntermediateTensorInfo(imagInfo);\n            cpuBackend.disposeIntermediateTensorInfo(sizeInfo);\n            cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);\n            cpuBackend.disposeIntermediateTensorInfo(divRealInfo);\n            cpuBackend.disposeIntermediateTensorInfo(divImagInfo);\n            return { real: divRealVals, imag: divImagVals };\n        }\n        return result;\n    }\n    else {\n        var data = tfjsCore.backend_util.mergeRealAndImagArrays(realVals, imagVals);\n        var rawOutput = fourierTransformByMatmul(data, inputSize, inverse);\n        return tfjsCore.backend_util.splitRealAndImagArrays(rawOutput);\n    }\n}\nfunction isExponentOf2(size) {\n    return (size & size - 1) === 0;\n}\n// FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\nfunction fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {\n    if (size === 1) {\n        return { real: realVals, imag: imagVals };\n    }\n    var data = tfjsCore.backend_util.mergeRealAndImagArrays(realVals, imagVals);\n    var half = size / 2;\n    var evenComplex = tfjsCore.backend_util.complexWithEvenIndex(data);\n    var evenRealVals = evenComplex.real;\n    var evenImagVals = evenComplex.imag;\n    var evenShape = [evenRealVals.length];\n    var evenRealInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);\n    var evenImagInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);\n    var evenTensorInfo = complex({ inputs: { real: evenRealInfo, imag: evenImagInfo }, backend: cpuBackend });\n    var oddComplex = tfjsCore.backend_util.complexWithOddIndex(data);\n    var oddRealVals = oddComplex.real;\n    var oddImagVals = oddComplex.imag;\n    var oddShape = [oddRealVals.length];\n    var oddRealInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);\n    var oddImagInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);\n    var oddTensorInfo = complex({ inputs: { real: oddRealInfo, imag: oddImagInfo }, backend: cpuBackend });\n    // Recursive call for half part of original input.\n    var $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);\n    var $evenRealVals = $evenComplex.real;\n    var $evenImagVals = $evenComplex.imag;\n    var $evenShape = [$evenRealVals.length];\n    var $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);\n    var $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);\n    var $evenTensorInfo = complex({\n        inputs: { real: $evenRealInfo, imag: $evenImagInfo },\n        backend: cpuBackend\n    });\n    var $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);\n    var $oddRealVals = $oddComplex.real;\n    var $oddImagVals = $oddComplex.imag;\n    var $oddShape = [$oddRealVals.length];\n    var $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);\n    var $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);\n    var $oddTensorInfo = complex({ inputs: { real: $oddRealInfo, imag: $oddImagInfo }, backend: cpuBackend });\n    var e = tfjsCore.backend_util.exponents(size, inverse);\n    var eShape = [e.real.length];\n    var eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);\n    var eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);\n    var complexInfo = complex({ inputs: { real: eRealInfo, imag: eImagInfo }, backend: cpuBackend });\n    var exponentInfo = multiply({ inputs: { a: complexInfo, b: $oddTensorInfo }, backend: cpuBackend });\n    var addPart = add({\n        inputs: { a: $evenTensorInfo, b: exponentInfo },\n        backend: cpuBackend\n    });\n    var subPart = sub({\n        inputs: { a: $evenTensorInfo, b: exponentInfo },\n        backend: cpuBackend\n    });\n    var addPartReal = real({ inputs: { input: addPart }, backend: cpuBackend });\n    var subPartReal = real({ inputs: { input: subPart }, backend: cpuBackend });\n    var addPartImag = imag({ inputs: { input: addPart }, backend: cpuBackend });\n    var subPartImag = imag({ inputs: { input: subPart }, backend: cpuBackend });\n    var $real = concat({\n        inputs: [addPartReal, subPartReal],\n        backend: cpuBackend,\n        attrs: { axis: 0 }\n    });\n    var $imag = concat({\n        inputs: [addPartImag, subPartImag],\n        backend: cpuBackend,\n        attrs: { axis: 0 }\n    });\n    var $realVals = cpuBackend.data.get($real.dataId).values;\n    var $imagVals = cpuBackend.data.get($imag.dataId).values;\n    cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo(eRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(eImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(complexInfo);\n    cpuBackend.disposeIntermediateTensorInfo(exponentInfo);\n    cpuBackend.disposeIntermediateTensorInfo(addPart);\n    cpuBackend.disposeIntermediateTensorInfo(subPart);\n    cpuBackend.disposeIntermediateTensorInfo(addPartReal);\n    cpuBackend.disposeIntermediateTensorInfo(addPartImag);\n    cpuBackend.disposeIntermediateTensorInfo(subPartReal);\n    cpuBackend.disposeIntermediateTensorInfo(subPartImag);\n    cpuBackend.disposeIntermediateTensorInfo($real);\n    cpuBackend.disposeIntermediateTensorInfo($imag);\n    return { real: $realVals, imag: $imagVals };\n}\n// Calculate fourier transform by multplying sinusoid matrix.\nfunction fourierTransformByMatmul(data, size, inverse) {\n    var ret = new Float32Array(size * 2);\n    // TODO: Use matmul instead once it supports complex64 type.\n    for (var r = 0; r < size; r++) {\n        var real_2 = 0.0;\n        var imag_2 = 0.0;\n        for (var c = 0; c < size; c++) {\n            var e = tfjsCore.backend_util.exponent(r * c, size, inverse);\n            var term = tfjsCore.backend_util.getComplexWithIndex(data, c);\n            real_2 += term.real * e.real - term.imag * e.imag;\n            imag_2 += term.real * e.imag + term.imag * e.real;\n        }\n        if (inverse) {\n            real_2 /= size;\n            imag_2 /= size;\n        }\n        tfjsCore.backend_util.assignToTypedArray(ret, real_2, imag_2, r);\n    }\n    return ret;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction fft(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var input = inputs.input;\n    var inputSize = tfjsCore.util.sizeFromShape(input.shape);\n    // Collapse all outer dimensions to a single batch dimension.\n    var innerDimensionSize = input.shape[input.shape.length - 1];\n    var batch = inputSize / innerDimensionSize;\n    var input2D = reshape({\n        inputs: { x: input },\n        backend: backend,\n        attrs: { shape: [batch, innerDimensionSize] }\n    });\n    var result = fftBatch(input2D, false, backend);\n    var resultReshaped = reshape({ inputs: { x: result }, backend: backend, attrs: { shape: input.shape } });\n    backend.disposeIntermediateTensorInfo(input2D);\n    backend.disposeIntermediateTensorInfo(result);\n    return resultReshaped;\n}\nvar fftConfig = {\n    kernelName: tfjsCore.FFT,\n    backendName: 'cpu',\n    kernelFunc: fft\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction fill(args) {\n    var backend = args.backend, attrs = args.attrs;\n    var shape = attrs.shape, value = attrs.value, dtype = attrs.dtype;\n    var $dtype = dtype || tfjsCore.util.inferDtype(value);\n    var values = tfjsCore.util.getArrayFromDType($dtype, tfjsCore.util.sizeFromShape(shape));\n    fillValues(values, value, $dtype);\n    return backend.makeTensorInfo(shape, $dtype, values);\n}\nvar fillConfig = {\n    kernelName: tfjsCore.Fill,\n    backendName: 'cpu',\n    kernelFunc: fill\n};\nfunction fillValues(values, value, dtype) {\n    if (dtype === 'string') {\n        values.fill(value);\n    }\n    else {\n        values.fill(value);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar flipLeftRightConfig = {\n    kernelName: tfjsCore.FlipLeftRight,\n    backendName: 'cpu',\n    kernelFunc: function (_a) {\n        var inputs = _a.inputs, attrs = _a.attrs, backend = _a.backend;\n        var image = inputs.image;\n        var cpuBackend = backend;\n        var output = tfjsCore.util.getTypedArrayFromDType(image.dtype, tfjsCore.util.sizeFromShape(image.shape));\n        var _b = image.shape, batch = _b[0], imageHeight = _b[1], imageWidth = _b[2], numChannels = _b[3];\n        var imageVals = cpuBackend.data.get(image.dataId).values;\n        for (var batchIdx = 0; batchIdx < batch; batchIdx++) {\n            var batchOffset = batchIdx * imageWidth * imageHeight * numChannels;\n            for (var row = 0; row < imageHeight; row++) {\n                var rowOffset = row * (imageWidth * numChannels);\n                for (var col = 0; col < imageWidth; col++) {\n                    var colOffset = col * numChannels;\n                    for (var channel = 0; channel < numChannels; channel++) {\n                        var coords = [batch, row, col, channel];\n                        var x = coords[2];\n                        var coordX = Math.round(imageWidth - x);\n                        var outIdx = batchOffset + rowOffset + colOffset + channel;\n                        var outputValue = imageVals[outIdx];\n                        // If the coordinate position falls within the image boundaries...\n                        if (coordX >= 0 && coordX < imageWidth) {\n                            // set the output to the image value at the coordinate position.\n                            var rotatedColOffset = coordX * numChannels;\n                            var imageIdx = batchOffset + rowOffset + rotatedColOffset + channel;\n                            outputValue = imageVals[imageIdx];\n                        }\n                        output[outIdx] = outputValue;\n                    }\n                }\n            }\n        }\n        var dataId = cpuBackend.write(output, image.shape, image.dtype);\n        return { dataId: dataId, shape: image.shape, dtype: image.dtype };\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar floorDivImpl = createSimpleBinaryKernelImpl(function (a, b) { return Math.floor(a / b); });\nvar floorDiv = binaryKernelFunc(tfjsCore.FloorDiv, floorDivImpl, null /* complexImpl */, 'int32');\nvar floorDivConfig = {\n    kernelName: tfjsCore.FloorDiv,\n    backendName: 'cpu',\n    kernelFunc: floorDiv\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction fusedConv2D(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, filter = inputs.filter, bias = inputs.bias, preluActivationWeights = inputs.preluActivationWeights;\n    var strides = attrs.strides, pad = attrs.pad, dataFormat = attrs.dataFormat, dilations = attrs.dilations, dimRoundingMode = attrs.dimRoundingMode, activation = attrs.activation, leakyreluAlpha = attrs.leakyreluAlpha;\n    var result = conv2D({\n        inputs: { x: x, filter: filter },\n        backend: backend,\n        attrs: { strides: strides, pad: pad, dataFormat: dataFormat, dilations: dilations, dimRoundingMode: dimRoundingMode }\n    });\n    if (bias) {\n        var resultOld = result;\n        result = add({ inputs: { a: result, b: bias }, backend: backend });\n        backend.disposeIntermediateTensorInfo(resultOld);\n    }\n    if (activation) {\n        var resultOld = result;\n        result = applyActivation(backend, result, activation, preluActivationWeights, leakyreluAlpha);\n        backend.disposeIntermediateTensorInfo(resultOld);\n    }\n    return result;\n}\nvar fusedConv2DConfig = {\n    kernelName: tfjsCore.FusedConv2D,\n    backendName: 'cpu',\n    kernelFunc: fusedConv2D\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction fusedDepthwiseConv2D(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, filter = inputs.filter, bias = inputs.bias, preluActivationWeights = inputs.preluActivationWeights;\n    var strides = attrs.strides, pad = attrs.pad, dataFormat = attrs.dataFormat, dilations = attrs.dilations, dimRoundingMode = attrs.dimRoundingMode, activation = attrs.activation, leakyreluAlpha = attrs.leakyreluAlpha;\n    var result = depthwiseConv2dNative({\n        inputs: { x: x, filter: filter },\n        backend: backend,\n        attrs: { strides: strides, pad: pad, dataFormat: dataFormat, dilations: dilations, dimRoundingMode: dimRoundingMode }\n    });\n    if (bias) {\n        var oldResult = result;\n        result = add({ inputs: { a: result, b: bias }, backend: backend });\n        backend.disposeIntermediateTensorInfo(oldResult);\n    }\n    if (activation) {\n        var oldResult = result;\n        result = applyActivation(backend, result, activation, preluActivationWeights, leakyreluAlpha);\n        backend.disposeIntermediateTensorInfo(oldResult);\n    }\n    return result;\n}\nvar fusedDepthwiseConv2DConfig = {\n    kernelName: tfjsCore.FusedDepthwiseConv2D,\n    backendName: 'cpu',\n    kernelFunc: fusedDepthwiseConv2D\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction gatherNd(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var params = inputs.params, indices = inputs.indices;\n    var paramsSize = tfjsCore.util.sizeFromShape(params.shape);\n    var indicesShape = indices.shape;\n    var sliceRank = indicesShape[indicesShape.length - 1];\n    var _a = tfjsCore.backend_util.prepareAndValidate(params, indices), resultShape = _a[0], numSlices = _a[1], sliceSize = _a[2], strides = _a[3];\n    if (numSlices === 0) {\n        return backend.makeTensorInfo(resultShape, params.dtype, []);\n    }\n    var outBuf = tfjsCore.buffer([numSlices, sliceSize], params.dtype);\n    var indicesData = backend.data.get(indices.dataId).values;\n    var paramsData = backend.data.get(params.dataId).values;\n    for (var i = 0; i < numSlices; i++) {\n        var index = [];\n        var flattenIndex = 0;\n        for (var j = 0; j < sliceRank; j++) {\n            var dim = indicesData[i * sliceRank + j];\n            flattenIndex += dim * strides[j];\n            index.push(dim);\n        }\n        if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) {\n            throw new Error(\"Invalid indices: \" + index + \" does not index into \" + params.shape);\n        }\n        for (var k = 0; k < sliceSize; k++) {\n            outBuf.values[i * sliceSize + k] =\n                paramsData[flattenIndex * sliceSize + k];\n        }\n    }\n    return backend.makeTensorInfo(resultShape, outBuf.dtype, outBuf.values);\n}\nvar gatherNdConfig = {\n    kernelName: tfjsCore.GatherNd,\n    backendName: 'cpu',\n    kernelFunc: gatherNd\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction gatherV2(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, indices = inputs.indices;\n    var axis = attrs.axis, batchDims = attrs.batchDims;\n    assertNotComplex([x, indices], 'gatherV2');\n    var $batchDims = batchDims;\n    if (batchDims == null) {\n        $batchDims = 0;\n    }\n    var indicesSize = tfjsCore.util.sizeFromShape(indices.shape);\n    var parsedAxis = tfjsCore.util.parseAxisParam(axis, x.shape)[0];\n    var shapeInfo = tfjsCore.backend_util.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, $batchDims);\n    var flattenX = reshape({\n        inputs: { x: x },\n        backend: backend,\n        attrs: {\n            shape: [\n                shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize,\n                shapeInfo.sliceSize\n            ]\n        }\n    });\n    var flattenIndex = reshape({\n        inputs: { x: indices },\n        backend: backend,\n        attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }\n    });\n    var flattenOutputShape = [\n        shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize,\n        shapeInfo.sliceSize\n    ];\n    var indicesBuf = backend.bufferSync(flattenIndex);\n    var xBuf = backend.bufferSync(flattenX);\n    var outBuf = gatherV2Impl(xBuf, indicesBuf, flattenOutputShape);\n    backend.disposeIntermediateTensorInfo(flattenX);\n    backend.disposeIntermediateTensorInfo(flattenIndex);\n    return backend.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);\n}\nvar gatherV2Config = {\n    kernelName: tfjsCore.GatherV2,\n    backendName: 'cpu',\n    kernelFunc: gatherV2\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar greaterEqualImpl = createSimpleBinaryKernelImpl(function (a, b) { return (a >= b) ? 1 : 0; });\nvar greaterEqual = binaryKernelFunc(tfjsCore.GreaterEqual, greaterEqualImpl, null /* complexImpl */, 'bool');\nvar greaterEqualConfig = {\n    kernelName: tfjsCore.GreaterEqual,\n    backendName: 'cpu',\n    kernelFunc: greaterEqual\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction ifft(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var input = inputs.input;\n    var inputSize = tfjsCore.util.sizeFromShape(input.shape);\n    // Collapse all outer dimensions to a single batch dimension.\n    var innerDimensionSize = input.shape[input.shape.length - 1];\n    var batch = inputSize / innerDimensionSize;\n    var input2D = reshape({\n        inputs: { x: input },\n        backend: backend,\n        attrs: { shape: [batch, innerDimensionSize] }\n    });\n    var result = fftBatch(input2D, true, backend);\n    var resultReshaped = reshape({ inputs: { x: result }, backend: backend, attrs: { shape: input.shape } });\n    backend.disposeIntermediateTensorInfo(input2D);\n    backend.disposeIntermediateTensorInfo(result);\n    return resultReshaped;\n}\nvar ifftConfig = {\n    kernelName: tfjsCore.IFFT,\n    backendName: 'cpu',\n    kernelFunc: ifft\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar isFinite = unaryKernelFunc(tfjsCore.IsFinite, function (xi) { return Number.isFinite(xi) ? 1 : 0; }, 'bool');\nvar isFiniteConfig = {\n    kernelName: tfjsCore.IsFinite,\n    backendName: 'cpu',\n    kernelFunc: isFinite,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar isInf = unaryKernelFunc(tfjsCore.IsInf, function (xi) { return Math.abs(xi) === Infinity ? 1 : 0; }, 'bool');\nvar isInfConfig = {\n    kernelName: tfjsCore.IsInf,\n    backendName: 'cpu',\n    kernelFunc: isInf,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar isNaN$1 = unaryKernelFunc(tfjsCore.IsNan, function (xi) { return Number.isNaN(xi) ? 1 : 0; }, 'bool');\nvar isNaNConfig = {\n    kernelName: tfjsCore.IsNan,\n    backendName: 'cpu',\n    kernelFunc: isNaN$1,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar lessEqualImpl = createSimpleBinaryKernelImpl(function (a, b) { return (a <= b) ? 1 : 0; });\nvar lessEqual = binaryKernelFunc(tfjsCore.LessEqual, lessEqualImpl, null /* complexImpl */, 'bool');\nvar lessEqualConfig = {\n    kernelName: tfjsCore.LessEqual,\n    backendName: 'cpu',\n    kernelFunc: lessEqual\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction linSpace(args) {\n    var backend = args.backend, attrs = args.attrs;\n    var start = attrs.start, stop = attrs.stop, num = attrs.num;\n    var outVals = linSpaceImpl(start, stop, num);\n    return backend.makeTensorInfo([outVals.length], 'float32', outVals);\n}\nvar linSpaceConfig = {\n    kernelName: tfjsCore.LinSpace,\n    backendName: 'cpu',\n    kernelFunc: linSpace\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar log1p = unaryKernelFunc(tfjsCore.Log1p, function (xi) { return Math.log1p(xi); });\nvar log1pConfig = {\n    kernelName: tfjsCore.Log1p,\n    backendName: 'cpu',\n    kernelFunc: log1p,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar logicalAndImpl = createSimpleBinaryKernelImpl(function (a, b) { return a && b; });\nvar logicalAnd = binaryKernelFunc(tfjsCore.LogicalAnd, logicalAndImpl, null /* complexImpl */, 'bool');\nvar logicalAndConfig = {\n    kernelName: tfjsCore.LogicalAnd,\n    backendName: 'cpu',\n    kernelFunc: logicalAnd\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar logicalNot = unaryKernelFunc(tfjsCore.LogicalNot, function (xi) { return xi ? 0 : 1; }, 'bool');\nvar logicalNotConfig = {\n    kernelName: tfjsCore.LogicalNot,\n    backendName: 'cpu',\n    kernelFunc: logicalNot,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar logicalOrImpl = createSimpleBinaryKernelImpl(function (a, b) { return a || b; });\nvar logicalOr = binaryKernelFunc(tfjsCore.LogicalOr, logicalOrImpl, null /* complexImpl */, 'bool');\nvar logicalOrConfig = {\n    kernelName: tfjsCore.LogicalOr,\n    backendName: 'cpu',\n    kernelFunc: logicalOr\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction lRN(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var depthRadius = attrs.depthRadius, bias = attrs.bias, alpha = attrs.alpha, beta = attrs.beta;\n    assertNotComplex(x, 'LRN');\n    var channels = x.shape[3];\n    var maxD = channels - 1;\n    var xValues = backend.data.get(x.dataId).values;\n    var size = tfjsCore.util.sizeFromShape(x.shape);\n    var result = new Float32Array(size);\n    function sumAcrossChannels(offset) {\n        var currentChannel = offset % channels;\n        var beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n        var endSumOffset = offset - currentChannel + Math.min(currentChannel + depthRadius, maxD);\n        var sum = 0.0;\n        for (; beginSumOffset <= endSumOffset; beginSumOffset++) {\n            var z = xValues[beginSumOffset];\n            sum += z * z;\n        }\n        return sum;\n    }\n    for (var offset = 0; offset < size; offset++) {\n        var sum = sumAcrossChannels(offset);\n        var val = xValues[offset] * Math.pow(bias + alpha * sum, -beta);\n        result[offset] = val;\n    }\n    return backend.makeTensorInfo(x.shape, x.dtype, result);\n}\nvar lRNConfig = {\n    kernelName: tfjsCore.LRN,\n    backendName: 'cpu',\n    kernelFunc: lRN\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction lRNGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, y = inputs.y, dy = inputs.dy;\n    var depthRadius = attrs.depthRadius, bias = attrs.bias, alpha = attrs.alpha, beta = attrs.beta;\n    assertNotComplex(dy, 'LRNGrad');\n    var dySize = tfjsCore.util.sizeFromShape(dy.shape);\n    var channels = dy.shape[3];\n    var dyValues = backend.data.get(dy.dataId).values;\n    var xValues = backend.data.get(x.dataId).values;\n    var yValues = backend.data.get(y.dataId).values;\n    var result = new Float32Array(dySize);\n    var size = dySize;\n    for (var offset = 0; offset < size; offset++) {\n        var currentChannel = offset % channels;\n        var depthBegin = (offset - currentChannel) + Math.max(0, currentChannel - depthRadius);\n        var depthEnd = (offset - currentChannel) +\n            Math.min(channels, currentChannel + depthRadius + 1);\n        var norm = 0;\n        for (var k = depthBegin; k < depthEnd; k++) {\n            norm += Math.pow(xValues[k], 2);\n        }\n        norm = alpha * norm + bias;\n        for (var k = depthBegin; k < depthEnd; k++) {\n            var dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm;\n            if (offset === k) {\n                dyi += Math.pow(norm, -beta);\n            }\n            dyi *= dyValues[offset];\n            result[k] += dyi;\n        }\n    }\n    return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\nvar lRNGradConfig = {\n    kernelName: tfjsCore.LRNGrad,\n    backendName: 'cpu',\n    kernelFunc: lRNGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction max(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var reductionIndices = attrs.reductionIndices, keepDims = attrs.keepDims;\n    var cpuBackend = backend;\n    var xShape = x.shape;\n    var xRank = xShape.length;\n    var origAxes = tfjsCore.util.parseAxisParam(reductionIndices, xShape);\n    var axes = origAxes;\n    var permutedAxes = tfjsCore.backend_util.getAxesPermutation(axes, xRank);\n    var xVals = cpuBackend.data.get(x.dataId).values;\n    if (permutedAxes != null) {\n        var newShape = new Array(xRank);\n        for (var i = 0; i < newShape.length; i++) {\n            newShape[i] = xShape[permutedAxes[i]];\n        }\n        xVals = transposeImpl(xVals, xShape, x.dtype, permutedAxes, newShape);\n        axes = tfjsCore.backend_util.getInnerMostAxes(axes.length, xRank);\n        xShape = newShape;\n    }\n    assertNotComplex(x, 'max');\n    tfjsCore.backend_util.assertAxesAreInnerMostDims('max', axes, xRank);\n    var _a = tfjsCore.backend_util.computeOutAndReduceShapes(xShape, axes), maxOutShape = _a[0], reduceShape = _a[1];\n    var reduceSize = tfjsCore.util.sizeFromShape(reduceShape);\n    var result = maxImpl(xVals, reduceSize, maxOutShape, x.dtype);\n    var dataId = cpuBackend.write(result, maxOutShape, x.dtype);\n    var outShape = maxOutShape;\n    if (keepDims) {\n        // reshape\n        var newShape = tfjsCore.backend_util.expandShapeToKeepDim(maxOutShape, origAxes);\n        outShape = newShape;\n    }\n    return { dataId: dataId, shape: outShape, dtype: x.dtype };\n}\nvar maxConfig = {\n    kernelName: tfjsCore.Max,\n    backendName: 'cpu',\n    kernelFunc: max\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxPool(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    assertNotComplex(x, 'maxPool');\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode;\n    var dilations = 1;\n    tfjsCore.util.assert(tfjsCore.backend_util.eitherStridesOrDilationsAreOne(strides, dilations), function () { return 'Error in maxPool: Either strides or dilations must be 1. ' +\n        (\"Got strides \" + strides + \" and dilations '\" + dilations + \"'\"); });\n    var convInfo = tfjsCore.backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    var res;\n    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n        tfjsCore.util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n        res = identity({ inputs: { x: x }, backend: backend });\n    }\n    else {\n        var xValues = backend.data.get(x.dataId).values;\n        var strides_1 = tfjsCore.util.computeStrides(x.shape);\n        var buffer = pool(xValues, x.shape, x.dtype, strides_1, convInfo, 'max');\n        res = backend.makeTensorInfo(convInfo.outShape, x.dtype, buffer.values);\n    }\n    return res;\n}\nvar maxPoolConfig = {\n    kernelName: tfjsCore.MaxPool,\n    backendName: 'cpu',\n    kernelFunc: maxPool\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxPool3D(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode, dataFormat = attrs.dataFormat, dilations = attrs.dilations;\n    assertNotComplex(x, 'maxPool3d');\n    var $dilations = dilations;\n    if ($dilations == null) {\n        $dilations = [1, 1, 1];\n    }\n    var convInfo = tfjsCore.backend_util.computePool3DInfo(x.shape, filterSize, strides, $dilations, pad, dimRoundingMode, dataFormat);\n    var xValues = backend.data.get(x.dataId).values;\n    var outBuf = pool3d(xValues, x.shape, x.dtype, tfjsCore.util.computeStrides(x.shape), convInfo, 'max');\n    return backend.makeTensorInfo(outBuf.shape, 'float32', outBuf.values);\n}\nvar maxPool3DConfig = {\n    kernelName: tfjsCore.MaxPool3D,\n    backendName: 'cpu',\n    kernelFunc: maxPool3D\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxPool3DGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, input = inputs.input;\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dilations = attrs.dilations, dimRoundingMode = attrs.dimRoundingMode;\n    assertNotComplex([dy, input], 'maxPool3DGrad');\n    var convInfo = tfjsCore.backend_util.computePool3DInfo(input.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    var inputBuf = backend.bufferSync(input);\n    var maxPosBuf = maxPool3dPositions(inputBuf, convInfo);\n    var strideDepth = convInfo.strideDepth;\n    var strideHeight = convInfo.strideHeight;\n    var strideWidth = convInfo.strideWidth;\n    var dilationDepth = convInfo.dilationDepth;\n    var dilationHeight = convInfo.dilationHeight;\n    var dilationWidth = convInfo.dilationWidth;\n    var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    var padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n    var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    var dx = tfjsCore.buffer(input.shape, 'float32');\n    var dyBuf = backend.bufferSync(dy);\n    for (var batch = 0; batch < convInfo.batchSize; ++batch) {\n        for (var channel = 0; channel < convInfo.inChannels; ++channel) {\n            for (var dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n                for (var dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n                    for (var dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n                        // Shader code begins\n                        var dyDepthCorner = dxDepth - padFront;\n                        var dyRowCorner = dxRow - padTop;\n                        var dyColCorner = dxCol - padLeft;\n                        var dotProd = 0;\n                        for (var wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                            var dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n                            if (dyDepth < 0 || dyDepth >= convInfo.outDepth ||\n                                Math.floor(dyDepth) !== dyDepth) {\n                                continue;\n                            }\n                            for (var wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                                var dyRow = (dyRowCorner + wRow) / strideHeight;\n                                if (dyRow < 0 || dyRow >= convInfo.outHeight ||\n                                    Math.floor(dyRow) !== dyRow) {\n                                    continue;\n                                }\n                                for (var wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                                    var dyCol = (dyColCorner + wCol) / strideWidth;\n                                    if (dyCol < 0 || dyCol >= convInfo.outWidth ||\n                                        Math.floor(dyCol) !== dyCol) {\n                                        continue;\n                                    }\n                                    var maxPos = effectiveFilterDepth * effectiveFilterHeight *\n                                        effectiveFilterWidth -\n                                        1 -\n                                        maxPosBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                    var curPos = wDepth * effectiveFilterHeight * effectiveFilterWidth +\n                                        wRow * effectiveFilterWidth + wCol;\n                                    var mask = maxPos === curPos ? 1 : 0;\n                                    if (mask === 0) {\n                                        continue;\n                                    }\n                                    var pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                    dotProd += pixel * mask;\n                                }\n                            }\n                        }\n                        dx.set(dotProd, batch, dxDepth, dxRow, dxCol, channel);\n                    }\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);\n}\nvar maxPool3DGradConfig = {\n    kernelName: tfjsCore.MaxPool3DGrad,\n    backendName: 'cpu',\n    kernelFunc: maxPool3DGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxPoolGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, input = inputs.input, output = inputs.output;\n    var x = input;\n    assertNotComplex([input, output], 'maxPoolGrad');\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode;\n    var convInfo = tfjsCore.backend_util.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */, pad, dimRoundingMode);\n    var xValues = backend.data.get(x.dataId).values;\n    var maxPosBuf = tfjsCore.buffer(convInfo.outShape, x.dtype, maxPoolPositions(xValues, x.shape, x.dtype, convInfo).values);\n    var strideHeight = convInfo.strideHeight;\n    var strideWidth = convInfo.strideWidth;\n    var dilationHeight = convInfo.dilationHeight;\n    var dilationWidth = convInfo.dilationWidth;\n    var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n    var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    var dx = tfjsCore.buffer(x.shape, 'float32');\n    var dyData = backend.data.get(dy.dataId).values;\n    var dyBuf = tfjsCore.buffer(dy.shape, 'float32', dyData);\n    for (var b = 0; b < convInfo.batchSize; ++b) {\n        for (var d = 0; d < convInfo.inChannels; ++d) {\n            for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {\n                for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {\n                    // Shader code begins.\n                    var dyRCorner = dxR - padTop;\n                    var dyCCorner = dxC - padLeft;\n                    var dotProd = 0;\n                    for (var wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {\n                        var dyR = (dyRCorner + wR) / strideHeight;\n                        if (dyR < 0 || dyR >= convInfo.outHeight ||\n                            Math.floor(dyR) !== dyR) {\n                            continue;\n                        }\n                        for (var wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {\n                            var dyC = (dyCCorner + wC) / strideWidth;\n                            if (dyC < 0 || dyC >= convInfo.outWidth ||\n                                Math.floor(dyC) !== dyC) {\n                                continue;\n                            }\n                            var maxPos = effectiveFilterHeight * effectiveFilterWidth - 1 -\n                                maxPosBuf.get(b, dyR, dyC, d);\n                            var curPos = wR * effectiveFilterWidth + wC;\n                            var mask = maxPos === curPos ? 1 : 0;\n                            if (mask === 0) {\n                                continue;\n                            }\n                            var pixel = dyBuf.get(b, dyR, dyC, d);\n                            dotProd += pixel * mask;\n                        }\n                    }\n                    dx.set(dotProd, b, dxR, dxC, d);\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);\n}\nvar maxPoolGradConfig = {\n    kernelName: tfjsCore.MaxPoolGrad,\n    backendName: 'cpu',\n    kernelFunc: maxPoolGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxPoolWithArgmaxImpl(xValues, xShape, dtype, includeBatchInIndex, convInfo) {\n    var strides = tfjsCore.util.computeStrides(xShape);\n    var maxPools = pool(xValues, xShape, dtype, strides, convInfo, 'max');\n    var maxPositions = maxPoolPositions(xValues, xShape, dtype, convInfo, true, includeBatchInIndex);\n    return [maxPools.values, maxPositions.values];\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar maxPoolWithArgmaxConfig = {\n    kernelName: tfjsCore.MaxPoolWithArgmax,\n    backendName: 'cpu',\n    kernelFunc: function (_a) {\n        var inputs = _a.inputs, attrs = _a.attrs, backend = _a.backend;\n        var x = inputs.x;\n        var _b = attrs, filterSize = _b.filterSize, strides = _b.strides, pad = _b.pad, includeBatchInIndex = _b.includeBatchInIndex;\n        var cpuBackend = backend;\n        assertNotComplex(x, 'MaxPoolWithArgmax');\n        var values = cpuBackend.data.get(x.dataId).values;\n        var convInfo = tfjsCore.backend_util.computePool2DInfo(x.shape, filterSize, strides, [1, 1], pad);\n        var _c = maxPoolWithArgmaxImpl(values, x.shape, x.dtype, includeBatchInIndex, convInfo), pooled = _c[0], indexes = _c[1];\n        var pooledDataId = cpuBackend.write(pooled, convInfo.outShape, x.dtype);\n        var indexesDataId = cpuBackend.write(indexes, convInfo.outShape, x.dtype);\n        return [\n            { dataId: pooledDataId, shape: convInfo.outShape, dtype: x.dtype },\n            { dataId: indexesDataId, shape: convInfo.outShape, dtype: 'int32' }\n        ];\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction sum(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, keepDims = attrs.keepDims;\n    assertNotComplex(x, 'sum');\n    var $x;\n    if (x.dtype === 'bool') {\n        $x = cast({ inputs: { x: x }, backend: backend, attrs: { dtype: 'int32' } });\n    }\n    else {\n        $x = identity({ inputs: { x: x }, backend: backend });\n    }\n    var xRank = $x.shape.length;\n    var axes = tfjsCore.util.parseAxisParam(axis, $x.shape);\n    var permutation = tfjsCore.backend_util.getAxesPermutation(axes, xRank);\n    var reductionAxes = axes;\n    var permutedX = $x;\n    if (permutation != null) {\n        permutedX =\n            transpose({ inputs: { x: $x }, backend: backend, attrs: { perm: permutation } });\n        reductionAxes = tfjsCore.backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n    }\n    tfjsCore.backend_util.assertAxesAreInnerMostDims('sum', reductionAxes, permutedX.shape.length);\n    var _a = tfjsCore.backend_util.computeOutAndReduceShapes(permutedX.shape, reductionAxes), outShape = _a[0], reduceShape = _a[1];\n    var resultDtype = tfjsCore.backend_util.upcastType(permutedX.dtype, 'int32');\n    var result = zeros(backend, outShape, resultDtype);\n    var reduceSize = tfjsCore.util.sizeFromShape(reduceShape);\n    var vals = backend.data.get(result.dataId).values;\n    var aVals = backend.data.get(permutedX.dataId).values;\n    for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var sum_1 = 0;\n        for (var j = 0; j < reduceSize; ++j) {\n            sum_1 += aVals[offset + j];\n        }\n        vals[i] = sum_1;\n    }\n    if (keepDims) {\n        var newShape = tfjsCore.backend_util.expandShapeToKeepDim(result.shape, axes);\n        var oldResult = result;\n        result = reshape({ inputs: { x: result }, backend: backend, attrs: { shape: newShape } });\n        backend.disposeIntermediateTensorInfo(oldResult);\n    }\n    backend.disposeIntermediateTensorInfo($x);\n    if (permutation != null) {\n        backend.disposeIntermediateTensorInfo(permutedX);\n    }\n    return result;\n}\nvar sumConfig = {\n    kernelName: tfjsCore.Sum,\n    backendName: 'cpu',\n    kernelFunc: sum\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction mean(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, keepDims = attrs.keepDims;\n    var axes = tfjsCore.util.parseAxisParam(axis, x.shape);\n    var shapes = tfjsCore.backend_util.computeOutAndReduceShapes(x.shape, axes);\n    var reduceShape = shapes[1];\n    var reduceSize = tfjsCore.util.sizeFromShape(reduceShape);\n    var toDispose = [];\n    var reduceSizeScalar = backend.makeTensorInfo([], 'float32', new Float32Array([reduceSize]));\n    toDispose.push(reduceSizeScalar);\n    var $x = cast({ inputs: { x: x }, backend: backend, attrs: { dtype: 'float32' } });\n    toDispose.push($x);\n    var res = div({ inputs: { a: $x, b: reduceSizeScalar }, backend: backend });\n    toDispose.push(res);\n    var result = sum({ inputs: { x: res }, backend: backend, attrs: { axis: axis, keepDims: keepDims } });\n    toDispose.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return result;\n}\nvar meanConfig = {\n    kernelName: tfjsCore.Mean,\n    backendName: 'cpu',\n    kernelFunc: mean\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction min(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, keepDims = attrs.keepDims;\n    assertNotComplex(x, 'min');\n    var origAxes = tfjsCore.util.parseAxisParam(axis, x.shape);\n    var axes = origAxes;\n    var permutedAxes = tfjsCore.backend_util.getAxesPermutation(axes, x.shape.length);\n    var $x = x;\n    if (permutedAxes != null) {\n        $x = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutedAxes } });\n        axes = tfjsCore.backend_util.getInnerMostAxes(axes.length, x.shape.length);\n    }\n    tfjsCore.backend_util.assertAxesAreInnerMostDims('min', axes, $x.shape.length);\n    var _a = tfjsCore.backend_util.computeOutAndReduceShapes($x.shape, axes), outShape = _a[0], reduceShape = _a[1];\n    var reduceSize = tfjsCore.util.sizeFromShape(reduceShape);\n    var vals = tfjsCore.util.makeZerosTypedArray(tfjsCore.util.sizeFromShape(outShape), $x.dtype);\n    var aVals = backend.data.get($x.dataId).values;\n    for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var min_1 = aVals[offset];\n        for (var j = 0; j < reduceSize; ++j) {\n            var value = aVals[offset + j];\n            if (value < min_1) {\n                min_1 = value;\n            }\n        }\n        vals[i] = min_1;\n    }\n    if (permutedAxes != null) {\n        backend.disposeIntermediateTensorInfo($x);\n    }\n    var result = backend.makeTensorInfo(outShape, $x.dtype, vals);\n    if (keepDims) {\n        var expandedShape = tfjsCore.backend_util.expandShapeToKeepDim(outShape, origAxes);\n        var reshapedResult = reshape({ inputs: { x: result }, backend: backend, attrs: { shape: expandedShape } });\n        backend.disposeIntermediateTensorInfo(result);\n        return reshapedResult;\n    }\n    return result;\n}\nvar minConfig = {\n    kernelName: tfjsCore.Min,\n    backendName: 'cpu',\n    kernelFunc: min\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction mirrorPad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var paddings = attrs.paddings, mode = attrs.mode;\n    assertNotComplex(x, 'mirrorPad');\n    var outShape = paddings.map(function (p, i) { return p[0] /* beforePad */ + x.shape[i] + p[1]; } /* afterPad */);\n    var start = paddings.map(function (p) { return p[0]; });\n    var end = paddings.map(function (p, i) { return p[0] + x.shape[i]; });\n    var offset = mode === 'reflect' ? 0 : 1;\n    var xVals = backend.data.get(x.dataId).values;\n    var xRank = x.shape.length;\n    var xStrides = tfjsCore.util.computeStrides(x.shape);\n    var resultSize = tfjsCore.util.sizeFromShape(outShape);\n    var resultRank = outShape.length;\n    var resultStrides = tfjsCore.util.computeStrides(outShape);\n    var resVals = tfjsCore.util.getTypedArrayFromDType(x.dtype, resultSize);\n    for (var i = 0; i < resultSize; i++) {\n        var coords = tfjsCore.util.indexToLoc(i, resultRank, resultStrides);\n        for (var i_1 = 0; i_1 < resultRank; i_1++) {\n            if (coords[i_1] < start[i_1]) {\n                coords[i_1] = start[i_1] * 2 - coords[i_1] - offset;\n            }\n            else if (coords[i_1] >= end[i_1]) {\n                coords[i_1] = (end[i_1] - 1) * 2 - coords[i_1] + offset;\n            }\n        }\n        coords = coords.map(function (c, i) { return c - start[i]; });\n        var inIndex = tfjsCore.util.locToIndex(coords, xRank, xStrides);\n        resVals[i] = xVals[inIndex];\n    }\n    var outId = backend.write(resVals, outShape, x.dtype);\n    return { dataId: outId, shape: outShape, dtype: x.dtype };\n}\nvar mirrorPadConfig = {\n    kernelName: tfjsCore.MirrorPad,\n    backendName: 'cpu',\n    kernelFunc: mirrorPad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar modImpl = createSimpleBinaryKernelImpl((function (aValue, bValue) {\n    var rem = aValue % bValue;\n    if ((aValue < 0 && bValue < 0) || (aValue >= 0 && bValue >= 0)) {\n        return rem;\n    }\n    else {\n        return (rem + bValue) % bValue;\n    }\n}));\nvar mod = binaryKernelFunc(tfjsCore.Mod, modImpl);\nvar modConfig = {\n    kernelName: tfjsCore.Mod,\n    backendName: 'cpu',\n    kernelFunc: mod\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction softmax(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var logits = inputs.logits;\n    var dim = attrs.dim;\n    var logitsRank = logits.shape.length;\n    var $dim = dim;\n    if ($dim === -1) {\n        $dim = logitsRank - 1;\n    }\n    if ($dim !== logitsRank - 1) {\n        throw Error('Softmax along a non-last dimension is not yet supported. ' +\n            (\"Logits was rank \" + logitsRank + \" and dim was \" + $dim));\n    }\n    var axes = tfjsCore.util.parseAxisParam([$dim], logits.shape);\n    var maxLogit = max({\n        inputs: { x: logits },\n        backend: backend,\n        attrs: { reductionIndices: axes, keepDims: false }\n    });\n    var expandedShape = tfjsCore.backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n    var maxLogitReshaped = reshape({ inputs: { x: maxLogit }, backend: backend, attrs: { shape: expandedShape } });\n    var a = sub({ inputs: { a: logits, b: maxLogitReshaped }, backend: backend });\n    var b = exp({ inputs: { x: a }, backend: backend });\n    var sumExp = sum({ inputs: { x: b }, backend: backend, attrs: { axis: axes, keepDims: false } });\n    var sumReshaped = reshape({ inputs: { x: sumExp }, backend: backend, attrs: { shape: expandedShape } });\n    var result = div({ inputs: { a: b, b: sumReshaped }, backend: backend });\n    backend.disposeIntermediateTensorInfo(maxLogit);\n    backend.disposeIntermediateTensorInfo(maxLogitReshaped);\n    backend.disposeIntermediateTensorInfo(a);\n    backend.disposeIntermediateTensorInfo(b);\n    backend.disposeIntermediateTensorInfo(sumExp);\n    backend.disposeIntermediateTensorInfo(sumReshaped);\n    return result;\n}\nvar softmaxConfig = {\n    kernelName: tfjsCore.Softmax,\n    backendName: 'cpu',\n    kernelFunc: softmax\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction multinomial(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var logits = inputs.logits;\n    var numSamples = attrs.numSamples, seed = attrs.seed, normalized = attrs.normalized;\n    assertNotComplex(logits, 'multinomial');\n    var probabilities = normalized ?\n        logits :\n        softmax({ inputs: { logits: logits }, backend: backend, attrs: { dim: -1 } });\n    var batchSize = probabilities.shape[0];\n    var numEvents = probabilities.shape[1];\n    var probVals = backend.data.get(probabilities.dataId).values;\n    var resShape = [batchSize, numSamples];\n    var resVals = tfjsCore.util.makeZerosTypedArray(tfjsCore.util.sizeFromShape(resShape), 'int32');\n    for (var b = 0; b < batchSize; ++b) {\n        var offset = b * numEvents;\n        // The cdf won't include the last event. It will be implicit if no other\n        // event happened.\n        var cdf = new Float32Array(numEvents - 1);\n        cdf[0] = probVals[offset];\n        for (var event_1 = 1; event_1 < cdf.length; ++event_1) {\n            cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1];\n        }\n        var random = seedrandom.alea(seed.toString());\n        var outOffset = b * numSamples;\n        for (var sampleId = 0; sampleId < numSamples; ++sampleId) {\n            var r = random();\n            // Assume last event happened by default.\n            resVals[outOffset + sampleId] = cdf.length;\n            for (var event_2 = 0; event_2 < cdf.length; event_2++) {\n                if (r < cdf[event_2]) {\n                    resVals[outOffset + sampleId] = event_2;\n                    break;\n                }\n            }\n        }\n    }\n    if (!normalized) {\n        backend.disposeIntermediateTensorInfo(probabilities);\n    }\n    return backend.makeTensorInfo(resShape, 'int32', resVals);\n}\nvar multinomialConfig = {\n    kernelName: tfjsCore.Multinomial,\n    backendName: 'cpu',\n    kernelFunc: multinomial\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar nonMaxSuppressionV3Impl = tfjsCore.kernel_impls.nonMaxSuppressionV3Impl;\nfunction nonMaxSuppressionV3(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var boxes = inputs.boxes, scores = inputs.scores;\n    var maxOutputSize = attrs.maxOutputSize, iouThreshold = attrs.iouThreshold, scoreThreshold = attrs.scoreThreshold;\n    assertNotComplex(boxes, 'NonMaxSuppression');\n    var boxesVals = backend.data.get(boxes.dataId).values;\n    var scoresVals = backend.data.get(scores.dataId).values;\n    var selectedIndices = nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold).selectedIndices;\n    return backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices));\n}\nvar nonMaxSuppressionV3Config = {\n    kernelName: tfjsCore.NonMaxSuppressionV3,\n    backendName: 'cpu',\n    kernelFunc: nonMaxSuppressionV3\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar nonMaxSuppressionV4Impl = tfjsCore.kernel_impls.nonMaxSuppressionV4Impl;\nfunction nonMaxSuppressionV4(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var boxes = inputs.boxes, scores = inputs.scores;\n    var maxOutputSize = attrs.maxOutputSize, iouThreshold = attrs.iouThreshold, scoreThreshold = attrs.scoreThreshold, padToMaxOutputSize = attrs.padToMaxOutputSize;\n    assertNotComplex(boxes, 'NonMaxSuppressionPadded');\n    var boxesVals = backend.data.get(boxes.dataId).values;\n    var scoresVals = backend.data.get(scores.dataId).values;\n    var _a = nonMaxSuppressionV4Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize), selectedIndices = _a.selectedIndices, validOutputs = _a.validOutputs;\n    return [\n        backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices)),\n        backend.makeTensorInfo([], 'int32', new Int32Array([validOutputs]))\n    ];\n}\nvar nonMaxSuppressionV4Config = {\n    kernelName: tfjsCore.NonMaxSuppressionV4,\n    backendName: 'cpu',\n    kernelFunc: nonMaxSuppressionV4\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar nonMaxSuppressionV5Impl = tfjsCore.kernel_impls.nonMaxSuppressionV5Impl;\nfunction nonMaxSuppressionV5(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var boxes = inputs.boxes, scores = inputs.scores;\n    var maxOutputSize = attrs.maxOutputSize, iouThreshold = attrs.iouThreshold, scoreThreshold = attrs.scoreThreshold, softNmsSigma = attrs.softNmsSigma;\n    assertNotComplex(boxes, 'NonMaxSuppressionWithScore');\n    var boxesVals = backend.data.get(boxes.dataId).values;\n    var scoresVals = backend.data.get(scores.dataId).values;\n    var maxOutputSizeVal = maxOutputSize;\n    var iouThresholdVal = iouThreshold;\n    var scoreThresholdVal = scoreThreshold;\n    var softNmsSigmaVal = softNmsSigma;\n    var _a = nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal), selectedIndices = _a.selectedIndices, selectedScores = _a.selectedScores;\n    return [\n        backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices)),\n        backend.makeTensorInfo([selectedScores.length], 'float32', new Float32Array(selectedScores))\n    ];\n}\nvar nonMaxSuppressionV5Config = {\n    kernelName: tfjsCore.NonMaxSuppressionV5,\n    backendName: 'cpu',\n    kernelFunc: nonMaxSuppressionV5\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction oneHot(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var indices = inputs.indices;\n    var depth = attrs.depth, onValue = attrs.onValue, offValue = attrs.offValue;\n    assertNotComplex(indices, 'oneHot');\n    var indicesSize = tfjsCore.util.sizeFromShape(indices.shape);\n    var res = new Float32Array(indicesSize * depth);\n    res.fill(offValue);\n    var indicesVal = backend.data.get(indices.dataId).values;\n    for (var event_1 = 0; event_1 < indicesSize; ++event_1) {\n        if (indicesVal[event_1] >= 0 && indicesVal[event_1] < depth) {\n            res[event_1 * depth + indicesVal[event_1]] = onValue;\n        }\n    }\n    return backend.makeTensorInfo(indices.shape.concat([depth]), 'int32', res);\n}\nvar oneHotConfig = {\n    kernelName: tfjsCore.OneHot,\n    backendName: 'cpu',\n    kernelFunc: oneHot\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction zerosLike(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    if (x.dtype === 'string') {\n        throw new Error('zerosLike is not supported for string tensors');\n    }\n    else if (x.dtype === 'complex64') {\n        var realPart = real({ inputs: { input: x }, backend: backend });\n        var r = zerosLike({ inputs: { x: realPart }, backend: backend });\n        var imagPart = imag({ inputs: { input: x }, backend: backend });\n        var i = zerosLike({ inputs: { x: imagPart }, backend: backend });\n        var result = complex({ inputs: { real: r, imag: i }, backend: backend });\n        backend.disposeIntermediateTensorInfo(realPart);\n        backend.disposeIntermediateTensorInfo(r);\n        backend.disposeIntermediateTensorInfo(imagPart);\n        backend.disposeIntermediateTensorInfo(i);\n        return result;\n    }\n    else {\n        return fill({ backend: backend, attrs: { shape: x.shape, value: 0, dtype: x.dtype } });\n    }\n}\nvar zerosLikeConfig = {\n    kernelName: tfjsCore.ZerosLike,\n    backendName: 'cpu',\n    kernelFunc: zerosLike\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction onesLike(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    if (x.dtype === 'string') {\n        throw new Error('onesLike is not supported for string tensors');\n    }\n    else if (x.dtype === 'complex64') {\n        var realPart = real({ inputs: { input: x }, backend: backend });\n        var r = onesLike({ inputs: { x: realPart }, backend: backend });\n        var imagPart = imag({ inputs: { input: x }, backend: backend });\n        var i = zerosLike({ inputs: { x: imagPart }, backend: backend });\n        var result = complex({ inputs: { real: r, imag: i }, backend: backend });\n        backend.disposeIntermediateTensorInfo(realPart);\n        backend.disposeIntermediateTensorInfo(r);\n        backend.disposeIntermediateTensorInfo(imagPart);\n        backend.disposeIntermediateTensorInfo(i);\n        return result;\n    }\n    else {\n        return fill({ backend: backend, attrs: { shape: x.shape, value: 1, dtype: x.dtype } });\n    }\n}\nvar onesLikeConfig = {\n    kernelName: tfjsCore.OnesLike,\n    backendName: 'cpu',\n    kernelFunc: onesLike\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction pack(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var axis = attrs.axis;\n    if (inputs.length === 1) {\n        return expandDims({ inputs: { input: inputs[0] }, backend: backend, attrs: { dim: axis } });\n    }\n    var shape = inputs[0].shape;\n    var dtype = inputs[0].dtype;\n    inputs.forEach(function (t) {\n        tfjsCore.util.assertShapesMatch(shape, t.shape, 'All tensors passed to stack must have matching shapes');\n        tfjsCore.util.assert(dtype === t.dtype, function () { return 'All tensors passed to stack must have matching dtypes'; });\n    });\n    var intermediateTensorInfos = [];\n    var expandedTensors = inputs.map(function (t) {\n        var expandedT = expandDims({ inputs: { input: t }, backend: backend, attrs: { dim: axis } });\n        intermediateTensorInfos.push(expandedT);\n        return expandedT;\n    });\n    var result = concat({ inputs: expandedTensors, backend: backend, attrs: { axis: axis } });\n    intermediateTensorInfos.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return result;\n}\nvar packConfig = {\n    kernelName: tfjsCore.Pack,\n    backendName: 'cpu',\n    kernelFunc: pack\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction padV2(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var paddings = attrs.paddings, constantValue = attrs.constantValue;\n    assertNotComplex(x, 'pad');\n    var outShape = paddings.map(function (p, i) { return p[0] /* beforePad */ + x.shape[i] + p[1]; } /* afterPad */);\n    var start = paddings.map(function (p) { return p[0]; });\n    var xVals = backend.data.get(x.dataId).values;\n    var xSize = tfjsCore.util.sizeFromShape(x.shape);\n    var xRank = x.shape.length;\n    var xStrides = tfjsCore.util.computeStrides(x.shape);\n    var resultSize = tfjsCore.util.sizeFromShape(outShape);\n    var resultRank = outShape.length;\n    var resultStrides = tfjsCore.util.computeStrides(outShape);\n    var resVals = tfjsCore.util.getTypedArrayFromDType(x.dtype, resultSize);\n    if (constantValue !== 0) {\n        resVals.fill(constantValue);\n    }\n    for (var i = 0; i < xSize; i++) {\n        var coords = tfjsCore.util.indexToLoc(i, xRank, xStrides);\n        var outCoords = coords.map(function (c, i) { return c + start[i]; });\n        var outIndex = tfjsCore.util.locToIndex(outCoords, resultRank, resultStrides);\n        resVals[outIndex] = xVals[i];\n    }\n    var outId = backend.write(resVals, outShape, x.dtype);\n    return { dataId: outId, shape: outShape, dtype: x.dtype };\n}\nvar padV2Config = {\n    kernelName: tfjsCore.PadV2,\n    backendName: 'cpu',\n    kernelFunc: padV2\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar powImpl = createSimpleBinaryKernelImpl(function (a, b) { return Math.pow(a, b); });\nvar pow = binaryKernelFunc(tfjsCore.Pow, powImpl);\nvar powConfig = {\n    kernelName: tfjsCore.Pow,\n    backendName: 'cpu',\n    kernelFunc: pow\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction range(args) {\n    var backend = args.backend, attrs = args.attrs;\n    var start = attrs.start, stop = attrs.stop, dtype = attrs.dtype, step = attrs.step;\n    var values = rangeImpl(start, stop, step, dtype);\n    return backend.makeTensorInfo([values.length], dtype, values);\n}\nvar rangeConfig = {\n    kernelName: tfjsCore.Range,\n    backendName: 'cpu',\n    kernelFunc: range\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar reciprocal = unaryKernelFunc(tfjsCore.Reciprocal, function (xi) { return 1 / xi; });\nvar reciprocalConfig = {\n    kernelName: tfjsCore.Reciprocal,\n    backendName: 'cpu',\n    kernelFunc: reciprocal,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction resizeBilinear(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var images = inputs.images;\n    var alignCorners = attrs.alignCorners, halfPixelCenters = attrs.halfPixelCenters, size = attrs.size;\n    assertNotComplex(images, 'resizeBilinear');\n    var imagesStrides = tfjsCore.util.computeStrides(images.shape);\n    var newHeight = size[0], newWidth = size[1];\n    var _a = images.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];\n    var xValues = backend.data.get(images.dataId).values;\n    var result = new Float32Array(tfjsCore.util.sizeFromShape([batch, newHeight, newWidth, numChannels]));\n    var effectiveInputSize = [\n        (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n        (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n    var effectiveOutputSize = [\n        (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n        (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n    var outputIdx = 0;\n    var effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n    var effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n    for (var b = 0; b < batch; b++) {\n        for (var r = 0; r < newHeight; r++) {\n            var sourceFracRow = void 0;\n            if (halfPixelCenters) {\n                sourceFracRow = effectiveRowSizeRatio * (r + 0.5) - 0.5;\n            }\n            else {\n                sourceFracRow = effectiveRowSizeRatio * r;\n            }\n            var sourceRowFloor = Math.max(0, Math.floor(sourceFracRow));\n            var rowFrac = sourceFracRow - sourceRowFloor;\n            var sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));\n            var topRowOffset = b * imagesStrides[0] + sourceRowFloor * imagesStrides[1];\n            var botRowOffset = b * imagesStrides[0] + sourceRowCeil * imagesStrides[1];\n            for (var c = 0; c < newWidth; c++) {\n                var sourceFracCol = void 0;\n                if (halfPixelCenters) {\n                    sourceFracCol = effectiveColSizeRatio * (c + 0.5) - 0.5;\n                }\n                else {\n                    sourceFracCol = effectiveColSizeRatio * c;\n                }\n                var sourceColFloor = Math.max(0, Math.floor(sourceFracCol));\n                var colFrac = sourceFracCol - sourceColFloor;\n                var sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));\n                var topLeftOffest = topRowOffset + sourceColFloor * imagesStrides[2];\n                var botLeftOffset = botRowOffset + sourceColFloor * imagesStrides[2];\n                var topRightOffset = topRowOffset + sourceColCeil * imagesStrides[2];\n                var botRightOffest = botRowOffset + sourceColCeil * imagesStrides[2];\n                for (var d = 0; d < numChannels; d++) {\n                    // Begin shader.\n                    // Compute the fractional index of the source.\n                    var topLeft = xValues[topLeftOffest + d];\n                    var bottomLeft = xValues[botLeftOffset + d];\n                    var topRight = xValues[topRightOffset + d];\n                    var bottomRight = xValues[botRightOffest + d];\n                    var top_1 = topLeft + (topRight - topLeft) * colFrac;\n                    var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n                    var newValue = top_1 + (bottom - top_1) * rowFrac;\n                    result[outputIdx++] = newValue;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], 'float32', result);\n}\nvar resizeBilinearConfig = {\n    kernelName: tfjsCore.ResizeBilinear,\n    backendName: 'cpu',\n    kernelFunc: resizeBilinear\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction resizeBilinearGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var images = inputs.images, dy = inputs.dy;\n    var alignCorners = attrs.alignCorners;\n    assertNotComplex([dy, images], 'resizeBilinearGrad');\n    var imagesStrides = tfjsCore.util.computeStrides(images.shape);\n    var _a = images.shape, batch = _a[0], xHeight = _a[1], xWidth = _a[2], depth = _a[3];\n    var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];\n    var output = new Float32Array(batch * xHeight * xWidth * depth);\n    // In the backwards pass, we want to find the pixels that were generated\n    // for each pixel in the input image the forward pass and add the\n    // corresponding coefficient from dy to the gradient (with some\n    // interpolation).\n    var effectiveXSize = [\n        (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n        (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n    var effectiveYSize = [\n        (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n        (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n    var heightScale = effectiveXSize[0] / effectiveYSize[0];\n    var widthScale = effectiveXSize[1] / effectiveYSize[1];\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n    var dyValues = backend.data.get(dy.dataId).values;\n    var offset = 0;\n    for (var b = 0; b < batch; b++) {\n        var bOffset = b * imagesStrides[0];\n        for (var r = 0; r < yHeight; r++) {\n            var dxR = r * heightScale;\n            var topDxRIndex = Math.floor(dxR);\n            var bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n            var topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n            var bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n            var dxRLerp = dxR - topDxRIndex;\n            var inverseDxRLerp = 1.0 - dxRLerp;\n            for (var c = 0; c < yWidth; c++) {\n                var dxC = c * widthScale;\n                var leftDxCIndex = Math.floor(dxC);\n                var rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n                var dxCLerp = dxC - leftDxCIndex;\n                var inverseDxCLerp = 1.0 - dxCLerp;\n                var topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n                var topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];\n                var bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];\n                var bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];\n                var inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n                var inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n                var dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n                var dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n                for (var d = 0; d < depth; d++) {\n                    var dyVal = dyValues[offset++];\n                    output[topLeftRCOffset + d] +=\n                        dyVal * inverseDxRLerpTimesInverseDxCLerp;\n                    output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n                    output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n                    output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo([batch, xWidth, xHeight, depth], 'float32', output);\n}\nvar resizeBilinearGradConfig = {\n    kernelName: tfjsCore.ResizeBilinearGrad,\n    backendName: 'cpu',\n    kernelFunc: resizeBilinearGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction resizeNearestNeighbor(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var images = inputs.images;\n    var alignCorners = attrs.alignCorners, halfPixelCenters = attrs.halfPixelCenters, size = attrs.size;\n    assertNotComplex(images, 'resizeNearestNeighbor');\n    var imagesStrides = tfjsCore.util.computeStrides(images.shape);\n    var newHeight = size[0], newWidth = size[1];\n    var _a = images.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];\n    var xValues = backend.data.get(images.dataId).values;\n    var output = new Float32Array(batch * newHeight * newWidth * numChannels);\n    var effectiveInputSize = [\n        (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n        (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n    var effectiveOutputSize = [\n        (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n        (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n    var effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n    var effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n    var outputOffset = 0;\n    for (var b = 0; b < batch; b++) {\n        var batchOffset = b * imagesStrides[0];\n        for (var r = 0; r < newHeight; r++) {\n            var sourceFracRow = halfPixelCenters ?\n                effectiveRowSizeRatio * (r + 0.5) :\n                effectiveRowSizeRatio * r;\n            var sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n            if (halfPixelCenters) {\n                sourceNearestRow = Math.max(0, sourceNearestRow);\n            }\n            var rowOffset = batchOffset + sourceNearestRow * imagesStrides[1];\n            for (var c = 0; c < newWidth; c++) {\n                var sourceFracCol = halfPixelCenters ?\n                    effectiveColSizeRatio * (c + 0.5) :\n                    effectiveColSizeRatio * c;\n                var sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) :\n                    Math.floor(sourceFracCol));\n                if (halfPixelCenters) {\n                    sourceNearestCol = Math.max(0, sourceNearestCol);\n                }\n                var colOffset = rowOffset + sourceNearestCol * imagesStrides[2];\n                for (var d = 0; d < numChannels; d++) {\n                    // Begin shader.\n                    // Compute the fractional index of the source.\n                    var newVal = xValues[colOffset + d];\n                    output[outputOffset++] = newVal;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], images.dtype, output);\n}\nvar resizeNearestNeighborConfig = {\n    kernelName: tfjsCore.ResizeNearestNeighbor,\n    backendName: 'cpu',\n    kernelFunc: resizeNearestNeighbor\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction resizeNearestNeighborGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var images = inputs.images, dy = inputs.dy;\n    var alignCorners = attrs.alignCorners;\n    assertNotComplex([dy, images], 'resizeNearestNeighborGrad');\n    var imagesStrides = tfjsCore.util.computeStrides(images.shape);\n    var dyStrides = tfjsCore.util.computeStrides(dy.shape);\n    var _a = images.shape, batch = _a[0], xHeight = _a[1], xWidth = _a[2], depth = _a[3];\n    var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];\n    var output = new Float32Array(batch * xHeight * xWidth * depth);\n    var dyValues = backend.data.get(dy.dataId).values;\n    // In the backwards pass, we want to find the pixels that were generated\n    // for each pixel in the input image the forward pass\n    var effectiveXSize = [\n        (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n        (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n    var effectiveYSize = [\n        (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n        (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n    var heightScale = effectiveXSize[0] / effectiveYSize[0];\n    var widthScale = effectiveXSize[1] / effectiveYSize[1];\n    var invHeightScale = 1 / heightScale;\n    var invWidthScale = 1 / widthScale;\n    // This defines the size of the window of values around a particular\n    // index in dy that we want to search for contributions to dx.\n    var winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n    var winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n    // Loop over the output space.\n    for (var b = 0; b < batch; b++) {\n        var batchOffset = b * imagesStrides[0];\n        for (var r = 0; r < xHeight; r++) {\n            var rowOffset = batchOffset + r * imagesStrides[1];\n            // Compute bounds for where in dy we will look\n            var startRLerp = Math.floor(r * invHeightScale);\n            var startDyR = Math.floor(startRLerp - (winHeight / 2));\n            for (var c = 0; c < xWidth; c++) {\n                var colOffset = rowOffset + c * imagesStrides[2];\n                // Compute bounds for where in dy we will look\n                var startCLerp = Math.floor(c * invWidthScale);\n                var startDyC = Math.floor(startCLerp - (winWidth / 2));\n                for (var d = 0; d < depth; d++) {\n                    var accum = 0;\n                    // loop over dy\n                    for (var dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {\n                        var dyR = dyRIndex + startDyR;\n                        // Guard against the window exceeding the bounds of dy\n                        if (dyR < 0 || dyR >= yHeight) {\n                            continue;\n                        }\n                        var dyROffset = batchOffset + dyR * dyStrides[1];\n                        var sourceFracRow = dyR * heightScale;\n                        var sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) :\n                            Math.floor(sourceFracRow));\n                        if (r !== sourceNearestRow) {\n                            continue;\n                        }\n                        for (var dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {\n                            var dyC = dyCIndex + startDyC;\n                            // Guard against the window exceeding the bounds of dy\n                            if (dyC < 0 || dyC >= yWidth) {\n                                continue;\n                            }\n                            var dyCOffset = dyROffset + dyC * dyStrides[2];\n                            var sourceFracCol = dyC * widthScale;\n                            var sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) :\n                                Math.floor(sourceFracCol));\n                            if (c === sourceNearestCol) {\n                                accum += dyValues[dyCOffset + d];\n                            }\n                        }\n                    }\n                    output[colOffset + d] = accum;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(images.shape, images.dtype, output);\n}\nvar resizeNearestNeighborGradConfig = {\n    kernelName: tfjsCore.ResizeNearestNeighborGrad,\n    backendName: 'cpu',\n    kernelFunc: resizeNearestNeighborGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction reverse(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var dims = attrs.dims;\n    assertNotComplex(x, 'reverse');\n    var xRank = x.shape.length;\n    var $dims = tfjsCore.util.parseAxisParam(dims, x.shape);\n    if (xRank === 0) {\n        return identity({ inputs: { x: x }, backend: backend });\n    }\n    var outBuf = new tfjsCore.TensorBuffer(x.shape, x.dtype);\n    var xBuf = backend.bufferSync(x);\n    var _loop_1 = function (i) {\n        var outLoc = outBuf.indexToLoc(i);\n        var inLoc = outLoc.slice();\n        $dims.forEach(function (d) { return inLoc[d] = x.shape[d] - 1 - inLoc[d]; });\n        outBuf.set.apply(outBuf, [xBuf.get.apply(xBuf, inLoc)].concat(outLoc));\n    };\n    for (var i = 0; i < outBuf.size; i++) {\n        _loop_1(i);\n    }\n    return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);\n}\nvar reverseConfig = {\n    kernelName: tfjsCore.Reverse,\n    backendName: 'cpu',\n    kernelFunc: reverse\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar rotateWithOffsetConfig = {\n    kernelName: tfjsCore.RotateWithOffset,\n    backendName: 'cpu',\n    kernelFunc: function (_a) {\n        var inputs = _a.inputs, attrs = _a.attrs, backend = _a.backend;\n        var image = inputs.image;\n        var _b = attrs, radians = _b.radians, fillValue = _b.fillValue, center = _b.center;\n        var cpuBackend = backend;\n        var output = tfjsCore.util.getTypedArrayFromDType(image.dtype, tfjsCore.util.sizeFromShape(image.shape));\n        var _c = image.shape, batch = _c[0], imageHeight = _c[1], imageWidth = _c[2], numChannels = _c[3];\n        var _d = tfjsCore.backend_util.getImageCenter(center, imageHeight, imageWidth), centerX = _d[0], centerY = _d[1];\n        var fullOpacityValue = 255;\n        var sinFactor = Math.sin(radians);\n        var cosFactor = Math.cos(radians);\n        var imageVals = cpuBackend.data.get(image.dataId).values;\n        for (var batchIdx = 0; batchIdx < batch; batchIdx++) {\n            var batchOffset = batchIdx * imageWidth * imageHeight * numChannels;\n            for (var row = 0; row < imageHeight; row++) {\n                var rowOffset = row * (imageWidth * numChannels);\n                for (var col = 0; col < imageWidth; col++) {\n                    var colOffset = col * numChannels;\n                    for (var channel = 0; channel < numChannels; channel++) {\n                        var coords = [batch, row, col, channel];\n                        var x = coords[2];\n                        var y = coords[1];\n                        // coordX/coordY are the result of rotating and translating x/y.\n                        var coordX = (x - centerX) * cosFactor - (y - centerY) * sinFactor;\n                        var coordY = (x - centerX) * sinFactor + (y - centerY) * cosFactor;\n                        coordX = Math.round(coordX + centerX);\n                        coordY = Math.round(coordY + centerY);\n                        var outputValue = fillValue;\n                        if (typeof fillValue !== 'number') {\n                            if (channel === 3) {\n                                outputValue = fullOpacityValue;\n                            }\n                            else {\n                                outputValue = fillValue[channel];\n                            }\n                        }\n                        // If the coordinate position falls within the image boundaries...\n                        if (coordX >= 0 && coordX < imageWidth && coordY >= 0 &&\n                            coordY < imageHeight) {\n                            // set the output to the image value at the coordinate position.\n                            var rotatedRowOffset = coordY * (imageWidth * numChannels);\n                            var rotatedColOffset = coordX * numChannels;\n                            var imageIdx = batchOffset + rotatedRowOffset + rotatedColOffset + channel;\n                            outputValue = imageVals[imageIdx];\n                        }\n                        var outIdx = batchOffset + rowOffset + colOffset + channel;\n                        output[outIdx] = outputValue;\n                    }\n                }\n            }\n        }\n        var dataId = cpuBackend.write(output, image.shape, image.dtype);\n        return { dataId: dataId, shape: image.shape, dtype: image.dtype };\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar round = unaryKernelFunc(tfjsCore.Round, function (xi) {\n    // The algorithm is based on banker's rounding.\n    var base = Math.floor(xi);\n    if (xi - base < 0.5) {\n        return Math.floor(xi);\n    }\n    else if (xi - base > 0.5) {\n        return Math.ceil(xi);\n    }\n    else {\n        if (base % 2.0 === 0.0) {\n            return base;\n        }\n        else {\n            return base + 1.0;\n        }\n    }\n});\nvar roundConfig = {\n    kernelName: tfjsCore.Round,\n    backendName: 'cpu',\n    kernelFunc: round,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction scatterImpl(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {\n    var flattenShape = [outputSize / sliceSize, sliceSize];\n    var indicesData = indices.values;\n    var updatesData = updates.values;\n    if (outputSize === 0) {\n        return tfjsCore.buffer(shape, updates.dtype);\n    }\n    var outBuf = tfjsCore.buffer(flattenShape, updates.dtype);\n    outBuf.values.fill(defaultValue);\n    for (var i = 0; i < numUpdates; i++) {\n        var index = [];\n        var flattenIndex = 0;\n        for (var j = 0; j < sliceRank; j++) {\n            var dim = indicesData[i * sliceRank + j];\n            index.push(dim);\n            flattenIndex += dim * strides[j];\n        }\n        if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {\n            throw new Error(\"Invalid indices: \" + index + \" does not index into \" + shape);\n        }\n        for (var k = 0; k < sliceSize; k++) {\n            if (sumDupeIndices) {\n                outBuf.values[flattenIndex * sliceSize + k] +=\n                    updatesData[i * sliceSize + k];\n            }\n            else {\n                outBuf.values[flattenIndex * sliceSize + k] = updates.rank === 0 ?\n                    updatesData[0] :\n                    updatesData[i * sliceSize + k];\n            }\n        }\n    }\n    return outBuf;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction scatterNd(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var indices = inputs.indices, updates = inputs.updates;\n    var shape = attrs.shape;\n    var _a = tfjsCore.backend_util.calculateShapes(updates, indices, shape), sliceRank = _a.sliceRank, numUpdates = _a.numUpdates, sliceSize = _a.sliceSize, strides = _a.strides, outputSize = _a.outputSize;\n    var sumDupeIndices = true;\n    var indicesBuf = backend.bufferSync(indices);\n    var updatesBuf = backend.bufferSync(updates);\n    var outBuf = scatterImpl(indicesBuf, updatesBuf, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, 0 /* defaultValue */, sumDupeIndices);\n    return backend.makeTensorInfo(shape, outBuf.dtype, outBuf.values);\n}\nvar scatterNdConfig = {\n    kernelName: tfjsCore.ScatterNd,\n    backendName: 'cpu',\n    kernelFunc: scatterNd\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction select(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var condition = inputs.condition, t = inputs.t, e = inputs.e;\n    assertNotComplex([condition, t, e], 'select');\n    var conditionRank = condition.shape.length;\n    var values = backend.data.get(condition.dataId).values;\n    var tValues = backend.data.get(t.dataId).values;\n    var eValues = backend.data.get(e.dataId).values;\n    var resultDtype = tfjsCore.upcastType(t.dtype, e.dtype);\n    var newValues = tfjsCore.util.makeZerosTypedArray(tfjsCore.util.sizeFromShape(t.shape), resultDtype);\n    var index = 0;\n    var offset = conditionRank === 0 || conditionRank > 1 || t.shape.length === 1 ?\n        1 :\n        tfjsCore.util.sizeFromShape(t.shape.slice(1));\n    for (var i = 0; i < values.length; i++) {\n        for (var j = 0; j < offset; j++) {\n            if (values[i] === 1) {\n                newValues[index++] = tValues[i];\n            }\n            else {\n                newValues[index++] = eValues[i];\n            }\n        }\n    }\n    return backend.makeTensorInfo(t.shape, resultDtype, newValues);\n}\nvar selectConfig = {\n    kernelName: tfjsCore.Select,\n    backendName: 'cpu',\n    kernelFunc: select\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar scaleAlpha = tfjsCore.backend_util.SELU_SCALEALPHA;\nvar scale = tfjsCore.backend_util.SELU_SCALE;\nvar selu = unaryKernelFunc(tfjsCore.Selu, function (xi) {\n    if (xi >= 0) {\n        return scale * xi;\n    }\n    else {\n        return scaleAlpha * (Math.exp(xi) - 1);\n    }\n});\nvar seluConfig = {\n    kernelName: tfjsCore.Selu,\n    backendName: 'cpu',\n    kernelFunc: selu,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar sigmoid = unaryKernelFunc(tfjsCore.Sigmoid, function (xi) { return 1 / (1 + Math.exp(-xi)); });\nvar sigmoidConfig = {\n    kernelName: tfjsCore.Sigmoid,\n    backendName: 'cpu',\n    kernelFunc: sigmoid,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar sign = unaryKernelFunc(tfjsCore.Sign, function (xi) {\n    if (xi < 0) {\n        return -1;\n    }\n    else if (xi > 0) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n});\nvar signConfig = {\n    kernelName: tfjsCore.Sign,\n    backendName: 'cpu',\n    kernelFunc: sign,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar sin = unaryKernelFunc(tfjsCore.Sin, function (xi) { return Math.sin(xi); });\nvar sinConfig = {\n    kernelName: tfjsCore.Sin,\n    backendName: 'cpu',\n    kernelFunc: sin,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar sinh = unaryKernelFunc(tfjsCore.Sinh, function (xi) { return Math.sinh(xi); });\nvar sinhConfig = {\n    kernelName: tfjsCore.Sinh,\n    backendName: 'cpu',\n    kernelFunc: sinh,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// mirrors the implementation of tf.nn.softplus: https://goo.gl/vkcvwX\n// epsilon is the difference between 1.0 and the next representable float.\n// For a single precision 32 bit float this should be 2^-23, see:\n// https://math.byu.edu/~schow/work/IEEEFloatingPoint.htm\nvar epsilon = 1.1920928955078125e-7;\nvar threshold = Math.log(epsilon) + 2.0;\nvar softplus = unaryKernelFunc(tfjsCore.Softplus, function (xi) {\n    // Value above which exp(x) may overflow, but softplus(x) == x\n    // is within machine epsilon.\n    var tooLarge = xi > -threshold;\n    // Value below which exp(x) may underflow, but softplus(x) == exp(x)\n    // is within machine epsilon.\n    var tooSmall = xi < threshold;\n    var expX = Math.exp(xi);\n    var result;\n    if (tooSmall) {\n        result = expX;\n    }\n    else if (tooLarge) {\n        result = xi;\n    }\n    else {\n        result = Math.log(1.0 + expX);\n    }\n    return result;\n});\nvar softplusConfig = {\n    kernelName: tfjsCore.Softplus,\n    backendName: 'cpu',\n    kernelFunc: softplus,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction spaceToBatchND(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var blockShape = attrs.blockShape, paddings = attrs.paddings;\n    assertNotComplex([x], 'spaceToBatchND');\n    var prod = tfjsCore.util.sizeFromShape(blockShape);\n    var completePaddings = [[0, 0]];\n    completePaddings.push.apply(completePaddings, paddings);\n    for (var i = 1 + blockShape.length; i < x.shape.length; ++i) {\n        completePaddings.push([0, 0]);\n    }\n    var paddedX = padV2Config.kernelFunc({\n        inputs: { x: x },\n        backend: backend,\n        attrs: { paddings: completePaddings, constantValue: 0 }\n    });\n    var reshapedPaddedShape = tfjsCore.backend_util.getReshaped(paddedX.shape, blockShape, prod, false);\n    var permutedReshapedPaddedPermutation = tfjsCore.backend_util.getPermuted(reshapedPaddedShape.length, blockShape.length, false);\n    var flattenShape = tfjsCore.backend_util.getReshapedPermuted(paddedX.shape, blockShape, prod, false);\n    var reshapeInputs = { x: paddedX };\n    var reshapeAttrs = { shape: reshapedPaddedShape };\n    var paddedXReshaped = reshape({ inputs: reshapeInputs, backend: backend, attrs: reshapeAttrs });\n    var transposeInputs = { x: paddedXReshaped };\n    var transposeAttrs = { perm: permutedReshapedPaddedPermutation };\n    var paddedXT = transpose({ inputs: transposeInputs, backend: backend, attrs: transposeAttrs });\n    var resultReshapeInputs = { x: paddedXT };\n    var resultReshapeAttrs = { shape: flattenShape };\n    var result = reshape({ inputs: resultReshapeInputs, backend: backend, attrs: resultReshapeAttrs });\n    backend.disposeIntermediateTensorInfo(paddedX);\n    backend.disposeIntermediateTensorInfo(paddedXReshaped);\n    backend.disposeIntermediateTensorInfo(paddedXT);\n    return result;\n}\nvar spaceToBatchNDConfig = {\n    kernelName: tfjsCore.SpaceToBatchND,\n    backendName: 'cpu',\n    kernelFunc: spaceToBatchND\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction sparseToDense(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var sparseIndices = inputs.sparseIndices, sparseValues = inputs.sparseValues, defaultValue = inputs.defaultValue;\n    var outputShape = attrs.outputShape;\n    var _a = tfjsCore.backend_util.calculateShapes(sparseValues, sparseIndices, outputShape), sliceRank = _a.sliceRank, numUpdates = _a.numUpdates, sliceSize = _a.sliceSize, strides = _a.strides, outputSize = _a.outputSize;\n    var sumDupeIndices = false;\n    var indicesBuf = backend.bufferSync(sparseIndices);\n    var updatesBuf = backend.bufferSync(sparseValues);\n    var $defaultValue = backend.data.get(defaultValue.dataId).values[0];\n    var outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);\n    return backend.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);\n}\nvar sparseToDenseConfig = {\n    kernelName: tfjsCore.SparseToDense,\n    backendName: 'cpu',\n    kernelFunc: sparseToDense\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction splitV(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var numOrSizeSplits = attrs.numOrSizeSplits, axis = attrs.axis;\n    var $axis = tfjsCore.util.parseAxisParam(axis, x.shape)[0];\n    var splitSizes = tfjsCore.backend_util.prepareSplitSize(x, numOrSizeSplits, $axis);\n    var begin = new Array(x.shape.length).fill(0);\n    var size = x.shape.slice();\n    return splitSizes.map(function (s) {\n        var sliceSize = size.slice();\n        sliceSize[$axis] = s;\n        var sliceT = slice({ inputs: { x: x }, backend: backend, attrs: { begin: begin, size: sliceSize } });\n        begin[$axis] += s;\n        return sliceT;\n    });\n}\nvar splitVConfig = {\n    kernelName: tfjsCore.SplitV,\n    backendName: 'cpu',\n    kernelFunc: splitV\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar sqrt = unaryKernelFunc(tfjsCore.Sqrt, function (xi) { return Math.sqrt(xi); });\nvar sqrtConfig = {\n    kernelName: tfjsCore.Sqrt,\n    backendName: 'cpu',\n    kernelFunc: sqrt,\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar squareConfig = {\n    kernelName: tfjsCore.Square,\n    backendName: 'cpu',\n    kernelFunc: function (_a) {\n        var inputs = _a.inputs, backend = _a.backend;\n        var x = inputs.x;\n        var cpuBackend = backend;\n        assertNotComplex(x, 'square');\n        var values = cpuBackend.data.get(x.dataId).values;\n        var newValues = new Float32Array(values.length);\n        for (var i = 0; i < values.length; ++i) {\n            var value = values[i];\n            newValues[i] = value * value;\n        }\n        var dataId = cpuBackend.write(newValues, x.shape, x.dtype);\n        return { dataId: dataId, shape: x.shape, dtype: x.dtype };\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar step = unaryKernelFunc(tfjsCore.Step, function (xi, attrs) {\n    var stepAttrs = attrs;\n    if (isNaN(xi)) {\n        return NaN;\n    }\n    else {\n        return xi > 0 ? 1 : stepAttrs.alpha;\n    }\n});\nvar stepConfig = {\n    kernelName: tfjsCore.Step,\n    backendName: 'cpu',\n    kernelFunc: step,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction stridedSlice(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var begin = attrs.begin, end = attrs.end, strides = attrs.strides, beginMask = attrs.beginMask, endMask = attrs.endMask, ellipsisMask = attrs.ellipsisMask, newAxisMask = attrs.newAxisMask, shrinkAxisMask = attrs.shrinkAxisMask;\n    assertNotComplex(x, 'stridedSlice');\n    var _a = tfjsCore.slice_util.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask), nonStrided = _a.nonStrided, $begin = _a.$begin, $strides = _a.$strides, size = _a.size, newShape = _a.newShape, outShape = _a.outShape;\n    var $x = reshape({ inputs: { x: x }, backend: backend, attrs: { shape: newShape } });\n    var result;\n    if (nonStrided) {\n        var sliced = slice({ inputs: { x: $x }, backend: backend, attrs: { begin: $begin, size: size } });\n        result = reshape({ inputs: { x: sliced }, backend: backend, attrs: { shape: outShape } });\n        backend.disposeIntermediateTensorInfo(sliced);\n    }\n    else if (outShape.some(function (axis) { return axis === 0; })) {\n        result = backend.makeTensorInfo(outShape, x.dtype, []);\n    }\n    else {\n        var xBuf = backend.bufferSync($x);\n        var outBuf = stridedSliceImpl(outShape, xBuf, $strides, $begin);\n        result = backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);\n    }\n    var resultReshaped = reshape({ inputs: { x: result }, backend: backend, attrs: { shape: outShape } });\n    backend.disposeIntermediateTensorInfo($x);\n    backend.disposeIntermediateTensorInfo(result);\n    return resultReshaped;\n}\nvar stridedSliceConfig = {\n    kernelName: tfjsCore.StridedSlice,\n    backendName: 'cpu',\n    kernelFunc: stridedSlice\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar tan = unaryKernelFunc(tfjsCore.Tan, function (xi) { return Math.tan(xi); });\nvar tanConfig = {\n    kernelName: tfjsCore.Tan,\n    backendName: 'cpu',\n    kernelFunc: tan,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar tanh = unaryKernelFunc(tfjsCore.Tanh, function (xi) { return Math.tanh(xi); });\nvar tanhConfig = {\n    kernelName: tfjsCore.Tanh,\n    backendName: 'cpu',\n    kernelFunc: tanh,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction tile(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var reps = attrs.reps;\n    assertNotComplex(x, 'tile');\n    var outBuf = tileImpl(backend.bufferSync(x), reps);\n    return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);\n}\nvar tileConfig = {\n    kernelName: tfjsCore.Tile,\n    backendName: 'cpu',\n    kernelFunc: tile\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction topK(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var k = attrs.k, sorted = attrs.sorted;\n    assertNotComplex(x, 'topk');\n    var xVals = backend.data.get(x.dataId).values;\n    var _a = topKImpl(xVals, x.shape, x.dtype, k), allTopKVals = _a[0], allTopKIndices = _a[1];\n    return [\n        backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),\n        backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)\n    ];\n}\nvar topKConfig = {\n    kernelName: tfjsCore.TopK,\n    backendName: 'cpu',\n    kernelFunc: topK\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction unique(args) {\n    var inputs = args.inputs, attrs = args.attrs, backend = args.backend;\n    var axis = attrs.axis;\n    var x = inputs.x;\n    assertNotComplex(x, 'unique');\n    var values = backend.data.get(x.dataId).values;\n    var _a = uniqueImpl(values, axis, x.shape, x.dtype), outputValues = _a.outputValues, outputShape = _a.outputShape, indices = _a.indices;\n    return [\n        backend.makeTensorInfo(outputShape, x.dtype, outputValues),\n        backend.makeTensorInfo([indices.length], 'int32', indices),\n    ];\n}\nvar uniqueConfig = {\n    kernelName: tfjsCore.Unique,\n    backendName: 'cpu',\n    kernelFunc: unique,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction unpack(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var value = inputs.value;\n    var axis = attrs.axis;\n    if (axis < 0) {\n        axis += value.shape.length;\n    }\n    var valueRank = value.shape.length;\n    var num = value.shape[axis];\n    var outShape = new Array(valueRank - 1);\n    var outIndex = 0;\n    for (var i = 0; i < valueRank; i++) {\n        if (i !== axis) {\n            outShape[outIndex++] = value.shape[i];\n        }\n    }\n    var begin = new Array(valueRank).fill(0);\n    var size = value.shape.slice();\n    size[axis] = 1;\n    var res = new Array(num);\n    for (var i = 0; i < res.length; i++) {\n        begin[axis] = i;\n        var tempRes = slice({ inputs: { x: value }, backend: backend, attrs: { begin: begin, size: size } });\n        res[i] = reshape({ inputs: { x: tempRes }, backend: backend, attrs: { shape: outShape } });\n        backend.disposeIntermediateTensorInfo(tempRes);\n    }\n    return res;\n}\nvar unpackConfig = {\n    kernelName: tfjsCore.Unpack,\n    backendName: 'cpu',\n    kernelFunc: unpack\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction unsortedSegmentSum(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, segmentIds = inputs.segmentIds;\n    var numSegments = attrs.numSegments;\n    assertNotComplex(x, 'unsortedSegmentSum');\n    var xRank = x.shape.length;\n    var segmentIdsRank = segmentIds.shape.length;\n    var res = [];\n    var intermediates = [];\n    // Reshape the segment id's so that they can be broadcast with\n    // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n    var numIters = xRank - segmentIdsRank;\n    var $segmentIds = segmentIds;\n    for (var i = 0; i < numIters; ++i) {\n        var expanded = expandDims({ inputs: { input: $segmentIds }, backend: backend, attrs: { dim: i + 1 } });\n        $segmentIds = expanded;\n        intermediates.push(expanded);\n    }\n    for (var i = 0; i < numSegments; ++i) {\n        var scalarValue = tfjsCore.util.createScalarValue(i, 'int32');\n        var segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n        var mask = equal({ inputs: { a: segmentId, b: $segmentIds }, backend: backend });\n        var maskCasted = cast({ inputs: { x: mask }, backend: backend, attrs: { dtype: 'float32' } });\n        var mul = multiply({ inputs: { a: maskCasted, b: x }, backend: backend });\n        var sumTensorInfo = sum({ inputs: { x: mul }, backend: backend, attrs: { axis: 0, keepDims: false } });\n        res.push(sumTensorInfo);\n        intermediates.push(segmentId);\n        intermediates.push(mask);\n        intermediates.push(maskCasted);\n        intermediates.push(mul);\n        intermediates.push(sumTensorInfo);\n    }\n    var result = pack({ inputs: res, backend: backend, attrs: { axis: 0 } });\n    intermediates.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return result;\n}\nvar unsortedSegmentSumConfig = {\n    kernelName: tfjsCore.UnsortedSegmentSum,\n    backendName: 'cpu',\n    kernelFunc: unsortedSegmentSum\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// List all kernel configs here\nvar kernelConfigs = [\n    _fusedMatMulConfig,\n    absConfig,\n    acosConfig,\n    acoshConfig,\n    addConfig,\n    addNConfig,\n    allConfig,\n    anyConfig,\n    argMaxConfig,\n    argMinConfig,\n    asinConfig,\n    asinhConfig,\n    atanConfig,\n    atan2Config,\n    atanhConfig,\n    avgPoolConfig,\n    avgPool3DConfig,\n    avgPool3DGradConfig,\n    avgPoolGradConfig,\n    batchMatMulConfig,\n    batchNormConfig,\n    batchToSpaceNDConfig,\n    bincountConfig,\n    castConfig,\n    ceilConfig,\n    clipConfig,\n    complexConfig,\n    complexAbsConfig,\n    concatConfig,\n    conv2DBackpropFilterConfig,\n    conv2DBackpropInputConfig,\n    conv2DConfig,\n    conv3DBackpropFilterV2Config,\n    conv3DBackpropInputV2Config,\n    conv3DConfig,\n    cosConfig,\n    coshConfig,\n    cropAndResizeConfig,\n    cumsumConfig,\n    denseBincountConfig,\n    depthToSpaceConfig,\n    depthwiseConv2dNativeConfig,\n    depthwiseConv2dNativeBackpropFilterConfig,\n    depthwiseConv2dNativeBackpropInputConfig,\n    diagConfig,\n    dilation2dConfig,\n    dilation2dBackpropInputConfig,\n    dilation2dBackpropFilterConfig,\n    realDivConfig,\n    eluConfig,\n    eluGradConfig,\n    equalConfig,\n    erfConfig,\n    expConfig,\n    expandDimsConfig,\n    expm1Config,\n    fftConfig,\n    fillConfig,\n    flipLeftRightConfig,\n    floorConfig,\n    floorDivConfig,\n    fusedConv2DConfig,\n    fusedDepthwiseConv2DConfig,\n    gatherNdConfig,\n    gatherV2Config,\n    greaterConfig,\n    greaterEqualConfig,\n    identityConfig,\n    ifftConfig,\n    imagConfig,\n    isFiniteConfig,\n    isInfConfig,\n    isNaNConfig,\n    leakyReluConfig,\n    lessConfig,\n    lessEqualConfig,\n    linSpaceConfig,\n    logConfig,\n    log1pConfig,\n    logicalAndConfig,\n    logicalNotConfig,\n    logicalOrConfig,\n    lRNConfig,\n    lRNGradConfig,\n    maximumConfig,\n    maxPoolConfig,\n    maxPool3DConfig,\n    maxPool3DGradConfig,\n    maxPoolGradConfig,\n    maxPoolWithArgmaxConfig,\n    maxConfig,\n    meanConfig,\n    minConfig,\n    minimumConfig,\n    mirrorPadConfig,\n    modConfig,\n    multinomialConfig,\n    multiplyConfig,\n    negConfig,\n    nonMaxSuppressionV3Config,\n    nonMaxSuppressionV4Config,\n    nonMaxSuppressionV5Config,\n    notEqualConfig,\n    oneHotConfig,\n    onesLikeConfig,\n    packConfig,\n    padV2Config,\n    powConfig,\n    preluConfig,\n    prodConfig,\n    rangeConfig,\n    realConfig,\n    reciprocalConfig,\n    reluConfig,\n    relu6Config,\n    reshapeConfig,\n    resizeBilinearConfig,\n    resizeBilinearGradConfig,\n    resizeNearestNeighborConfig,\n    resizeNearestNeighborGradConfig,\n    reverseConfig,\n    rotateWithOffsetConfig,\n    roundConfig,\n    rsqrtConfig,\n    scatterNdConfig,\n    selectConfig,\n    seluConfig,\n    sigmoidConfig,\n    signConfig,\n    sinConfig,\n    sinhConfig,\n    sliceConfig,\n    softmaxConfig,\n    softplusConfig,\n    spaceToBatchNDConfig,\n    sparseToDenseConfig,\n    splitVConfig,\n    sqrtConfig,\n    squareConfig,\n    squaredDifferenceConfig,\n    stepConfig,\n    stridedSliceConfig,\n    subConfig,\n    sumConfig,\n    tanConfig,\n    tanhConfig,\n    tileConfig,\n    topKConfig,\n    transposeConfig,\n    uniqueConfig,\n    unpackConfig,\n    unsortedSegmentSumConfig,\n    zerosLikeConfig\n];\nfor (var _i = 0, kernelConfigs_1 = kernelConfigs; _i < kernelConfigs_1.length; _i++) {\n    var kernelConfig = kernelConfigs_1[_i];\n    tfjsCore.registerKernel(kernelConfig);\n}\n\nexports.MathBackendCPU = MathBackendCPU;\nexports.shared = shared;\nexports.version_cpu = version;\n//# sourceMappingURL=tf-backend-cpu.node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRlbnNvcmZsb3crdGZqcy1iYWNrZW5kLWNwdUAyLjguNl9AdGVuc29yZmxvdyt0ZmpzLWNvcmVAMi44LjYvbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtYmFja2VuZC1jcHUvZGlzdC90Zi1iYWNrZW5kLWNwdS5ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxlQUFlLG1CQUFPLENBQUMsNklBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLGdHQUFZOztBQUVyQztBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hE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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMkJBQTJCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBLG1EQUFtRCx3QkFBd0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UseUJBQXlCO0FBQ2pHO0FBQ0EsYUFBYTtBQUNiLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQSx5Q0FBeUMsMkJBQTJCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0MsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6Qyw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVSxNQUFNLDZCQUE2QixpQ0FBaUM7QUFDM0c7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsdUJBQXVCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVLE1BQU0sNkJBQTZCLG1CQUFtQjtBQUN2RjtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb21vbmdhaC5naXRodWIuaW8vLi9ub2RlX21vZHVsZXMvLnBucG0vQHRlbnNvcmZsb3crdGZqcy1iYWNrZW5kLWNwdUAyLjguNl9AdGVuc29yZmxvdyt0ZmpzLWNvcmVAMi44LjYvbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtYmFja2VuZC1jcHUvZGlzdC90Zi1iYWNrZW5kLWNwdS5ub2RlLmpzPzBlZjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdGZqc0NvcmUgPSByZXF1aXJlKCdAdGVuc29yZmxvdy90ZmpzLWNvcmUnKTtcbnZhciBzZWVkcmFuZG9tID0gcmVxdWlyZSgnc2VlZHJhbmRvbScpO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBhc3NlcnROb3RDb21wbGV4KHRlbnNvciwgb3BOYW1lKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRlbnNvcikpIHtcbiAgICAgICAgdGVuc29yID0gW3RlbnNvcl07XG4gICAgfVxuICAgIHRlbnNvci5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRmanNDb3JlLnV0aWwuYXNzZXJ0KHQuZHR5cGUgIT09ICdjb21wbGV4NjQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvcE5hbWUgKyBcIiBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXg2NCB0ZW5zb3JzIGluIHRoZSBDUFUgYmFja2VuZC5cIjsgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIHdoZXJlSW1wbCA9IHRmanNDb3JlLmtlcm5lbF9pbXBscy53aGVyZUltcGw7XG52YXIgTWF0aEJhY2tlbmRDUFUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hdGhCYWNrZW5kQ1BVLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hdGhCYWNrZW5kQ1BVKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ibG9ja1NpemUgPSA0ODtcbiAgICAgICAgX3RoaXMuZmlyc3RVc2UgPSB0cnVlO1xuICAgICAgICBfdGhpcy5kYXRhID0gbmV3IHRmanNDb3JlLkRhdGFTdG9yYWdlKF90aGlzLCB0ZmpzQ29yZS5lbmdpbmUoKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHZhbHVlcywgc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0VXNlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0VXNlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGZqc0NvcmUuZW52KCkuZ2V0KCdJU19OT0RFJykpIHtcbiAgICAgICAgICAgICAgICB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwud2FybignXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbicgK1xuICAgICAgICAgICAgICAgICAgICAnSGkgdGhlcmUg8J+Riy4gTG9va3MgbGlrZSB5b3UgYXJlIHJ1bm5pbmcgVGVuc29yRmxvdy5qcyBpbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ05vZGUuanMuIFRvIHNwZWVkIHRoaW5ncyB1cCBkcmFtYXRpY2FsbHksIGluc3RhbGwgb3VyIG5vZGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdiYWNrZW5kLCB3aGljaCBiaW5kcyB0byBUZW5zb3JGbG93IEMrKywgYnkgcnVubmluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ25wbSBpIEB0ZW5zb3JmbG93L3RmanMtbm9kZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICdvciBucG0gaSBAdGVuc29yZmxvdy90ZmpzLW5vZGUtZ3B1IGlmIHlvdSBoYXZlIENVREEuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVGhlbiBjYWxsIHJlcXVpcmUoXFwnQHRlbnNvcmZsb3cvdGZqcy1ub2RlXFwnKTsgKC1ncHUgJyArXG4gICAgICAgICAgICAgICAgICAgICdzdWZmaXggZm9yIENVREEpIGF0IHRoZSBzdGFydCBvZiB5b3VyIHByb2dyYW0uICcgK1xuICAgICAgICAgICAgICAgICAgICAnVmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy1ub2RlIGZvciBtb3JlIGRldGFpbHMuJyArXG4gICAgICAgICAgICAgICAgICAgICdcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGFJZCA9IHt9O1xuICAgICAgICB0aGlzLmRhdGEuc2V0KGRhdGFJZCwgeyB2YWx1ZXM6IHZhbHVlcywgZHR5cGU6IGR0eXBlLCByZWZDb3VudDogMSB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGFJZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRhdGEgYnVja2V0IGluIGNwdSBiYWNrZW5kLlxuICAgICAqIEBwYXJhbSBzaGFwZSBTaGFwZSBvZiB0aGUgYFRlbnNvckluZm9gLlxuICAgICAqIEBwYXJhbSBkdHlwZSBEVHlwZSBvZiB0aGUgYFRlbnNvckluZm9gLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgVGhlIHZhbHVlIG9mIHRoZSBgVGVuc29ySW5mb2Agc3RvcmVkIGFzIGEgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tYWtlVGVuc29ySW5mbyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUsIHZhbHVlcykge1xuICAgICAgICB2YXIgb3V0SWQ7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVzICE9IG51bGwgJiYgdmFsdWVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRmanNDb3JlLnV0aWwuaXNTdHJpbmcodmFsdWVzWzBdKSkge1xuICAgICAgICAgICAgdmFyIGVuY29kZWRWYWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiB0ZmpzQ29yZS51dGlsLmVuY29kZVN0cmluZyhkKTsgfSk7XG4gICAgICAgICAgICBvdXRJZCA9IHRoaXMud3JpdGUoZW5jb2RlZFZhbHVlcywgc2hhcGUsIGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dElkID0gdGhpcy53cml0ZSh2YWx1ZXMsIHNoYXBlLCBkdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUlkOiBvdXRJZCwgc2hhcGU6IHNoYXBlLCBkdHlwZTogZHR5cGUgfTtcbiAgICB9O1xuICAgIC8qKiBJbmNyZWFzZSByZWZDb3VudCBvZiBhIGBUZW5zb3JEYXRhYC4gKi9cbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuaW5jUmVmID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICB2YXIgdGVuc29yRGF0YSA9IHRoaXMuZGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgdGVuc29yRGF0YS5yZWZDb3VudCsrO1xuICAgIH07XG4gICAgLyoqIERlY3JlYXNlIHJlZkNvdW50IG9mIGEgYFRlbnNvckRhdGFgLiAqL1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5kZWNSZWYgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHZhciB0ZW5zb3JEYXRhID0gdGhpcy5kYXRhLmdldChkYXRhSWQpO1xuICAgICAgICAgICAgdGVuc29yRGF0YS5yZWZDb3VudC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChkYXRhSWQsIHZhbHVlcywgc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHRoaXMuZGF0YS5zZXQoZGF0YUlkLCB7IHZhbHVlczogdmFsdWVzLCBkdHlwZTogZHR5cGUsIHJlZkNvdW50OiAxIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm51bURhdGFJZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubnVtRGF0YUlkcygpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5yZWFkU3luYyhkYXRhSWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZWFkU3luYyA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5kYXRhLmdldChkYXRhSWQpLCBkdHlwZSA9IF9hLmR0eXBlLCBjb21wbGV4VGVuc29ySW5mb3MgPSBfYS5jb21wbGV4VGVuc29ySW5mb3M7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgICAgICAgIHZhciByZWFsVmFsdWVzID0gdGhpcy5yZWFkU3luYyhjb21wbGV4VGVuc29ySW5mb3MucmVhbC5kYXRhSWQpO1xuICAgICAgICAgICAgdmFyIGltYWdWYWx1ZXMgPSB0aGlzLnJlYWRTeW5jKGNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLmRhdGFJZCk7XG4gICAgICAgICAgICByZXR1cm4gdGZqc0NvcmUuYmFja2VuZF91dGlsLm1lcmdlUmVhbEFuZEltYWdBcnJheXMocmVhbFZhbHVlcywgaW1hZ1ZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5nZXQoZGF0YUlkKS52YWx1ZXM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYnVmZmVyU3luYyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5yZWFkU3luYyh0LmRhdGFJZCk7XG4gICAgICAgIHZhciBkZWNvZGVkRGF0YSA9IGRhdGE7XG4gICAgICAgIGlmICh0LmR0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBEZWNvZGUgdGhlIGJ5dGVzIGludG8gc3RyaW5nLlxuICAgICAgICAgICAgICAgIGRlY29kZWREYXRhID0gZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHRmanNDb3JlLnV0aWwuZGVjb2RlU3RyaW5nKGQpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY29kZSBlbmNvZGVkIHN0cmluZyBieXRlcyBpbnRvIHV0Zi04Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRmanNDb3JlLmJ1ZmZlcih0LnNoYXBlLCB0LmR0eXBlLCBkZWNvZGVkRGF0YSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWFrZU91dHB1dCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICB2YXIgZGF0YUlkID0gdGhpcy53cml0ZSh2YWx1ZXMsIHNoYXBlLCBkdHlwZSk7XG4gICAgICAgIHJldHVybiB0ZmpzQ29yZS5lbmdpbmUoKS5tYWtlVGVuc29yRnJvbURhdGFJZChkYXRhSWQsIHNoYXBlLCBkdHlwZSwgdGhpcyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZGlzcG9zZURhdGEgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHZhciBjb21wbGV4VGVuc29ySW5mb3MgPSB0aGlzLmRhdGEuZ2V0KGRhdGFJZCkuY29tcGxleFRlbnNvckluZm9zO1xuICAgICAgICAgICAgaWYgKGNvbXBsZXhUZW5zb3JJbmZvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlRGF0YShjb21wbGV4VGVuc29ySW5mb3MucmVhbC5kYXRhSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZURhdGEoY29tcGxleFRlbnNvckluZm9zLmltYWcuZGF0YUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGF0YS5kZWxldGUoZGF0YUlkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvID0gZnVuY3Rpb24gKHRlbnNvckluZm8pIHtcbiAgICAgICAgdmFyIGRhdGFJZCA9IHRlbnNvckluZm8uZGF0YUlkO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICB2YXIgdGVuc29yRGF0YSA9IHRoaXMuZGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgICAgIHRlbnNvckRhdGEucmVmQ291bnQtLTtcbiAgICAgICAgICAgIGlmICh0ZW5zb3JEYXRhLnJlZkNvdW50IDwgMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZURhdGEoZGF0YUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRpbWUgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQsIGtlcm5lbE1zO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGZqc0NvcmUudXRpbC5ub3coKTtcbiAgICAgICAgICAgICAgICBmKCk7XG4gICAgICAgICAgICAgICAga2VybmVsTXMgPSB0ZmpzQ29yZS51dGlsLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsga2VybmVsTXM6IGtlcm5lbE1zIH1dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm1lbW9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIFVucmVsaWFibGUgZHVlIHRvIGF1dG9tYXRpYyBnYy4gVGhlIG51bWJlcnMgYWJvdmUgYXJlIGN1bXVsYXRpdmUuXG4gICAgICAgICAgICB1bnJlbGlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgcmVhc29uczogWydUaGUgcmVwb3J0ZWQgbWVtb3J5IGlzIGFuIHVwcGVyIGJvdW5kLiBEdWUgdG8gYXV0b21hdGljIGdhcmJhZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICdjb2xsZWN0aW9uLCB0aGUgdHJ1ZSBhbGxvY2F0ZWQgbWVtb3J5IG1heSBiZSBsZXNzLiddXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUud2hlcmUgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgIGFzc2VydE5vdENvbXBsZXgoW2NvbmRpdGlvbl0sICd3aGVyZScpO1xuICAgICAgICB2YXIgY29uZFZhbHMgPSB0aGlzLnJlYWRTeW5jKGNvbmRpdGlvbi5kYXRhSWQpO1xuICAgICAgICByZXR1cm4gd2hlcmVJbXBsKGNvbmRpdGlvbi5zaGFwZSwgY29uZFZhbHMpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmZsb2F0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMzI7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgc21hbGxlc3QgcmVwcmVzZW50YWJsZSBudW1iZXIuICAqL1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5lcHNpbG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lcHNpbG9uLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gTWF0aEJhY2tlbmRDUFU7XG59KHRmanNDb3JlLktlcm5lbEJhY2tlbmQpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUFic0ltcGwodmFscykge1xuICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hYnModmFsc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRWYWx1ZXM7XG59XG52YXIgYWJzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgeCA9IGFyZ3MuaW5wdXRzLng7XG4gICAgdmFyIGNwdUJhY2tlbmQgPSBhcmdzLmJhY2tlbmQ7XG4gICAgYXNzZXJ0Tm90Q29tcGxleCh4LCAnYWJzJyk7XG4gICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKHguc2hhcGUpKTtcbiAgICB2YXIgdmFsdWVzID0gY3B1QmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgIHJlc3VsdFZhbHVlcyA9IHNpbXBsZUFic0ltcGwodmFsdWVzKTtcbiAgICByZXR1cm4gY3B1QmFja2VuZC5tYWtlT3V0cHV0KHJlc3VsdFZhbHVlcywgeC5zaGFwZSwgJ2Zsb2F0MzInKTtcbn07XG52YXIgYWJzQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkFicyxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogYWJzLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBUZW1wbGF0ZSB0aGF0IGNyZWF0ZXMgaW1wbGVtZW50YXRpb24gZm9yIGJpbmFyeSBvcHMuIFN1cHBvcnRzIGJyb2FkY2FzdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2ltcGxlQmluYXJ5S2VybmVsSW1wbChvcCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYVNoYXBlLCBiU2hhcGUsIGFWYWxzLCBiVmFscywgZHR5cGUpIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGFTaGFwZSwgYlNoYXBlKTtcbiAgICAgICAgdmFyIHJlc3VsdFJhbmsgPSBuZXdTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHRTdHJpZGVzID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyhuZXdTaGFwZSk7XG4gICAgICAgIHZhciByZXN1bHRTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRmanNDb3JlLnV0aWwuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShkdHlwZSwgcmVzdWx0U2l6ZSk7XG4gICAgICAgIHZhciBhUmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBiUmFuayA9IGJTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBhU3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoYVNoYXBlKTtcbiAgICAgICAgdmFyIGJTdHJpZGVzID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyhiU2hhcGUpO1xuICAgICAgICB2YXIgYUJyb2FkY2FzdERpbXMgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0QnJvYWRjYXN0RGltcyhhU2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgICAgdmFyIGJCcm9hZGNhc3REaW1zID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmdldEJyb2FkY2FzdERpbXMoYlNoYXBlLCBuZXdTaGFwZSk7XG4gICAgICAgIGlmIChhQnJvYWRjYXN0RGltcy5sZW5ndGggKyBiQnJvYWRjYXN0RGltcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gb3AoYVZhbHNbaSAlIGFWYWxzLmxlbmd0aF0sIGJWYWxzW2kgJSBiVmFscy5sZW5ndGhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jID0gdGZqc0NvcmUudXRpbC5pbmRleFRvTG9jKGksIHJlc3VsdFJhbmssIHJlc3VsdFN0cmlkZXMpO1xuICAgICAgICAgICAgICAgIHZhciBhTG9jID0gbG9jLnNsaWNlKC1hUmFuayk7XG4gICAgICAgICAgICAgICAgYUJyb2FkY2FzdERpbXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gYUxvY1tkXSA9IDA7IH0pO1xuICAgICAgICAgICAgICAgIHZhciBhSW5kZXggPSB0ZmpzQ29yZS51dGlsLmxvY1RvSW5kZXgoYUxvYywgYVJhbmssIGFTdHJpZGVzKTtcbiAgICAgICAgICAgICAgICB2YXIgYkxvYyA9IGxvYy5zbGljZSgtYlJhbmspO1xuICAgICAgICAgICAgICAgIGJCcm9hZGNhc3REaW1zLmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGJMb2NbZF0gPSAwOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgYkluZGV4ID0gdGZqc0NvcmUudXRpbC5sb2NUb0luZGV4KGJMb2MsIGJSYW5rLCBiU3RyaWRlcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gb3AoYVZhbHNbYUluZGV4XSwgYlZhbHNbYkluZGV4XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcmVzdWx0LCBuZXdTaGFwZV07XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY29tcGxleChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciByZWFsID0gaW5wdXRzLnJlYWwsIGltYWcgPSBpbnB1dHMuaW1hZztcbiAgICB2YXIgcmVhbFZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHJlYWwuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIGltYWdWYWxzID0gYmFja2VuZC5kYXRhLmdldChpbWFnLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBjb21wbGV4SW5mbyA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8ocmVhbC5zaGFwZSwgJ2NvbXBsZXg2NCcpO1xuICAgIHZhciBjb21wbGV4ID0gYmFja2VuZC5kYXRhLmdldChjb21wbGV4SW5mby5kYXRhSWQpO1xuICAgIC8vIFRoZSBjb21wbGV4IHRlbnNvciBvd25zIHRoZSB1bmRlcmx5aW5nIHJlYWwgYW5kIGltYWcgdGVuc29ySW5mb3MsIG9ubHkgdGhlXG4gICAgLy8gY29tcGxleCB0ZW5zb3IgdHJhY2tzIHJlZkNvdW50LCB3aGVuIGNvbXBsZXhEYXRhIGlzIGRpc3Bvc2VkIHRoZVxuICAgIC8vIHVuZGVybHlpbmcgdGVuc29yRGF0YSB3aWxsIGJlIGRpc3Bvc2VkLlxuICAgIGNvbXBsZXguY29tcGxleFRlbnNvckluZm9zID0ge1xuICAgICAgICByZWFsOiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKHJlYWwuc2hhcGUsICdmbG9hdDMyJywgcmVhbFZhbHMpLFxuICAgICAgICBpbWFnOiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKGltYWcuc2hhcGUsICdmbG9hdDMyJywgaW1hZ1ZhbHMpXG4gICAgfTtcbiAgICByZXR1cm4gY29tcGxleEluZm87XG59XG52YXIgY29tcGxleENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Db21wbGV4LFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBjb21wbGV4XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEdlbmVyYXRlcyBhIHRlbnNvckluZm8gd2l0aCBhbGwgemVyb3MgdmFsdWUuXG4gKiBAcGFyYW0gYmFja2VuZCBjcHUgYmFja2VuZC5cbiAqIEBwYXJhbSBzaGFwZSBTaGFwZSBmb3IgdGhlIHplcm9zIHRlbnNvci5cbiAqIEBwYXJhbSBkdHlwZSBPcHRpb25hbC4gSWYgc2V0LCB0aGUgcmVzdWx0IGhhcyB0aGlzIGR0eXBlLlxuICovXG5mdW5jdGlvbiB6ZXJvcyhiYWNrZW5kLCBzaGFwZSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgIGlmIChkdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgICAgdmFyIHJlYWwgPSB6ZXJvcyhiYWNrZW5kLCBzaGFwZSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgdmFyIGltYWcgPSB6ZXJvcyhiYWNrZW5kLCBzaGFwZSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXgoeyBpbnB1dHM6IHsgcmVhbDogcmVhbCwgaW1hZzogaW1hZyB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgIH1cbiAgICB2YXIgdmFsdWVzID0gdGZqc0NvcmUudXRpbC5tYWtlWmVyb3NUeXBlZEFycmF5KHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSksIGR0eXBlKTtcbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhzaGFwZSwgZHR5cGUsIHZhbHVlcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQ7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICBiYWNrZW5kLmluY1JlZih4LmRhdGFJZCk7XG4gICAgcmV0dXJuIHsgZGF0YUlkOiB4LmRhdGFJZCwgc2hhcGU6IHguc2hhcGUsIGR0eXBlOiB4LmR0eXBlIH07XG59XG52YXIgaWRlbnRpdHlDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuSWRlbnRpdHksXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGlkZW50aXR5XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiByZWFsKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQ7XG4gICAgdmFyIGlucHV0ID0gaW5wdXRzLmlucHV0O1xuICAgIHZhciByZWFsID0gYmFja2VuZC5kYXRhLmdldChpbnB1dC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsO1xuICAgIHZhciByZWFsVmFsID0gYmFja2VuZC5kYXRhLmdldChyZWFsLmRhdGFJZCkudmFsdWVzO1xuICAgIC8vIFdoZW4gY29tcGxleCB0ZW5zb3IgaXMgZGlzcG9zZWQsIGl0cyB1bmRlcmx5aW5nIHBhcnRzIHdpbGwgYmUgZGlzcG9zZWQgdG9vLlxuICAgIC8vIE1ha2UgbmV3IHRlbnNvciBvdXQgb2YgdGhlIHJlYWwgdmFsdWUgb2YgdGhlIGNvbXBsZXguIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgICAvLyB2YWx1ZSBpcyBzdGlsbCBhY2Nlc3NpYmxlIGV2ZW4gaWYgY29tcGxleCB0ZW5zb3IgaXMgZGlzcG9zZWQuXG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8ocmVhbC5zaGFwZSwgcmVhbC5kdHlwZSwgcmVhbFZhbCk7XG59XG52YXIgcmVhbENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5SZWFsLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiByZWFsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBjYXN0KGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBkdHlwZSA9IGF0dHJzLmR0eXBlO1xuICAgIC8vIENhc3RpbmcgdG8gY29tcGxleDY0LlxuICAgIGlmIChkdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgICAgaWYgKHguZHR5cGUgPT09ICdjb21wbGV4NjQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpdHkoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB6ZXJvc1RlbnNvckluZm8gPSB6ZXJvcyhiYWNrZW5kLCB4LnNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIGZsb2F0WCA9IGNhc3QoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBkdHlwZTogJ2Zsb2F0MzInIH0gfSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wbGV4KHsgaW5wdXRzOiB7IHJlYWw6IGZsb2F0WCwgaW1hZzogemVyb3NUZW5zb3JJbmZvIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oemVyb3NUZW5zb3JJbmZvKTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmbG9hdFgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBDYXN0aW5nIGZyb20gY29tcGxleDY0XG4gICAgaWYgKHguZHR5cGUgPT09ICdjb21wbGV4NjQnKSB7XG4gICAgICAgIHZhciByZWFsUGFydCA9IHJlYWwoeyBpbnB1dHM6IHsgaW5wdXQ6IHggfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhc3QoeyBpbnB1dHM6IHsgeDogcmVhbFBhcnQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgZHR5cGU6IGR0eXBlIH0gfSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVhbFBhcnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoIXRmanNDb3JlLnV0aWwuaGFzRW5jb2RpbmdMb3NzKHguZHR5cGUsIGR0eXBlKSkge1xuICAgICAgICAvLyBXZSBkb24ndCBjaGFuZ2UgdGhlIHVuZGVybHlpbmcgZGF0YSwgc2luY2Ugd2UgY2FzdCB0byBoaWdoZXJcbiAgICAgICAgLy8gcHJlY2lzaW9uLlxuICAgICAgICB2YXIgcmVzdWx0ID0gaWRlbnRpdHkoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICByZXR1cm4geyBkYXRhSWQ6IHJlc3VsdC5kYXRhSWQsIHNoYXBlOiByZXN1bHQuc2hhcGUsIGR0eXBlOiBkdHlwZSB9O1xuICAgIH1cbiAgICBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGJhY2tlbmQuZGF0YS5nZXQoeC5kYXRhSWQpLnZhbHVlcztcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IEludDMyQXJyYXkuZnJvbSh2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyh4LnNoYXBlLCAnaW50MzInLCByZXN1bHRWYWx1ZXMpO1xuICAgIH1cbiAgICBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAvLyBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSByZXN1bHQgb2Ygbm90RXF1YWwoeCwgMCkuIFdlIGF2b2lkIHVzaW5nXG4gICAgICAgIC8vIGtlcm5lbCBub3RFcXVhbCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5LCBpLmUuIGJpbmFyeV91dGlscyAtPlxuICAgICAgICAvLyBjYXN0IC0+IG5vdEVxdWFsIC0+IGJpbmFyeV91dGlscy5cbiAgICAgICAgdmFyIHhWYWxzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgICAgICB2YXIgemVybyA9IHRmanNDb3JlLnV0aWwudG9UeXBlZEFycmF5KFswXSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciBfYSA9IGNyZWF0ZVNpbXBsZUJpbmFyeUtlcm5lbEltcGwoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhICE9PSBiKSA/IDEgOiAwOyB9KSh4LnNoYXBlLCBbXSwgeFZhbHMsIHplcm8sICdib29sJyksIHJlc3VsdERhdGEgPSBfYVswXSwgcmVzdWx0U2hhcGUgPSBfYVsxXTtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8ocmVzdWx0U2hhcGUsICdib29sJywgcmVzdWx0RGF0YSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIENhc3Q6IGZhaWxlZCB0byBjYXN0IFwiICsgeC5kdHlwZSArIFwiIHRvIFwiICsgZHR5cGUpO1xufVxudmFyIGNhc3RDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQ2FzdCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogY2FzdFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBUZW1wbGF0ZSB0aGF0IGNyZWF0ZXMgYSBgS2VybmVsRnVuY2AgZm9yIGJpbmFyeSBvcHMuXG4gKiBAcGFyYW0gbmFtZSBLZXJuZWwgbmFtZS5cbiAqIEBwYXJhbSBiaW5hcnlLZXJuZWxJbXBsIEEgYFNpbXBsZUJpbmFyeUtlcm5lbEltcGxgIGZvciB0aGUga2VybmVsLlxuICogQHBhcmFtIGJpbmFyeUtlcm5lbENvbXBsZXhJbXBsIE9wdGlvbmFsLiBJZiBleGlzdHMsIHJlcHJlc2VudHMgYVxuICogICAgIGBDb21wbGV4QmluYXJ5S2VybmVsSW1wbGAgZm9yIHRoZSBrZXJuZWwsIHdpbGwgYmUgdXNlZCB3aGVuIGlucHV0IGR0eXBlXG4gKiAgICAgaXMgYGNvbXBsZXg2NGAuXG4gKiBAcGFyYW0gZHR5cGUgT3B0aW9uYWwuIElmIHNldCwgdGhlIHJlc3VsdCBoYXMgdGhpcyBkdHlwZS4gT3RoZXJ3aXNlLCB0aGVcbiAqICAgICByZXN1bHQgaGFzIHRoZSBzYW1lIGR0eXBlIGFzIHRoZSBmaXJzdCBpbnB1dC4gVGhpcyBpcyBtYWlubHkgdXNlZCBpblxuICogICAgIGNvbXBhcmlzb24ga2VybmVscywgc3VjaCBhcyBFcXVhbCwgTGVzcywgR3JlYXRlciwgZXRjLlxuICovXG5mdW5jdGlvbiBiaW5hcnlLZXJuZWxGdW5jKG5hbWUsIHNpbXBsZUltcGwsIGNvbXBsZXhJbXBsLCBkdHlwZSkge1xuICAgIGlmIChjb21wbGV4SW1wbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSBfYS5pbnB1dHMsIGJhY2tlbmQgPSBfYS5iYWNrZW5kO1xuICAgICAgICAgICAgdmFyIF9iID0gaW5wdXRzLCBhID0gX2IuYSwgYiA9IF9iLmI7XG4gICAgICAgICAgICB2YXIgY3B1QmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgICAgICAgICBhc3NlcnROb3RDb21wbGV4KFthLCBiXSwgbmFtZSk7XG4gICAgICAgICAgICB2YXIgYVZhbHMgPSBjcHVCYWNrZW5kLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXM7XG4gICAgICAgICAgICB2YXIgYlZhbHMgPSBjcHVCYWNrZW5kLmRhdGEuZ2V0KGIuZGF0YUlkKS52YWx1ZXM7XG4gICAgICAgICAgICB2YXIgJGR0eXBlID0gZHR5cGUgfHwgYS5kdHlwZTtcbiAgICAgICAgICAgIHZhciBfYyA9IHNpbXBsZUltcGwoYS5zaGFwZSwgYi5zaGFwZSwgYVZhbHMsIGJWYWxzLCAkZHR5cGUpLCByZXN1bHREYXRhID0gX2NbMF0sIHJlc3VsdFNoYXBlID0gX2NbMV07XG4gICAgICAgICAgICByZXR1cm4gY3B1QmFja2VuZC5tYWtlVGVuc29ySW5mbyhyZXN1bHRTaGFwZSwgJGR0eXBlLCByZXN1bHREYXRhKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaW5wdXRzID0gX2EuaW5wdXRzLCBiYWNrZW5kID0gX2EuYmFja2VuZDtcbiAgICAgICAgdmFyIF9iID0gaW5wdXRzLCBhID0gX2IuYSwgYiA9IF9iLmI7XG4gICAgICAgIHZhciBjcHVCYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgaWYgKGEuZHR5cGUgPT09ICdjb21wbGV4NjQnIHx8IGIuZHR5cGUgPT09ICdjb21wbGV4NjQnKSB7XG4gICAgICAgICAgICB2YXIgJGFDb21wbGV4ID0gY2FzdCh7IGlucHV0czogeyB4OiBhIH0sIGJhY2tlbmQ6IGNwdUJhY2tlbmQsIGF0dHJzOiB7IGR0eXBlOiAnY29tcGxleDY0JyB9IH0pO1xuICAgICAgICAgICAgdmFyICRhQ29tcGxleFZhbHMgPSBjcHVCYWNrZW5kLmRhdGEuZ2V0KCRhQ29tcGxleC5kYXRhSWQpO1xuICAgICAgICAgICAgdmFyIGFSZWFsID0gJGFDb21wbGV4VmFscy5jb21wbGV4VGVuc29ySW5mb3MucmVhbDtcbiAgICAgICAgICAgIHZhciBhSW1hZyA9ICRhQ29tcGxleFZhbHMuY29tcGxleFRlbnNvckluZm9zLmltYWc7XG4gICAgICAgICAgICB2YXIgYVJlYWxWYWxzID0gY3B1QmFja2VuZC5kYXRhLmdldChhUmVhbC5kYXRhSWQpLnZhbHVlcztcbiAgICAgICAgICAgIHZhciBhSW1hZ1ZhbHMgPSBjcHVCYWNrZW5kLmRhdGEuZ2V0KGFJbWFnLmRhdGFJZCkudmFsdWVzO1xuICAgICAgICAgICAgdmFyICRiQ29tcGxleCA9IGNhc3QoeyBpbnB1dHM6IHsgeDogYiB9LCBiYWNrZW5kOiBjcHVCYWNrZW5kLCBhdHRyczogeyBkdHlwZTogJ2NvbXBsZXg2NCcgfSB9KTtcbiAgICAgICAgICAgIHZhciAkYkNvbXBsZXhWYWxzID0gY3B1QmFja2VuZC5kYXRhLmdldCgkYkNvbXBsZXguZGF0YUlkKTtcbiAgICAgICAgICAgIHZhciBiUmVhbCA9ICRiQ29tcGxleFZhbHMuY29tcGxleFRlbnNvckluZm9zLnJlYWw7XG4gICAgICAgICAgICB2YXIgYkltYWcgPSAkYkNvbXBsZXhWYWxzLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnO1xuICAgICAgICAgICAgdmFyIGJSZWFsVmFscyA9IGNwdUJhY2tlbmQuZGF0YS5nZXQoYlJlYWwuZGF0YUlkKS52YWx1ZXM7XG4gICAgICAgICAgICB2YXIgYkltYWdWYWxzID0gY3B1QmFja2VuZC5kYXRhLmdldChiSW1hZy5kYXRhSWQpLnZhbHVlcztcbiAgICAgICAgICAgIHZhciBfYyA9IGNvbXBsZXhJbXBsKGEuc2hhcGUsIGIuc2hhcGUsIGFSZWFsVmFscywgYUltYWdWYWxzLCBiUmVhbFZhbHMsIGJJbWFnVmFscyksIHJlc3VsdFJlYWxEYXRhID0gX2NbMF0sIHJlc3VsdEltYWdEYXRhID0gX2NbMV0sIHJlc3VsdFNoYXBlID0gX2NbMl07XG4gICAgICAgICAgICB2YXIgcmVzdWx0UmVhbCA9IGNwdUJhY2tlbmQubWFrZVRlbnNvckluZm8ocmVzdWx0U2hhcGUsICdmbG9hdDMyJywgcmVzdWx0UmVhbERhdGEpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdEltYWcgPSBjcHVCYWNrZW5kLm1ha2VUZW5zb3JJbmZvKHJlc3VsdFNoYXBlLCAnZmxvYXQzMicsIHJlc3VsdEltYWdEYXRhKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb21wbGV4KHsgaW5wdXRzOiB7IHJlYWw6IHJlc3VsdFJlYWwsIGltYWc6IHJlc3VsdEltYWcgfSwgYmFja2VuZDogY3B1QmFja2VuZCB9KTtcbiAgICAgICAgICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oJGFDb21wbGV4KTtcbiAgICAgICAgICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oJGJDb21wbGV4KTtcbiAgICAgICAgICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzdWx0UmVhbCk7XG4gICAgICAgICAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlc3VsdEltYWcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhVmFscyA9IGNwdUJhY2tlbmQuZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcztcbiAgICAgICAgICAgIHZhciBiVmFscyA9IGNwdUJhY2tlbmQuZGF0YS5nZXQoYi5kYXRhSWQpLnZhbHVlcztcbiAgICAgICAgICAgIHZhciAkZHR5cGUgPSBkdHlwZSB8fCBhLmR0eXBlO1xuICAgICAgICAgICAgdmFyIF9kID0gc2ltcGxlSW1wbChhLnNoYXBlLCBiLnNoYXBlLCBhVmFscywgYlZhbHMsICRkdHlwZSksIHJlc3VsdERhdGEgPSBfZFswXSwgcmVzdWx0U2hhcGUgPSBfZFsxXTtcbiAgICAgICAgICAgIHJldHVybiBjcHVCYWNrZW5kLm1ha2VUZW5zb3JJbmZvKHJlc3VsdFNoYXBlLCAkZHR5cGUsIHJlc3VsdERhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogVGVtcGxhdGUgdGhhdCBjcmVhdGVzIHRoZSBjb21wbGV4IHR5cGUgaW1wbGVtZW50YXRpb24gZm9yIGJpbmFyeSBvcHMuXG4gKiBTdXBwb3J0cyBicm9hZGNhc3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBsZXhCaW5hcnlLZXJuZWxJbXBsKG9wKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhU2hhcGUsIGJTaGFwZSwgYVJlYWxWYWxzLCBhSW1hZ1ZhbHMsIGJSZWFsVmFscywgYkltYWdWYWxzKSB7XG4gICAgICAgIHZhciByZXN1bHRTaGFwZSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhU2hhcGUsIGJTaGFwZSk7XG4gICAgICAgIHZhciByZXN1bHRTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKHJlc3VsdFNoYXBlKTtcbiAgICAgICAgdmFyIHJlc3VsdFJhbmsgPSByZXN1bHRTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHRTdHJpZGVzID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyhyZXN1bHRTaGFwZSk7XG4gICAgICAgIHZhciByZXN1bHRSZWFsVmFscyA9IHRmanNDb3JlLnV0aWwuZ2V0VHlwZWRBcnJheUZyb21EVHlwZSgnZmxvYXQzMicsIHJlc3VsdFNpemUpO1xuICAgICAgICB2YXIgcmVzdWx0SW1hZ1ZhbHMgPSB0ZmpzQ29yZS51dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoJ2Zsb2F0MzInLCByZXN1bHRTaXplKTtcbiAgICAgICAgdmFyIGFCcm9hZGNhc3REaW1zID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmdldEJyb2FkY2FzdERpbXMoYVNoYXBlLCByZXN1bHRTaGFwZSk7XG4gICAgICAgIHZhciBiQnJvYWRjYXN0RGltcyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGJTaGFwZSwgcmVzdWx0U2hhcGUpO1xuICAgICAgICB2YXIgYVZhbHMgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwubWVyZ2VSZWFsQW5kSW1hZ0FycmF5cyhhUmVhbFZhbHMsIGFJbWFnVmFscyk7XG4gICAgICAgIHZhciBiVmFscyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5tZXJnZVJlYWxBbmRJbWFnQXJyYXlzKGJSZWFsVmFscywgYkltYWdWYWxzKTtcbiAgICAgICAgdmFyIGFSYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGFTdHJpZGVzID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyhhU2hhcGUpO1xuICAgICAgICB2YXIgYlJhbmsgPSBiU2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgYlN0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKGJTaGFwZSk7XG4gICAgICAgIGlmIChhQnJvYWRjYXN0RGltcy5sZW5ndGggKyBiQnJvYWRjYXN0RGltcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0UmVhbFZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYUlkeCA9IGkgJSBhVmFscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGJJZHggPSBpICUgYlZhbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcChhVmFsc1thSWR4ICogMl0sIGFWYWxzW2FJZHggKiAyICsgMV0sIGJWYWxzW2JJZHggKiAyXSwgYlZhbHNbYklkeCAqIDIgKyAxXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0UmVhbFZhbHNbaV0gPSByZXN1bHQucmVhbDtcbiAgICAgICAgICAgICAgICByZXN1bHRJbWFnVmFsc1tpXSA9IHJlc3VsdC5pbWFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciBsb2MgPSB0ZmpzQ29yZS51dGlsLmluZGV4VG9Mb2MoaSwgcmVzdWx0UmFuaywgcmVzdWx0U3RyaWRlcyk7XG4gICAgICAgICAgICAgICAgdmFyIGFMb2MgPSBsb2Muc2xpY2UoLWFSYW5rKTtcbiAgICAgICAgICAgICAgICBhQnJvYWRjYXN0RGltcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBhTG9jW2RdID0gMDsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGFJbmRleCA9IHRmanNDb3JlLnV0aWwubG9jVG9JbmRleChhTG9jLCBhUmFuaywgYVN0cmlkZXMpO1xuICAgICAgICAgICAgICAgIHZhciBiTG9jID0gbG9jLnNsaWNlKC1iUmFuayk7XG4gICAgICAgICAgICAgICAgYkJyb2FkY2FzdERpbXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gYkxvY1tkXSA9IDA7IH0pO1xuICAgICAgICAgICAgICAgIHZhciBiSW5kZXggPSB0ZmpzQ29yZS51dGlsLmxvY1RvSW5kZXgoYkxvYywgYlJhbmssIGJTdHJpZGVzKTtcbiAgICAgICAgICAgICAgICB2YXIgb3BSZXN1bHQgPSBvcChhVmFsc1thSW5kZXggKiAyXSwgYVZhbHNbYUluZGV4ICogMiArIDFdLCBiVmFsc1tiSW5kZXggKiAyXSwgYlZhbHNbYkluZGV4ICogMiArIDFdKTtcbiAgICAgICAgICAgICAgICByZXN1bHRSZWFsVmFsc1tpXSA9IG9wUmVzdWx0LnJlYWw7XG4gICAgICAgICAgICAgICAgcmVzdWx0SW1hZ1ZhbHNbaV0gPSBvcFJlc3VsdC5pbWFnO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0UmVhbFZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcmVzdWx0UmVhbFZhbHMsIHJlc3VsdEltYWdWYWxzLCByZXN1bHRTaGFwZV07XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGFkZEltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0pKTtcbnZhciBhZGRDb21wbGV4SW1wbCA9IGNyZWF0ZUNvbXBsZXhCaW5hcnlLZXJuZWxJbXBsKChmdW5jdGlvbiAoYVJlYWwsIGFJbWFnLCBiUmVhbCwgYkltYWcpIHtcbiAgICByZXR1cm4geyByZWFsOiBhUmVhbCArIGJSZWFsLCBpbWFnOiBhSW1hZyArIGJJbWFnIH07XG59KSk7XG52YXIgYWRkID0gYmluYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5BZGQsIGFkZEltcGwsIGFkZENvbXBsZXhJbXBsKTtcbnZhciBhZGRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQWRkLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBhZGRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGJpbmNvdW50SW1wbCh4VmFscywgd2VpZ2h0c1ZhbHMsIHdlaWdodHNEdHlwZSwgd2VpZ2h0c1NoYXBlLCBzaXplKSB7XG4gICAgdmFyIHdlaWdodHNTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKHdlaWdodHNTaGFwZSk7XG4gICAgdmFyIG91dFZhbHMgPSB0ZmpzQ29yZS51dGlsLm1ha2VaZXJvc1R5cGVkQXJyYXkoc2l6ZSwgd2VpZ2h0c0R0eXBlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhWYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHhWYWxzW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHggbXVzdCBiZSBub24tbmVnYXRpdmUhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID49IHNpemUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWlnaHRzU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIG91dFZhbHNbdmFsdWVdICs9IHdlaWdodHNWYWxzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0VmFsc1t2YWx1ZV0gKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0VmFscztcbn1cbmZ1bmN0aW9uIGJpbmNvdW50UmVkdWNlSW1wbCh4QnVmLCB3ZWlnaHRzQnVmLCBzaXplLCBiaW5hcnlPdXRwdXQpIHtcbiAgICBpZiAoYmluYXJ5T3V0cHV0ID09PSB2b2lkIDApIHsgYmluYXJ5T3V0cHV0ID0gZmFsc2U7IH1cbiAgICB2YXIgbnVtUm93cyA9IHhCdWYuc2hhcGVbMF07XG4gICAgdmFyIG51bUNvbHMgPSB4QnVmLnNoYXBlWzFdO1xuICAgIHZhciBvdXRCdWYgPSB0ZmpzQ29yZS5idWZmZXIoW251bVJvd3MsIHNpemVdLCB3ZWlnaHRzQnVmLmR0eXBlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVJvd3M7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUNvbHM7IGorKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0geEJ1Zi5nZXQoaSwgaik7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCB4IG11c3QgYmUgbm9uLW5lZ2F0aXZlIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHNpemUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5hcnlPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBvdXRCdWYuc2V0KDEsIGksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh3ZWlnaHRzQnVmLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dEJ1Zi5zZXQob3V0QnVmLmdldChpLCB2YWx1ZSkgKyB3ZWlnaHRzQnVmLmdldChpLCBqKSwgaSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0QnVmLnNldChvdXRCdWYuZ2V0KGksIHZhbHVlKSArIDEsIGksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dEJ1Zjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBUZW1wbGF0ZSB0aGF0IGNyZWF0ZXMgaW1wbGVtZW50YXRpb24gZm9yIHVuYXJ5IG9wLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVVbmFyeUltcGwob3ApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlcywgZHR5cGUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSB0ZmpzQ29yZS51dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoZHR5cGUsIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gb3AodmFsdWVzW2ldLCBhdHRycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlcztcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIFRlbXBsYXRlIHRoYXQgY3JlYXRlcyBhIGBLZXJuZWxGdW5jYCBmb3IgdW5hcnkgb3BzLlxuICogQHBhcmFtIG5hbWUgS2VybmVsIG5hbWUuXG4gKiBAcGFyYW0gb3AgQSBgU2ltcGxlVW5hcnlPcGVyYXRpb25gIGZvciB0aGUga2VybmVsLlxuICogQHBhcmFtIGR0eXBlIE9wdGlvbmFsLiBJZiBzZXQsIHRoZSByZXN1bHQgaGFzIHRoaXMgZHR5cGUuIE90aGVyd2lzZSwgdGhlXG4gKiAgICAgcmVzdWx0IGhhcyB0aGUgc2FtZSBkdHlwZSBhcyB0aGUgaW5wdXQuIFRoaXMgaXMgbWFpbmx5IHVzZWQgaW4gY2VydGFpblxuICogICAgIGtlcm5lbHMgdGhhdCByZXR1cm4gYm9vbCB0eXBlLCBzdWNoIGFzIGlzRmluaXRlLCBpc0luZiwgZXRjLlxuICovXG5mdW5jdGlvbiB1bmFyeUtlcm5lbEZ1bmMobmFtZSwgb3AsIGR0eXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaW5wdXRzID0gX2EuaW5wdXRzLCBhdHRycyA9IF9hLmF0dHJzLCBiYWNrZW5kID0gX2EuYmFja2VuZDtcbiAgICAgICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICAgICAgYXNzZXJ0Tm90Q29tcGxleCh4LCBuYW1lKTtcbiAgICAgICAgaWYgKHguZHR5cGUgPT09ICdzdHJpbmcnIHx8IGR0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFyeUtlcm5lbEZ1bmMgZG9lcyBub3Qgc3VwcG9ydCBzdHJpbmcgaW5wdXQvb3V0cHV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNwdUJhY2tlbmQgPSBiYWNrZW5kO1xuICAgICAgICB2YXIgdmFsdWVzID0gY3B1QmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgICAgICB2YXIgeFNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUoeC5zaGFwZSk7XG4gICAgICAgIHZhciAkZHR5cGUgPSBkdHlwZSB8fCB4LmR0eXBlO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gdGZqc0NvcmUudXRpbC5nZXRBcnJheUZyb21EVHlwZSgkZHR5cGUsIHhTaXplKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4U2l6ZTsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBvcCh2YWx1ZXNbaV0sIGF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3B1QmFja2VuZC5tYWtlVGVuc29ySW5mbyh4LnNoYXBlLCAkZHR5cGUsIG5ld1ZhbHVlcyk7XG4gICAgfTtcbn1cbi8qKlxuICogVGVtcGxhdGUgdGhhdCBjcmVhdGVzIGEgYEtlcm5lbEZ1bmNgIGZvciB1bmFyeSBvcHMgZnJvbSB0aGUgZ2l2ZW5cbiAqIGBTaW1wbGVVbmFyeUltcGxgLi5cbiAqIEBwYXJhbSBuYW1lIEtlcm5lbCBuYW1lLlxuICogQHBhcmFtIHVuYXJ5SW1wbCBBIGBTaW1wbGVVbmFyeUltcGxgIHRoYXQgaW1wbGVtZW50cyB0aGUgb3AuXG4gKiBAcGFyYW0gZHR5cGUgT3B0aW9uYWwuIElmIHNldCwgdGhlIHJlc3VsdCBoYXMgdGhpcyBkdHlwZS4gT3RoZXJ3aXNlLCB0aGVcbiAqICAgICByZXN1bHQgaGFzIHRoZSBzYW1lIGR0eXBlIGFzIHRoZSBpbnB1dC4gVGhpcyBpcyBtYWlubHkgdXNlZCBpbiBjZXJ0YWluXG4gKiAgICAga2VybmVscyB0aGF0IHJldHVybiBib29sIHR5cGUsIHN1Y2ggYXMgaXNGaW5pdGUsIGlzSW5mLCBldGMuXG4gKi9cbmZ1bmN0aW9uIHVuYXJ5S2VybmVsRnVuY0Zyb21JbXBsKG5hbWUsIHVuYXJ5SW1wbCwgZHR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBfYS5pbnB1dHMsIGF0dHJzID0gX2EuYXR0cnMsIGJhY2tlbmQgPSBfYS5iYWNrZW5kO1xuICAgICAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgICAgICBhc3NlcnROb3RDb21wbGV4KHgsIG5hbWUpO1xuICAgICAgICBpZiAoeC5kdHlwZSA9PT0gJ3N0cmluZycgfHwgZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYXJ5S2VybmVsRnVuYyBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyBpbnB1dC9vdXRwdXQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3B1QmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBjcHVCYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgICAgIHZhciAkZHR5cGUgPSBkdHlwZSB8fCB4LmR0eXBlO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gdW5hcnlJbXBsKHZhbHVlcywgJGR0eXBlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBjcHVCYWNrZW5kLm1ha2VUZW5zb3JJbmZvKHguc2hhcGUsICRkdHlwZSwgbmV3VmFsdWVzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGNlaWxJbXBsID0gY3JlYXRlU2ltcGxlVW5hcnlJbXBsKGZ1bmN0aW9uICh4aSkgeyByZXR1cm4gTWF0aC5jZWlsKHhpKTsgfSk7XG52YXIgY2VpbCA9IHVuYXJ5S2VybmVsRnVuY0Zyb21JbXBsKHRmanNDb3JlLkNlaWwsIGNlaWxJbXBsKTtcbnZhciBjZWlsQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkNlaWwsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGNlaWwsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBjb25jYXRJbXBsKGlucHV0cywgb3V0U2hhcGUsIGR0eXBlLCBzaW1wbHlDb25jYXQpIHtcbiAgICB2YXIgb3V0VmFscyA9IHRmanNDb3JlLnV0aWwuZ2V0QXJyYXlGcm9tRFR5cGUoZHR5cGUsIHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShvdXRTaGFwZSkpO1xuICAgIGlmIChzaW1wbHlDb25jYXQgJiYgZHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFVzZSBidWlsdC1pbiBUeXBlZEFycmF5LnNldCgpIG1ldGhvZCBmb3Igc3BlZWQuXG4gICAgICAgIHZhciBvZmZzZXRfMSA9IDA7XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUoaW5wdXQuc2hhcGUpO1xuICAgICAgICAgICAgb3V0VmFscy5zZXQoaW5wdXQudmFscywgb2Zmc2V0XzEpO1xuICAgICAgICAgICAgb2Zmc2V0XzEgKz0gc2l6ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY29sT2Zmc2V0XzEgPSAwO1xuICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkZWNvZGVkRGF0YSA9IGR0eXBlID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAgICAgdGZqc0NvcmUuYmFja2VuZF91dGlsLmZyb21VaW50OFRvU3RyaW5nQXJyYXkoaW5wdXQudmFscykgOlxuICAgICAgICAgICAgICAgIGlucHV0LnZhbHM7XG4gICAgICAgICAgICB2YXIgdElkeCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBpbnB1dC5zaGFwZVswXTsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzSWR4ID0gcm93ICogb3V0U2hhcGVbMV0gKyBjb2xPZmZzZXRfMTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBpbnB1dC5zaGFwZVsxXTsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0VmFsc1tyZXNJZHggKyBjb2xdID0gZGVjb2RlZERhdGFbdElkeCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xPZmZzZXRfMSArPSBpbnB1dC5zaGFwZVsxXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRWYWxzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGV4cEltcGwgPSBjcmVhdGVTaW1wbGVVbmFyeUltcGwoZnVuY3Rpb24gKHhpKSB7IHJldHVybiBNYXRoLmV4cCh4aSk7IH0pO1xudmFyIGV4cCA9IHVuYXJ5S2VybmVsRnVuY0Zyb21JbXBsKHRmanNDb3JlLkV4cCwgZXhwSW1wbCk7XG52YXIgZXhwQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkV4cCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZXhwLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBleHBtMUltcGwgPSBjcmVhdGVTaW1wbGVVbmFyeUltcGwoZnVuY3Rpb24gKHhpKSB7IHJldHVybiBNYXRoLmV4cG0xKHhpKTsgfSk7XG52YXIgZXhwbTEgPSB1bmFyeUtlcm5lbEZ1bmNGcm9tSW1wbCh0ZmpzQ29yZS5FeHBtMSwgZXhwbTFJbXBsKTtcbnZhciBleHBtMUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5FeHBtMSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZXhwbTEsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGZsb29ySW1wbCA9IGNyZWF0ZVNpbXBsZVVuYXJ5SW1wbChmdW5jdGlvbiAoeGkpIHsgcmV0dXJuIE1hdGguZmxvb3IoeGkpOyB9KTtcbnZhciBmbG9vciA9IHVuYXJ5S2VybmVsRnVuY0Zyb21JbXBsKHRmanNDb3JlLkZsb29yLCBmbG9vckltcGwpO1xudmFyIGZsb29yQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkZsb29yLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBmbG9vcixcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGdhdGhlclYySW1wbCh4QnVmLCBpbmRpY2VzQnVmLCBmbGF0dGVuT3V0cHV0U2hhcGUpIHtcbiAgICB2YXIgb3V0QnVmID0gdGZqc0NvcmUuYnVmZmVyKGZsYXR0ZW5PdXRwdXRTaGFwZSwgeEJ1Zi5kdHlwZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRCdWYuc2l6ZTsgKytpKSB7XG4gICAgICAgIHZhciBuZXdMb2MgPSBvdXRCdWYuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgdmFyIG9yaWdpbmFsTG9jID0gbmV3TG9jLnNsaWNlKCk7XG4gICAgICAgIHZhciBiYXRjaElkeCA9IG9yaWdpbmFsTG9jWzBdO1xuICAgICAgICB2YXIgaW5kaWNlc0lkeCA9IG9yaWdpbmFsTG9jWzJdO1xuICAgICAgICB2YXIgaW5kaWNlc0luZGV4ID0gaW5kaWNlc0J1Zi5sb2NUb0luZGV4KFtiYXRjaElkeCwgaW5kaWNlc0lkeF0pO1xuICAgICAgICBvcmlnaW5hbExvY1syXSA9IGluZGljZXNCdWYudmFsdWVzW2luZGljZXNJbmRleF07XG4gICAgICAgIHZhciBvcmlnaW5hbEluZGV4ID0geEJ1Zi5sb2NUb0luZGV4KG9yaWdpbmFsTG9jKTtcbiAgICAgICAgb3V0QnVmLnZhbHVlc1tpXSA9IHhCdWYudmFsdWVzW29yaWdpbmFsSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0QnVmO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZ3JlYXRlckltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYSA+IGIpID8gMSA6IDA7IH0pO1xudmFyIGdyZWF0ZXIgPSBiaW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLkdyZWF0ZXIsIGdyZWF0ZXJJbXBsLCBudWxsIC8qIGNvbXBsZXhJbXBsICovLCAnYm9vbCcpO1xudmFyIGdyZWF0ZXJDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuR3JlYXRlcixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZ3JlYXRlclxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGxlc3NJbXBsID0gY3JlYXRlU2ltcGxlQmluYXJ5S2VybmVsSW1wbChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGEgPCBiKSA/IDEgOiAwOyB9KTtcbnZhciBsZXNzID0gYmluYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5MZXNzLCBsZXNzSW1wbCwgbnVsbCAvKiBjb21wbGV4SW1wbCAqLywgJ2Jvb2wnKTtcbnZhciBsZXNzQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkxlc3MsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGxlc3Ncbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGxpblNwYWNlSW1wbChzdGFydCwgc3RvcCwgbnVtKSB7XG4gICAgdmFyIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIChudW0gLSAxKTtcbiAgICB2YXIgdmFsdWVzID0gdGZqc0NvcmUudXRpbC5tYWtlWmVyb3NUeXBlZEFycmF5KG51bSwgJ2Zsb2F0MzInKTtcbiAgICB2YWx1ZXNbMF0gPSBzdGFydDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbaSAtIDFdICsgc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBsb2dJbXBsID0gY3JlYXRlU2ltcGxlVW5hcnlJbXBsKGZ1bmN0aW9uICh4aSkgeyByZXR1cm4gTWF0aC5sb2coeGkpOyB9KTtcbnZhciBsb2cgPSB1bmFyeUtlcm5lbEZ1bmNGcm9tSW1wbCh0ZmpzQ29yZS5Mb2csIGxvZ0ltcGwpO1xudmFyIGxvZ0NvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Mb2csXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGxvZyxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIG1heEltcGwoYVZhbHMsIHJlZHVjZVNpemUsIG91dFNoYXBlLCBkdHlwZSkge1xuICAgIHZhciB2YWxzID0gdGZqc0NvcmUudXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKGR0eXBlLCB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUob3V0U2hhcGUpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICB2YXIgbWF4ID0gYVZhbHNbb2Zmc2V0XTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsc1tpXSA9IG1heDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBtYXhpbXVtSW1wbCA9IGNyZWF0ZVNpbXBsZUJpbmFyeUtlcm5lbEltcGwoKGZ1bmN0aW9uIChhVmFsdWUsIGJWYWx1ZSkgeyByZXR1cm4gTWF0aC5tYXgoYVZhbHVlLCBiVmFsdWUpOyB9KSk7XG52YXIgbWF4aW11bSA9IGJpbmFyeUtlcm5lbEZ1bmModGZqc0NvcmUuTWF4aW11bSwgbWF4aW11bUltcGwpO1xudmFyIG1heGltdW1Db25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuTWF4aW11bSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogbWF4aW11bVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIG1pbmltdW1JbXBsID0gY3JlYXRlU2ltcGxlQmluYXJ5S2VybmVsSW1wbCgoZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBNYXRoLm1pbihhVmFsdWUsIGJWYWx1ZSk7IH0pKTtcbnZhciBtaW5pbXVtID0gYmluYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5NaW5pbXVtLCBtaW5pbXVtSW1wbCk7XG52YXIgbWluaW11bUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5NaW5pbXVtLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBtaW5pbXVtXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgbXVsdGlwbHlJbXBsID0gY3JlYXRlU2ltcGxlQmluYXJ5S2VybmVsSW1wbCgoZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBhVmFsdWUgKiBiVmFsdWU7IH0pKTtcbnZhciBtdWx0aXBseUNvbXBsZXhJbXBsID0gY3JlYXRlQ29tcGxleEJpbmFyeUtlcm5lbEltcGwoKGZ1bmN0aW9uIChhUmVhbCwgYUltYWcsIGJSZWFsLCBiSW1hZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlYWw6IGFSZWFsICogYlJlYWwgLSBhSW1hZyAqIGJJbWFnLFxuICAgICAgICBpbWFnOiBhUmVhbCAqIGJJbWFnICsgYUltYWcgKiBiUmVhbFxuICAgIH07XG59KSk7XG52YXIgbXVsdGlwbHkgPSBiaW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLk11bHRpcGx5LCBtdWx0aXBseUltcGwsIG11bHRpcGx5Q29tcGxleEltcGwpO1xudmFyIG11bHRpcGx5Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLk11bHRpcGx5LFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBtdWx0aXBseVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbmVnSW1wbCh4VmFscywgeFNoYXBlLCB4RHR5cGUpIHtcbiAgICB2YXIgbWludXNPbmUgPSB0ZmpzQ29yZS51dGlsLmNyZWF0ZVNjYWxhclZhbHVlKC0xLCB4RHR5cGUpO1xuICAgIHJldHVybiBtdWx0aXBseUltcGwoW10sIHhTaGFwZSwgbWludXNPbmUsIHhWYWxzLCB4RHR5cGUpO1xufVxuZnVuY3Rpb24gbmVnKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQ7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICduZWcnKTtcbiAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIF9hID0gbmVnSW1wbCh4VmFscywgeC5zaGFwZSwgeC5kdHlwZSksIHJlcyA9IF9hWzBdLCBuZXdTaGFwZSA9IF9hWzFdO1xuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG5ld1NoYXBlLCB4LmR0eXBlLCByZXMpO1xufVxudmFyIG5lZ0NvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5OZWcsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IG5lZ1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIG5vdEVxdWFsSW1wbCA9IGNyZWF0ZVNpbXBsZUJpbmFyeUtlcm5lbEltcGwoKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYSAhPT0gYikgPyAxIDogMDsgfSkpO1xudmFyIG5vdEVxdWFsID0gYmluYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5Ob3RFcXVhbCwgbm90RXF1YWxJbXBsLCBudWxsIC8qIGNvbXBsZXhPcCAqLywgJ2Jvb2wnKTtcbnZhciBub3RFcXVhbENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Ob3RFcXVhbCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogbm90RXF1YWxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcG9zZUltcGwoeFZhbHMsIHhTaGFwZSwgZHR5cGUsIHBlcm0sIG5ld1NoYXBlKSB7XG4gICAgdmFyIHhSYW5rID0geFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgeFNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUoeFNoYXBlKTtcbiAgICB2YXIgeFN0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKHhTaGFwZSk7XG4gICAgdmFyIG5ld1N0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKG5ld1NoYXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gdGZqc0NvcmUudXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKGR0eXBlLCB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhTaXplOyArK2kpIHtcbiAgICAgICAgdmFyIGxvYyA9IHRmanNDb3JlLnV0aWwuaW5kZXhUb0xvYyhpLCB4UmFuaywgeFN0cmlkZXMpO1xuICAgICAgICAvLyBQZXJtdXRlIGxvY2F0aW9uLlxuICAgICAgICB2YXIgbmV3TG9jID0gbmV3IEFycmF5KGxvYy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpXzEgPSAwOyBpXzEgPCBuZXdMb2MubGVuZ3RoOyBpXzErKykge1xuICAgICAgICAgICAgbmV3TG9jW2lfMV0gPSBsb2NbcGVybVtpXzFdXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3SW5kZXggPSB0ZmpzQ29yZS51dGlsLmxvY1RvSW5kZXgobmV3TG9jLCB4UmFuaywgbmV3U3RyaWRlcyk7XG4gICAgICAgIHJlc3VsdFtuZXdJbmRleF0gPSB4VmFsc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gdHJhbnNwb3NlKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGF0dHJzID0gYXJncy5hdHRycywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBwZXJtID0gYXR0cnMucGVybTtcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICd0cmFuc3Bvc2UnKTtcbiAgICB2YXIgeFJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgbmV3U2hhcGUgPSBuZXcgQXJyYXkoeFJhbmspO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3U2hhcGVbaV0gPSB4LnNoYXBlW3Blcm1baV1dO1xuICAgIH1cbiAgICB2YXIgdmFsdWVzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciByZXN1bHQgPSB0cmFuc3Bvc2VJbXBsKHZhbHVlcywgeC5zaGFwZSwgeC5kdHlwZSwgcGVybSwgbmV3U2hhcGUpO1xuICAgIHZhciBkYXRhSWQgPSBiYWNrZW5kLndyaXRlKHJlc3VsdCwgbmV3U2hhcGUsIHguZHR5cGUpO1xuICAgIHJldHVybiB7IGRhdGFJZDogZGF0YUlkLCBzaGFwZTogbmV3U2hhcGUsIGR0eXBlOiB4LmR0eXBlIH07XG59XG52YXIgdHJhbnNwb3NlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlRyYW5zcG9zZSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogdHJhbnNwb3NlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBwcm9kSW1wbCh4U2hhcGUsIHhEdHlwZSwgeFZhbHMsIHJlZHVjdGlvbkF4ZXMpIHtcbiAgICB2YXIgX2EgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4U2hhcGUsIHJlZHVjdGlvbkF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgIHZhciBvdXREdHlwZSA9IHRmanNDb3JlLnVwY2FzdFR5cGUoeER0eXBlLCAnaW50MzInKTtcbiAgICB2YXIgb3V0VmFscyA9IHRmanNDb3JlLnV0aWwubWFrZVplcm9zVHlwZWRBcnJheSh0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUob3V0U2hhcGUpLCBvdXREdHlwZSk7XG4gICAgdmFyIHJlZHVjZVNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0VmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgIHZhciBwcm9kXzEgPSAxO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgcHJvZF8xICo9IHhWYWxzW29mZnNldCArIGpdO1xuICAgICAgICB9XG4gICAgICAgIG91dFZhbHNbaV0gPSBwcm9kXzE7XG4gICAgfVxuICAgIHJldHVybiB7IG91dFZhbHM6IG91dFZhbHMsIG91dFNoYXBlOiBvdXRTaGFwZSwgb3V0RHR5cGU6IG91dER0eXBlIH07XG59XG5mdW5jdGlvbiBwcm9kKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBheGlzID0gYXR0cnMuYXhpcywga2VlcERpbXMgPSBhdHRycy5rZWVwRGltcztcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICdwcm9kJyk7XG4gICAgdmFyIHhSYW5rID0geC5zaGFwZS5sZW5ndGg7XG4gICAgdmFyIGF4ZXMgPSB0ZmpzQ29yZS51dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgIHZhciBwZXJtdXRhdGlvbiA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeFJhbmspO1xuICAgIHZhciByZWR1Y3Rpb25BeGVzID0gYXhlcztcbiAgICB2YXIgcGVybXV0ZWRYID0geDtcbiAgICB2YXIgaW50ZXJtZWRpYXRlVGVuc29ySW5mb3MgPSBbXTtcbiAgICBpZiAocGVybXV0YXRpb24gIT0gbnVsbCkge1xuICAgICAgICBwZXJtdXRlZFggPSB0cmFuc3Bvc2UoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBwZXJtOiBwZXJtdXRhdGlvbiB9IH0pO1xuICAgICAgICBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcy5wdXNoKHBlcm11dGVkWCk7XG4gICAgICAgIHJlZHVjdGlvbkF4ZXMgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhyZWR1Y3Rpb25BeGVzLmxlbmd0aCwgeFJhbmspO1xuICAgIH1cbiAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHBlcm11dGVkWC5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgX2EgPSBwcm9kSW1wbChwZXJtdXRlZFguc2hhcGUsIHBlcm11dGVkWC5kdHlwZSwgeFZhbHMsIHJlZHVjdGlvbkF4ZXMpLCBvdXRWYWxzID0gX2Eub3V0VmFscywgb3V0U2hhcGUgPSBfYS5vdXRTaGFwZSwgb3V0RHR5cGUgPSBfYS5vdXREdHlwZTtcbiAgICB2YXIgcmVzdWx0U2hhcGUgPSBvdXRTaGFwZTtcbiAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgcmVzdWx0U2hhcGUgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ob3V0U2hhcGUsIGF4ZXMpO1xuICAgIH1cbiAgICBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IHJldHVybiBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHQpOyB9KTtcbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhyZXN1bHRTaGFwZSwgb3V0RHR5cGUsIG91dFZhbHMpO1xufVxudmFyIHByb2RDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuUHJvZCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogcHJvZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gcmFuZ2VJbXBsKHN0YXJ0LCBzdG9wLCBzdGVwLCBkdHlwZSkge1xuICAgIHZhciBzYW1lU3RhcnRTdG9wID0gc3RhcnQgPT09IHN0b3A7XG4gICAgdmFyIGluY3JlYXNpbmdSYW5nZU5lZ2F0aXZlU3RlcCA9IHN0YXJ0IDwgc3RvcCAmJiBzdGVwIDwgMDtcbiAgICB2YXIgZGVjcmVhc2luZ1JhbmdlUG9zaXRpdmVTdGVwID0gc3RvcCA8IHN0YXJ0ICYmIHN0ZXAgPiAxO1xuICAgIGlmIChzYW1lU3RhcnRTdG9wIHx8IGluY3JlYXNpbmdSYW5nZU5lZ2F0aXZlU3RlcCB8fFxuICAgICAgICBkZWNyZWFzaW5nUmFuZ2VQb3NpdGl2ZVN0ZXApIHtcbiAgICAgICAgcmV0dXJuIHRmanNDb3JlLnV0aWwubWFrZVplcm9zVHlwZWRBcnJheSgwLCBkdHlwZSk7XG4gICAgfVxuICAgIHZhciBudW1FbGVtZW50cyA9IE1hdGguYWJzKE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApKTtcbiAgICB2YXIgdmFsdWVzID0gdGZqc0NvcmUudXRpbC5tYWtlWmVyb3NUeXBlZEFycmF5KG51bUVsZW1lbnRzLCBkdHlwZSk7XG4gICAgaWYgKHN0b3AgPCBzdGFydCAmJiBzdGVwID09PSAxKSB7XG4gICAgICAgIC8vIEF1dG8gYWRqdXN0IHRoZSBzdGVwJ3Mgc2lnbiBpZiBpdCBoYXNuJ3QgYmVlbiBzZXRcbiAgICAgICAgLy8gKG9yIHdhcyBzZXQgdG8gMSlcbiAgICAgICAgc3RlcCA9IC0xO1xuICAgIH1cbiAgICB2YWx1ZXNbMF0gPSBzdGFydDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbaSAtIDFdICsgc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciByc3FydEltcGwgPSBjcmVhdGVTaW1wbGVVbmFyeUltcGwoZnVuY3Rpb24gKHhpKSB7IHJldHVybiAxIC8gTWF0aC5zcXJ0KHhpKTsgfSk7XG52YXIgcnNxcnQgPSB1bmFyeUtlcm5lbEZ1bmNGcm9tSW1wbCh0ZmpzQ29yZS5Sc3FydCwgcnNxcnRJbXBsKTtcbnZhciByc3FydENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Sc3FydCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogcnNxcnQsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBzbGljZUltcGwodmFscywgYmVnaW4sIHNpemUsIHNoYXBlLCBkdHlwZSkge1xuICAgIHZhciBpc0NvbnRpbm91cyA9IHRmanNDb3JlLnNsaWNlX3V0aWwuaXNTbGljZUNvbnRpbm91cyhzaGFwZSwgYmVnaW4sIHNpemUpO1xuICAgIHZhciBsZW5ndGggPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUoc2l6ZSk7XG4gICAgdmFyIHhTdHJpZGVzID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZSk7XG4gICAgaWYgKGlzQ29udGlub3VzKSB7XG4gICAgICAgIHZhciBmbGF0T2Zmc2V0ID0gdGZqc0NvcmUuc2xpY2VfdXRpbC5jb21wdXRlRmxhdE9mZnNldChiZWdpbiwgeFN0cmlkZXMpO1xuICAgICAgICBpZiAoZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFscy5zbGljZShmbGF0T2Zmc2V0LCBmbGF0T2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFscy5zdWJhcnJheShmbGF0T2Zmc2V0LCBmbGF0T2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGRlY29kZWREYXRhID0gZHR5cGUgPT09ICdzdHJpbmcnID9cbiAgICAgICAgdGZqc0NvcmUuYmFja2VuZF91dGlsLmZyb21VaW50OFRvU3RyaW5nQXJyYXkodmFscykgOlxuICAgICAgICB2YWxzO1xuICAgIHZhciBpbkJ1ZiA9IHRmanNDb3JlLmJ1ZmZlcihzaGFwZSwgZHR5cGUsIGRlY29kZWREYXRhKTtcbiAgICB2YXIgb3V0QnVmID0gdGZqc0NvcmUuYnVmZmVyKHNpemUsIGR0eXBlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dEJ1Zi5zaXplOyArK2kpIHtcbiAgICAgICAgdmFyIG91dExvYyA9IG91dEJ1Zi5pbmRleFRvTG9jKGkpO1xuICAgICAgICB2YXIgaW5Mb2MgPSBvdXRMb2MubWFwKGZ1bmN0aW9uIChpZHgsIGopIHsgcmV0dXJuIGlkeCArIGJlZ2luW2pdOyB9KTtcbiAgICAgICAgb3V0QnVmLnNldC5hcHBseShvdXRCdWYsIFtpbkJ1Zi5nZXQuYXBwbHkoaW5CdWYsIGluTG9jKV0uY29uY2F0KG91dExvYykpO1xuICAgIH1cbiAgICBpZiAoZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZnJvbVN0cmluZ0FycmF5VG9VaW50OChvdXRCdWYudmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dEJ1Zi52YWx1ZXM7XG59XG5mdW5jdGlvbiBzbGljZShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgYmVnaW4gPSBhdHRycy5iZWdpbiwgc2l6ZSA9IGF0dHJzLnNpemU7XG4gICAgYXNzZXJ0Tm90Q29tcGxleCh4LCAnc2xpY2UnKTtcbiAgICB2YXIgX2EgPSB0ZmpzQ29yZS5zbGljZV91dGlsLnBhcnNlU2xpY2VQYXJhbXMoeCwgYmVnaW4sIHNpemUpLCAkYmVnaW4gPSBfYVswXSwgJHNpemUgPSBfYVsxXTtcbiAgICB0ZmpzQ29yZS5zbGljZV91dGlsLmFzc2VydFBhcmFtc1ZhbGlkKHgsICRiZWdpbiwgJHNpemUpO1xuICAgIHZhciB2YWxzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBvdXRWYWxzID0gc2xpY2VJbXBsKHZhbHMsICRiZWdpbiwgJHNpemUsIHguc2hhcGUsIHguZHR5cGUpO1xuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKCRzaXplLCB4LmR0eXBlLCBvdXRWYWxzKTtcbn1cbnZhciBzbGljZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5TbGljZSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogc2xpY2Vcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBzcXVhcmVkRGlmZmVyZW5jZUltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBkaWZmID0gYSAtIGI7XG4gICAgcmV0dXJuIGRpZmYgKiBkaWZmO1xufSkpO1xudmFyIHNxdWFyZWREaWZmZXJlbmNlID0gYmluYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5TcXVhcmVkRGlmZmVyZW5jZSwgc3F1YXJlZERpZmZlcmVuY2VJbXBsKTtcbnZhciBzcXVhcmVkRGlmZmVyZW5jZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5TcXVhcmVkRGlmZmVyZW5jZSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogc3F1YXJlZERpZmZlcmVuY2Vcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHN0cmlkZWRTbGljZUltcGwob3V0U2hhcGUsIHhCdWYsIHN0cmlkZXMsIGJlZ2luKSB7XG4gICAgdmFyIG91dEJ1ZiA9IHRmanNDb3JlLmJ1ZmZlcihvdXRTaGFwZSwgeEJ1Zi5kdHlwZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRCdWYuc2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciBsb2MgPSBvdXRCdWYuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgdmFyIG5ld0xvYyA9IG5ldyBBcnJheShsb2MubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdMb2MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG5ld0xvY1tqXSA9IGxvY1tqXSAqIHN0cmlkZXNbal0gKyBiZWdpbltqXTtcbiAgICAgICAgfVxuICAgICAgICBvdXRCdWYuc2V0LmFwcGx5KG91dEJ1ZiwgW3hCdWYuZ2V0LmFwcGx5KHhCdWYsIG5ld0xvYyldLmNvbmNhdChsb2MpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dEJ1Zjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIHN1YkltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKChmdW5jdGlvbiAoYVZhbHVlLCBiVmFsdWUpIHsgcmV0dXJuIGFWYWx1ZSAtIGJWYWx1ZTsgfSkpO1xudmFyIHN1YkNvbXBsZXhJbXBsID0gY3JlYXRlQ29tcGxleEJpbmFyeUtlcm5lbEltcGwoKGZ1bmN0aW9uIChhUmVhbCwgYUltYWcsIGJSZWFsLCBiSW1hZykge1xuICAgIHJldHVybiB7IHJlYWw6IGFSZWFsIC0gYlJlYWwsIGltYWc6IGFJbWFnIC0gYkltYWcgfTtcbn0pKTtcbnZhciBzdWIgPSBiaW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLlN1Yiwgc3ViSW1wbCwgc3ViQ29tcGxleEltcGwpO1xudmFyIHN1YkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5TdWIsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IHN1YlxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgdGlsZSBrZXJuZWwgc2hhcmVkIGJldHdlZW4gd2ViZ2wgYW5kIGNwdSBmb3Igc3RyaW5nXG4gKiB0ZW5zb3JzIG9ubHkuXG4gKi9cbmZ1bmN0aW9uIHRpbGVJbXBsKHhCdWYsIHJlcHMpIHtcbiAgICB2YXIgbmV3U2hhcGUgPSBuZXcgQXJyYXkoeEJ1Zi5yYW5rKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1NoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld1NoYXBlW2ldID0geEJ1Zi5zaGFwZVtpXSAqIHJlcHNbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0ZmpzQ29yZS5idWZmZXIobmV3U2hhcGUsIHhCdWYuZHR5cGUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbmV3TG9jID0gcmVzdWx0LmluZGV4VG9Mb2MoaSk7XG4gICAgICAgIHZhciBvcmlnaW5hbExvYyA9IG5ldyBBcnJheSh4QnVmLnJhbmspO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9yaWdpbmFsTG9jLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExvY1tqXSA9IG5ld0xvY1tqXSAlIHhCdWYuc2hhcGVbal07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdpbmFsSW5kZXggPSB4QnVmLmxvY1RvSW5kZXgob3JpZ2luYWxMb2MpO1xuICAgICAgICByZXN1bHQudmFsdWVzW2ldID0geEJ1Zi52YWx1ZXNbb3JpZ2luYWxJbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHRvcEtJbXBsKHgsIHhTaGFwZSwgeER0eXBlLCBrLCBzb3J0ZWQpIHtcbiAgICAvLyBSZXNoYXBlIGludG8gYSAyZCB0ZW5zb3IgW2JhdGNoLCBsYXN0RGltXSBhbmQgY29tcHV0ZSB0b3BrIGFsb25nIGxhc3REaW0uXG4gICAgdmFyIGxhc3REaW0gPSB4U2hhcGVbeFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIHZhciBfYSA9IFt4Lmxlbmd0aCAvIGxhc3REaW0sIGxhc3REaW1dLCBiYXRjaCA9IF9hWzBdLCBzaXplID0gX2FbMV07XG4gICAgdmFyIGFsbFRvcEtWYWxzID0gdGZqc0NvcmUudXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKHhEdHlwZSwgYmF0Y2ggKiBrKTtcbiAgICB2YXIgYWxsVG9wS0luZGljZXMgPSB0ZmpzQ29yZS51dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoJ2ludDMyJywgYmF0Y2ggKiBrKTtcbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoOyBiKyspIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGIgKiBzaXplO1xuICAgICAgICB2YXIgdmFscyA9IHguc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBzaXplKTtcbiAgICAgICAgdmFyIHZhbEFuZEluZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbEFuZEluZC5wdXNoKHsgdmFsdWU6IHZhbHNbaV0sIGluZGV4OiBpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhbEFuZEluZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTsgfSk7XG4gICAgICAgIHZhciBvdXRPZmZzZXQgPSBiICogaztcbiAgICAgICAgdmFyIHRvcEtWYWxzID0gYWxsVG9wS1ZhbHMuc3ViYXJyYXkob3V0T2Zmc2V0LCBvdXRPZmZzZXQgKyBrKTtcbiAgICAgICAgdmFyIHRvcEtJbmRpY2VzID0gYWxsVG9wS0luZGljZXMuc3ViYXJyYXkob3V0T2Zmc2V0LCBvdXRPZmZzZXQgKyBrKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgIHRvcEtWYWxzW2ldID0gdmFsQW5kSW5kW2ldLnZhbHVlO1xuICAgICAgICAgICAgdG9wS0luZGljZXNbaV0gPSB2YWxBbmRJbmRbaV0uaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVzaGFwZSBiYWNrIHRvIHRoZSBvcmlnaW5hbCBpbnB1dCBzaGFwZSwgZXhjZXB0IHRoYXQgdGhlIGxhc3RcbiAgICAvLyBkaW1lbnNpb24gaXMgay5cbiAgICB2YXIgb3V0cHV0U2hhcGUgPSB4U2hhcGUuc2xpY2UoKTtcbiAgICBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxXSA9IGs7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGZqc0NvcmUuYnVmZmVyKG91dHB1dFNoYXBlLCB4RHR5cGUsIGFsbFRvcEtWYWxzKSxcbiAgICAgICAgdGZqc0NvcmUuYnVmZmVyKG91dHB1dFNoYXBlLCAnaW50MzInLCBhbGxUb3BLSW5kaWNlcylcbiAgICBdO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiB1bmlxdWVJbXBsKHZhbHVlcywgYXhpcywgc2hhcGUsIGR0eXBlKSB7XG4gICAgLy8gTm9ybWFsaXplIGFuZCB2YWxpZGF0ZSBheGlzLlxuICAgIHZhciAkYXhpcyA9IHRmanNDb3JlLnV0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgc2hhcGUpWzBdO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IHNoYXBlIHRoYXQgaXMgc3VpdGFibGUgZm9yIGV4dHJhY3RpbmcgZGF0YSBhbG9uZyB0aGVcbiAgICAvLyBnaXZlbiBheGlzLlxuICAgIC8vXG4gICAgLy8gVGhlIHJhbmsgaXMgMy5cbiAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgMXN0IGRpbWVuc2lvbiBpcyB0aGUgc2l6ZSBvZiBhbGwgdGhlIGF4ZXMgPCB0aGUgZ2l2ZW4gYXhpcy5cbiAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgMm5kIGRpbWVuc2lvbiBpcyB0aGUgc2FtZSBhcyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpcy5cbiAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgM3JkIGRpbWVuc2lvbiBpcyB0aGUgc2l6ZSBvZiBhbGwgdGhlIGF4ZXMgPiB0aGUgZ2l2ZW4gYXhpcy5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCBmb3IgYSA0RCB0ZW5zb3Igd2l0aCBzaGFwZT1bMiwgMywgNSwgNF0gYW5kIGF4aXM9MiwgdGhlXG4gICAgLy8gbmV3U2hhcGUgd291bGQgYmU6IFsyKjMsIDUsIDRdLlxuICAgIC8vXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgbm90IHRoZSBmaW5hbCBvdXRwdXQgc2hhcGUuIFRoaXMgd2lsbCBiZSB0aGUgc2hhcGUgZm9yIGFuXG4gICAgLy8gaW50ZXJtZWRpYXRlIFRlbnNvckJ1ZmZlciAoc2VlIGlucHV0QnVmZmVyIGJlbG93KSB0byBhbGxvdyB1cyB0byBleHRyYWN0XG4gICAgLy8gdmFsdWVzIGFsb25nIHRoZSBnaXZlbiBheGlzLiBUbyBkZW1vbnN0cmF0ZSBob3cgaXQgd29ya3MsIGNvbnNpZGVyIHRoZVxuICAgIC8vIGZvbGxvd2luZyBleGFtcGxlOlxuICAgIC8vXG4gICAgLy8gSW5wdXQ6IGEgM0QgdGVuc29yLCB3aXRoIHNoYXBlIFsxLCAyLCAzXVxuICAgIC8vIFtcbiAgICAvLyAgIFtcbiAgICAvLyAgICAgIFsxLDIsM10sXG4gICAgLy8gICAgICBbNCw1LDZdXG4gICAgLy8gICBdXG4gICAgLy8gXVxuICAgIC8vIEF4aXM6IDIgKHRoZSBsYXN0IGF4aXMpLlxuICAgIC8vIEFsb25nIGF4aXMgMiwgd2UgZXhwZWN0IHRvIGV4dHJhY3QgMyB0ZW5zb3JzOiBbMSw0XSwgWzIsNV0sIFszLDZdLlxuICAgIC8vXG4gICAgLy8gRm9yIHRoaXMgZXhhbXBsZSwgbmV3U2hhcGUgd291bGQgYmU6IFsyLCAzLCAxXSwgd2hlcmUgMiBpcyBjYWxjdWxhdGVkIGZyb21cbiAgICAvLyAxKjIuIFRoZSByZS1zaGFwZWQgZGF0YSB3b3VsZCBsb29rIGxpa2U6XG4gICAgLy9cbiAgICAvLyBbXG4gICAgLy8gICBbXG4gICAgLy8gICAgIFsxXSwgWzJdLCBbM11cbiAgICAvLyAgIF0sXG4gICAgLy8gICBbXG4gICAgLy8gICAgIFs0XSwgWzVdLCBbNl1cbiAgICAvLyAgIF1cbiAgICAvLyBdXG4gICAgLy9cbiAgICAvLyBUaGVuLCB3ZSBjYW4gY29uc3RydWN0IGEgMy1sZXZlbCBuZXN0ZWQgbG9vcCBieSB0aGUgZm9sbG93aW5nIGRpbWVuc2lvblxuICAgIC8vIG9yZGVyIHRvIGV4dHJhY3QgdGhlIHZhbHVlcyBhbG9uZyB0aGUgYXhpcyAoZGltZW5zaW9uMSk6XG4gICAgLy8gaTogZGltZW5zaW9uMSAgICAgICAvLyAwLDEsMiAobmV3U2hhcGVbMV0pXG4gICAgLy8gICBtOiBkaW1lbnNpb24wICAgICAvLyAwLDEgICAobmV3U2hhcGVbMF0pXG4gICAgLy8gICAgIG46IGRpbWVuc2lvbjIgICAvLyAwICAgICAobmV3U2hhcGVbMl0pXG4gICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgbSwgaSwgblxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIC0tLS0tLS0tLVxuICAgIC8vIEl0ZXJhdGlvbiAwOiBkYXRhIGF0IFswLCAwLCAwXSA9PiBcIjFcIlxuICAgIC8vIEl0ZXJhdGlvbiAxOiBkYXRhIGF0IFsxLCAwLCAwXSA9PiBcIjRcIlxuICAgIC8vIFdlIGdvdCBbMSw0XS5cbiAgICAvLyBJdGVyYXRpb24gMjogZGF0YSBhdCBbMCwgMSwgMF0gPT4gXCIyXCJcbiAgICAvLyBJdGVyYXRpb24gMzogZGF0YSBhdCBbMSwgMSwgMF0gPT4gXCI1XCJcbiAgICAvLyBXZSBnb3QgWzIsNV0uXG4gICAgLy8gSXRlcmF0aW9uIDQ6IGRhdGEgYXQgWzAsIDIsIDBdID0+IFwiM1wiXG4gICAgLy8gSXRlcmF0aW9uIDU6IGRhdGEgYXQgWzEsIDIsIDBdID0+IFwiNlwiXG4gICAgLy8gV2UgZ290IFszLDZdLlxuICAgIHZhciBuZXdTaGFwZSA9IFsxLCBzaGFwZVswXSwgMV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAkYXhpczsgaSsrKSB7XG4gICAgICAgIG5ld1NoYXBlWzBdICo9IHNoYXBlW2ldO1xuICAgIH1cbiAgICBuZXdTaGFwZVsxXSA9IHNoYXBlWyRheGlzXTtcbiAgICBmb3IgKHZhciBpID0gJGF4aXMgKyAxOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3U2hhcGVbMl0gKj0gc2hhcGVbaV07XG4gICAgfVxuICAgIC8vIEEgbWFwIGZyb20gdW5pcXVlIGVsZW1lbnRzICh0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb25zKSB0byB0aGVpciB2YWx1ZXNcbiAgICAvLyBpbiBcImluZGljZXNcIiAoYmVsb3cpLlxuICAgIHZhciB1bmlxdWVFbGVtZW50cyA9IHt9O1xuICAgIC8vIFRoZSBpbmRpY2VzIG9mIGVhY2ggdW5pcXVlIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIHRlbnNvciBhbG9uZyB0aGUgZ2l2ZW5cbiAgICAvLyBheGlzLiBJdCBpcyAxRCBhbmQgaGFzIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIGF4aXMuXG4gICAgdmFyIGluZGljZXMgPSBuZXcgSW50MzJBcnJheShzaGFwZVskYXhpc10pO1xuICAgIC8vIENyZWF0ZSBhIGJ1ZmZlciBzbyB3ZSBjYW4gZWFzaWx5IGV4dHJhY3QgdmFsdWUgYXQgYSBnaXZlbiBsb2NhdGlvbi5cbiAgICB2YXIgaW5wdXRCdWZmZXIgPSBuZXcgdGZqc0NvcmUuVGVuc29yQnVmZmVyKG5ld1NoYXBlLCBkdHlwZSwgdmFsdWVzKTtcbiAgICAvLyBUaGUgaW5kaWNlcyBhbG9uZyB0aGUgZ2l2ZW4gYXhpcyB0aGF0IGhhdmUgdW5pcXVlIGVsZW1lbnRzLiBUaGlzIGlzIGFcbiAgICAvLyBkZS1kdXBlZCB2ZXJzaW9uIG9mIFwiaW5kaWNlc1wiIGFib3ZlLlxuICAgIHZhciB1bmlxdWVJbmRpY2VzID0gW107XG4gICAgdmFyIGlzMURUZW5zb3IgPSBuZXdTaGFwZVswXSA9PT0gMSAmJiBuZXdTaGFwZVsyXSA9PT0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlWyRheGlzXTsgaSsrKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgdmFsdWVzIGFsb25nIHRoZSBheGlzLlxuICAgICAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGlzMURUZW5zb3IpIHtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgMUQgdGVuc29yIGlucHV0LlxuICAgICAgICAgICAgZWxlbWVudCA9IHZhbHVlc1tpXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGF4aXNWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbmV3U2hhcGVbMF07IG0rKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbmV3U2hhcGVbMl07IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBheGlzVmFsdWVzLnB1c2goaW5wdXRCdWZmZXIuZ2V0KG0sIGksIG4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50ID0gYXhpc1ZhbHVlcy5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVkdXAgYW5kIHVwZGF0ZSB2YXJpb3VzIGluZGljZXMuXG4gICAgICAgIGlmICh1bmlxdWVFbGVtZW50c1tlbGVtZW50XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gdW5pcXVlRWxlbWVudHNbZWxlbWVudF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdW5pcXVlSW5kZXggPSBPYmplY3Qua2V5cyh1bmlxdWVFbGVtZW50cykubGVuZ3RoO1xuICAgICAgICAgICAgdW5pcXVlRWxlbWVudHNbZWxlbWVudF0gPSB1bmlxdWVJbmRleDtcbiAgICAgICAgICAgIGluZGljZXNbaV0gPSB1bmlxdWVJbmRleDtcbiAgICAgICAgICAgIHVuaXF1ZUluZGljZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3cgd2Uga25vdyB3aGVyZSBlYWNoIG9mIHRoZSB1bmlxdWUgZWxlbWVudHMgYXJlIGxvY2F0ZWQgYWxvbmcgdGhlIGF4aXNcbiAgICAvLyAodW5pcXVlSW5kaWNlcykuIEV4dHJhY3QgdGhlbSBmcm9tIGlucHV0IGJ1ZmZlciBhbmQgc3RvcmUgdGhlbSBpbiB0aGVcbiAgICAvLyBvdXRwdXQgYnVmZmVyLlxuICAgIHZhciBvdXRwdXRUbXBTaGFwZSA9IG5ld1NoYXBlLnNsaWNlKCk7XG4gICAgb3V0cHV0VG1wU2hhcGVbMV0gPSBPYmplY3Qua2V5cyh1bmlxdWVFbGVtZW50cykubGVuZ3RoO1xuICAgIHZhciBvdXRwdXRCdWZmZXIgPSBuZXcgdGZqc0NvcmUuVGVuc29yQnVmZmVyKG91dHB1dFRtcFNoYXBlLCBkdHlwZSk7XG4gICAgdW5pcXVlSW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uICh1bmlxdWVFbGVtZW50SW5kZXgsIGkpIHtcbiAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBuZXdTaGFwZVswXTsgbSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5ld1NoYXBlWzJdOyBuKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRCdWZmZXIuc2V0KGlucHV0QnVmZmVyLmdldChtLCB1bmlxdWVFbGVtZW50SW5kZXgsIG4pLCBtLCBpLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFRoZSBvdXRwdXQgc2hhcGUgY2FuIGJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgaW5wdXQgc2hhcGUgd2l0aCB0aGUgc2l6ZSBvZlxuICAgIC8vIHRoZSBnaXZlbiBheGlzIHJlcGxhY2VkIGJ5IHRoZSBudW1iZXIgb2YgdW5pcXVlIGVsZW1lbnRzIGFsb25nIHRoYXQgYXhpcy5cbiAgICB2YXIgb3V0cHV0U2hhcGUgPSBzaGFwZS5zbGljZSgpO1xuICAgIG91dHB1dFNoYXBlWyRheGlzXSA9IG91dHB1dFRtcFNoYXBlWzFdO1xuICAgIHJldHVybiB7XG4gICAgICAgIG91dHB1dFZhbHVlczogb3V0cHV0QnVmZmVyLnZhbHVlcyxcbiAgICAgICAgb3V0cHV0U2hhcGU6IG91dHB1dFNoYXBlLFxuICAgICAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICAgIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxudmFyIHNoYXJlZCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgc2ltcGxlQWJzSW1wbDogc2ltcGxlQWJzSW1wbCxcbiAgICBhZGRJbXBsOiBhZGRJbXBsLFxuICAgIGJpbmNvdW50SW1wbDogYmluY291bnRJbXBsLFxuICAgIGJpbmNvdW50UmVkdWNlSW1wbDogYmluY291bnRSZWR1Y2VJbXBsLFxuICAgIGNlaWxJbXBsOiBjZWlsSW1wbCxcbiAgICBjb25jYXRJbXBsOiBjb25jYXRJbXBsLFxuICAgIGV4cEltcGw6IGV4cEltcGwsXG4gICAgZXhwbTFJbXBsOiBleHBtMUltcGwsXG4gICAgZmxvb3JJbXBsOiBmbG9vckltcGwsXG4gICAgZ2F0aGVyVjJJbXBsOiBnYXRoZXJWMkltcGwsXG4gICAgZ3JlYXRlckltcGw6IGdyZWF0ZXJJbXBsLFxuICAgIGxlc3NJbXBsOiBsZXNzSW1wbCxcbiAgICBsaW5TcGFjZUltcGw6IGxpblNwYWNlSW1wbCxcbiAgICBsb2dJbXBsOiBsb2dJbXBsLFxuICAgIG1heEltcGw6IG1heEltcGwsXG4gICAgbWF4aW11bUltcGw6IG1heGltdW1JbXBsLFxuICAgIG1pbmltdW1JbXBsOiBtaW5pbXVtSW1wbCxcbiAgICBtdWx0aXBseUltcGw6IG11bHRpcGx5SW1wbCxcbiAgICBuZWdJbXBsOiBuZWdJbXBsLFxuICAgIG5vdEVxdWFsSW1wbDogbm90RXF1YWxJbXBsLFxuICAgIHByb2RJbXBsOiBwcm9kSW1wbCxcbiAgICByYW5nZUltcGw6IHJhbmdlSW1wbCxcbiAgICByc3FydEltcGw6IHJzcXJ0SW1wbCxcbiAgICBzbGljZUltcGw6IHNsaWNlSW1wbCxcbiAgICBzcXVhcmVkRGlmZmVyZW5jZUltcGw6IHNxdWFyZWREaWZmZXJlbmNlSW1wbCxcbiAgICBzdHJpZGVkU2xpY2VJbXBsOiBzdHJpZGVkU2xpY2VJbXBsLFxuICAgIHN1YkltcGw6IHN1YkltcGwsXG4gICAgdGlsZUltcGw6IHRpbGVJbXBsLFxuICAgIHRvcEtJbXBsOiB0b3BLSW1wbCxcbiAgICB0cmFuc3Bvc2VJbXBsOiB0cmFuc3Bvc2VJbXBsLFxuICAgIHVuaXF1ZUltcGw6IHVuaXF1ZUltcGxcbn07XG5cbi8qKiBAbGljZW5zZSBTZWUgdGhlIExJQ0VOU0UgZmlsZS4gKi9cbi8vIFRoaXMgY29kZSBpcyBhdXRvLWdlbmVyYXRlZCwgZG8gbm90IG1vZGlmeSB0aGlzIGZpbGUhXG52YXIgdmVyc2lvbiA9ICcyLjguNic7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8vIFNpZGUgZWZmZWN0cyBmb3IgZGVmYXVsdCBpbml0aWFsaXphdGlvbiBvZiBNYXRoQmFja2VuZENQVVxudGZqc0NvcmUucmVnaXN0ZXJCYWNrZW5kKCdjcHUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWF0aEJhY2tlbmRDUFUoKTsgfSwgMSAvKiBwcmlvcml0eSAqLyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZWx1ID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLkVsdSwgZnVuY3Rpb24gKHhpKSB7IHJldHVybiB4aSA+PSAwID8geGkgOiAoTWF0aC5leHAoeGkpIC0gMSk7IH0pO1xudmFyIGVsdUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5FbHUsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGVsdSxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGxlYWt5UmVsdShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgYWxwaGEgPSBhdHRycy5hbHBoYTtcbiAgICBhc3NlcnROb3RDb21wbGV4KFt4XSwgJ2xlYWt5UmVsdScpO1xuICAgIHZhciB4U2l6ZSA9IHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZSh4LnNoYXBlKTtcbiAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIG91dFZhbHMgPSB0ZmpzQ29yZS51dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoJ2Zsb2F0MzInLCB4U2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4VmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRWYWxzW2ldID0geFZhbHNbaV0gPCAwID8gYWxwaGEgKiB4VmFsc1tpXSA6IHhWYWxzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyh4LnNoYXBlLCAnZmxvYXQzMicsIG91dFZhbHMpO1xufVxudmFyIGxlYWt5UmVsdUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5MZWFreVJlbHUsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGxlYWt5UmVsdVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBwcmVsdUltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKGZ1bmN0aW9uICh4VmFsdWUsIGFWYWx1ZSkgeyByZXR1cm4geFZhbHVlIDwgMCA/IGFWYWx1ZSAqIHhWYWx1ZSA6IHhWYWx1ZTsgfSk7XG5mdW5jdGlvbiBwcmVsdShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciB4ID0gaW5wdXRzLngsIGFscGhhID0gaW5wdXRzLmFscGhhO1xuICAgIGFzc2VydE5vdENvbXBsZXgoW3gsIGFscGhhXSwgJ3ByZWx1Jyk7XG4gICAgdmFyIGFWYWxzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBiVmFscyA9IGJhY2tlbmQuZGF0YS5nZXQoYWxwaGEuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIF9hID0gcHJlbHVJbXBsKHguc2hhcGUsIGFscGhhLnNoYXBlLCBhVmFscywgYlZhbHMsIHguZHR5cGUpLCByZXN1bHREYXRhID0gX2FbMF0sIHJlc3VsdFNoYXBlID0gX2FbMV07XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8ocmVzdWx0U2hhcGUsIHguZHR5cGUsIHJlc3VsdERhdGEpO1xufVxudmFyIHByZWx1Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlByZWx1LFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBwcmVsdSxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgcmVsdSA9IHVuYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5SZWx1LCBmdW5jdGlvbiAoeGkpIHsgcmV0dXJuIE1hdGgubWF4KDAsIHhpKTsgfSk7XG52YXIgcmVsdUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5SZWx1LFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiByZWx1LFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciByZWx1NiA9IHVuYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5SZWx1NiwgZnVuY3Rpb24gKHhpKSB7IHJldHVybiBNYXRoLm1pbihNYXRoLm1heCgwLCB4aSksIDYpOyB9KTtcbnZhciByZWx1NkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5SZWx1NixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogcmVsdTYsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBhcHBseUFjdGl2YXRpb24oYmFja2VuZCwgeCwgYWN0aXZhdGlvbiwgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cywgbGVha3lyZWx1QWxwaGEpIHtcbiAgICBpZiAoYWN0aXZhdGlvbiA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWN0aXZhdGlvbiA9PT0gJ3JlbHUnKSB7XG4gICAgICAgIHJldHVybiByZWx1KHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWN0aXZhdGlvbiA9PT0gJ2VsdScpIHtcbiAgICAgICAgcmV0dXJuIGVsdSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdyZWx1NicpIHtcbiAgICAgICAgcmV0dXJuIHJlbHU2KHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWN0aXZhdGlvbiA9PT0gJ3ByZWx1Jykge1xuICAgICAgICByZXR1cm4gcHJlbHUoeyBpbnB1dHM6IHsgeDogeCwgYWxwaGE6IHByZWx1QWN0aXZhdGlvbldlaWdodHMgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWN0aXZhdGlvbiA9PT0gJ2xlYWt5cmVsdScpIHtcbiAgICAgICAgcmV0dXJuIGxlYWt5UmVsdSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGFscGhhOiBsZWFreXJlbHVBbHBoYSB9IH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY3RpdmF0aW9uIFwiICsgYWN0aXZhdGlvbiArIFwiIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBmb3IgdGhlIENQVSBiYWNrZW5kLlwiKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gcmVzaGFwZShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgc2hhcGUgPSBhdHRycy5zaGFwZTtcbiAgICB2YXIgeFNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUoeC5zaGFwZSk7XG4gICAgdmFyICRzaGFwZSA9IHRmanNDb3JlLnV0aWwuaW5mZXJGcm9tSW1wbGljaXRTaGFwZShzaGFwZSwgeFNpemUpO1xuICAgIHZhciAkeFNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUoJHNoYXBlKTtcbiAgICB0ZmpzQ29yZS51dGlsLmFzc2VydCh4U2l6ZSA9PT0gJHhTaXplLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlRoZSBuZXcgc2hhcGUgKFwiICsgJHNoYXBlICsgXCIpIGhhcyBcIiArICR4U2l6ZSArIFwiIGVsZW1lbnRzIGFuZCB0aGUgb2xkIFwiICtcbiAgICAgICAgKFwic2hhcGUgKFwiICsgeC5zaGFwZSArIFwiKSBoYXMgXCIgKyB4U2l6ZSArIFwiIGVsZW1lbnRzLiBUaGUgbmV3IHNoYXBlIGFuZCBvbGQgXCIpICtcbiAgICAgICAgXCJzaGFwZSBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLlwiOyB9KTtcbiAgICBiYWNrZW5kLmluY1JlZih4LmRhdGFJZCk7XG4gICAgdmFyIHhEYXRhID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCk7XG4gICAgaWYgKHhEYXRhLmNvbXBsZXhUZW5zb3JJbmZvcyAhPSBudWxsKSB7XG4gICAgICAgIHZhciByZWFsID0geERhdGEuY29tcGxleFRlbnNvckluZm9zLnJlYWw7XG4gICAgICAgIHZhciBpbWFnID0geERhdGEuY29tcGxleFRlbnNvckluZm9zLmltYWc7XG4gICAgICAgIHJlYWwuc2hhcGUgPSAkc2hhcGU7XG4gICAgICAgIGltYWcuc2hhcGUgPSAkc2hhcGU7XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGFJZDogeC5kYXRhSWQsIHNoYXBlOiAkc2hhcGUsIGR0eXBlOiB4LmR0eXBlIH07XG59XG52YXIgcmVzaGFwZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5SZXNoYXBlLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiByZXNoYXBlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gYmF0Y2hNYXRNdWwoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBhID0gaW5wdXRzLmEsIGIgPSBpbnB1dHMuYjtcbiAgICB2YXIgdHJhbnNwb3NlQSA9IGF0dHJzLnRyYW5zcG9zZUEsIHRyYW5zcG9zZUIgPSBhdHRycy50cmFuc3Bvc2VCO1xuICAgIGFzc2VydE5vdENvbXBsZXgoW2EsIGJdLCAnbWF0TXVsJyk7XG4gICAgdmFyIGFSYW5rID0gYS5zaGFwZS5sZW5ndGg7XG4gICAgdmFyIGJSYW5rID0gYi5zaGFwZS5sZW5ndGg7XG4gICAgdmFyIGlubmVyU2hhcGVBID0gdHJhbnNwb3NlQSA/IGEuc2hhcGVbYVJhbmsgLSAyXSA6IGEuc2hhcGVbYVJhbmsgLSAxXTtcbiAgICB2YXIgaW5uZXJTaGFwZUIgPSB0cmFuc3Bvc2VCID8gYi5zaGFwZVtiUmFuayAtIDFdIDogYi5zaGFwZVtiUmFuayAtIDJdO1xuICAgIHZhciBvdXRlclNoYXBlQSA9IHRyYW5zcG9zZUEgPyBhLnNoYXBlW2FSYW5rIC0gMV0gOiBhLnNoYXBlW2FSYW5rIC0gMl07XG4gICAgdmFyIG91dGVyU2hhcGVCID0gdHJhbnNwb3NlQiA/IGIuc2hhcGVbYlJhbmsgLSAyXSA6IGIuc2hhcGVbYlJhbmsgLSAxXTtcbiAgICB2YXIgb3V0ZXJEaW1zQSA9IGEuc2hhcGUuc2xpY2UoMCwgLTIpO1xuICAgIHZhciBvdXRlckRpbXNCID0gYi5zaGFwZS5zbGljZSgwLCAtMik7XG4gICAgdmFyIGJhdGNoRGltQSA9IHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShvdXRlckRpbXNBKTtcbiAgICB2YXIgYmF0Y2hEaW1CID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKG91dGVyRGltc0IpO1xuICAgIHZhciBiYXRjaERpbXNDb21wYXRpYmxlID0gYmF0Y2hEaW1BID09PSBiYXRjaERpbUIgfHwgYmF0Y2hEaW1BID09PSAxIHx8IGJhdGNoRGltQiA9PT0gMTtcbiAgICB0ZmpzQ29yZS51dGlsLmFzc2VydChhUmFuayA+PSAyICYmIGJSYW5rID49IDIgJiYgYmF0Y2hEaW1zQ29tcGF0aWJsZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJFcnJvciBpbiBtYXRNdWw6IHRoZSBpbnB1dCBiYXRjaCBkaW1lbnNpb25zIG11c3QgZWl0aGVyIGJlIHRoZSBcIiArXG4gICAgICAgIFwic2FtZSBvciBhdCBsZWFzdCBvbmUgaW5wdXQgYmF0Y2ggZGltZW5zaW9uIG11c3QgYmUgMS4gR290IGlucHV0IFwiICtcbiAgICAgICAgKFwiYmF0Y2ggZGltZW5zaW9ucyBvZiAoXCIgKyBvdXRlckRpbXNBICsgXCIpIGFuZCAoXCIgKyBvdXRlckRpbXNCICsgXCIpLlwiKTsgfSk7XG4gICAgdmFyIG91dFNoYXBlT3V0ZXJEaW1zID0gYmF0Y2hEaW1BID4gYmF0Y2hEaW1CID8gYS5zaGFwZS5zbGljZSgwLCAtMikgOiBiLnNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICB2YXIgb3V0U2hhcGUgPSBvdXRTaGFwZU91dGVyRGltcy5jb25jYXQoW291dGVyU2hhcGVBLCBvdXRlclNoYXBlQl0pO1xuICAgIHRmanNDb3JlLnV0aWwuYXNzZXJ0KGlubmVyU2hhcGVBID09PSBpbm5lclNoYXBlQiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJFcnJvciBpbiBtYXRNdWw6IGlubmVyIHNoYXBlcyAoXCIgKyBpbm5lclNoYXBlQSArIFwiKSBhbmQgKFwiICtcbiAgICAgICAgKGlubmVyU2hhcGVCICsgXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIgKyBhLnNoYXBlICsgXCIgYW5kIFwiKSArXG4gICAgICAgIChiLnNoYXBlICsgXCIgYW5kIHRyYW5zcG9zZUE9XCIgKyB0cmFuc3Bvc2VBKSArXG4gICAgICAgIChcIiBhbmQgdHJhbnNwb3NlQj1cIiArIHRyYW5zcG9zZUIgKyBcIiBtdXN0IG1hdGNoLlwiKTsgfSk7XG4gICAgdmFyIGEzZFNoYXBlID0gdHJhbnNwb3NlQSA/IFtiYXRjaERpbUEsIGlubmVyU2hhcGVBLCBvdXRlclNoYXBlQV0gOlxuICAgICAgICBbYmF0Y2hEaW1BLCBvdXRlclNoYXBlQSwgaW5uZXJTaGFwZUFdO1xuICAgIHZhciBiM2RTaGFwZSA9IHRyYW5zcG9zZUIgPyBbYmF0Y2hEaW1CLCBvdXRlclNoYXBlQiwgaW5uZXJTaGFwZUJdIDpcbiAgICAgICAgW2JhdGNoRGltQiwgaW5uZXJTaGFwZUIsIG91dGVyU2hhcGVCXTtcbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgaW1wbGVtZW50YXRpb24gaXMgZGVzaWduZWQgdG8gb3BlcmF0ZSBvbiByYW5rLTMgdGVuc29yc1xuICAgIHZhciBhM2QgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IGEgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IGEzZFNoYXBlIH0gfSk7XG4gICAgdmFyIGIzZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogYiB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogYjNkU2hhcGUgfSB9KTtcbiAgICB2YXIgc2hhcmVkRGltID0gdHJhbnNwb3NlQSA/IGEzZC5zaGFwZVsxXSA6IGEzZC5zaGFwZVsyXTtcbiAgICB2YXIgbGVmdERpbSA9IHRyYW5zcG9zZUEgPyBhM2Quc2hhcGVbMl0gOiBhM2Quc2hhcGVbMV07XG4gICAgdmFyIHJpZ2h0RGltID0gdHJhbnNwb3NlQiA/IGIzZC5zaGFwZVsxXSA6IGIzZC5zaGFwZVsyXTtcbiAgICB2YXIgYmF0Y2hEaW0gPSBNYXRoLm1heChiYXRjaERpbUEsIGJhdGNoRGltQik7XG4gICAgdmFyIGEzZFZhbHVlcyA9IGJhY2tlbmQuZGF0YS5nZXQoYTNkLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBiM2RWYWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KGIzZC5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgYTNkU3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoYTNkLnNoYXBlKTtcbiAgICB2YXIgYjNkU3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoYjNkLnNoYXBlKTtcbiAgICB2YXIgX2EgPSB0cmFuc3Bvc2VBID9cbiAgICAgICAgW2EzZFN0cmlkZXNbMF0sIDEsIGEzZFN0cmlkZXNbMV1dIDpcbiAgICAgICAgW2EzZFN0cmlkZXNbMF0sIGEzZFN0cmlkZXNbMV0sIDFdLCBhQmF0Y2ggPSBfYVswXSwgYU91dGVyU3RlcCA9IF9hWzFdLCBhSW5uZXJTdGVwID0gX2FbMl07XG4gICAgdmFyIF9iID0gdHJhbnNwb3NlQiA/XG4gICAgICAgIFsxLCBiM2RTdHJpZGVzWzFdLCBiM2RTdHJpZGVzWzBdXSA6XG4gICAgICAgIFtiM2RTdHJpZGVzWzFdLCAxLCBiM2RTdHJpZGVzWzBdXSwgYklubmVyU3RlcCA9IF9iWzBdLCBiT3V0ZXJTdGVwID0gX2JbMV0sIGJCYXRjaCA9IF9iWzJdO1xuICAgIHZhciBzaXplID0gbGVmdERpbSAqIHJpZ2h0RGltO1xuICAgIHZhciByZXN1bHQgPSB0ZmpzQ29yZS5idWZmZXIoW2JhdGNoRGltLCBsZWZ0RGltLCByaWdodERpbV0sIGEzZC5kdHlwZSk7XG4gICAgdmFyIHJlc1ZhbHMgPSByZXN1bHQudmFsdWVzO1xuICAgIHZhciBibG9ja1NpemUgPSBiYWNrZW5kLmJsb2NrU2l6ZTtcbiAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYmF0Y2hEaW07IGJpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaTAgPSAwOyBpMCA8IGxlZnREaW07IGkwICs9IGJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgajAgPSAwOyBqMCA8IHJpZ2h0RGltOyBqMCArPSBibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrMCA9IDA7IGswIDwgc2hhcmVkRGltOyBrMCArPSBibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHdoZW4gYmxvY2tTaXplIGRvZXNuJ3QgZXZlbmx5IGRpdmlkZSB0aGUgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlCbG9jayA9IE1hdGgubWluKGkwICsgYmxvY2tTaXplLCBsZWZ0RGltKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpCbG9jayA9IE1hdGgubWluKGowICsgYmxvY2tTaXplLCByaWdodERpbSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrQmxvY2sgPSBNYXRoLm1pbihrMCArIGJsb2NrU2l6ZSwgc2hhcmVkRGltKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGkwOyBpIDwgaUJsb2NrOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBqMDsgaiA8IGpCbG9jazsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gazA7IGsgPCBrQmxvY2s7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmF0Y2hPZmZzZXRBID0gTWF0aC5taW4oYmksIGJhdGNoRGltQSAtIDEpICogYUJhdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmF0Y2hPZmZzZXRCID0gTWF0aC5taW4oYmksIGJhdGNoRGltQiAtIDEpICogYkJhdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYVZhbCA9IGEzZFZhbHVlc1tiYXRjaE9mZnNldEEgKyBpICogYU91dGVyU3RlcCArIGsgKiBhSW5uZXJTdGVwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJWYWwgPSBiM2RWYWx1ZXNbayAqIGJJbm5lclN0ZXAgKyBqICogYk91dGVyU3RlcCArIGJhdGNoT2Zmc2V0Ql07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSBhVmFsICogYlZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzVmFsc1tiaSAqIHNpemUgKyAoaSAqIHJpZ2h0RGltICsgaildICs9IHN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGEzZCk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhiM2QpO1xuICAgIC8vIHNldCBjb3JyZWN0IHNoYXBlIG9uIG91dHB1dC5cbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRTaGFwZSwgcmVzdWx0LmR0eXBlLCByZXN1bHQudmFsdWVzKTtcbn1cbnZhciBiYXRjaE1hdE11bENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5CYXRjaE1hdE11bCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogYmF0Y2hNYXRNdWwsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gX2Z1c2VkTWF0TXVsKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgYSA9IGlucHV0cy5hLCBiID0gaW5wdXRzLmIsIGJpYXMgPSBpbnB1dHMuYmlhcywgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IGlucHV0cy5wcmVsdUFjdGl2YXRpb25XZWlnaHRzO1xuICAgIHZhciB0cmFuc3Bvc2VBID0gYXR0cnMudHJhbnNwb3NlQSwgdHJhbnNwb3NlQiA9IGF0dHJzLnRyYW5zcG9zZUIsIGFjdGl2YXRpb24gPSBhdHRycy5hY3RpdmF0aW9uLCBsZWFreXJlbHVBbHBoYSA9IGF0dHJzLmxlYWt5cmVsdUFscGhhO1xuICAgIHZhciBjdXJyZW50O1xuICAgIHZhciBhZGRSZXM7XG4gICAgdmFyIGFjdGl2YXRpb25SZXM7XG4gICAgdmFyIGludGVybWVkaWF0ZXMgPSBbXTtcbiAgICB2YXIgbWF0TXVsUmVzID0gYmF0Y2hNYXRNdWwoeyBpbnB1dHM6IHsgYTogYSwgYjogYiB9LCBhdHRyczogeyB0cmFuc3Bvc2VBOiB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCOiB0cmFuc3Bvc2VCIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgY3VycmVudCA9IG1hdE11bFJlcztcbiAgICBpZiAoYmlhcykge1xuICAgICAgICBhZGRSZXMgPSBhZGQoeyBpbnB1dHM6IHsgYTogY3VycmVudCwgYjogYmlhcyB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICBpbnRlcm1lZGlhdGVzLnB1c2goY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBhZGRSZXM7XG4gICAgfVxuICAgIGlmIChhY3RpdmF0aW9uKSB7XG4gICAgICAgIGFjdGl2YXRpb25SZXMgPSBhcHBseUFjdGl2YXRpb24oYmFja2VuZCwgY3VycmVudCwgYWN0aXZhdGlvbiwgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cywgbGVha3lyZWx1QWxwaGEpO1xuICAgICAgICBpbnRlcm1lZGlhdGVzLnB1c2goY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBhY3RpdmF0aW9uUmVzO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIGludGVybWVkaWF0ZXNfMSA9IGludGVybWVkaWF0ZXM7IF9pIDwgaW50ZXJtZWRpYXRlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaSA9IGludGVybWVkaWF0ZXNfMVtfaV07XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xufVxudmFyIF9mdXNlZE1hdE11bENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5fRnVzZWRNYXRNdWwsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IF9mdXNlZE1hdE11bCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgYWNvcyA9IHVuYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5BY29zLCBmdW5jdGlvbiAoeGkpIHsgcmV0dXJuIE1hdGguYWNvcyh4aSk7IH0pO1xudmFyIGFjb3NDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQWNvcyxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogYWNvcyxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgYWNvc2ggPSB1bmFyeUtlcm5lbEZ1bmModGZqc0NvcmUuQWNvc2gsIGZ1bmN0aW9uICh4aSkgeyByZXR1cm4gTWF0aC5hY29zaCh4aSk7IH0pO1xudmFyIGFjb3NoQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkFjb3NoLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBhY29zaCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGFkZE4oYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgdGVuc29ycyA9IGlucHV0cztcbiAgICBhc3NlcnROb3RDb21wbGV4KGlucHV0cywgJ2FkZE4nKTtcbiAgICB2YXIgdmFscyA9IHRlbnNvcnMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBiYWNrZW5kLmRhdGEuZ2V0KHQuZGF0YUlkKS52YWx1ZXM7IH0pO1xuICAgIHZhciBvdXRCdWYgPSB0ZmpzQ29yZS5idWZmZXIodGVuc29yc1swXS5zaGFwZSwgdGVuc29yc1swXS5kdHlwZSk7XG4gICAgdmFyIG91dFZhbHMgPSBvdXRCdWYudmFsdWVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVuc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VyclZhbHMgPSB2YWxzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG91dFZhbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG91dFZhbHNbal0gKz0gY3VyclZhbHNbal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8ob3V0QnVmLnNoYXBlLCBvdXRCdWYuZHR5cGUsIG91dEJ1Zi52YWx1ZXMpO1xufVxudmFyIGFkZE5Db25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQWRkTixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogYWRkTlxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gYWxsKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBheGlzID0gYXR0cnMuYXhpcywga2VlcERpbXMgPSBhdHRycy5rZWVwRGltcztcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICdhbGwnKTtcbiAgICB2YXIgb3JpZ0F4ZXMgPSB0ZmpzQ29yZS51dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgIHZhciBheGVzID0gb3JpZ0F4ZXM7XG4gICAgdmFyIHBlcm11dGVkQXhlcyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5zaGFwZS5sZW5ndGgpO1xuICAgIHZhciAkeCA9IHg7XG4gICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICR4ID0gdHJhbnNwb3NlKHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgcGVybTogcGVybXV0ZWRBeGVzIH0gfSk7XG4gICAgICAgIGF4ZXMgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeC5zaGFwZS5sZW5ndGgpO1xuICAgIH1cbiAgICB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ2FsbCcsIGF4ZXMsICR4LnNoYXBlLmxlbmd0aCk7XG4gICAgdmFyIF9hID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoJHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgIHZhciByZWR1Y2VTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICB2YXIgdmFscyA9IHRmanNDb3JlLnV0aWwubWFrZVplcm9zVHlwZWRBcnJheSh0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUob3V0U2hhcGUpLCAkeC5kdHlwZSk7XG4gICAgdmFyIGFWYWxzID0gYmFja2VuZC5kYXRhLmdldCgkeC5kYXRhSWQpLnZhbHVlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICB2YXIgYWxsXzEgPSBhVmFsc1tvZmZzZXRdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYVZhbHNbb2Zmc2V0ICsgal07XG4gICAgICAgICAgICBhbGxfMSA9IGFsbF8xICYmIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHNbaV0gPSBhbGxfMTtcbiAgICB9XG4gICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oJHgpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRTaGFwZSwgJHguZHR5cGUsIHZhbHMpO1xuICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICB2YXIgZXhwYW5kZWRTaGFwZSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShvdXRTaGFwZSwgb3JpZ0F4ZXMpO1xuICAgICAgICB2YXIgcmVzaGFwZWRSZXN1bHQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHJlc3VsdCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogZXhwYW5kZWRTaGFwZSB9IH0pO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXNoYXBlZFJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBhbGxDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQWxsLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBhbGxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGFueShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgYXhpcyA9IGF0dHJzLmF4aXMsIGtlZXBEaW1zID0gYXR0cnMua2VlcERpbXM7XG4gICAgYXNzZXJ0Tm90Q29tcGxleCh4LCAnYW55Jyk7XG4gICAgdmFyIG9yaWdBeGVzID0gdGZqc0NvcmUudXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICB2YXIgYXhlcyA9IG9yaWdBeGVzO1xuICAgIHZhciBwZXJtdXRlZEF4ZXMgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHguc2hhcGUubGVuZ3RoKTtcbiAgICB2YXIgJHggPSB4O1xuICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAkeCA9IHRyYW5zcG9zZSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHBlcm06IHBlcm11dGVkQXhlcyB9IH0pO1xuICAgICAgICBheGVzID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIHguc2hhcGUubGVuZ3RoKTtcbiAgICB9XG4gICAgdGZqc0NvcmUuYmFja2VuZF91dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdhbnknLCBheGVzLCAkeC5zaGFwZS5sZW5ndGgpO1xuICAgIHZhciBfYSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKCR4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICB2YXIgcmVkdWNlU2l6ZSA9IHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgdmFyIHZhbHMgPSB0ZmpzQ29yZS51dGlsLm1ha2VaZXJvc1R5cGVkQXJyYXkodGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKG91dFNoYXBlKSwgJHguZHR5cGUpO1xuICAgIHZhciBhVmFscyA9IGJhY2tlbmQuZGF0YS5nZXQoJHguZGF0YUlkKS52YWx1ZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgdmFyIGFueVZhbCA9IGFWYWxzW29mZnNldF07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgIGFueVZhbCA9IGFueVZhbCB8fCB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWxzW2ldID0gYW55VmFsO1xuICAgIH1cbiAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbygkeCk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dFNoYXBlLCAkeC5kdHlwZSwgdmFscyk7XG4gICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIHZhciBleHBhbmRlZFNoYXBlID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKG91dFNoYXBlLCBvcmlnQXhlcyk7XG4gICAgICAgIHZhciByZXNoYXBlZFJlc3VsdCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogcmVzdWx0IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBleHBhbmRlZFNoYXBlIH0gfSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc2hhcGVkUmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGFueUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5BbnksXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGFueVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gYXJnTWF4KGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBheGlzID0gYXR0cnMuYXhpcztcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICdhcmdNYXgnKTtcbiAgICB2YXIgYXhlcyA9IHRmanNDb3JlLnV0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgdmFyIHBlcm11dGVkQXhlcyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5zaGFwZS5sZW5ndGgpO1xuICAgIHZhciAkeCA9IHg7XG4gICAgdmFyIGludGVybWVkaWF0ZVRlbnNvckluZm9zID0gW107XG4gICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICR4ID0gdHJhbnNwb3NlKHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgcGVybTogcGVybXV0ZWRBeGVzIH0gfSk7XG4gICAgICAgIGludGVybWVkaWF0ZVRlbnNvckluZm9zLnB1c2goJHgpO1xuICAgICAgICBheGVzID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsICR4LnNoYXBlLmxlbmd0aCk7XG4gICAgfVxuICAgIGF4ZXMgPSBbYXhlc1swXV07XG4gICAgdGZqc0NvcmUuYmFja2VuZF91dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdhcmdNYXgnLCBheGVzLCAkeC5zaGFwZS5sZW5ndGgpO1xuICAgIHZhciBfYSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKCR4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICB2YXIgb3V0U2l6ZSA9IHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShvdXRTaGFwZSk7XG4gICAgdmFyIHZhbHMgPSB0ZmpzQ29yZS51dGlsLm1ha2VaZXJvc1R5cGVkQXJyYXkob3V0U2l6ZSwgJ2ludDMyJyk7XG4gICAgdmFyIHJlZHVjZVNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgIHZhciBhVmFscyA9IGJhY2tlbmQuZGF0YS5nZXQoJHguZGF0YUlkKS52YWx1ZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgdmFyIG1heCA9IGFWYWxzW29mZnNldF07XG4gICAgICAgIHZhciBtYXhJbmRleCA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIG1heEluZGV4ID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWxzW2ldID0gbWF4SW5kZXg7XG4gICAgfVxuICAgIGludGVybWVkaWF0ZVRlbnNvckluZm9zLmZvckVhY2goZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odCk7IH0pO1xuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dFNoYXBlLCAnaW50MzInLCB2YWxzKTtcbn1cbnZhciBhcmdNYXhDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQXJnTWF4LFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBhcmdNYXhcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGFyZ01pbihhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgYXhpcyA9IGF0dHJzLmF4aXM7XG4gICAgYXNzZXJ0Tm90Q29tcGxleCh4LCAnYXJnTWluJyk7XG4gICAgdmFyIGF4ZXMgPSB0ZmpzQ29yZS51dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgIHZhciBwZXJtdXRlZEF4ZXMgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHguc2hhcGUubGVuZ3RoKTtcbiAgICB2YXIgJHggPSB4O1xuICAgIHZhciBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcyA9IFtdO1xuICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAkeCA9IHRyYW5zcG9zZSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHBlcm06IHBlcm11dGVkQXhlcyB9IH0pO1xuICAgICAgICBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcy5wdXNoKCR4KTtcbiAgICAgICAgYXhlcyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCAkeC5zaGFwZS5sZW5ndGgpO1xuICAgIH1cbiAgICBheGVzID0gW2F4ZXNbMF1dO1xuICAgIHRmanNDb3JlLmJhY2tlbmRfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWluJywgYXhlcywgJHguc2hhcGUubGVuZ3RoKTtcbiAgICB2YXIgX2EgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcygkeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgdmFyIG91dFNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUob3V0U2hhcGUpO1xuICAgIHZhciB2YWxzID0gdGZqc0NvcmUudXRpbC5tYWtlWmVyb3NUeXBlZEFycmF5KG91dFNpemUsICdpbnQzMicpO1xuICAgIHZhciByZWR1Y2VTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICB2YXIgYVZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KCR4LmRhdGFJZCkudmFsdWVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgIHZhciBtaW4gPSBhVmFsc1tvZmZzZXRdO1xuICAgICAgICB2YXIgbWluSW5kZXggPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYVZhbHNbb2Zmc2V0ICsgal07XG4gICAgICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsc1tpXSA9IG1pbkluZGV4O1xuICAgIH1cbiAgICBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IHJldHVybiBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHQpOyB9KTtcbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRTaGFwZSwgJ2ludDMyJywgdmFscyk7XG59XG52YXIgYXJnTWluQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkFyZ01pbixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogYXJnTWluXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGFzaW4gPSB1bmFyeUtlcm5lbEZ1bmModGZqc0NvcmUuQXNpbiwgZnVuY3Rpb24gKHhpKSB7IHJldHVybiBNYXRoLmFzaW4oeGkpOyB9KTtcbnZhciBhc2luQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkFzaW4sXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGFzaW4sXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGFzaW5oID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLkFzaW5oLCBmdW5jdGlvbiAoeGkpIHsgcmV0dXJuIE1hdGguYXNpbmgoeGkpOyB9KTtcbnZhciBhc2luaENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Bc2luaCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogYXNpbmgsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGF0YW4gPSB1bmFyeUtlcm5lbEZ1bmModGZqc0NvcmUuQXRhbiwgZnVuY3Rpb24gKHhpKSB7IHJldHVybiBNYXRoLmF0YW4oeGkpOyB9KTtcbnZhciBhdGFuQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkF0YW4sXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGF0YW4sXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGF0YW4ySW1wbCA9IGNyZWF0ZVNpbXBsZUJpbmFyeUtlcm5lbEltcGwoZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBNYXRoLmF0YW4yKGFWYWx1ZSwgYlZhbHVlKTsgfSk7XG52YXIgYXRhbjIgPSBiaW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLkF0YW4yLCBhdGFuMkltcGwpO1xudmFyIGF0YW4yQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkF0YW4yLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBhdGFuMixcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgYXRhbmggPSB1bmFyeUtlcm5lbEZ1bmModGZqc0NvcmUuQXRhbmgsIGZ1bmN0aW9uICh4aSkgeyByZXR1cm4gTWF0aC5hdGFuaCh4aSk7IH0pO1xudmFyIGF0YW5oQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkF0YW5oLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBhdGFuaCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHBvb2woeFZhbHVlcywgeFNoYXBlLCBkdHlwZSwgc3RyaWRlcywgY29udkluZm8sIHBvb2xUeXBlKSB7XG4gICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICB2YXIgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodDtcbiAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgdmFyIGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlckhlaWdodDtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJXaWR0aDtcbiAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IChwb29sVHlwZSA9PT0gJ21heCcgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgOlxuICAgICAgICBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIHZhciBvdXRwdXQgPSB0ZmpzQ29yZS5idWZmZXIoY29udkluZm8ub3V0U2hhcGUsIGR0eXBlKTtcbiAgICB2YXIgb3V0cHV0VmFscyA9IG91dHB1dC52YWx1ZXM7XG4gICAgdmFyIG91dHB1dEJhdGNoU3RyaWRlcyA9IGNvbnZJbmZvLm91dFNoYXBlWzFdICogY29udkluZm8ub3V0U2hhcGVbMl0gKiBjb252SW5mby5vdXRTaGFwZVszXTtcbiAgICB2YXIgb3V0cHV0Um93U3RyaWRlcyA9IGNvbnZJbmZvLm91dFNoYXBlWzJdICogY29udkluZm8ub3V0U2hhcGVbM107XG4gICAgdmFyIG91dHB1dENvbFN0cmlkZXMgPSBjb252SW5mby5vdXRTaGFwZVszXTtcbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgIHZhciBvdXRwdXRCYXRjaE9mZnNldCA9IGIgKiBvdXRwdXRCYXRjaFN0cmlkZXM7XG4gICAgICAgIHZhciBpbnB1dEJhdGNoT2Zmc2V0ID0gYiAqIHN0cmlkZXNbMF07XG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgY29udkluZm8uaW5DaGFubmVsczsgKytkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgY29udkluZm8ub3V0SGVpZ2h0OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBzdHJpZGVIZWlnaHQgLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgIHZhciB4Uk1heCA9IE1hdGgubWluKGNvbnZJbmZvLmluSGVpZ2h0LCBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dFJvd09mZnNldCA9IG91dHB1dEJhdGNoT2Zmc2V0ICsgeVIgKiBvdXRwdXRSb3dTdHJpZGVzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0gMDsgeUMgPCBjb252SW5mby5vdXRXaWR0aDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIHN0cmlkZVdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbihjb252SW5mby5pbldpZHRoLCBlZmZlY3RpdmVGaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbk1heFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXZnVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyB4UiArPSBkaWxhdGlvbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhST2Zmc2V0ID0gaW5wdXRCYXRjaE9mZnNldCArIHhSICogc3RyaWRlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0geENNaW47IHhDIDwgeENNYXg7IHhDICs9IGRpbGF0aW9uV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENPZmZzZXQgPSB4Uk9mZnNldCArIHhDICogc3RyaWRlc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4VmFsdWVzW3hDT2Zmc2V0ICsgZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwb29sVHlwZSA9PT0gJ21heCcgJiYgcGl4ZWwgPiBtaW5NYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9vbFR5cGUgPT09ICdhdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Z1ZhbHVlICs9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW5NYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0T2Zmc2V0ID0gb3V0cHV0Um93T2Zmc2V0ICsgeUMgKiBvdXRwdXRDb2xTdHJpZGVzICsgZDtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0VmFsc1tvdXRwdXRPZmZzZXRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvb2xUeXBlID09PSAnYXZnJyA/IGF2Z1ZhbHVlIC8gY291bnQgOiBtaW5NYXhWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIG1heFBvb2xQb3NpdGlvbnMoeFZhbHVlcywgeFNoYXBlLCBkdHlwZSwgY29udkluZm8sIGZsYXR0ZW5Qb3NpdGlvbnMsIGluY2x1ZGVCYXRjaEluSW5kZXgpIHtcbiAgICBpZiAoZmxhdHRlblBvc2l0aW9ucyA9PT0gdm9pZCAwKSB7IGZsYXR0ZW5Qb3NpdGlvbnMgPSBmYWxzZTsgfVxuICAgIGlmIChpbmNsdWRlQmF0Y2hJbkluZGV4ID09PSB2b2lkIDApIHsgaW5jbHVkZUJhdGNoSW5JbmRleCA9IGZhbHNlOyB9XG4gICAgdmFyIG1heFBvc2l0aW9ucyA9IHRmanNDb3JlLmJ1ZmZlcihjb252SW5mby5vdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICB2YXIgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodDtcbiAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgdmFyIGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlckhlaWdodDtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJXaWR0aDtcbiAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgdmFyIHhCdWYgPSB0ZmpzQ29yZS5idWZmZXIoeFNoYXBlLCBkdHlwZSwgeFZhbHVlcyk7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgeVIgPSAwOyB5UiA8IGNvbnZJbmZvLm91dEhlaWdodDsgKyt5Uikge1xuICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogc3RyaWRlSGVpZ2h0IC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgIHdoaWxlICh4Uk1pbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeFJNaW4gKz0gZGlsYXRpb25IZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgIHZhciB4Uk1heCA9IE1hdGgubWluKGNvbnZJbmZvLmluSGVpZ2h0LCBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IGNvbnZJbmZvLm91dFdpZHRoOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogc3RyaWRlV2lkdGggLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHhDTWluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeENNaW4gKz0gZGlsYXRpb25XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbihjb252SW5mby5pbldpZHRoLCBlZmZlY3RpdmVGaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4UG9zaXRpb24gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgeFIgKz0gZGlsYXRpb25IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3UiA9IHhSIC0geFJDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyB4QyArPSBkaWxhdGlvbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdDID0geEMgLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4QnVmLmdldChiLCB4UiwgeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaXhlbCA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGF0dGVuUG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbiA9IGluY2x1ZGVCYXRjaEluSW5kZXggP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYiAqIGNvbnZJbmZvLmluSGVpZ2h0ICsgeFIpICogY29udkluZm8uaW5XaWR0aCArIHhDKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZJbmZvLmluQ2hhbm5lbHMgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeFIgKiBjb252SW5mby5pbldpZHRoICsgeEMpICogY29udkluZm8uaW5DaGFubmVscyArIGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbiA9IHdSICogZWZmZWN0aXZlRmlsdGVyV2lkdGggKyB3QztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbnMuc2V0KG1heFBvc2l0aW9uLCBiLCB5UiwgeUMsIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4UG9zaXRpb25zO1xufVxuZnVuY3Rpb24gcG9vbDNkKHhWYWx1ZXMsIHhTaGFwZSwgZHR5cGUsIHN0cmlkZXMsIGNvbnZJbmZvLCBwb29sVHlwZSkge1xuICAgIHZhciBzdHJpZGVEZXB0aCA9IGNvbnZJbmZvLnN0cmlkZURlcHRoO1xuICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgdmFyIGRpbGF0aW9uRGVwdGggPSBjb252SW5mby5kaWxhdGlvbkRlcHRoO1xuICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgIHZhciBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVyRGVwdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJEZXB0aDtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVySGVpZ2h0O1xuICAgIHZhciBlZmZlY3RpdmVGaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlcldpZHRoO1xuICAgIHZhciBwYWRGcm9udCA9IGNvbnZJbmZvLnBhZEluZm8uZnJvbnQ7XG4gICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgIHZhciBpbml0aWFsVmFsdWUgPSAocG9vbFR5cGUgPT09ICdtYXgnID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIDpcbiAgICAgICAgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICB2YXIgb3V0cHV0ID0gdGZqc0NvcmUuYnVmZmVyKGNvbnZJbmZvLm91dFNoYXBlLCBkdHlwZSk7XG4gICAgdmFyIG91dHB1dFZhbHMgPSBvdXRwdXQudmFsdWVzO1xuICAgIHZhciBvdXRwdXRCYXRjaFN0cmlkZXMgPSBjb252SW5mby5vdXRTaGFwZVsxXSAqIGNvbnZJbmZvLm91dFNoYXBlWzJdICpcbiAgICAgICAgY29udkluZm8ub3V0U2hhcGVbM10gKiBjb252SW5mby5vdXRTaGFwZVs0XTtcbiAgICB2YXIgb3V0cHV0RGVwdGhTdHJpZGVzID0gY29udkluZm8ub3V0U2hhcGVbMl0gKiBjb252SW5mby5vdXRTaGFwZVszXSAqIGNvbnZJbmZvLm91dFNoYXBlWzRdO1xuICAgIHZhciBvdXRwdXRSb3dTdHJpZGVzID0gY29udkluZm8ub3V0U2hhcGVbM10gKiBjb252SW5mby5vdXRTaGFwZVs0XTtcbiAgICB2YXIgb3V0cHV0Q29sU3RyaWRlcyA9IGNvbnZJbmZvLm91dFNoYXBlWzRdO1xuICAgIGZvciAodmFyIGJhdGNoID0gMDsgYmF0Y2ggPCBjb252SW5mby5iYXRjaFNpemU7ICsrYmF0Y2gpIHtcbiAgICAgICAgdmFyIG91dHB1dEJhdGNoT2Zmc2V0ID0gYmF0Y2ggKiBvdXRwdXRCYXRjaFN0cmlkZXM7XG4gICAgICAgIHZhciBpbnB1dEJhdGNoT2Zmc2V0ID0gYmF0Y2ggKiBzdHJpZGVzWzBdO1xuICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrY2hhbm5lbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgeURlcHRoID0gMDsgeURlcHRoIDwgY29udkluZm8ub3V0RGVwdGg7ICsreURlcHRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhEZXB0aENvcm5lciA9IHlEZXB0aCAqIHN0cmlkZURlcHRoIC0gcGFkRnJvbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHhEZXB0aE1pbiA9IHhEZXB0aENvcm5lcjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoeERlcHRoTWluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB4RGVwdGhNaW4gKz0gZGlsYXRpb25EZXB0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHhEZXB0aE1heCA9IE1hdGgubWluKGNvbnZJbmZvLmluRGVwdGgsIGVmZmVjdGl2ZUZpbHRlckRlcHRoICsgeERlcHRoQ29ybmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0RGVwdGhPZmZzZXQgPSBvdXRwdXRCYXRjaE9mZnNldCArIHlEZXB0aCAqIG91dHB1dERlcHRoU3RyaWRlcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5Um93ID0gMDsgeVJvdyA8IGNvbnZJbmZvLm91dEhlaWdodDsgKyt5Um93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Um93Q29ybmVyID0geVJvdyAqIHN0cmlkZUhlaWdodCAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSb3dNaW4gPSB4Um93Q29ybmVyO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoeFJvd01pbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhSb3dNaW4gKz0gZGlsYXRpb25IZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSb3dNYXggPSBNYXRoLm1pbihjb252SW5mby5pbkhlaWdodCwgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ICsgeFJvd0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRSb3dPZmZzZXQgPSBvdXRwdXREZXB0aE9mZnNldCArIHlSb3cgKiBvdXRwdXRSb3dTdHJpZGVzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5Q29sID0gMDsgeUNvbCA8IGNvbnZJbmZvLm91dFdpZHRoOyArK3lDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q29sQ29ybmVyID0geUNvbCAqIHN0cmlkZVdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q29sTWluID0geENvbENvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh4Q29sTWluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhDb2xNaW4gKz0gZGlsYXRpb25XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q29sTWF4ID0gTWF0aC5taW4oY29udkluZm8uaW5XaWR0aCwgZWZmZWN0aXZlRmlsdGVyV2lkdGggKyB4Q29sQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWRlciBjb2RlIGJlZ2luc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dENvbE9mZnNldCA9IG91dHB1dFJvd09mZnNldCArIHlDb2wgKiBvdXRwdXRDb2xTdHJpZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbk1heFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF2Z1ZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4RGVwdGggPSB4RGVwdGhNaW47IHhEZXB0aCA8IHhEZXB0aE1heDsgeERlcHRoICs9IGRpbGF0aW9uRGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeERlcHRoT2Zmc2V0ID0gaW5wdXRCYXRjaE9mZnNldCArIHhEZXB0aCAqIHN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeFJvdyA9IHhSb3dNaW47IHhSb3cgPCB4Um93TWF4OyB4Um93ICs9IGRpbGF0aW9uSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Um93T2Zmc2V0ID0geERlcHRoT2Zmc2V0ICsgeFJvdyAqIHN0cmlkZXNbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDb2wgPSB4Q29sTWluOyB4Q29sIDwgeENvbE1heDsgeENvbCArPSBkaWxhdGlvbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENvbE9mZnNldCA9IHhSb3dPZmZzZXQgKyB4Q29sICogc3RyaWRlc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHhWYWx1ZXNbeENvbE9mZnNldCArIGNoYW5uZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwb29sVHlwZSA9PT0gJ21heCcgJiYgcGl4ZWwgPiBtaW5NYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9vbFR5cGUgPT09ICdhdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZnVmFsdWUgKz0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW5NYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obWluTWF4VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obWluTWF4VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRPZmZzZXQgPSBvdXRwdXRDb2xPZmZzZXQgKyBjaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VmFsc1tvdXRwdXRPZmZzZXRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb29sVHlwZSA9PT0gJ2F2ZycgPyBhdmdWYWx1ZSAvIGNvdW50IDogbWluTWF4VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIG1heFBvb2wzZFBvc2l0aW9ucyh4QnVmLCBjb252SW5mbykge1xuICAgIHZhciBtYXhQb3NpdGlvbnMgPSB0ZmpzQ29yZS5idWZmZXIoY29udkluZm8ub3V0U2hhcGUsICdpbnQzMicpO1xuICAgIHZhciBzdHJpZGVEZXB0aCA9IGNvbnZJbmZvLnN0cmlkZURlcHRoO1xuICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgdmFyIGRpbGF0aW9uRGVwdGggPSBjb252SW5mby5kaWxhdGlvbkRlcHRoO1xuICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgIHZhciBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVyRGVwdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJEZXB0aDtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVySGVpZ2h0O1xuICAgIHZhciBlZmZlY3RpdmVGaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlcldpZHRoO1xuICAgIHZhciBwYWRGcm9udCA9IGNvbnZJbmZvLnBhZEluZm8uZnJvbnQ7XG4gICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgIGZvciAodmFyIGJhdGNoID0gMDsgYmF0Y2ggPCBjb252SW5mby5iYXRjaFNpemU7ICsrYmF0Y2gpIHtcbiAgICAgICAgZm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBjb252SW5mby5pbkNoYW5uZWxzOyArK2NoYW5uZWwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHlEZXB0aCA9IDA7IHlEZXB0aCA8IGNvbnZJbmZvLm91dERlcHRoOyArK3lEZXB0aCkge1xuICAgICAgICAgICAgICAgIHZhciB4RGVwdGhDb3JuZXIgPSB5RGVwdGggKiBzdHJpZGVEZXB0aCAtIHBhZEZyb250O1xuICAgICAgICAgICAgICAgIHZhciB4RGVwdGhNaW4gPSB4RGVwdGhDb3JuZXI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHhEZXB0aE1pbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeERlcHRoTWluICs9IGRpbGF0aW9uRGVwdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB4RGVwdGhNYXggPSBNYXRoLm1pbihjb252SW5mby5pbkRlcHRoLCBlZmZlY3RpdmVGaWx0ZXJEZXB0aCArIHhEZXB0aENvcm5lcik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeVJvdyA9IDA7IHlSb3cgPCBjb252SW5mby5vdXRIZWlnaHQ7ICsreVJvdykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJvd0Nvcm5lciA9IHlSb3cgKiBzdHJpZGVIZWlnaHQgLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Um93TWluID0geFJvd0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHhSb3dNaW4gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4Um93TWluICs9IGRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Um93TWF4ID0gTWF0aC5taW4oY29udkluZm8uaW5IZWlnaHQsIGVmZmVjdGl2ZUZpbHRlckhlaWdodCArIHhSb3dDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5Q29sID0gMDsgeUNvbCA8IGNvbnZJbmZvLm91dFdpZHRoOyArK3lDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q29sQ29ybmVyID0geUNvbCAqIHN0cmlkZVdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q29sTWluID0geENvbENvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh4Q29sTWluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhDb2xNaW4gKz0gZGlsYXRpb25XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q29sTWF4ID0gTWF0aC5taW4oY29udkluZm8uaW5XaWR0aCwgZWZmZWN0aXZlRmlsdGVyV2lkdGggKyB4Q29sQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWRlciBjb2RlIGJlZ2luc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFBvc2l0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4RGVwdGggPSB4RGVwdGhNaW47IHhEZXB0aCA8IHhEZXB0aE1heDsgeERlcHRoICs9IGRpbGF0aW9uRGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0RlcHRoID0geERlcHRoIC0geERlcHRoQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhSb3cgPSB4Um93TWluOyB4Um93IDwgeFJvd01heDsgeFJvdyArPSBkaWxhdGlvbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1JvdyA9IHhSb3cgLSB4Um93Q29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4Q29sID0geENvbE1pbjsgeENvbCA8IHhDb2xNYXg7IHhDb2wgKz0gZGlsYXRpb25XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdDb2wgPSB4Q29sIC0geENvbENvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHhCdWYuZ2V0KGJhdGNoLCB4RGVwdGgsIHhSb3csIHhDb2wsIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpeGVsID49IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdEZXB0aCAqIGVmZmVjdGl2ZUZpbHRlckhlaWdodCAqIGVmZmVjdGl2ZUZpbHRlcldpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdSb3cgKiBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgKyB3Q29sO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UG9zaXRpb25zLnNldChtYXhQb3NpdGlvbiwgYmF0Y2gsIHlEZXB0aCwgeVJvdywgeUNvbCwgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heFBvc2l0aW9ucztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gYXZnUG9vbChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICdhdmdQb29sJyk7XG4gICAgdmFyIGZpbHRlclNpemUgPSBhdHRycy5maWx0ZXJTaXplLCBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBkaW1Sb3VuZGluZ01vZGUgPSBhdHRycy5kaW1Sb3VuZGluZ01vZGU7XG4gICAgdmFyIGRpbGF0aW9ucyA9IDE7XG4gICAgdGZqc0NvcmUudXRpbC5hc3NlcnQodGZqc0NvcmUuYmFja2VuZF91dGlsLmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShzdHJpZGVzLCBkaWxhdGlvbnMpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnRXJyb3IgaW4gYXZnUG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gJyArXG4gICAgICAgIChcIkdvdCBzdHJpZGVzIFwiICsgc3RyaWRlcyArIFwiIGFuZCBkaWxhdGlvbnMgJ1wiICsgZGlsYXRpb25zICsgXCInXCIpOyB9KTtcbiAgICB2YXIgY29udkluZm8gPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY29tcHV0ZVBvb2wyREluZm8oeC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoY29udkluZm8uZmlsdGVyV2lkdGggPT09IDEgJiYgY29udkluZm8uZmlsdGVySGVpZ2h0ID09PSAxICYmXG4gICAgICAgIHRmanNDb3JlLnV0aWwuYXJyYXlzRXF1YWwoY29udkluZm8uaW5TaGFwZSwgY29udkluZm8ub3V0U2hhcGUpKSB7XG4gICAgICAgIHJlcyA9IGlkZW50aXR5KHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB4VmFsdWVzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgICAgICB2YXIgc3RyaWRlc18xID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyh4LnNoYXBlKTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHBvb2woeFZhbHVlcywgeC5zaGFwZSwgeC5kdHlwZSwgc3RyaWRlc18xLCBjb252SW5mbywgJ2F2ZycpO1xuICAgICAgICByZXMgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKGNvbnZJbmZvLm91dFNoYXBlLCB4LmR0eXBlLCBidWZmZXIudmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbnZhciBhdmdQb29sQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkF2Z1Bvb2wsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGF2Z1Bvb2xcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGF2Z1Bvb2wzRChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGF0dHJzLmZpbHRlclNpemUsIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZSwgZGF0YUZvcm1hdCA9IGF0dHJzLmRhdGFGb3JtYXQsIGRpbGF0aW9ucyA9IGF0dHJzLmRpbGF0aW9ucztcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICdhdmdQb29sM2QnKTtcbiAgICB2YXIgJGRpbGF0aW9ucyA9IGRpbGF0aW9ucztcbiAgICBpZiAoJGRpbGF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICRkaWxhdGlvbnMgPSBbMSwgMSwgMV07XG4gICAgfVxuICAgIHZhciBjb252SW5mbyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlUG9vbDNESW5mbyh4LnNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCAkZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSwgZGF0YUZvcm1hdCk7XG4gICAgdmFyIHhWYWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIG91dEJ1ZiA9IHBvb2wzZCh4VmFsdWVzLCB4LnNoYXBlLCB4LmR0eXBlLCB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKHguc2hhcGUpLCBjb252SW5mbywgJ2F2ZycpO1xuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dEJ1Zi5zaGFwZSwgJ2Zsb2F0MzInLCBvdXRCdWYudmFsdWVzKTtcbn1cbnZhciBhdmdQb29sM0RDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQXZnUG9vbDNELFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBhdmdQb29sM0Rcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGF2Z1Bvb2wzREdyYWQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBkeSA9IGlucHV0cy5keSwgaW5wdXQgPSBpbnB1dHMuaW5wdXQ7XG4gICAgdmFyIGZpbHRlclNpemUgPSBhdHRycy5maWx0ZXJTaXplLCBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBkaWxhdGlvbnMgPSBhdHRycy5kaWxhdGlvbnMsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZTtcbiAgICBhc3NlcnROb3RDb21wbGV4KFtkeSwgaW5wdXRdLCAnYXZnUG9vbDNER3JhZCcpO1xuICAgIHZhciBjb252SW5mbyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlUG9vbDNESW5mbyhpbnB1dC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgdmFyIHN0cmlkZURlcHRoID0gY29udkluZm8uc3RyaWRlRGVwdGg7XG4gICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICB2YXIgZmlsdGVyRGVwdGggPSBjb252SW5mby5maWx0ZXJEZXB0aDtcbiAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgIHZhciBkaWxhdGlvbkRlcHRoID0gY29udkluZm8uZGlsYXRpb25EZXB0aDtcbiAgICB2YXIgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodDtcbiAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgdmFyIGVmZmVjdGl2ZUZpbHRlckRlcHRoID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVyRGVwdGg7XG4gICAgdmFyIGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlckhlaWdodDtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJXaWR0aDtcbiAgICB2YXIgcGFkRnJvbnQgPSBlZmZlY3RpdmVGaWx0ZXJEZXB0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmZyb250O1xuICAgIHZhciBwYWRMZWZ0ID0gZWZmZWN0aXZlRmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgIHZhciBwYWRUb3AgPSBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgdmFyIGR4ID0gdGZqc0NvcmUuYnVmZmVyKGlucHV0LnNoYXBlLCAnZmxvYXQzMicpO1xuICAgIHZhciBhdmdNdWx0aXBsaWVyID0gMSAvIChmaWx0ZXJEZXB0aCAqIGZpbHRlckhlaWdodCAqIGZpbHRlcldpZHRoKTtcbiAgICB2YXIgZHlCdWYgPSBiYWNrZW5kLmJ1ZmZlclN5bmMoZHkpO1xuICAgIGZvciAodmFyIGJhdGNoID0gMDsgYmF0Y2ggPCBjb252SW5mby5iYXRjaFNpemU7ICsrYmF0Y2gpIHtcbiAgICAgICAgZm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBjb252SW5mby5pbkNoYW5uZWxzOyArK2NoYW5uZWwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGR4RGVwdGggPSAwOyBkeERlcHRoIDwgY29udkluZm8uaW5EZXB0aDsgKytkeERlcHRoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZHhSb3cgPSAwOyBkeFJvdyA8IGNvbnZJbmZvLmluSGVpZ2h0OyArK2R4Um93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGR4Q29sID0gMDsgZHhDb2wgPCBjb252SW5mby5pbldpZHRoOyArK2R4Q29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGFkZXIgY29kZSBiZWdpbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlEZXB0aENvcm5lciA9IGR4RGVwdGggLSBwYWRGcm9udDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeVJvd0Nvcm5lciA9IGR4Um93IC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5Q29sQ29ybmVyID0gZHhDb2wgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0RlcHRoID0gMDsgd0RlcHRoIDwgZWZmZWN0aXZlRmlsdGVyRGVwdGg7IHdEZXB0aCArPSBkaWxhdGlvbkRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5RGVwdGggPSAoZHlEZXB0aENvcm5lciArIHdEZXB0aCkgLyBzdHJpZGVEZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHlEZXB0aCA8IDAgfHwgZHlEZXB0aCA+PSBjb252SW5mby5vdXREZXB0aCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGR5RGVwdGgpICE9PSBkeURlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3Um93ID0gMDsgd1JvdyA8IGVmZmVjdGl2ZUZpbHRlckhlaWdodDsgd1JvdyArPSBkaWxhdGlvbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlSb3cgPSAoZHlSb3dDb3JuZXIgKyB3Um93KSAvIHN0cmlkZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5Um93IDwgMCB8fCBkeVJvdyA+PSBjb252SW5mby5vdXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZHlSb3cpICE9PSBkeVJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0NvbCA9IDA7IHdDb2wgPCBlZmZlY3RpdmVGaWx0ZXJXaWR0aDsgd0NvbCArPSBkaWxhdGlvbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlDb2wgPSAoZHlDb2xDb3JuZXIgKyB3Q29sKSAvIHN0cmlkZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5Q29sIDwgMCB8fCBkeUNvbCA+PSBjb252SW5mby5vdXRXaWR0aCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZHlDb2wpICE9PSBkeUNvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gZHlCdWYuZ2V0KGJhdGNoLCBkeURlcHRoLCBkeVJvdywgZHlDb2wsIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGR4LnNldChkb3RQcm9kICogYXZnTXVsdGlwbGllciwgYmF0Y2gsIGR4RGVwdGgsIGR4Um93LCBkeENvbCwgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oZHguc2hhcGUsIGR4LmR0eXBlLCBkeC52YWx1ZXMpO1xufVxudmFyIGF2Z1Bvb2wzREdyYWRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQXZnUG9vbDNER3JhZCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogYXZnUG9vbDNER3JhZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gYXZnUG9vbEdyYWQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBkeSA9IGlucHV0cy5keSwgaW5wdXQgPSBpbnB1dHMuaW5wdXQ7XG4gICAgdmFyIHggPSBpbnB1dDtcbiAgICBhc3NlcnROb3RDb21wbGV4KFtkeSwgaW5wdXRdLCAnYXZnUG9vbEdyYWQnKTtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGF0dHJzLmZpbHRlclNpemUsIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQ7XG4gICAgdmFyIGNvbnZJbmZvID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmNvbXB1dGVQb29sMkRJbmZvKHguc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIDEgLyogZGlsYXRpb25zICovLCBwYWQpO1xuICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICB2YXIgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodDtcbiAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgdmFyIGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlckhlaWdodDtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJXaWR0aDtcbiAgICB2YXIgcGFkTGVmdCA9IGVmZmVjdGl2ZUZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICB2YXIgcGFkVG9wID0gZWZmZWN0aXZlRmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIHZhciBkeCA9IHRmanNDb3JlLmJ1ZmZlcih4LnNoYXBlLCAnZmxvYXQzMicpO1xuICAgIHZhciBhdmdNdWx0aXBsaWVyID0gMSAvIChmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCk7XG4gICAgdmFyIGR5RGF0YSA9IGJhY2tlbmQuZGF0YS5nZXQoZHkuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIGR5QnVmID0gdGZqc0NvcmUuYnVmZmVyKGR5LnNoYXBlLCAnZmxvYXQzMicsIGR5RGF0YSk7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZHhSID0gMDsgZHhSIDwgY29udkluZm8uaW5IZWlnaHQ7ICsrZHhSKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZHhDID0gMDsgZHhDIDwgY29udkluZm8uaW5XaWR0aDsgKytkeEMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hhZGVyIGNvZGUgYmVnaW5zLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZHlSQ29ybmVyID0gZHhSIC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHlDQ29ybmVyID0gZHhDIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZWZmZWN0aXZlRmlsdGVySGVpZ2h0OyB3UiArPSBkaWxhdGlvbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UiA9IChkeVJDb3JuZXIgKyB3UikgLyBzdHJpZGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gY29udkluZm8ub3V0SGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkeVIpICE9PSBkeVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBlZmZlY3RpdmVGaWx0ZXJXaWR0aDsgd0MgKz0gZGlsYXRpb25XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUMgPSAoZHlDQ29ybmVyICsgd0MpIC8gc3RyaWRlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IGNvbnZJbmZvLm91dFdpZHRoIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZHlDKSAhPT0gZHlDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBkeUJ1Zi5nZXQoYiwgZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHguc2V0KGRvdFByb2QgKiBhdmdNdWx0aXBsaWVyLCBiLCBkeFIsIGR4QywgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKGR4LnNoYXBlLCBkeC5kdHlwZSwgZHgudmFsdWVzKTtcbn1cbnZhciBhdmdQb29sR3JhZENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5BdmdQb29sR3JhZCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogYXZnUG9vbEdyYWRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGJhdGNoTm9ybShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueCwgc2NhbGUgPSBpbnB1dHMuc2NhbGUsIG9mZnNldCA9IGlucHV0cy5vZmZzZXQsIG1lYW4gPSBpbnB1dHMubWVhbiwgdmFyaWFuY2UgPSBpbnB1dHMudmFyaWFuY2U7XG4gICAgdGZqc0NvcmUudXRpbC5hc3NlcnQobWVhbi5zaGFwZS5sZW5ndGggPT09IHZhcmlhbmNlLnNoYXBlLmxlbmd0aCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0JhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgdmFyaWFuY2UgdG8gaGF2ZSAnICtcbiAgICAgICAgJ2VxdWFsIHJhbmtzLic7IH0pO1xuICAgIHRmanNDb3JlLnV0aWwuYXNzZXJ0KG9mZnNldCA9PSBudWxsIHx8IG1lYW4uc2hhcGUubGVuZ3RoID09PSBvZmZzZXQuc2hhcGUubGVuZ3RoLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBvZmZzZXQgdG8gaGF2ZSAnICtcbiAgICAgICAgJ2VxdWFsIHJhbmtzLic7IH0pO1xuICAgIHRmanNDb3JlLnV0aWwuYXNzZXJ0KHNjYWxlID09IG51bGwgfHwgbWVhbi5zaGFwZS5sZW5ndGggPT09IHNjYWxlLnNoYXBlLmxlbmd0aCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0JhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgc2NhbGUgdG8gaGF2ZSAnICtcbiAgICAgICAgJ2VxdWFsIHJhbmtzLic7IH0pO1xuICAgIGFzc2VydE5vdENvbXBsZXgoW3gsIG1lYW4sIHZhcmlhbmNlLCBzY2FsZSwgb2Zmc2V0XSwgJ2JhdGNoTm9ybScpO1xuICAgIHZhciB2YXJpYW5jZUVwc2lsb24gPSBhdHRycy52YXJpYW5jZUVwc2lsb247XG4gICAgaWYgKHZhcmlhbmNlRXBzaWxvbiA9PSBudWxsKSB7XG4gICAgICAgIHZhcmlhbmNlRXBzaWxvbiA9IDAuMDAxO1xuICAgIH1cbiAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIG1WYWxzID0gYmFja2VuZC5kYXRhLmdldChtZWFuLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciB2YXJWYWxzID0gYmFja2VuZC5kYXRhLmdldCh2YXJpYW5jZS5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgc1ZhbHMgPSBzY2FsZSA/IGJhY2tlbmQuZGF0YS5nZXQoc2NhbGUuZGF0YUlkKS52YWx1ZXMgOlxuICAgICAgICBuZXcgRmxvYXQzMkFycmF5KFsxXSk7XG4gICAgdmFyIG9mZlZhbHMgPSBvZmZzZXQgP1xuICAgICAgICBiYWNrZW5kLmRhdGEuZ2V0KG9mZnNldC5kYXRhSWQpLnZhbHVlcyA6XG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoWzBdKTtcbiAgICB2YXIgb3V0VmFscyA9IG5ldyBGbG9hdDMyQXJyYXkoeFZhbHMubGVuZ3RoKTtcbiAgICB2YXIgb2ZmVmFsc0xlbmd0aCA9IG9mZlZhbHMubGVuZ3RoO1xuICAgIHZhciBzVmFsc0xlbmd0aCA9IHNWYWxzLmxlbmd0aDtcbiAgICB2YXIgdmFyVmFsc0xlbmd0aCA9IHZhclZhbHMubGVuZ3RoO1xuICAgIHZhciBtVmFsc0xlbmd0aCA9IG1WYWxzLmxlbmd0aDtcbiAgICB2YXIgb2ZmaSA9IDA7XG4gICAgdmFyIG1pID0gMDtcbiAgICB2YXIgc2kgPSAwO1xuICAgIHZhciB2aSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4VmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICBvdXRWYWxzW2ldID0gb2ZmVmFsc1tvZmZpKytdICtcbiAgICAgICAgICAgICh4VmFsc1tpXSAtIG1WYWxzW21pKytdKSAqIHNWYWxzW3NpKytdIC9cbiAgICAgICAgICAgICAgICBNYXRoLnNxcnQodmFyVmFsc1t2aSsrXSArIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgICAgIGlmIChvZmZpID49IG9mZlZhbHNMZW5ndGgpIHtcbiAgICAgICAgICAgIG9mZmkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaSA+PSBtVmFsc0xlbmd0aCkge1xuICAgICAgICAgICAgbWkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaSA+PSBzVmFsc0xlbmd0aCkge1xuICAgICAgICAgICAgc2kgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aSA+PSB2YXJWYWxzTGVuZ3RoKSB7XG4gICAgICAgICAgICB2aSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oeC5zaGFwZSwgeC5kdHlwZSwgb3V0VmFscyk7XG59XG52YXIgYmF0Y2hOb3JtQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkZ1c2VkQmF0Y2hOb3JtLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBiYXRjaE5vcm0sXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBiYXRjaFRvU3BhY2VORChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgYmxvY2tTaGFwZSA9IGF0dHJzLmJsb2NrU2hhcGUsIGNyb3BzID0gYXR0cnMuY3JvcHM7XG4gICAgYXNzZXJ0Tm90Q29tcGxleChbeF0sICdiYXRjaFRvU3BhY2VORCcpO1xuICAgIHZhciBwcm9kID0gYmxvY2tTaGFwZS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKiBiOyB9KTtcbiAgICB2YXIgcmVzaGFwZWQgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0UmVzaGFwZWQoeC5zaGFwZSwgYmxvY2tTaGFwZSwgcHJvZCk7XG4gICAgdmFyIHBlcm11dGVkID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmdldFBlcm11dGVkKHJlc2hhcGVkLmxlbmd0aCwgYmxvY2tTaGFwZS5sZW5ndGgpO1xuICAgIHZhciByZXNoYXBlZFBlcm11dGVkID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmdldFJlc2hhcGVkUGVybXV0ZWQoeC5zaGFwZSwgYmxvY2tTaGFwZSwgcHJvZCk7XG4gICAgdmFyIHNsaWNlQmVnaW5Db29yZHMgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0U2xpY2VCZWdpbkNvb3Jkcyhjcm9wcywgYmxvY2tTaGFwZS5sZW5ndGgpO1xuICAgIHZhciBzbGljZVNpemUgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0U2xpY2VTaXplKHJlc2hhcGVkUGVybXV0ZWQsIGNyb3BzLCBibG9ja1NoYXBlLmxlbmd0aCk7XG4gICAgdmFyIHhSZXNoYXBlZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogcmVzaGFwZWQgfSB9KTtcbiAgICB2YXIgeFRyYW5zcG9zZWQgPSB0cmFuc3Bvc2UoeyBpbnB1dHM6IHsgeDogeFJlc2hhcGVkIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHBlcm06IHBlcm11dGVkIH0gfSk7XG4gICAgdmFyIHhUcmFuc3Bvc2VkUmVzaGFwZWQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHhUcmFuc3Bvc2VkIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiByZXNoYXBlZFBlcm11dGVkIH0gfSk7XG4gICAgdmFyIHJlc3VsdCA9IHNsaWNlKHtcbiAgICAgICAgaW5wdXRzOiB7IHg6IHhUcmFuc3Bvc2VkUmVzaGFwZWQgfSxcbiAgICAgICAgYmFja2VuZDogYmFja2VuZCxcbiAgICAgICAgYXR0cnM6IHsgYmVnaW46IHNsaWNlQmVnaW5Db29yZHMsIHNpemU6IHNsaWNlU2l6ZSB9XG4gICAgfSk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh4UmVzaGFwZWQpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oeFRyYW5zcG9zZWQpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oeFRyYW5zcG9zZWRSZXNoYXBlZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBiYXRjaFRvU3BhY2VORENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5CYXRjaFRvU3BhY2VORCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogYmF0Y2hUb1NwYWNlTkRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGJpbmNvdW50KGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54LCB3ZWlnaHRzID0gaW5wdXRzLndlaWdodHM7XG4gICAgdmFyIHNpemUgPSBhdHRycy5zaXplO1xuICAgIHZhciB4VmFscyA9IGJhY2tlbmQuZGF0YS5nZXQoeC5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgd2VpZ2h0c1ZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHdlaWdodHMuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIG91dFZhbHMgPSBiaW5jb3VudEltcGwoeFZhbHMsIHdlaWdodHNWYWxzLCB3ZWlnaHRzLmR0eXBlLCB3ZWlnaHRzLnNoYXBlLCBzaXplKTtcbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhbc2l6ZV0sIHdlaWdodHMuZHR5cGUsIG91dFZhbHMpO1xufVxudmFyIGJpbmNvdW50Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkJpbmNvdW50LFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBiaW5jb3VudFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBjbGlwID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLkNsaXBCeVZhbHVlLCBmdW5jdGlvbiAoeGksIGF0dHJzKSB7XG4gICAgdmFyIGNsaXBBdHRycyA9IGF0dHJzO1xuICAgIGlmICh4aSA+IGNsaXBBdHRycy5jbGlwVmFsdWVNYXgpIHtcbiAgICAgICAgcmV0dXJuIGNsaXBBdHRycy5jbGlwVmFsdWVNYXg7XG4gICAgfVxuICAgIHJldHVybiB4aSA8IGNsaXBBdHRycy5jbGlwVmFsdWVNaW4gPyBjbGlwQXR0cnMuY2xpcFZhbHVlTWluIDogeGk7XG59KTtcbnZhciBjbGlwQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkNsaXBCeVZhbHVlLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBjbGlwLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBjb21wbGV4QWJzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgeCA9IGFyZ3MuaW5wdXRzLng7XG4gICAgdmFyIGNwdUJhY2tlbmQgPSBhcmdzLmJhY2tlbmQ7XG4gICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKHguc2hhcGUpKTtcbiAgICB2YXIgY29tcGxleFZhbHMgPSBjcHVCYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKTtcbiAgICB2YXIgcmVhbCA9IGNvbXBsZXhWYWxzLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsO1xuICAgIHZhciBpbWFnID0gY29tcGxleFZhbHMuY29tcGxleFRlbnNvckluZm9zLmltYWc7XG4gICAgdmFyIHJlYWxWYWxzID0gY3B1QmFja2VuZC5kYXRhLmdldChyZWFsLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBpbWFnVmFscyA9IGNwdUJhY2tlbmQuZGF0YS5nZXQoaW1hZy5kYXRhSWQpLnZhbHVlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlYWxWYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZWFsXzEgPSByZWFsVmFsc1tpXTtcbiAgICAgICAgdmFyIGltYWdfMSA9IGltYWdWYWxzW2ldO1xuICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmh5cG90KHJlYWxfMSwgaW1hZ18xKTtcbiAgICB9XG4gICAgcmV0dXJuIGNwdUJhY2tlbmQubWFrZU91dHB1dChyZXN1bHRWYWx1ZXMsIHguc2hhcGUsICdmbG9hdDMyJyk7XG59O1xudmFyIGNvbXBsZXhBYnNDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQ29tcGxleEFicyxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogY29tcGxleEFicyxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGltYWcoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgaW5wdXQgPSBpbnB1dHMuaW5wdXQ7XG4gICAgdmFyIGltYWcgPSBiYWNrZW5kLmRhdGEuZ2V0KGlucHV0LmRhdGFJZCkuY29tcGxleFRlbnNvckluZm9zLmltYWc7XG4gICAgdmFyIGltYWdWYWwgPSBiYWNrZW5kLmRhdGEuZ2V0KGltYWcuZGF0YUlkKS52YWx1ZXM7XG4gICAgLy8gV2hlbiBjb21wbGV4IHRlbnNvciBpcyBkaXNwb3NlZCwgaXRzIHVuZGVybHlpbmcgcGFydHMgd2lsbCBiZSBkaXNwb3NlZCB0b28uXG4gICAgLy8gTWFrZSBuZXcgdGVuc29yIG91dCBvZiB0aGUgaW1hZyB2YWx1ZSBvZiB0aGUgY29tcGxleC4gVGhpcyBtYWtlcyBzdXJlIHRoZVxuICAgIC8vIHZhbHVlIGlzIHN0aWxsIGFjY2Vzc2libGUgZXZlbiBpZiBjb21wbGV4IHRlbnNvciBpcyBkaXNwb3NlZC5cbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhpbWFnLnNoYXBlLCBpbWFnLmR0eXBlLCBpbWFnVmFsKTtcbn1cbnZhciBpbWFnQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkltYWcsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGltYWdcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGF4aXMgPSBhdHRycy5heGlzO1xuICAgIHZhciAkYXhpcyA9IHRmanNDb3JlLnV0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgaW5wdXRzWzBdLnNoYXBlKVswXTtcbiAgICB2YXIgb3V0U2hhcGUgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY29tcHV0ZU91dFNoYXBlKGlucHV0cy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuc2hhcGU7IH0pLCAkYXhpcyk7XG4gICAgaWYgKHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShvdXRTaGFwZSkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8ob3V0U2hhcGUsIGlucHV0c1swXS5kdHlwZSwgW10pO1xuICAgIH1cbiAgICAvLyBLZWVwIG9ubHkgbm9uLWVtcHR5IHRlbnNvcnMgKGlnbm9yZSB0ZW5zb3JzIHdpdGggMCBpbiB0aGVpciBzaGFwZSkuXG4gICAgdmFyICRpbnB1dHMgPSBpbnB1dHMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUodC5zaGFwZSkgPiAwOyB9KTtcbiAgICBpZiAoJGlucHV0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KHsgaW5wdXRzOiB7IHg6ICRpbnB1dHNbMF0gfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB9XG4gICAgdmFyIHNoYXBlcyA9ICRpbnB1dHMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnNoYXBlOyB9KTtcbiAgICB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuYXNzZXJ0UGFyYW1zQ29uc2lzdGVudChzaGFwZXMsICRheGlzKTtcbiAgICBpZiAoJGlucHV0c1swXS5kdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgICAgdmFyIHJlYWxzID0gJGlucHV0cy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHJlYWwoeyBpbnB1dHM6IHsgaW5wdXQ6IHQgfSwgYmFja2VuZDogYmFja2VuZCB9KTsgfSk7XG4gICAgICAgIHZhciBpbWFncyA9ICRpbnB1dHMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBpbWFnKHsgaW5wdXRzOiB7IGlucHV0OiB0IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7IH0pO1xuICAgICAgICB2YXIgcmVhbENvbmNhdGVkID0gY29uY2F0KHsgaW5wdXRzOiByZWFscywgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgYXhpczogJGF4aXMgfSB9KTtcbiAgICAgICAgdmFyIGltYWdDb25jYXRlZCA9IGNvbmNhdCh7IGlucHV0czogaW1hZ3MsIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGF4aXM6ICRheGlzIH0gfSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wbGV4KHsgaW5wdXRzOiB7IHJlYWw6IHJlYWxDb25jYXRlZCwgaW1hZzogaW1hZ0NvbmNhdGVkIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIHJlYWxzLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgcmV0dXJuIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocik7IH0pO1xuICAgICAgICBpbWFncy5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7IHJldHVybiBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGkpOyB9KTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyZWFsQ29uY2F0ZWQpO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGltYWdDb25jYXRlZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEFueSBjb25jYXQgb2Ygbi1kaW1lbnNpb25hbCB0ZW5zb3JzIGFjcm9zcyBhbnkgYXhpcyBjYW4gYmUgcmVkdWNlZCB0b1xuICAgIC8vIGEgY29uY2F0ZW5hdGlvbiBvZiB0d28tZGltZW5zaW9uYWwgdGVuc29ycyBhY3Jvc3MgdGhlIGF4aXMgMSBieSBmaXJzdFxuICAgIC8vIHBhcnRpdGlvbmluZyB0aGUgYXhlcyBvZiB0aGUgb3JpZ2luYWwgdGVuc29ycyBpbnRvIHRob3NlIGxlc3MgdGhhbiB0aGVcbiAgICAvLyBheGlzIHRvIGJlIGNvbmNhdGVuYXRlZCBhbmQgdGhlIHJlc3QuIFRoZW4gcmVzaGFwZSB0aGUgdGVuc29yc1xuICAgIC8vIGludG8gYSB0d28tZGltZW5zaW9uYWwgdGVuc29yIGJ5IGNvbGxhcHNpbmcgdGhlc2UgdHdvIHNldHMgb2YgYXhlcyBhbmRcbiAgICAvLyBjb25jYXRlbmF0ZSB0aGUgcmVzdWx0aW5nIG1hdHJpY2VzIGFjcm9zcyB0aGUgYXhpcyAxLCBmaW5hbGx5IHJlc2hhcGluZ1xuICAgIC8vIHRoZSByZXN1bHQgdG8gaGF2ZSB0aGUgcHJvcGVyIHNoYXBlLlxuICAgIHZhciBpbnB1dHMyRCA9ICRpbnB1dHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBpbm5lclNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUodC5zaGFwZS5zbGljZSgkYXhpcykpO1xuICAgICAgICB2YXIgc2hhcGUgPSBbLTEsIGlubmVyU2l6ZV07XG4gICAgICAgIHJldHVybiByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IHNoYXBlIH0gfSk7XG4gICAgfSk7XG4gICAgdmFyIGlucHV0c1ZhbFNoYXBlcyA9IGlucHV0czJELm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4geyB2YWxzOiBiYWNrZW5kLmRhdGEuZ2V0KHQuZGF0YUlkKS52YWx1ZXMsIHNoYXBlOiB0LnNoYXBlIH07XG4gICAgfSk7XG4gICAgLy8gQ29uY2F0cyAyZCB0ZW5zb3JzIGFsb25nIGF4aXM9MS5cbiAgICBvdXRTaGFwZSA9XG4gICAgICAgIHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlT3V0U2hhcGUoaW5wdXRzMkQubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnNoYXBlOyB9KSwgMSAvKiBheGlzICovKTtcbiAgICB2YXIgc2ltcGx5Q29uY2F0ID0gaW5wdXRzMkRbMF0uc2hhcGVbMF0gPT09IDE7XG4gICAgdmFyIG91dFZhbHMgPSBjb25jYXRJbXBsKGlucHV0c1ZhbFNoYXBlcywgb3V0U2hhcGUsIGlucHV0c1swXS5kdHlwZSwgc2ltcGx5Q29uY2F0KTtcbiAgICB2YXIgZmluYWxPdXRTaGFwZSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlT3V0U2hhcGUoJGlucHV0cy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuc2hhcGU7IH0pLCAkYXhpcyk7XG4gICAgdmFyIG91dEluZm8gPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKGZpbmFsT3V0U2hhcGUsIGlucHV0c1swXS5kdHlwZSwgb3V0VmFscyk7XG4gICAgaW5wdXRzMkQuZm9yRWFjaChmdW5jdGlvbiAodCkgeyByZXR1cm4gYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh0KTsgfSk7XG4gICAgcmV0dXJuIG91dEluZm87XG59XG52YXIgY29uY2F0Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkNvbmNhdCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogY29uY2F0XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBjb252MkQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLngsIGZpbHRlciA9IGlucHV0cy5maWx0ZXI7XG4gICAgdmFyIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGRhdGFGb3JtYXQgPSBhdHRycy5kYXRhRm9ybWF0LCBkaWxhdGlvbnMgPSBhdHRycy5kaWxhdGlvbnMsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZTtcbiAgICBhc3NlcnROb3RDb21wbGV4KFt4LCBmaWx0ZXJdLCAnY29udjJkJyk7XG4gICAgdmFyICRkYXRhRm9ybWF0ID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmNvbnZlcnRDb252MkREYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgIHZhciBjb252SW5mbyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4LnNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkLCBkaW1Sb3VuZGluZ01vZGUsIGZhbHNlIC8qIGRlcHRod2lzZSAqLywgJGRhdGFGb3JtYXQpO1xuICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgdmFyIGRpbGF0aW9uSGVpZ2h0ID0gY29udkluZm8uZGlsYXRpb25IZWlnaHQ7XG4gICAgdmFyIGRpbGF0aW9uV2lkdGggPSBjb252SW5mby5kaWxhdGlvbldpZHRoO1xuICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICB2YXIgaXNDaGFubmVsc0xhc3QgPSBjb252SW5mby5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0JztcbiAgICB2YXIgeSA9IG5ldyB0ZmpzQ29yZS5UZW5zb3JCdWZmZXIoY29udkluZm8ub3V0U2hhcGUsIHguZHR5cGUpO1xuICAgIHZhciB4U3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoeC5zaGFwZSk7XG4gICAgdmFyIGZpbHRlclN0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKGZpbHRlci5zaGFwZSk7XG4gICAgdmFyIHhCYXRjaFN0cmlkZSA9IHhTdHJpZGVzWzBdO1xuICAgIHZhciB4Um93U3RyaWRlID0gaXNDaGFubmVsc0xhc3QgPyB4U3RyaWRlc1sxXSA6IHhTdHJpZGVzWzJdO1xuICAgIHZhciB4Q29sU3RyaWRlID0gaXNDaGFubmVsc0xhc3QgPyB4U3RyaWRlc1syXSA6IDE7XG4gICAgdmFyIHhDaGFubmVsU3RyaWRlID0gaXNDaGFubmVsc0xhc3QgPyAxIDogeFN0cmlkZXNbMV07XG4gICAgdmFyIHlCYXRjaFN0cmlkZSA9IHkuc3RyaWRlc1swXTtcbiAgICB2YXIgeVJvd1N0cmlkZSA9IGlzQ2hhbm5lbHNMYXN0ID8geS5zdHJpZGVzWzFdIDogeS5zdHJpZGVzWzJdO1xuICAgIHZhciB5Q29sU3RyaWRlID0gaXNDaGFubmVsc0xhc3QgPyB5LnN0cmlkZXNbMl0gOiAxO1xuICAgIHZhciB5Q2hhbm5lbFN0cmlkZSA9IGlzQ2hhbm5lbHNMYXN0ID8gMSA6IHkuc3RyaWRlc1sxXTtcbiAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIHdWYWxzID0gYmFja2VuZC5kYXRhLmdldChmaWx0ZXIuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIHlWYWxzID0geS52YWx1ZXM7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICB2YXIgeE9mZnNldDEgPSBiICogeEJhdGNoU3RyaWRlO1xuICAgICAgICB2YXIgeU9mZnNldDEgPSBiICogeUJhdGNoU3RyaWRlO1xuICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgY29udkluZm8ub3V0SGVpZ2h0OyArK3lSKSB7XG4gICAgICAgICAgICB2YXIgeU9mZnNldDIgPSB5T2Zmc2V0MSArIHlSICogeVJvd1N0cmlkZTtcbiAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogY29udkluZm8uc3RyaWRlSGVpZ2h0IC0gcGFkVG9wO1xuICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgICAgIHZhciB4UiA9IHhSQ29ybmVyICsgd1IgKiBkaWxhdGlvbkhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IGNvbnZJbmZvLmluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgd09mZnNldDEgPSB3UiAqIGZpbHRlclN0cmlkZXNbMF07XG4gICAgICAgICAgICAgICAgdmFyIHhPZmZzZXQyID0geE9mZnNldDEgKyB4UiAqIHhSb3dTdHJpZGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IGNvbnZJbmZvLm91dFdpZHRoOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5T2Zmc2V0MyA9IHlPZmZzZXQyICsgeUMgKiB5Q29sU3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIGNvbnZJbmZvLnN0cmlkZVdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwOyB3QyA8IGZpbHRlcldpZHRoOyArK3dDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeEMgPSB4Q0Nvcm5lciArIHdDICogZGlsYXRpb25XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gY29udkluZm8uaW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdPZmZzZXQyID0gd09mZnNldDEgKyB3QyAqIGZpbHRlclN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeE9mZnNldDMgPSB4T2Zmc2V0MiArIHhDICogeENvbFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3T2Zmc2V0MyA9IHdPZmZzZXQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeFZhbCA9IHhWYWxzW3hPZmZzZXQzICsgZDEgKiB4Q2hhbm5lbFN0cmlkZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IGNvbnZJbmZvLm91dENoYW5uZWxzOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlWYWxzW3lPZmZzZXQzICsgZDIgKiB5Q2hhbm5lbFN0cmlkZV0gKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhWYWwgKiB3VmFsc1t3T2Zmc2V0MyArIGQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd09mZnNldDMgKz0gY29udkluZm8ub3V0Q2hhbm5lbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oeS5zaGFwZSwgeS5kdHlwZSwgeVZhbHMpO1xufVxudmFyIGNvbnYyRENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Db252MkQsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGNvbnYyRFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY29udjJEQmFja3Byb3BGaWx0ZXIoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLngsIGR5ID0gaW5wdXRzLmR5O1xuICAgIHZhciBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBkYXRhRm9ybWF0ID0gYXR0cnMuZGF0YUZvcm1hdCwgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlLCBmaWx0ZXJTaGFwZSA9IGF0dHJzLmZpbHRlclNoYXBlO1xuICAgIGFzc2VydE5vdENvbXBsZXgoW3gsIGR5XSwgJ2NvbnYyZEJhY2twcm9wRmlsdGVyJyk7XG4gICAgdmFyICRkYXRhRm9ybWF0ID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmNvbnZlcnRDb252MkREYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgIHZhciBjb252SW5mbyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4LnNoYXBlLCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgMSAvKiBkaWxhdGlvbnMgKi8sIHBhZCwgZGltUm91bmRpbmdNb2RlLCBmYWxzZSAvKiBkZXB0aHdpc2UgKi8sICRkYXRhRm9ybWF0KTtcbiAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoLCBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgdmFyIGlzQ2hhbm5lbHNMYXN0ID0gY29udkluZm8uZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gICAgdmFyIGRXID0gbmV3IHRmanNDb3JlLlRlbnNvckJ1ZmZlcihjb252SW5mby5maWx0ZXJTaGFwZSwgJ2Zsb2F0MzInKTtcbiAgICB2YXIgbGVmdFBhZCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICB2YXIgdG9wUGFkID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgdmFyIHhWYWxzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBkeVZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KGR5LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciB4QnVmID0gbmV3IHRmanNDb3JlLlRlbnNvckJ1ZmZlcih4LnNoYXBlLCB4LmR0eXBlLCB4VmFscyk7XG4gICAgdmFyIGR5QnVmID0gbmV3IHRmanNDb3JlLlRlbnNvckJ1ZmZlcihkeS5zaGFwZSwgZHkuZHR5cGUsIGR5VmFscyk7XG4gICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICB2YXIgeVJNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHRvcFBhZCAtIHdSKSAvIHN0cmlkZUhlaWdodCkpO1xuICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbihjb252SW5mby5vdXRIZWlnaHQsIChjb252SW5mby5pbkhlaWdodCArIHRvcFBhZCAtIHdSKSAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgdmFyIHlDTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChsZWZ0UGFkIC0gd0MpIC8gc3RyaWRlV2lkdGgpKTtcbiAgICAgICAgICAgIHZhciB5Q01heCA9IE1hdGgubWluKGNvbnZJbmZvLm91dFdpZHRoLCAoY29udkluZm8uaW5XaWR0aCArIGxlZnRQYWQgLSB3QykgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgY29udkluZm8uaW5DaGFubmVsczsgKytkMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGQyID0gMDsgZDIgPCBjb252SW5mby5vdXRDaGFubmVsczsgKytkMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY29udkluZm8uYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0geVJNaW47IHlSIDwgeVJNYXg7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeFIgPSB3UiArIHlSICogc3RyaWRlSGVpZ2h0IC0gdG9wUGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0geUNNaW47IHlDIDwgeUNNYXg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDID0gd0MgKyB5QyAqIHN0cmlkZVdpZHRoIC0gbGVmdFBhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhCdWYuZ2V0KGIsIHhSLCB4QywgZDEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeUJ1Zi5nZXQoYiwgeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhCdWYuZ2V0KGIsIGQxLCB4UiwgeEMpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeUJ1Zi5nZXQoYiwgZDIsIHlSLCB5Qyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZFcuc2V0KGRvdFByb2QsIHdSLCB3QywgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oZFcuc2hhcGUsIGRXLmR0eXBlLCBkVy52YWx1ZXMpO1xufVxudmFyIGNvbnYyREJhY2twcm9wRmlsdGVyQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkNvbnYyREJhY2twcm9wRmlsdGVyLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBjb252MkRCYWNrcHJvcEZpbHRlclxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY29udjJEQmFja3Byb3BJbnB1dChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGR5ID0gaW5wdXRzLmR5LCBmaWx0ZXIgPSBpbnB1dHMuZmlsdGVyO1xuICAgIHZhciBpbnB1dFNoYXBlID0gYXR0cnMuaW5wdXRTaGFwZSwgc3RyaWRlcyA9IGF0dHJzLnN0cmlkZXMsIHBhZCA9IGF0dHJzLnBhZCwgZGF0YUZvcm1hdCA9IGF0dHJzLmRhdGFGb3JtYXQsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZTtcbiAgICBhc3NlcnROb3RDb21wbGV4KFtkeSwgZmlsdGVyXSwgJ2NvbnYyZEJhY2twcm9wSW5wdXQnKTtcbiAgICB2YXIgZmlsdGVyU3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoZmlsdGVyLnNoYXBlKTtcbiAgICB2YXIgZHlTdHJpZGVzID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyhkeS5zaGFwZSk7XG4gICAgdmFyICRkYXRhRm9ybWF0ID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmNvbnZlcnRDb252MkREYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgIHZhciBjb252SW5mbyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlQ29udjJESW5mbyhpbnB1dFNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIDEgLyogZGlsYXRpb25zICovLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSwgZmFsc2UsICRkYXRhRm9ybWF0KTtcbiAgICB2YXIgZHggPSBuZXcgdGZqc0NvcmUuVGVuc29yQnVmZmVyKGNvbnZJbmZvLmluU2hhcGUsICdmbG9hdDMyJyk7XG4gICAgdmFyIGR4VmFsdWVzID0gZHgudmFsdWVzO1xuICAgIHZhciBkeVZhbHVlcyA9IGJhY2tlbmQuZGF0YS5nZXQoZHkuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIGZsdFZhbHVlcyA9IGJhY2tlbmQuZGF0YS5nZXQoZmlsdGVyLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBmbHRTMCA9IGZpbHRlclN0cmlkZXNbMF0sIGZsdFMxID0gZmlsdGVyU3RyaWRlc1sxXSwgZmx0UzIgPSBmaWx0ZXJTdHJpZGVzWzJdO1xuICAgIHZhciBiYXRjaFNpemUgPSBjb252SW5mby5iYXRjaFNpemUsIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aCwgaW5DaGFubmVscyA9IGNvbnZJbmZvLmluQ2hhbm5lbHMsIGluSGVpZ2h0ID0gY29udkluZm8uaW5IZWlnaHQsIGluV2lkdGggPSBjb252SW5mby5pbldpZHRoLCBvdXRDaGFubmVscyA9IGNvbnZJbmZvLm91dENoYW5uZWxzLCBvdXRIZWlnaHQgPSBjb252SW5mby5vdXRIZWlnaHQsIG91dFdpZHRoID0gY29udkluZm8ub3V0V2lkdGgsIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAkZGF0YUZvcm1hdCA9IGNvbnZJbmZvLmRhdGFGb3JtYXQ7XG4gICAgdmFyIHRvcFBhZCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICB2YXIgbGVmdFBhZCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICB2YXIgaXNDaGFubmVsc0xhc3QgPSAkZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gICAgdmFyIHhCYXRjaFN0cmlkZSA9IGR4LnN0cmlkZXNbMF07XG4gICAgdmFyIHhSb3dTdHJpZGUgPSBpc0NoYW5uZWxzTGFzdCA/IGR4LnN0cmlkZXNbMV0gOiBkeC5zdHJpZGVzWzJdO1xuICAgIHZhciB4Q29sU3RyaWRlID0gaXNDaGFubmVsc0xhc3QgPyBkeC5zdHJpZGVzWzJdIDogMTtcbiAgICB2YXIgeENoYW5uZWxTdHJpZGUgPSBpc0NoYW5uZWxzTGFzdCA/IDEgOiBkeC5zdHJpZGVzWzFdO1xuICAgIHZhciB5QmF0Y2hTdHJpZGUgPSBkeVN0cmlkZXNbMF07XG4gICAgdmFyIHlSb3dTdHJpZGUgPSBpc0NoYW5uZWxzTGFzdCA/IGR5U3RyaWRlc1sxXSA6IGR5U3RyaWRlc1syXTtcbiAgICB2YXIgeUNvbFN0cmlkZSA9IGlzQ2hhbm5lbHNMYXN0ID8gZHlTdHJpZGVzWzJdIDogMTtcbiAgICB2YXIgeUNoYW5uZWxTdHJpZGUgPSBpc0NoYW5uZWxzTGFzdCA/IDEgOiBkeVN0cmlkZXNbMV07XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaFNpemU7ICsrYikge1xuICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgaW5DaGFubmVsczsgKytkMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgeFIgPSAwOyB4UiA8IGluSGVpZ2h0OyArK3hSKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geFIgLSB0b3BQYWQ7XG4gICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHhSQ29ybmVyIC8gc3RyaWRlSGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgdmFyIHlSTWF4ID0gTWF0aC5taW4ob3V0SGVpZ2h0LCAoZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IDA7IHhDIDwgaW5XaWR0aDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB4QyAtIGxlZnRQYWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4Q0Nvcm5lciAvIHN0cmlkZVdpZHRoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5Q01heCA9IE1hdGgubWluKG91dFdpZHRoLCAoZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcikgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSB4Uk1pbjsgeVIgPCB5Uk1heDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdSID0geVIgKiBzdHJpZGVIZWlnaHQgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0geENNaW47IHlDIDwgeUNNYXg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0MgPSB5QyAqIHN0cmlkZVdpZHRoIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5T2Zmc2V0ID0geUJhdGNoU3RyaWRlICogYiArIHlSb3dTdHJpZGUgKiB5UiArIHlDb2xTdHJpZGUgKiB5QztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmx0T2Zmc2V0ID0gZmx0UzAgKiAoZmlsdGVySGVpZ2h0IC0gMSAtIHdSKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdFMxICogKGZpbHRlcldpZHRoIC0gMSAtIHdDKSArIGZsdFMyICogZDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IG91dENoYW5uZWxzOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGR5VmFsdWVzW2R5T2Zmc2V0ICsgeUNoYW5uZWxTdHJpZGUgKiBkMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBmbHRWYWx1ZXNbZmx0T2Zmc2V0ICsgZDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZHhPZmZzZXQgPSB4QmF0Y2hTdHJpZGUgKiBiICsgeFJvd1N0cmlkZSAqIHhSICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhDb2xTdHJpZGUgKiB4QyArIHhDaGFubmVsU3RyaWRlICogZDE7XG4gICAgICAgICAgICAgICAgICAgIGR4VmFsdWVzW2R4T2Zmc2V0XSA9IGRvdFByb2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKGR4LnNoYXBlLCBkeC5kdHlwZSwgZHgudmFsdWVzKTtcbn1cbnZhciBjb252MkRCYWNrcHJvcElucHV0Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkNvbnYyREJhY2twcm9wSW5wdXQsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGNvbnYyREJhY2twcm9wSW5wdXRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGNvbnYzRChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueCwgZmlsdGVyID0gaW5wdXRzLmZpbHRlcjtcbiAgICB2YXIgc3RyaWRlcyA9IGF0dHJzLnN0cmlkZXMsIHBhZCA9IGF0dHJzLnBhZCwgZGlsYXRpb25zID0gYXR0cnMuZGlsYXRpb25zO1xuICAgIGFzc2VydE5vdENvbXBsZXgoW3gsIGZpbHRlcl0sICdjb252M2QnKTtcbiAgICB2YXIgY29udkluZm8gPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY29tcHV0ZUNvbnYzREluZm8oeC5zaGFwZSwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCk7XG4gICAgdmFyIGZpbHRlckRlcHRoID0gY29udkluZm8uZmlsdGVyRGVwdGgsIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aCwgZGlsYXRpb25EZXB0aCA9IGNvbnZJbmZvLmRpbGF0aW9uRGVwdGgsIGRpbGF0aW9uSGVpZ2h0ID0gY29udkluZm8uZGlsYXRpb25IZWlnaHQsIGRpbGF0aW9uV2lkdGggPSBjb252SW5mby5kaWxhdGlvbldpZHRoLCBwYWRJbmZvID0gY29udkluZm8ucGFkSW5mbztcbiAgICB2YXIgcGFkRnJvbnQgPSBwYWRJbmZvLmZyb250O1xuICAgIHZhciBwYWRMZWZ0ID0gcGFkSW5mby5sZWZ0O1xuICAgIHZhciBwYWRUb3AgPSBwYWRJbmZvLnRvcDtcbiAgICB2YXIgeSA9IG5ldyB0ZmpzQ29yZS5UZW5zb3JCdWZmZXIoY29udkluZm8ub3V0U2hhcGUsIHguZHR5cGUpO1xuICAgIHZhciB4VmFscyA9IGJhY2tlbmQuZGF0YS5nZXQoeC5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgd1ZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KGZpbHRlci5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgeVZhbHMgPSB5LnZhbHVlcztcbiAgICB2YXIgeFN0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKHguc2hhcGUpO1xuICAgIHZhciBmaWx0ZXJTdHJpZGVzID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyhmaWx0ZXIuc2hhcGUpO1xuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY29udkluZm8uYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgdmFyIHhPZmZzZXQxID0gYiAqIHhTdHJpZGVzWzBdO1xuICAgICAgICB2YXIgeU9mZnNldDEgPSBiICogeS5zdHJpZGVzWzBdO1xuICAgICAgICBmb3IgKHZhciB5RiA9IDA7IHlGIDwgY29udkluZm8ub3V0RGVwdGg7ICsreUYpIHtcbiAgICAgICAgICAgIHZhciB5T2Zmc2V0MiA9IHlPZmZzZXQxICsgeUYgKiB5LnN0cmlkZXNbMV07XG4gICAgICAgICAgICB2YXIgeEZDb3JuZXIgPSB5RiAqIGNvbnZJbmZvLnN0cmlkZURlcHRoIC0gcGFkRnJvbnQ7XG4gICAgICAgICAgICBmb3IgKHZhciB3RiA9IDA7IHdGIDwgZmlsdGVyRGVwdGg7ICsrd0YpIHtcbiAgICAgICAgICAgICAgICB2YXIgeEYgPSB4RkNvcm5lciArIHdGICogZGlsYXRpb25EZXB0aDtcbiAgICAgICAgICAgICAgICBpZiAoeEYgPCAwIHx8IHhGID49IGNvbnZJbmZvLmluRGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB3T2Zmc2V0MSA9IHdGICogZmlsdGVyU3RyaWRlc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgeE9mZnNldDIgPSB4T2Zmc2V0MSArIHhGICogeFN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSAwOyB5UiA8IGNvbnZJbmZvLm91dEhlaWdodDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeU9mZnNldDMgPSB5T2Zmc2V0MiArIHlSICogeS5zdHJpZGVzWzJdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB5UiAqIGNvbnZJbmZvLnN0cmlkZUhlaWdodCAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhSID0geFJDb3JuZXIgKyB3UiAqIGRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBjb252SW5mby5pbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdPZmZzZXQyID0gd09mZnNldDEgKyB3UiAqIGZpbHRlclN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeE9mZnNldDMgPSB4T2Zmc2V0MiArIHhSICogeFN0cmlkZXNbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgY29udkluZm8ub3V0V2lkdGg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeU9mZnNldDQgPSB5T2Zmc2V0MyArIHlDICogY29udkluZm8ub3V0Q2hhbm5lbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geUMgKiBjb252SW5mby5zdHJpZGVXaWR0aCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwOyB3QyA8IGZpbHRlcldpZHRoOyArK3dDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4QyA9IHhDQ29ybmVyICsgd0MgKiBkaWxhdGlvbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IGNvbnZJbmZvLmluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3T2Zmc2V0MyA9IHdPZmZzZXQyICsgd0MgKiBmaWx0ZXJTdHJpZGVzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeE9mZnNldDQgPSB4T2Zmc2V0MyArIHhDICogY29udkluZm8uaW5DaGFubmVscztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdPZmZzZXQ0ID0gd09mZnNldDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMDsgZDEgPCBjb252SW5mby5pbkNoYW5uZWxzOyArK2QxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeFZhbCA9IHhWYWxzW3hPZmZzZXQ0ICsgZDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IGNvbnZJbmZvLm91dENoYW5uZWxzOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVZhbHNbeU9mZnNldDQgKyBkMl0gKz0geFZhbCAqIHdWYWxzW3dPZmZzZXQ0ICsgZDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd09mZnNldDQgKz0gY29udkluZm8ub3V0Q2hhbm5lbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oeS5zaGFwZSwgeS5kdHlwZSwgeS52YWx1ZXMpO1xufVxudmFyIGNvbnYzRENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Db252M0QsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGNvbnYzRFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY29udjNEQmFja3Byb3BGaWx0ZXJWMihhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueCwgZHkgPSBpbnB1dHMuZHk7XG4gICAgdmFyIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGZpbHRlclNoYXBlID0gYXR0cnMuZmlsdGVyU2hhcGU7XG4gICAgYXNzZXJ0Tm90Q29tcGxleChbeCwgZHldLCAnY29udjNkQmFja3Byb3BGaWx0ZXJWMicpO1xuICAgIHZhciB4U3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoeC5zaGFwZSk7XG4gICAgdmFyIGR5U3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoZHkuc2hhcGUpO1xuICAgIHZhciBjb252SW5mbyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlQ29udjNESW5mbyh4LnNoYXBlLCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgMSAvKiBkaWxhdGlvbnMgKi8sIHBhZCk7XG4gICAgdmFyIHN0cmlkZURlcHRoID0gY29udkluZm8uc3RyaWRlRGVwdGg7XG4gICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICB2YXIgZmlsdGVyRGVwdGggPSBjb252SW5mby5maWx0ZXJEZXB0aDtcbiAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgIHZhciBkdyA9IG5ldyB0ZmpzQ29yZS5UZW5zb3JCdWZmZXIoY29udkluZm8uZmlsdGVyU2hhcGUsICdmbG9hdDMyJyk7XG4gICAgdmFyIGR3VmFsdWVzID0gZHcudmFsdWVzO1xuICAgIHZhciBfYSA9IGR3LnN0cmlkZXMsIGR3UzAgPSBfYVswXSwgZHdTMSA9IF9hWzFdLCBkd1MyID0gX2FbMl0sIGR3UzMgPSBfYVszXTtcbiAgICB2YXIgZHlWYWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KGR5LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBkeVMwID0gZHlTdHJpZGVzWzBdLCBkeVMxID0gZHlTdHJpZGVzWzFdLCBkeVMyID0gZHlTdHJpZGVzWzJdLCBkeVMzID0gZHlTdHJpZGVzWzNdO1xuICAgIHZhciB4VmFsdWVzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciB4UzAgPSB4U3RyaWRlc1swXSwgeFMxID0geFN0cmlkZXNbMV0sIHhTMiA9IHhTdHJpZGVzWzJdLCB4UzMgPSB4U3RyaWRlc1szXTtcbiAgICB2YXIgZnJvbnRQYWQgPSBjb252SW5mby5wYWRJbmZvLmZyb250O1xuICAgIHZhciBsZWZ0UGFkID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgIHZhciB0b3BQYWQgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICBmb3IgKHZhciB3RiA9IDA7IHdGIDwgZmlsdGVyRGVwdGg7ICsrd0YpIHtcbiAgICAgICAgdmFyIHlGTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChmcm9udFBhZCAtIHdGKSAvIHN0cmlkZURlcHRoKSk7XG4gICAgICAgIHZhciB5Rk1heCA9IE1hdGgubWluKGNvbnZJbmZvLm91dERlcHRoLCAoY29udkluZm8uaW5EZXB0aCArIGZyb250UGFkIC0gd0YpIC8gc3RyaWRlRGVwdGgpO1xuICAgICAgICB2YXIgd09mZnNldDEgPSB3RiAqIGR3UzA7XG4gICAgICAgIGZvciAodmFyIHdSID0gMDsgd1IgPCBmaWx0ZXJIZWlnaHQ7ICsrd1IpIHtcbiAgICAgICAgICAgIHZhciB5Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgodG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KSk7XG4gICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbihjb252SW5mby5vdXRIZWlnaHQsIChjb252SW5mby5pbkhlaWdodCArIHRvcFBhZCAtIHdSKSAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgICAgICB2YXIgd09mZnNldDIgPSB3UiAqIGR3UzEgKyB3T2Zmc2V0MTtcbiAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgIHZhciB5Q01pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgobGVmdFBhZCAtIHdDKSAvIHN0cmlkZVdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHlDTWF4ID0gTWF0aC5taW4oY29udkluZm8ub3V0V2lkdGgsIChjb252SW5mby5pbldpZHRoICsgbGVmdFBhZCAtIHdDKSAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgICAgICAgICB2YXIgd09mZnNldDMgPSB3QyAqIGR3UzIgKyB3T2Zmc2V0MjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgY29udkluZm8uaW5DaGFubmVsczsgKytkMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd09mZnNldDQgPSBkMSAqIGR3UzMgKyB3T2Zmc2V0MztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IGNvbnZJbmZvLm91dENoYW5uZWxzOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhPZmZzZXQxID0gYiAqIHhTMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeU9mZnNldDEgPSBiICogZHlTMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5RiA9IHlGTWluOyB5RiA8IHlGTWF4OyArK3lGKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4RiA9IHdGICsgeUYgKiBzdHJpZGVEZXB0aCAtIGZyb250UGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeE9mZnNldDIgPSB4RiAqIHhTMSArIHhPZmZzZXQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeU9mZnNldDIgPSB5RiAqIGR5UzEgKyB5T2Zmc2V0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSB5Uk1pbjsgeVIgPCB5Uk1heDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhSID0gd1IgKyB5UiAqIHN0cmlkZUhlaWdodCAtIHRvcFBhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4T2Zmc2V0MyA9IHhSICogeFMyICsgeE9mZnNldDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeU9mZnNldDMgPSB5UiAqIGR5UzIgKyB5T2Zmc2V0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0geUNNaW47IHlDIDwgeUNNYXg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeEMgPSB3QyArIHlDICogc3RyaWRlV2lkdGggLSBsZWZ0UGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4T2Zmc2V0NCA9IHhDICogeFMzICsgeE9mZnNldDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHlPZmZzZXQ0ID0geUMgKiBkeVMzICsgeU9mZnNldDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWVzW3hPZmZzZXQ0ICsgZDFdICogZHlWYWx1ZXNbeU9mZnNldDQgKyBkMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkd1ZhbHVlc1t3T2Zmc2V0NCArIGQyXSA9IGRvdFByb2Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oZHcuc2hhcGUsIGR3LmR0eXBlLCBkdy52YWx1ZXMpO1xufVxudmFyIGNvbnYzREJhY2twcm9wRmlsdGVyVjJDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQ29udjNEQmFja3Byb3BGaWx0ZXJWMixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogY29udjNEQmFja3Byb3BGaWx0ZXJWMlxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY29udjNEQmFja3Byb3BJbnB1dFYyKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgZHkgPSBpbnB1dHMuZHksIGZpbHRlciA9IGlucHV0cy5maWx0ZXI7XG4gICAgdmFyIHBhZCA9IGF0dHJzLnBhZCwgc3RyaWRlcyA9IGF0dHJzLnN0cmlkZXMsIGlucHV0U2hhcGUgPSBhdHRycy5pbnB1dFNoYXBlO1xuICAgIGFzc2VydE5vdENvbXBsZXgoW2R5XSwgJ2NvbnYzZEJhY2twcm9wSW5wdXRWMicpO1xuICAgIHZhciBkeVN0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKGR5LnNoYXBlKTtcbiAgICB2YXIgZmlsdGVyU3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoZmlsdGVyLnNoYXBlKTtcbiAgICB2YXIgY29udkluZm8gPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY29tcHV0ZUNvbnYzREluZm8oaW5wdXRTaGFwZSwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCAxIC8qIGRpbGF0aW9ucyAqLywgcGFkKTtcbiAgICB2YXIgZHggPSBuZXcgdGZqc0NvcmUuVGVuc29yQnVmZmVyKGNvbnZJbmZvLmluU2hhcGUsICdmbG9hdDMyJyk7XG4gICAgdmFyIGR4VmFsdWVzID0gZHgudmFsdWVzO1xuICAgIHZhciBfYSA9IGR4LnN0cmlkZXMsIGR4UzAgPSBfYVswXSwgZHhTMSA9IF9hWzFdLCBkeFMyID0gX2FbMl0sIGR4UzMgPSBfYVszXTtcbiAgICB2YXIgZHlWYWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KGR5LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBkeVMwID0gZHlTdHJpZGVzWzBdLCBkeVMxID0gZHlTdHJpZGVzWzFdLCBkeVMyID0gZHlTdHJpZGVzWzJdLCBkeVMzID0gZHlTdHJpZGVzWzNdO1xuICAgIHZhciBmbHRWYWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KGZpbHRlci5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgZmx0UzAgPSBmaWx0ZXJTdHJpZGVzWzBdLCBmbHRTMSA9IGZpbHRlclN0cmlkZXNbMV0sIGZsdFMyID0gZmlsdGVyU3RyaWRlc1syXSwgZmx0UzMgPSBmaWx0ZXJTdHJpZGVzWzNdO1xuICAgIHZhciBiYXRjaFNpemUgPSBjb252SW5mby5iYXRjaFNpemUsIGZpbHRlckRlcHRoID0gY29udkluZm8uZmlsdGVyRGVwdGgsIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aCwgaW5DaGFubmVscyA9IGNvbnZJbmZvLmluQ2hhbm5lbHMsIGluRGVwdGggPSBjb252SW5mby5pbkRlcHRoLCBpbkhlaWdodCA9IGNvbnZJbmZvLmluSGVpZ2h0LCBpbldpZHRoID0gY29udkluZm8uaW5XaWR0aCwgb3V0Q2hhbm5lbHMgPSBjb252SW5mby5vdXRDaGFubmVscywgb3V0RGVwdGggPSBjb252SW5mby5vdXREZXB0aCwgb3V0SGVpZ2h0ID0gY29udkluZm8ub3V0SGVpZ2h0LCBvdXRXaWR0aCA9IGNvbnZJbmZvLm91dFdpZHRoLCBzdHJpZGVEZXB0aCA9IGNvbnZJbmZvLnN0cmlkZURlcHRoLCBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgdmFyIGZyb250UGFkID0gZmlsdGVyRGVwdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5mcm9udDtcbiAgICB2YXIgdG9wUGFkID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIHZhciBsZWZ0UGFkID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgIC8vIEZyYW1lcyBvZiBkZXB0aFxuICAgICAgICAgICAgZm9yICh2YXIgeEYgPSAwOyB4RiA8IGluRGVwdGg7ICsreEYpIHtcbiAgICAgICAgICAgICAgICB2YXIgeEZDb3JuZXIgPSB4RiAtIGZyb250UGFkO1xuICAgICAgICAgICAgICAgIHZhciB4Rk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4RkNvcm5lciAvIHN0cmlkZURlcHRoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHlGTWF4ID0gTWF0aC5taW4ob3V0RGVwdGgsIChmaWx0ZXJEZXB0aCArIHhGQ29ybmVyKSAvIHN0cmlkZURlcHRoKTtcbiAgICAgICAgICAgICAgICAvLyBSb3dzIGFzIHBlciBzdGFuZGFyZCAyZCBtYXRyaXggbm90YXRpb25cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IDA7IHhSIDwgaW5IZWlnaHQ7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geFIgLSB0b3BQYWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4UkNvcm5lciAvIHN0cmlkZUhlaWdodCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbihvdXRIZWlnaHQsIChmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcikgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb2x1bW5zIGFzIHBlciBzdGFuZGFyZCAyZCBtYXRyaXggbm90YXRpb25cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSAwOyB4QyA8IGluV2lkdGg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHhDIC0gbGVmdFBhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4Q0Nvcm5lciAvIHN0cmlkZVdpZHRoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeUNNYXggPSBNYXRoLm1pbihvdXRXaWR0aCwgKGZpbHRlcldpZHRoICsgeENDb3JuZXIpIC8gc3RyaWRlV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUYgPSB4Rk1pbjsgeUYgPCB5Rk1heDsgKyt5Rikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3RiA9IHlGICogc3RyaWRlRGVwdGggLSB4RkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IHhSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3UiA9IHlSICogc3RyaWRlSGVpZ2h0IC0geFJDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0geENNaW47IHlDIDwgeUNNYXg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHlDICogc3RyaWRlV2lkdGggLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeU9mZnNldCA9IGR5UzAgKiBiICsgZHlTMSAqIHlGICsgZHlTMiAqIHlSICsgZHlTMyAqIHlDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZsdE9mZnNldCA9IGZsdFMwICogKGZpbHRlckRlcHRoIC0gMSAtIHdGKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx0UzEgKiAoZmlsdGVySGVpZ2h0IC0gMSAtIHdSKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx0UzIgKiAoZmlsdGVyV2lkdGggLSAxIC0gd0MpICsgZmx0UzMgKiBkMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQyID0gMDsgZDIgPCBvdXRDaGFubmVsczsgKytkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGR5VmFsdWVzW2R5T2Zmc2V0ICsgZDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBmbHRWYWx1ZXNbZmx0T2Zmc2V0ICsgZDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkeFZhbHVlc1tkeFMwICogYiArIGR4UzEgKiB4RiArIGR4UzIgKiB4UiArIGR4UzMgKiB4QyArIGQxXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhkeC5zaGFwZSwgZHguZHR5cGUsIGR4LnZhbHVlcyk7XG59XG52YXIgY29udjNEQmFja3Byb3BJbnB1dFYyQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkNvbnYzREJhY2twcm9wSW5wdXRWMixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogY29udjNEQmFja3Byb3BJbnB1dFYyXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgY29zID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLkNvcywgZnVuY3Rpb24gKHhpKSB7IHJldHVybiBNYXRoLmNvcyh4aSk7IH0pO1xudmFyIGNvc0NvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Db3MsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGNvcyxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgY29zaCA9IHVuYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5Db3NoLCBmdW5jdGlvbiAoeGkpIHsgcmV0dXJuIE1hdGguY29zaCh4aSk7IH0pO1xudmFyIGNvc2hDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQ29zaCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogY29zaCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGNyb3BBbmRSZXNpemUoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBpbWFnZSA9IGlucHV0cy5pbWFnZSwgYm94ZXMgPSBpbnB1dHMuYm94ZXMsIGJveEluZCA9IGlucHV0cy5ib3hJbmQ7XG4gICAgdmFyIGNyb3BTaXplID0gYXR0cnMuY3JvcFNpemUsIG1ldGhvZCA9IGF0dHJzLm1ldGhvZCwgZXh0cmFwb2xhdGlvblZhbHVlID0gYXR0cnMuZXh0cmFwb2xhdGlvblZhbHVlO1xuICAgIHZhciBfYSA9IGltYWdlLnNoYXBlLCBiYXRjaCA9IF9hWzBdLCBpbWFnZUhlaWdodCA9IF9hWzFdLCBpbWFnZVdpZHRoID0gX2FbMl0sIG51bUNoYW5uZWxzID0gX2FbM107XG4gICAgdmFyIG51bUJveGVzID0gYm94ZXMuc2hhcGVbMF07XG4gICAgdmFyIGNyb3BIZWlnaHQgPSBjcm9wU2l6ZVswXSwgY3JvcFdpZHRoID0gY3JvcFNpemVbMV07XG4gICAgdmFyIG91dHB1dCA9IHRmanNDb3JlLmJ1ZmZlcihbbnVtQm94ZXMsIGNyb3BIZWlnaHQsIGNyb3BXaWR0aCwgbnVtQ2hhbm5lbHNdLCAnZmxvYXQzMicpO1xuICAgIHZhciBib3hWYWxzID0gYmFja2VuZC5kYXRhLmdldChib3hlcy5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgYm94SW5kVmFscyA9IGJhY2tlbmQuZGF0YS5nZXQoYm94SW5kLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBpbWFnZVZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KGltYWdlLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBpblN0cmlkZSA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoaW1hZ2Uuc2hhcGUpOyAvLyB0byBjYWxjdWxhdGUgZmxhdCBpbmRleGVzIGludG8gaW1hZ2VcbiAgICB2YXIgb3V0U3RyaWRlID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyhvdXRwdXQuc2hhcGUpOyAvLyB0byBjYWxjdWxhdGUgZmxhdCBpbmRleGVzIGludG8gb3V0cHV0XG4gICAgLy8gUmVmZXJlbmNlIGltcGxlbWVudGF0aW9uXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RlbnNvcmZsb3cvYmxvYi9tYXN0ZXIvdGVuc29yZmxvdy9jb3JlL2tlcm5lbHMvY3JvcF9hbmRfcmVzaXplX29wLmNjXG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCBudW1Cb3hlczsgYisrKSB7XG4gICAgICAgIHZhciBzdGFydEluZCA9IGIgKiA0O1xuICAgICAgICB2YXIgeTEgPSBib3hWYWxzW3N0YXJ0SW5kXTtcbiAgICAgICAgdmFyIHgxID0gYm94VmFsc1tzdGFydEluZCArIDFdO1xuICAgICAgICB2YXIgeTIgPSBib3hWYWxzW3N0YXJ0SW5kICsgMl07XG4gICAgICAgIHZhciB4MiA9IGJveFZhbHNbc3RhcnRJbmQgKyAzXTtcbiAgICAgICAgdmFyIGJJbmQgPSBib3hJbmRWYWxzW2JdO1xuICAgICAgICBpZiAoYkluZCA+PSBiYXRjaCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlaWdodFNjYWxlID0gKGNyb3BIZWlnaHQgPiAxKSA/ICh5MiAtIHkxKSAqIChpbWFnZUhlaWdodCAtIDEpIC8gKGNyb3BIZWlnaHQgLSAxKSA6IDA7XG4gICAgICAgIHZhciB3aWR0aFNjYWxlID0gKGNyb3BXaWR0aCA+IDEpID8gKHgyIC0geDEpICogKGltYWdlV2lkdGggLSAxKSAvIChjcm9wV2lkdGggLSAxKSA6IDA7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY3JvcEhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgeUluZCA9IChjcm9wSGVpZ2h0ID4gMSkgP1xuICAgICAgICAgICAgICAgIHkxICogKGltYWdlSGVpZ2h0IC0gMSkgKyB5ICogKGhlaWdodFNjYWxlKSA6XG4gICAgICAgICAgICAgICAgMC41ICogKHkxICsgeTIpICogKGltYWdlSGVpZ2h0IC0gMSk7XG4gICAgICAgICAgICBpZiAoeUluZCA8IDAgfHwgeUluZCA+IGltYWdlSGVpZ2h0IC0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY3JvcFdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBudW1DaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kID0gYyArIHggKiBvdXRTdHJpZGVbMl0gKyB5ICogb3V0U3RyaWRlWzFdICsgYiAqIG91dFN0cmlkZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC52YWx1ZXNbaW5kXSA9IGV4dHJhcG9sYXRpb25WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdiaWxpbmVhcicpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9wSW5kID0gTWF0aC5mbG9vcih5SW5kKTtcbiAgICAgICAgICAgICAgICB2YXIgYm90dG9tSW5kID0gTWF0aC5jZWlsKHlJbmQpO1xuICAgICAgICAgICAgICAgIHZhciB5TGVycCA9IHlJbmQgLSB0b3BJbmQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjcm9wV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeEluZCA9IChjcm9wV2lkdGggPiAxKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSAqIChpbWFnZVdpZHRoIC0gMSkgKyB4ICogd2lkdGhTY2FsZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAwLjUgKiAoeDEgKyB4MikgKiAoaW1hZ2VXaWR0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeEluZCA8IDAgfHwgeEluZCA+IGltYWdlV2lkdGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG51bUNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kID0gYyArIHggKiBvdXRTdHJpZGVbMl0gKyB5ICogb3V0U3RyaWRlWzFdICsgYiAqIG91dFN0cmlkZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQudmFsdWVzW2luZF0gPSBleHRyYXBvbGF0aW9uVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdEluZCA9IE1hdGguZmxvb3IoeEluZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaWdodEluZCA9IE1hdGguY2VpbCh4SW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhMZXJwID0geEluZCAtIGxlZnRJbmQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbnVtQ2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZCA9IGMgKyBsZWZ0SW5kICogaW5TdHJpZGVbMl0gKyB0b3BJbmQgKiBpblN0cmlkZVsxXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkluZCAqIGluU3RyaWRlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcExlZnQgPSBpbWFnZVZhbHNbaW5kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZCA9IGMgKyByaWdodEluZCAqIGluU3RyaWRlWzJdICsgdG9wSW5kICogaW5TdHJpZGVbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJJbmQgKiBpblN0cmlkZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3BSaWdodCA9IGltYWdlVmFsc1tpbmRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kID0gYyArIGxlZnRJbmQgKiBpblN0cmlkZVsyXSArIGJvdHRvbUluZCAqIGluU3RyaWRlWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiSW5kICogaW5TdHJpZGVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tTGVmdCA9IGltYWdlVmFsc1tpbmRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kID0gYyArIHJpZ2h0SW5kICogaW5TdHJpZGVbMl0gKyBib3R0b21JbmQgKiBpblN0cmlkZVsxXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkluZCAqIGluU3RyaWRlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gaW1hZ2VWYWxzW2luZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9wXzEgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiB4TGVycDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiB4TGVycDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZCA9IGMgKyB4ICogb3V0U3RyaWRlWzJdICsgeSAqIG91dFN0cmlkZVsxXSArIGIgKiBvdXRTdHJpZGVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQudmFsdWVzW2luZF0gPSB0b3BfMSArICgoYm90dG9tIC0gdG9wXzEpICogeUxlcnApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIG1ldGhvZCA9PSBcIm5lYXJlc3RcIlxuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY3JvcFdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhJbmQgPSAoY3JvcFdpZHRoID4gMSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgKiAoaW1hZ2VXaWR0aCAtIDEpICsgeCAqIHdpZHRoU2NhbGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgMC41ICogKHgxICsgeDIpICogKGltYWdlV2lkdGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhJbmQgPCAwIHx8IHhJbmQgPiBpbWFnZVdpZHRoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBudW1DaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZCA9IGMgKyB4ICogb3V0U3RyaWRlWzJdICsgeSAqIG91dFN0cmlkZVsxXSArIGIgKiBvdXRTdHJpZGVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnZhbHVlc1tpbmRdID0gZXh0cmFwb2xhdGlvblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3Nlc3RYID0gTWF0aC5yb3VuZCh4SW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3Nlc3RZID0gTWF0aC5yb3VuZCh5SW5kKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBudW1DaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5JbmQgPSBjICsgY2xvc2VzdFggKiBpblN0cmlkZVsyXSArIGNsb3Nlc3RZICogaW5TdHJpZGVbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJJbmQgKiBpblN0cmlkZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRJbmQgPSBjICsgeCAqIG91dFN0cmlkZVsyXSArIHkgKiBvdXRTdHJpZGVbMV0gKyBiICogb3V0U3RyaWRlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnZhbHVlc1tvdXRJbmRdID0gaW1hZ2VWYWxzW2luSW5kXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRwdXQuc2hhcGUsIG91dHB1dC5kdHlwZSwgb3V0cHV0LnZhbHVlcyk7XG59XG52YXIgY3JvcEFuZFJlc2l6ZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Dcm9wQW5kUmVzaXplLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBjcm9wQW5kUmVzaXplXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBjdW1zdW0oYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGF4aXMgPSBhdHRycy5heGlzLCBleGNsdXNpdmUgPSBhdHRycy5leGNsdXNpdmUsIHJldmVyc2UgPSBhdHRycy5yZXZlcnNlO1xuICAgIGFzc2VydE5vdENvbXBsZXgoeCwgJ2N1bXN1bScpO1xuICAgIHZhciBwZXJtdXRhdGlvbiA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oW2F4aXNdLCB4LnNoYXBlLmxlbmd0aCk7XG4gICAgdmFyICR4ID0geDtcbiAgICBpZiAocGVybXV0YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAkeCA9IHRyYW5zcG9zZSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHBlcm06IHBlcm11dGF0aW9uIH0gfSk7XG4gICAgfVxuICAgIHZhciBwZXJtdXRlZEF4aXMgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcygxLCB4LnNoYXBlLmxlbmd0aClbMF07XG4gICAgaWYgKHBlcm11dGVkQXhpcyAhPT0gJHguc2hhcGUubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWNrZW5kLmN1bXN1bSBpbiBDUFUgZXhwZWN0cyBhbiBpbm5lci1tb3N0IFwiICtcbiAgICAgICAgICAgIChcImF4aXM9XCIgKyAoJHguc2hhcGUubGVuZ3RoIC0gMSkgKyBcIiBidXQgZ290IGF4aXM9XCIgKyBwZXJtdXRlZEF4aXMpKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdER0eXBlID0gdGZqc0NvcmUudXBjYXN0VHlwZSgkeC5kdHlwZSwgJ2ludDMyJyk7XG4gICAgdmFyIHZhbHMgPSB0ZmpzQ29yZS51dGlsLm1ha2VaZXJvc1R5cGVkQXJyYXkodGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKCR4LnNoYXBlKSwgcmVzdWx0RHR5cGUpO1xuICAgIHZhciBhVmFscyA9IGJhY2tlbmQuZGF0YS5nZXQoJHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIGZpbmFsRGltID0gJHguc2hhcGVbJHguc2hhcGUubGVuZ3RoIC0gMV07XG4gICAgdmFyIGluZGV4QWRqdXN0ZXIgPSByZXZlcnNlID9cbiAgICAgICAgZnVuY3Rpb24gKGksIGopIHsgcmV0dXJuIGkgKyBmaW5hbERpbSAtIGogLSAxOyB9IDpcbiAgICAgICAgZnVuY3Rpb24gKGksIGopIHsgcmV0dXJuIGkgKyBqOyB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYVZhbHMubGVuZ3RoOyBpICs9IGZpbmFsRGltKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmluYWxEaW07IGorKykge1xuICAgICAgICAgICAgdmFyIGlkeCA9IGluZGV4QWRqdXN0ZXIoaSwgaik7XG4gICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHNbaWR4XSA9IGV4Y2x1c2l2ZSA/IDAgOiBhVmFsc1tpZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZJZHggPSBpbmRleEFkanVzdGVyKGksIGogLSAxKTtcbiAgICAgICAgICAgICAgICB2YWxzW2lkeF0gPSBleGNsdXNpdmUgPyBhVmFsc1twcmV2SWR4XSArIHZhbHNbcHJldklkeF0gOlxuICAgICAgICAgICAgICAgICAgICBhVmFsc1tpZHhdICsgdmFsc1twcmV2SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbygkeC5zaGFwZSwgcmVzdWx0RHR5cGUsIHZhbHMpO1xuICAgIGlmIChwZXJtdXRhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHZhciByZXZlcnNlUGVybXV0YXRpb24gPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbihwZXJtdXRhdGlvbik7XG4gICAgICAgIHZhciByZXZlcnNlVHJhbnNwb3NlZFJlc3VsdCA9IHRyYW5zcG9zZSh7IGlucHV0czogeyB4OiByZXN1bHQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgcGVybTogcmV2ZXJzZVBlcm11dGF0aW9uIH0gfSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzdWx0KTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbygkeCk7XG4gICAgICAgIHJldHVybiByZXZlcnNlVHJhbnNwb3NlZFJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBjdW1zdW1Db25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuQ3Vtc3VtLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBjdW1zdW1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGRlbnNlQmluY291bnQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLngsIHdlaWdodHMgPSBpbnB1dHMud2VpZ2h0cztcbiAgICB2YXIgc2l6ZSA9IGF0dHJzLnNpemUsIGJpbmFyeU91dHB1dCA9IGF0dHJzLmJpbmFyeU91dHB1dDtcbiAgICBpZiAoeC5zaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIHhWYWxzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgICAgICB2YXIgd2VpZ2h0c1ZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHdlaWdodHMuZGF0YUlkKS52YWx1ZXM7XG4gICAgICAgIHZhciBvdXRWYWxzID0gYmluY291bnRJbXBsKHhWYWxzLCB3ZWlnaHRzVmFscywgd2VpZ2h0cy5kdHlwZSwgd2VpZ2h0cy5zaGFwZSwgc2l6ZSk7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtzaXplXSwgd2VpZ2h0cy5kdHlwZSwgb3V0VmFscyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHguc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHZhciB4QnVmID0gYmFja2VuZC5idWZmZXJTeW5jKHgpO1xuICAgICAgICB2YXIgd2VpZ2h0c0J1ZiA9IGJhY2tlbmQuYnVmZmVyU3luYyh3ZWlnaHRzKTtcbiAgICAgICAgdmFyIG91dEJ1ZiA9IGJpbmNvdW50UmVkdWNlSW1wbCh4QnVmLCB3ZWlnaHRzQnVmLCBzaXplLCBiaW5hcnlPdXRwdXQpO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRCdWYuc2hhcGUsIHdlaWdodHMuZHR5cGUsIG91dEJ1Zi52YWx1ZXMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBkZW5zZUJpbmNvdW50OiBpbnB1dCBtdXN0IGJlIGF0IG1vc3QgcmFuayAyLCBidXQgZ290IHJhbmtcIiArXG4gICAgICAgICh4LnNoYXBlLmxlbmd0aCArIFwiLlwiKSk7XG59XG52YXIgZGVuc2VCaW5jb3VudENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5EZW5zZUJpbmNvdW50LFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBkZW5zZUJpbmNvdW50XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBkZXB0aFRvU3BhY2UoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGJsb2NrU2l6ZSA9IGF0dHJzLmJsb2NrU2l6ZSwgZGF0YUZvcm1hdCA9IGF0dHJzLmRhdGFGb3JtYXQ7XG4gICAgdGZqc0NvcmUudXRpbC5hc3NlcnQoZGF0YUZvcm1hdCA9PT0gJ05IV0MnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIk9ubHkgTkhXQyBkYXRhRm9ybWF0IHN1cHBvcnRlZCBvbiBDUFUgZm9yIGRlcHRoVG9TcGFjZS4gR290IFwiICsgZGF0YUZvcm1hdDsgfSk7XG4gICAgdGZqc0NvcmUudXRpbC5hc3NlcnQoYmxvY2tTaXplID4gMSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJibG9ja1NpemUgc2hvdWxkIGJlID4gMSBmb3IgZGVwdGhUb1NwYWNlLCBidXQgd2FzOiBcIiArIGJsb2NrU2l6ZTsgfSk7XG4gICAgdmFyIGJhdGNoU2l6ZSA9IHguc2hhcGVbMF07XG4gICAgdmFyIGlucHV0SGVpZ2h0ID0geC5zaGFwZVsxXTtcbiAgICB2YXIgaW5wdXRXaWR0aCA9IHguc2hhcGVbMl07XG4gICAgdmFyIGlucHV0RGVwdGggPSB4LnNoYXBlWzNdO1xuICAgIHZhciBvdXRwdXRIZWlnaHQgPSBpbnB1dEhlaWdodCAqIGJsb2NrU2l6ZTtcbiAgICB2YXIgb3V0cHV0V2lkdGggPSBpbnB1dFdpZHRoICogYmxvY2tTaXplO1xuICAgIHZhciBvdXRwdXREZXB0aCA9IGlucHV0RGVwdGggLyAoYmxvY2tTaXplICogYmxvY2tTaXplKTtcbiAgICB2YXIgeFZhbHVlcyA9IGJhY2tlbmQuZGF0YS5nZXQoeC5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShiYXRjaFNpemUgKiBvdXRwdXRIZWlnaHQgKiBvdXRwdXRXaWR0aCAqIG91dHB1dERlcHRoKTtcbiAgICB2YXIgb3V0cHV0SWR4ID0gMDtcbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgb3V0cHV0SGVpZ2h0OyArK2gpIHtcbiAgICAgICAgICAgIHZhciBpbkggPSBNYXRoLmZsb29yKGggLyBibG9ja1NpemUpO1xuICAgICAgICAgICAgdmFyIG9mZnNldEggPSAoaCAlIGJsb2NrU2l6ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IG91dHB1dFdpZHRoOyArK3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5XID0gTWF0aC5mbG9vcih3IC8gYmxvY2tTaXplKTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0VyA9ICh3ICUgYmxvY2tTaXplKTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0RCA9IChvZmZzZXRIICogYmxvY2tTaXplICsgb2Zmc2V0VykgKiBvdXRwdXREZXB0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IG91dHB1dERlcHRoOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluRCA9IGQgKyBvZmZzZXREO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRJZHggPSBpbkQgKyBpbnB1dERlcHRoICogKGluVyArIGlucHV0V2lkdGggKiAoaW5IICsgaW5wdXRIZWlnaHQgKiBiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtvdXRwdXRJZHgrK10gPSB4VmFsdWVzW2lucHV0SWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oW2JhdGNoU2l6ZSwgb3V0cHV0SGVpZ2h0LCBvdXRwdXRXaWR0aCwgb3V0cHV0RGVwdGhdLCB4LmR0eXBlLCByZXN1bHQpO1xufVxudmFyIGRlcHRoVG9TcGFjZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5EZXB0aFRvU3BhY2UsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGRlcHRoVG9TcGFjZVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZGVwdGh3aXNlQ29udjJkTmF0aXZlKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54LCBmaWx0ZXIgPSBpbnB1dHMuZmlsdGVyO1xuICAgIHZhciBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBkaWxhdGlvbnMgPSBhdHRycy5kaWxhdGlvbnMsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZTtcbiAgICBhc3NlcnROb3RDb21wbGV4KFt4LCBmaWx0ZXJdLCAnZGVwdGh3aXNlQ29udjJETmF0aXZlJyk7XG4gICAgdmFyIHhTdHJpZGVzID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyh4LnNoYXBlKTtcbiAgICB2YXIgZmlsdGVyU3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoZmlsdGVyLnNoYXBlKTtcbiAgICB2YXIgJGRpbGF0aW9ucyA9IGRpbGF0aW9ucztcbiAgICBpZiAoJGRpbGF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICRkaWxhdGlvbnMgPSBbMSwgMV07XG4gICAgfVxuICAgIHRmanNDb3JlLnV0aWwuYXNzZXJ0KHRmanNDb3JlLmJhY2tlbmRfdXRpbC5laXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUoc3RyaWRlcywgJGRpbGF0aW9ucyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlICcgK1xuICAgICAgICAoXCIxLiBHb3Qgc3RyaWRlcyBcIiArIHN0cmlkZXMgKyBcIiBhbmQgZGlsYXRpb25zICdcIiArICRkaWxhdGlvbnMgKyBcIidcIik7IH0pO1xuICAgIHZhciBjb252SW5mbyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4LnNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsICRkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlLCB0cnVlIC8qIGRlcHRod2lzZSAqLyk7XG4gICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aCwgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodCwgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGgsIHBhZEluZm8gPSBjb252SW5mby5wYWRJbmZvO1xuICAgIHZhciBwYWRMZWZ0ID0gcGFkSW5mby5sZWZ0O1xuICAgIHZhciBwYWRUb3AgPSBwYWRJbmZvLnRvcDtcbiAgICB2YXIgY2hNdWwgPSBjb252SW5mby5vdXRDaGFubmVscyAvIGNvbnZJbmZvLmluQ2hhbm5lbHM7XG4gICAgdmFyIHkgPSBuZXcgdGZqc0NvcmUuVGVuc29yQnVmZmVyKGNvbnZJbmZvLm91dFNoYXBlLCB4LmR0eXBlKTtcbiAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIHdWYWxzID0gYmFja2VuZC5kYXRhLmdldChmaWx0ZXIuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIHlWYWxzID0geS52YWx1ZXM7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICB2YXIgeE9mZnNldDEgPSBiICogeFN0cmlkZXNbMF07XG4gICAgICAgIHZhciB5T2Zmc2V0MSA9IGIgKiB5LnN0cmlkZXNbMF07XG4gICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCBjb252SW5mby5vdXRIZWlnaHQ7ICsreVIpIHtcbiAgICAgICAgICAgIHZhciB5T2Zmc2V0MiA9IHlPZmZzZXQxICsgeVIgKiB5LnN0cmlkZXNbMV07XG4gICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB5UiAqIGNvbnZJbmZvLnN0cmlkZUhlaWdodCAtIHBhZExlZnQ7XG4gICAgICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZmlsdGVySGVpZ2h0OyArK3dSKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhSID0geFJDb3JuZXIgKyB3UiAqIGRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gY29udkluZm8uaW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB3T2Zmc2V0MSA9IHdSICogZmlsdGVyU3RyaWRlc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgeE9mZnNldDIgPSB4T2Zmc2V0MSArIHhSICogeFN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IGNvbnZJbmZvLm91dFdpZHRoOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5T2Zmc2V0MyA9IHlPZmZzZXQyICsgeUMgKiB5LnN0cmlkZXNbMl07XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogY29udkluZm8uc3RyaWRlV2lkdGggLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDID0geENDb3JuZXIgKyB3QyAqIGRpbGF0aW9uV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IGNvbnZJbmZvLmluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3T2Zmc2V0MiA9IHdPZmZzZXQxICsgd0MgKiBmaWx0ZXJTdHJpZGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhPZmZzZXQzID0geE9mZnNldDIgKyB4QyAqIGNvbnZJbmZvLmluQ2hhbm5lbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeU9mZnNldDQgPSB5T2Zmc2V0MztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3T2Zmc2V0MyA9IHdPZmZzZXQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeFZhbCA9IHhWYWxzW3hPZmZzZXQzICsgZDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgY2hNdWw7ICsrcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5VmFsc1t5T2Zmc2V0NCArIHFdICs9IHhWYWwgKiB3VmFsc1t3T2Zmc2V0MyArIHFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0NCArPSBjaE11bDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3T2Zmc2V0MyArPSBjaE11bDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyh5LnNoYXBlLCB5LmR0eXBlLCB5LnZhbHVlcyk7XG59XG52YXIgZGVwdGh3aXNlQ29udjJkTmF0aXZlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkRlcHRod2lzZUNvbnYyZE5hdGl2ZSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZGVwdGh3aXNlQ29udjJkTmF0aXZlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBkZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcEZpbHRlcihhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueCwgZHkgPSBpbnB1dHMuZHk7XG4gICAgdmFyIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBkaWxhdGlvbnMgPSBhdHRycy5kaWxhdGlvbnMsIHBhZCA9IGF0dHJzLnBhZCwgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlLCBmaWx0ZXJTaGFwZSA9IGF0dHJzLmZpbHRlclNoYXBlO1xuICAgIGFzc2VydE5vdENvbXBsZXgoW3gsIGR5XSwgJ2RlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wRmlsdGVyJyk7XG4gICAgdmFyIGNvbnZJbmZvID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmNvbXB1dGVDb252MkRJbmZvKHguc2hhcGUsIGZpbHRlclNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlLCB0cnVlIC8qIGRlcHRod2lzZSAqLyk7XG4gICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aCwgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgIHZhciBkVyA9IG5ldyB0ZmpzQ29yZS5UZW5zb3JCdWZmZXIoY29udkluZm8uZmlsdGVyU2hhcGUsICdmbG9hdDMyJyk7XG4gICAgdmFyIGxlZnRQYWQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgdmFyIHRvcFBhZCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIHZhciBjaE11bCA9IGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscztcbiAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIHhCdWYgPSBuZXcgdGZqc0NvcmUuVGVuc29yQnVmZmVyKHguc2hhcGUsIHguZHR5cGUsIHhWYWxzKTtcbiAgICB2YXIgZHlWYWxzID0gYmFja2VuZC5kYXRhLmdldChkeS5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgZHlCdWYgPSBuZXcgdGZqc0NvcmUuVGVuc29yQnVmZmVyKGR5LnNoYXBlLCBkeS5kdHlwZSwgZHlWYWxzKTtcbiAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZmlsdGVySGVpZ2h0OyArK3dSKSB7XG4gICAgICAgIHZhciB5Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgodG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KSk7XG4gICAgICAgIHZhciB5Uk1heCA9IE1hdGgubWluKGNvbnZJbmZvLm91dEhlaWdodCwgKGNvbnZJbmZvLmluSGVpZ2h0ICsgdG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgZm9yICh2YXIgd0MgPSAwOyB3QyA8IGZpbHRlcldpZHRoOyArK3dDKSB7XG4gICAgICAgICAgICB2YXIgeUNNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGxlZnRQYWQgLSB3QykgLyBzdHJpZGVXaWR0aCkpO1xuICAgICAgICAgICAgdmFyIHlDTWF4ID0gTWF0aC5taW4oY29udkluZm8ub3V0V2lkdGgsIChjb252SW5mby5pbldpZHRoICsgbGVmdFBhZCAtIHdDKSAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGQyID0gMDsgZDIgPCBjb252SW5mby5vdXRDaGFubmVsczsgKytkMikge1xuICAgICAgICAgICAgICAgIHZhciBkMSA9IE1hdGgudHJ1bmMoZDIgLyBjaE11bCk7XG4gICAgICAgICAgICAgICAgdmFyIGRtID0gZDIgJSBjaE11bDtcbiAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IHlSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeFIgPSB3UiArIHlSICogc3RyaWRlSGVpZ2h0IC0gdG9wUGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSB5Q01pbjsgeUMgPCB5Q01heDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4QyA9IHdDICsgeUMgKiBzdHJpZGVXaWR0aCAtIGxlZnRQYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSB4QnVmLmdldChiLCB4UiwgeEMsIGQxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5QnVmLmdldChiLCB5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkVy5zZXQoZG90UHJvZCwgd1IsIHdDLCBkMSwgZG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKGRXLnNoYXBlLCBkVy5kdHlwZSwgZFcudmFsdWVzKTtcbn1cbnZhciBkZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcEZpbHRlckNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5EZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcEZpbHRlcixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BGaWx0ZXJcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wSW5wdXQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBkeSA9IGlucHV0cy5keSwgZmlsdGVyID0gaW5wdXRzLmZpbHRlcjtcbiAgICB2YXIgc3RyaWRlcyA9IGF0dHJzLnN0cmlkZXMsIGRpbGF0aW9ucyA9IGF0dHJzLmRpbGF0aW9ucywgcGFkID0gYXR0cnMucGFkLCBkaW1Sb3VuZGluZ01vZGUgPSBhdHRycy5kaW1Sb3VuZGluZ01vZGUsIGlucHV0U2hhcGUgPSBhdHRycy5pbnB1dFNoYXBlO1xuICAgIGFzc2VydE5vdENvbXBsZXgoW2R5LCBmaWx0ZXJdLCAnZGVwdGh3aXNlQ29udjJETmF0aXZlQmFja3Byb3BJbnB1dCcpO1xuICAgIHZhciBkeVN0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKGR5LnNoYXBlKTtcbiAgICB2YXIgZmlsdGVyU3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoZmlsdGVyLnNoYXBlKTtcbiAgICB2YXIgY29udkluZm8gPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY29tcHV0ZUNvbnYyREluZm8oaW5wdXRTaGFwZSwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlLCB0cnVlIC8qIGRlcHRod2lzZSAqLyk7XG4gICAgdmFyIGR4ID0gbmV3IHRmanNDb3JlLlRlbnNvckJ1ZmZlcihjb252SW5mby5pblNoYXBlLCAnZmxvYXQzMicpO1xuICAgIHZhciBkeFZhbHVlcyA9IGR4LnZhbHVlcztcbiAgICB2YXIgX2EgPSBkeC5zdHJpZGVzLCBkeFMwID0gX2FbMF0sIGR4UzEgPSBfYVsxXSwgZHhTMiA9IF9hWzJdO1xuICAgIHZhciBkeVZhbHVlcyA9IGJhY2tlbmQuZGF0YS5nZXQoZHkuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIGR5UzAgPSBkeVN0cmlkZXNbMF0sIGR5UzEgPSBkeVN0cmlkZXNbMV0sIGR5UzIgPSBkeVN0cmlkZXNbMl07XG4gICAgdmFyIGZsdFZhbHVlcyA9IGJhY2tlbmQuZGF0YS5nZXQoZmlsdGVyLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBmbHRTMCA9IGZpbHRlclN0cmlkZXNbMF0sIGZsdFMxID0gZmlsdGVyU3RyaWRlc1sxXSwgZmx0UzIgPSBmaWx0ZXJTdHJpZGVzWzJdO1xuICAgIHZhciBiYXRjaFNpemUgPSBjb252SW5mby5iYXRjaFNpemUsIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aCwgaW5DaGFubmVscyA9IGNvbnZJbmZvLmluQ2hhbm5lbHMsIGluSGVpZ2h0ID0gY29udkluZm8uaW5IZWlnaHQsIGluV2lkdGggPSBjb252SW5mby5pbldpZHRoLCBvdXRDaGFubmVscyA9IGNvbnZJbmZvLm91dENoYW5uZWxzLCBvdXRIZWlnaHQgPSBjb252SW5mby5vdXRIZWlnaHQsIG91dFdpZHRoID0gY29udkluZm8ub3V0V2lkdGgsIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICB2YXIgdG9wUGFkID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIHZhciBsZWZ0UGFkID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgIHZhciBjaE11bCA9IG91dENoYW5uZWxzIC8gaW5DaGFubmVscztcbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgIGZvciAodmFyIGQxID0gMDsgZDEgPCBpbkNoYW5uZWxzOyArK2QxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4UiA9IDA7IHhSIDwgaW5IZWlnaHQ7ICsreFIpIHtcbiAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB4UiAtIHRvcFBhZDtcbiAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoeFJDb3JuZXIgLyBzdHJpZGVIZWlnaHQpKTtcbiAgICAgICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbihvdXRIZWlnaHQsIChmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcikgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0gMDsgeEMgPCBpbldpZHRoOyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHhDIC0gbGVmdFBhZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHhDQ29ybmVyIC8gc3RyaWRlV2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlDTWF4ID0gTWF0aC5taW4ob3V0V2lkdGgsIChmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKSAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IHhSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1IgPSB5UiAqIHN0cmlkZUhlaWdodCAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSB4Q01pbjsgeUMgPCB5Q01heDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHlDICogc3RyaWRlV2lkdGggLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlPZmZzZXQgPSBkeVMwICogYiArIGR5UzEgKiB5UiArIGR5UzIgKiB5QztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmx0T2Zmc2V0ID0gZmx0UzAgKiAoZmlsdGVySGVpZ2h0IC0gMSAtIHdSKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdFMxICogKGZpbHRlcldpZHRoIC0gMSAtIHdDKSArIGZsdFMyICogZDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZG0gPSAwOyBkbSA8IGNoTXVsOyArK2RtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkMiA9IGQxICogY2hNdWwgKyBkbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gZHlWYWx1ZXNbZHlPZmZzZXQgKyBkMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBmbHRWYWx1ZXNbZmx0T2Zmc2V0ICsgZG1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkeFZhbHVlc1tkeFMwICogYiArIGR4UzEgKiB4UiArIGR4UzIgKiB4QyArIGQxXSA9IGRvdFByb2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKGR4LnNoYXBlLCBkeC5kdHlwZSwgZHgudmFsdWVzKTtcbn1cbnZhciBkZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcElucHV0Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wSW5wdXQsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wSW5wdXRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGRpYWcoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciB4U2l6ZSA9IHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZSh4LnNoYXBlKTtcbiAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIG91dEJ1ZiA9IHRmanNDb3JlLmJ1ZmZlcihbeFNpemUsIHhTaXplXSwgeC5kdHlwZSk7XG4gICAgdmFyIHZhbHMgPSBvdXRCdWYudmFsdWVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeFZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsc1tpICogeFNpemUgKyBpXSA9IHhWYWxzW2ldO1xuICAgIH1cbiAgICB2YXIgb3V0U2hhcGUgPSB4LnNoYXBlLmNvbmNhdCh4LnNoYXBlKTtcbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRTaGFwZSwgb3V0QnVmLmR0eXBlLCBvdXRCdWYudmFsdWVzKTtcbn1cbnZhciBkaWFnQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkRpYWcsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGRpYWdcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBkaWxhdGlvbjJkQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkRpbGF0aW9uMkQsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaW5wdXRzID0gX2EuaW5wdXRzLCBiYWNrZW5kID0gX2EuYmFja2VuZCwgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgdmFyIF9iID0gaW5wdXRzLCB4ID0gX2IueCwgZmlsdGVyID0gX2IuZmlsdGVyO1xuICAgICAgICB2YXIgX2MgPSBhdHRycywgc3RyaWRlcyA9IF9jLnN0cmlkZXMsIHBhZCA9IF9jLnBhZCwgZGlsYXRpb25zID0gX2MuZGlsYXRpb25zO1xuICAgICAgICB2YXIgY3B1QmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgICAgIHZhciB4VmFscyA9IGNwdUJhY2tlbmQuZGF0YS5nZXQoeC5kYXRhSWQpLnZhbHVlcztcbiAgICAgICAgdmFyIHhSYW5rID0geC5zaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBmaWx0ZXJWYWxzID0gY3B1QmFja2VuZC5kYXRhLmdldChmaWx0ZXIuZGF0YUlkKS52YWx1ZXM7XG4gICAgICAgIHZhciBmaWx0ZXJSYW5rID0gZmlsdGVyLnNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIF9kID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmNvbXB1dGVEaWxhdGlvbjJESW5mbyh4LnNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIHBhZCwgJ05IV0MnIC8qIGRhdGFGb3JtYXQgKi8sIGRpbGF0aW9ucyksIGJhdGNoU2l6ZSA9IF9kLmJhdGNoU2l6ZSwgaW5IZWlnaHQgPSBfZC5pbkhlaWdodCwgaW5XaWR0aCA9IF9kLmluV2lkdGgsIGluQ2hhbm5lbHMgPSBfZC5pbkNoYW5uZWxzLCBvdXRIZWlnaHQgPSBfZC5vdXRIZWlnaHQsIG91dFdpZHRoID0gX2Qub3V0V2lkdGgsIHBhZEluZm8gPSBfZC5wYWRJbmZvLCBzdHJpZGVIZWlnaHQgPSBfZC5zdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoID0gX2Quc3RyaWRlV2lkdGgsIGZpbHRlckhlaWdodCA9IF9kLmZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGggPSBfZC5maWx0ZXJXaWR0aCwgZGlsYXRpb25IZWlnaHQgPSBfZC5kaWxhdGlvbkhlaWdodCwgZGlsYXRpb25XaWR0aCA9IF9kLmRpbGF0aW9uV2lkdGgsIG91dFNoYXBlID0gX2Qub3V0U2hhcGU7XG4gICAgICAgIHZhciBvdXRTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKG91dFNoYXBlKTtcbiAgICAgICAgdmFyIG91dFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBvdXRwdXRWYWxzID0gdGZqc0NvcmUudXRpbC5nZXRBcnJheUZyb21EVHlwZSh4LmR0eXBlLCBvdXRTaXplKTtcbiAgICAgICAgLy8gVXBzYW1wbGluZyB0aGUgaW5wdXQgYnkgZmlsbCBpbiBgZGlsYXRpb24gc2l6ZSAtIDFgIHZhbHVlcyBiZXR3ZWVuIGVhY2hcbiAgICAgICAgLy8gaW5wdXQgdmFsdWUuXG4gICAgICAgIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gZm9sbG93cyB0aGUgVEYgYysrIGltcGxlbWVudGF0aW9uOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZW5zb3JmbG93L2Jsb2IvZDlhM2E4NDllZGMxOThlOTAxNzJiYzU4ZWIyOTNkZTQ1N2Y5ZDk4Ni90ZW5zb3JmbG93L2NvcmUva2VybmVscy9kaWxhdGlvbl9vcHMuY2NcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgZm9yICh2YXIgaE91dCA9IDA7IGhPdXQgPCBvdXRIZWlnaHQ7ICsraE91dCkge1xuICAgICAgICAgICAgICAgIHZhciBoQmVnID0gaE91dCAqIHN0cmlkZUhlaWdodCAtIHBhZEluZm8udG9wO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHdPdXQgPSAwOyB3T3V0IDwgb3V0V2lkdGg7ICsrd091dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd0JlZyA9IHdPdXQgKiBzdHJpZGVXaWR0aCAtIHBhZEluZm8ubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBpbkNoYW5uZWxzOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJWYWwgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgZmlsdGVySGVpZ2h0OyArK2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaEluID0gaEJlZyArIGggKiBkaWxhdGlvbkhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaEluID49IDAgJiYgaEluIDwgaW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCBmaWx0ZXJXaWR0aDsgKyt3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0luID0gd0JlZyArIHcgKiBkaWxhdGlvbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdJbiA+PSAwICYmIHdJbiA8IGluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeEluZGV4ID0gdGZqc0NvcmUudXRpbC5sb2NUb0luZGV4KFtiLCBoSW4sIHdJbiwgZF0sIHhSYW5rLCB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKHguc2hhcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVySW5kZXggPSB0ZmpzQ29yZS51dGlsLmxvY1RvSW5kZXgoW2gsIHcsIGRdLCBmaWx0ZXJSYW5rLCB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKGZpbHRlci5zaGFwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB4VmFsc1t4SW5kZXhdICsgZmlsdGVyVmFsc1tmaWx0ZXJJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA+IGN1clZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJWYWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gdGZqc0NvcmUudXRpbC5sb2NUb0luZGV4KFtiLCBoT3V0LCB3T3V0LCBkXSwgb3V0UmFuaywgdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyhvdXRTaGFwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VmFsc1tvdXRwdXRJbmRleF0gPSBjdXJWYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGFJZCA9IGNwdUJhY2tlbmQud3JpdGUodGZqc0NvcmUudXRpbC50b1R5cGVkQXJyYXkob3V0cHV0VmFscywgeC5kdHlwZSksIG91dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUlkOiBkYXRhSWQsIHNoYXBlOiBvdXRTaGFwZSwgZHR5cGU6IHguZHR5cGUgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZGlsYXRpb24yZEJhY2twcm9wRmlsdGVyQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkRpbGF0aW9uMkRCYWNrcHJvcEZpbHRlcixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBfYS5pbnB1dHMsIGJhY2tlbmQgPSBfYS5iYWNrZW5kLCBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICB2YXIgX2IgPSBpbnB1dHMsIHggPSBfYi54LCBmaWx0ZXIgPSBfYi5maWx0ZXIsIGR5ID0gX2IuZHk7XG4gICAgICAgIHZhciBfYyA9IGF0dHJzLCBzdHJpZGVzID0gX2Muc3RyaWRlcywgcGFkID0gX2MucGFkLCBkaWxhdGlvbnMgPSBfYy5kaWxhdGlvbnM7XG4gICAgICAgIHZhciBjcHVCYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgdmFyICR4ID0gdGZqc0NvcmUudXRpbC50b05lc3RlZEFycmF5KHguc2hhcGUsIGNwdUJhY2tlbmQuZGF0YS5nZXQoeC5kYXRhSWQpLnZhbHVlcyk7XG4gICAgICAgIHZhciAkZmlsdGVyID0gdGZqc0NvcmUudXRpbC50b05lc3RlZEFycmF5KGZpbHRlci5zaGFwZSwgY3B1QmFja2VuZC5kYXRhLmdldChmaWx0ZXIuZGF0YUlkKS52YWx1ZXMpO1xuICAgICAgICB2YXIgX2QgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY29tcHV0ZURpbGF0aW9uMkRJbmZvKHguc2hhcGUsIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgcGFkLCAnTkhXQycgLyogZGF0YUZvcm1hdCAqLywgZGlsYXRpb25zKSwgYmF0Y2hTaXplID0gX2QuYmF0Y2hTaXplLCBpbkhlaWdodCA9IF9kLmluSGVpZ2h0LCBpbldpZHRoID0gX2QuaW5XaWR0aCwgaW5DaGFubmVscyA9IF9kLmluQ2hhbm5lbHMsIG91dEhlaWdodCA9IF9kLm91dEhlaWdodCwgb3V0V2lkdGggPSBfZC5vdXRXaWR0aCwgcGFkSW5mbyA9IF9kLnBhZEluZm8sIHN0cmlkZUhlaWdodCA9IF9kLnN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGggPSBfZC5zdHJpZGVXaWR0aCwgZmlsdGVySGVpZ2h0ID0gX2QuZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCA9IF9kLmZpbHRlcldpZHRoLCBkaWxhdGlvbkhlaWdodCA9IF9kLmRpbGF0aW9uSGVpZ2h0LCBkaWxhdGlvbldpZHRoID0gX2QuZGlsYXRpb25XaWR0aCwgb3V0U2hhcGUgPSBfZC5vdXRTaGFwZTtcbiAgICAgICAgdGZqc0NvcmUudXRpbC5hc3NlcnQoZHkucmFuayA9PT0gb3V0U2hhcGUubGVuZ3RoLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkVycm9yIGluIFwiICsgdGZqc0NvcmUuRGlsYXRpb24yREJhY2twcm9wRmlsdGVyICsgXCIsIGR5IFwiICtcbiAgICAgICAgICAgIChcIm11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIG91dHB1dCBcIiArIG91dFNoYXBlLmxlbmd0aCArIFwiLCBidXQgZ290IFwiKSArXG4gICAgICAgICAgICAoXCJcIiArIGR5LnJhbmspOyB9KTtcbiAgICAgICAgdmFyICRkeSA9IHRmanNDb3JlLnV0aWwudG9OZXN0ZWRBcnJheShvdXRTaGFwZSwgY3B1QmFja2VuZC5kYXRhLmdldChkeS5kYXRhSWQpLnZhbHVlcyk7XG4gICAgICAgIC8vIFRoZSBjb21wdXRlZCBmaWx0ZXIgZ3JhZGllbnRzIGhhcyB0aGUgc2FtZSBkaW1lbnNpb25zIGFzIHRoZSBmaWx0ZXI6XG4gICAgICAgIC8vIFtmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBkZXB0aF1cbiAgICAgICAgdmFyIGdyYWRpZW50cyA9IHRmanNDb3JlLnV0aWwubWFrZVplcm9zTmVzdGVkVHlwZWRBcnJheShmaWx0ZXIuc2hhcGUsIGZpbHRlci5kdHlwZSk7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIG11bHRpcGxlIGFyZ21heCBicmFuY2hlcywgd2Ugb25seSBiYWNrLXByb3BhZ2F0ZSBhbG9uZyB0aGVcbiAgICAgICAgLy8gbGFzdCBicmFuY2gsIGkuZS4sIHRoZSBvbmUgd2l0aCBsYXJnZXN0IHZhbHVlIG9mIGBoICogZmlsdGVyX2NvbHMgKyB3YCxcbiAgICAgICAgLy8gc2ltaWxhcmx5IHRvIHRoZSBtYXgtcG9vbGluZyBiYWNrd2FyZCByb3V0aW5lcy5cbiAgICAgICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBmb2xsb3dzIHRoZSBURiBjKysgaW1wbGVtZW50YXRpb246XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RlbnNvcmZsb3cvYmxvYi9kOWEzYTg0OWVkYzE5OGU5MDE3MmJjNThlYjI5M2RlNDU3ZjlkOTg2L3RlbnNvcmZsb3cvY29yZS9rZXJuZWxzL2RpbGF0aW9uX29wcy5jY1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBoT3V0ID0gMDsgaE91dCA8IG91dEhlaWdodDsgKytoT3V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhCZWcgPSBoT3V0ICogc3RyaWRlSGVpZ2h0IC0gcGFkSW5mby50b3A7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd091dCA9IDA7IHdPdXQgPCBvdXRXaWR0aDsgKyt3T3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3QmVnID0gd091dCAqIHN0cmlkZVdpZHRoIC0gcGFkSW5mby5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1clZhbCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhNYXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdNYXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCBmaWx0ZXJIZWlnaHQ7ICsraCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoSW4gPSBoQmVnICsgaCAqIGRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoSW4gPj0gMCAmJiBoSW4gPCBpbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IGZpbHRlcldpZHRoOyArK3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3SW4gPSB3QmVnICsgdyAqIGRpbGF0aW9uV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod0luID49IDAgJiYgd0luIDwgaW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSAkeFtiXVtoSW5dW3dJbl1bZF0gKyAkZmlsdGVyW2hdW3ddW2RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPiBjdXJWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVmFsID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoTWF4ID0gaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd01heCA9IHc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRzW2hNYXhdW3dNYXhdW2RdICs9ICRkeVtiXVtoT3V0XVt3T3V0XVtkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YUlkID0gY3B1QmFja2VuZC53cml0ZSh0ZmpzQ29yZS51dGlsLnRvVHlwZWRBcnJheShncmFkaWVudHMsIHguZHR5cGUpLCBmaWx0ZXIuc2hhcGUsIGZpbHRlci5kdHlwZSk7XG4gICAgICAgIHJldHVybiB7IGRhdGFJZDogZGF0YUlkLCBzaGFwZTogZmlsdGVyLnNoYXBlLCBkdHlwZTogZmlsdGVyLmR0eXBlIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGRpbGF0aW9uMmRCYWNrcHJvcElucHV0Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkRpbGF0aW9uMkRCYWNrcHJvcElucHV0LFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGlucHV0cyA9IF9hLmlucHV0cywgYmFja2VuZCA9IF9hLmJhY2tlbmQsIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgIHZhciBfYiA9IGlucHV0cywgeCA9IF9iLngsIGZpbHRlciA9IF9iLmZpbHRlciwgZHkgPSBfYi5keTtcbiAgICAgICAgdmFyIF9jID0gYXR0cnMsIHN0cmlkZXMgPSBfYy5zdHJpZGVzLCBwYWQgPSBfYy5wYWQsIGRpbGF0aW9ucyA9IF9jLmRpbGF0aW9ucztcbiAgICAgICAgdmFyIGNwdUJhY2tlbmQgPSBiYWNrZW5kO1xuICAgICAgICB2YXIgJHggPSB0ZmpzQ29yZS51dGlsLnRvTmVzdGVkQXJyYXkoeC5zaGFwZSwgY3B1QmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzKTtcbiAgICAgICAgdmFyICRmaWx0ZXIgPSB0ZmpzQ29yZS51dGlsLnRvTmVzdGVkQXJyYXkoZmlsdGVyLnNoYXBlLCBjcHVCYWNrZW5kLmRhdGEuZ2V0KGZpbHRlci5kYXRhSWQpLnZhbHVlcyk7XG4gICAgICAgIHZhciBfZCA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlRGlsYXRpb24yREluZm8oeC5zaGFwZSwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBwYWQsICdOSFdDJyAvKiBkYXRhRm9ybWF0ICovLCBkaWxhdGlvbnMpLCBiYXRjaFNpemUgPSBfZC5iYXRjaFNpemUsIGluSGVpZ2h0ID0gX2QuaW5IZWlnaHQsIGluV2lkdGggPSBfZC5pbldpZHRoLCBpbkNoYW5uZWxzID0gX2QuaW5DaGFubmVscywgb3V0SGVpZ2h0ID0gX2Qub3V0SGVpZ2h0LCBvdXRXaWR0aCA9IF9kLm91dFdpZHRoLCBwYWRJbmZvID0gX2QucGFkSW5mbywgc3RyaWRlSGVpZ2h0ID0gX2Quc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCA9IF9kLnN0cmlkZVdpZHRoLCBmaWx0ZXJIZWlnaHQgPSBfZC5maWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoID0gX2QuZmlsdGVyV2lkdGgsIGRpbGF0aW9uSGVpZ2h0ID0gX2QuZGlsYXRpb25IZWlnaHQsIGRpbGF0aW9uV2lkdGggPSBfZC5kaWxhdGlvbldpZHRoLCBvdXRTaGFwZSA9IF9kLm91dFNoYXBlO1xuICAgICAgICB0ZmpzQ29yZS51dGlsLmFzc2VydChkeS5yYW5rID09PSBvdXRTaGFwZS5sZW5ndGgsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiRXJyb3IgaW4gXCIgKyB0ZmpzQ29yZS5EaWxhdGlvbjJEQmFja3Byb3BJbnB1dCArIFwiLCBkeSBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyBvdXRwdXQgXCIgKyBvdXRTaGFwZS5sZW5ndGggKyBcIiwgYnV0IGdvdCBcIikgK1xuICAgICAgICAgICAgKFwiXCIgKyBkeS5yYW5rKTsgfSk7XG4gICAgICAgIHZhciAkZHkgPSB0ZmpzQ29yZS51dGlsLnRvTmVzdGVkQXJyYXkob3V0U2hhcGUsIGNwdUJhY2tlbmQuZGF0YS5nZXQoZHkuZGF0YUlkKS52YWx1ZXMpO1xuICAgICAgICAvLyBUaGUgY29tcHV0ZWQgZ3JhZGllbnRzIGhhcyB0aGUgc2FtZSBkaW1lbnNpb25zIGFzIHRoZSBpbnB1dDpcbiAgICAgICAgLy8gW2JhdGNoLCBpbnB1dEhlaWdodCwgaW5wdXRDb2xzLCBpbkNoYW5uZWxdXG4gICAgICAgIHZhciBncmFkaWVudHMgPSB0ZmpzQ29yZS51dGlsLm1ha2VaZXJvc05lc3RlZFR5cGVkQXJyYXkoeC5zaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIG11bHRpcGxlIGFyZ21heCBicmFuY2hlcywgd2Ugb25seSBiYWNrLXByb3BhZ2F0ZSBhbG9uZyB0aGVcbiAgICAgICAgLy8gbGFzdCBicmFuY2gsIGkuZS4sIHRoZSBvbmUgd2l0aCBsYXJnZXN0IHZhbHVlIG9mIGBoICogZmlsdGVyX2NvbHMgKyB3YCxcbiAgICAgICAgLy8gc2ltaWxhcmx5IHRvIHRoZSBtYXgtcG9vbGluZyBiYWNrd2FyZCByb3V0aW5lcy5cbiAgICAgICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBmb2xsb3dzIHRoZSBURiBjKysgaW1wbGVtZW50YXRpb246XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RlbnNvcmZsb3cvYmxvYi9kOWEzYTg0OWVkYzE5OGU5MDE3MmJjNThlYjI5M2RlNDU3ZjlkOTg2L3RlbnNvcmZsb3cvY29yZS9rZXJuZWxzL2RpbGF0aW9uX29wcy5jY1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBoT3V0ID0gMDsgaE91dCA8IG91dEhlaWdodDsgKytoT3V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhCZWcgPSBoT3V0ICogc3RyaWRlSGVpZ2h0IC0gcGFkSW5mby50b3A7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd091dCA9IDA7IHdPdXQgPCBvdXRXaWR0aDsgKyt3T3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3QmVnID0gd091dCAqIHN0cmlkZVdpZHRoIC0gcGFkSW5mby5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1clZhbCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhJbk1heCA9IChoQmVnIDwgMCkgPyAwIDogaEJlZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3SW5NYXggPSAod0JlZyA8IDApID8gMCA6IHdCZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IGZpbHRlckhlaWdodDsgKytoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhJbiA9IGhCZWcgKyBoICogZGlsYXRpb25IZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhJbiA+PSAwICYmIGhJbiA8IGluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgZmlsdGVyV2lkdGg7ICsrdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdJbiA9IHdCZWcgKyB3ICogZGlsYXRpb25XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3SW4gPj0gMCAmJiB3SW4gPCBpbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9ICR4W2JdW2hJbl1bd0luXVtkXSArICRmaWx0ZXJbaF1bd11bZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA+IGN1clZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJWYWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhJbk1heCA9IGhJbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd0luTWF4ID0gd0luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50c1tiXVtoSW5NYXhdW3dJbk1heF1bZF0gKz0gJGR5W2JdW2hPdXRdW3dPdXRdW2RdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhSWQgPSBjcHVCYWNrZW5kLndyaXRlKHRmanNDb3JlLnV0aWwudG9UeXBlZEFycmF5KGdyYWRpZW50cywgeC5kdHlwZSksIHguc2hhcGUsIHguZHR5cGUpO1xuICAgICAgICByZXR1cm4geyBkYXRhSWQ6IGRhdGFJZCwgc2hhcGU6IHguc2hhcGUsIGR0eXBlOiB4LmR0eXBlIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZWx1R3JhZChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciBkeSA9IGlucHV0cy5keSwgeSA9IGlucHV0cy55O1xuICAgIGFzc2VydE5vdENvbXBsZXgoW2R5LCB5XSwgJ2VsdUdyYWQnKTtcbiAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUoeS5zaGFwZSkpO1xuICAgIHZhciB2YWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KHkuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIGR5VmFsdWVzID0gYmFja2VuZC5kYXRhLmdldChkeS5kYXRhSWQpLnZhbHVlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgaWYgKHYgPj0gMSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gZHlWYWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBkeVZhbHVlc1tpXSAqICh2ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oeS5zaGFwZSwgJ2Zsb2F0MzInLCByZXN1bHRWYWx1ZXMpO1xufVxudmFyIGVsdUdyYWRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuRWx1R3JhZCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZWx1R3JhZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGVxdWFsSW1wbCA9IGNyZWF0ZVNpbXBsZUJpbmFyeUtlcm5lbEltcGwoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhID09PSBiKSA/IDEgOiAwOyB9KTtcbnZhciBlcXVhbCA9IGJpbmFyeUtlcm5lbEZ1bmModGZqc0NvcmUuRXF1YWwsIGVxdWFsSW1wbCwgbnVsbCAvKiBjb21wbGV4SW1wbCAqLywgJ2Jvb2wnKTtcbnZhciBlcXVhbENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5FcXVhbCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZXF1YWxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgcCA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5FUkZfUDtcbnZhciBhMSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5FUkZfQTE7XG52YXIgYTIgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuRVJGX0EyO1xudmFyIGEzID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLkVSRl9BMztcbnZhciBhNCA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5FUkZfQTQ7XG52YXIgYTUgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuRVJGX0E1O1xudmFyIGVyZiA9IHVuYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5FcmYsIGZ1bmN0aW9uICh4aSkge1xuICAgIHZhciBzaWduID0gTWF0aC5zaWduKHhpKTtcbiAgICB2YXIgdiA9IE1hdGguYWJzKHhpKTtcbiAgICB2YXIgdCA9IDEuMCAvICgxLjAgKyBwICogdik7XG4gICAgcmV0dXJuIHNpZ24gKlxuICAgICAgICAoMS4wIC1cbiAgICAgICAgICAgICgoKCgoYTUgKiB0ICsgYTQpICogdCkgKyBhMykgKiB0ICsgYTIpICogdCArIGExKSAqIHQgKlxuICAgICAgICAgICAgICAgIE1hdGguZXhwKC12ICogdikpO1xufSk7XG52YXIgZXJmQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkVyZixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZXJmLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZXhwYW5kRGltcyhhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGlucHV0ID0gaW5wdXRzLmlucHV0O1xuICAgIHZhciBkaW0gPSBhdHRycy5kaW07XG4gICAgdmFyIGlucHV0UmFuayA9IGlucHV0LnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgbmV3U2hhcGUgPSBpbnB1dC5zaGFwZS5zbGljZSgpO1xuICAgIHZhciAkZGltID0gZGltO1xuICAgIGlmIChkaW0gPCAwKSB7XG4gICAgICAgIC8vIE5lZ2F0aXZlIHZhbHVlIGlzIGNvdW50ZWQgZnJvbSB0aGUgdGFpbCBvZiByYW5rLlxuICAgICAgICB0ZmpzQ29yZS51dGlsLmFzc2VydCgtKGlucHV0UmFuayArIDEpIDw9IGRpbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJBeGlzIG11c3QgYmUgaW4gdGhlIGludGVydmFsIFtcIiArIC0oaW5wdXRSYW5rICsgMSkgKyBcIiwgXCIgKyBpbnB1dFJhbmsgKyBcIl1cIjsgfSk7XG4gICAgICAgICRkaW0gPSBpbnB1dFJhbmsgKyBkaW0gKyAxO1xuICAgIH1cbiAgICBuZXdTaGFwZS5zcGxpY2UoJGRpbSwgMCwgMSk7XG4gICAgcmV0dXJuIHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogaW5wdXQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IG5ld1NoYXBlIH0gfSk7XG59XG52YXIgZXhwYW5kRGltc0NvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5FeHBhbmREaW1zLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBleHBhbmREaW1zXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgcmVhbERpdkltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC8gYjsgfSk7XG52YXIgZGl2ID0gYmluYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5SZWFsRGl2LCByZWFsRGl2SW1wbCk7XG52YXIgcmVhbERpdkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5SZWFsRGl2LFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBkaXZcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogQ2FsY3VsYXRlIEZGVCBvZiBpbm5lciBtb3N0IGVsZW1lbnRzIG9mIGJhdGNoIHRlbnNvci5cbiAqL1xuZnVuY3Rpb24gZmZ0QmF0Y2goaW5wdXQsIGludmVyc2UsIGNwdUJhY2tlbmQpIHtcbiAgICB2YXIgaW5wdXRTaGFwZSA9IGlucHV0LnNoYXBlO1xuICAgIHZhciBiYXRjaCA9IGlucHV0U2hhcGVbMF07XG4gICAgdmFyIGlubmVyRGltID0gaW5wdXRTaGFwZVsxXTtcbiAgICB2YXIgaW5wdXRWYWxzID0gY3B1QmFja2VuZC5kYXRhLmdldChpbnB1dC5kYXRhSWQpO1xuICAgIHZhciByZWFsMkQgPSBpbnB1dFZhbHMuY29tcGxleFRlbnNvckluZm9zLnJlYWw7XG4gICAgdmFyIGltYWcyRCA9IGlucHV0VmFscy5jb21wbGV4VGVuc29ySW5mb3MuaW1hZztcbiAgICAvLyBDb2xsZWN0cyByZWFsIGFuZCBpbWFnaW5hcnkgdmFsdWVzIHNlcGFyYXRlbHkuXG4gICAgdmFyIHJlc3VsdFNoYXBlID0gW2JhdGNoLCBpbm5lckRpbV07XG4gICAgdmFyIHJlc3VsdFNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUocmVzdWx0U2hhcGUpO1xuICAgIHZhciByZXN1bHRSZWFsID0gdGZqc0NvcmUudXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKCdmbG9hdDMyJywgcmVzdWx0U2l6ZSk7XG4gICAgdmFyIHJlc3VsdEltYWcgPSB0ZmpzQ29yZS51dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoJ2Zsb2F0MzInLCByZXN1bHRTaXplKTtcbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoOyBiKyspIHtcbiAgICAgICAgLy8gVE9ETzogU3VwcG9ydCBzbGljZSBvcHMgZm9yIGNvbXBsZXggdHlwZS5cbiAgICAgICAgdmFyIHIgPSBzbGljZSh7XG4gICAgICAgICAgICBpbnB1dHM6IHsgeDogcmVhbDJEIH0sXG4gICAgICAgICAgICBiYWNrZW5kOiBjcHVCYWNrZW5kLFxuICAgICAgICAgICAgYXR0cnM6IHsgYmVnaW46IFtiLCAwXSwgc2l6ZTogWzEsIGlubmVyRGltXSB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaSA9IHNsaWNlKHtcbiAgICAgICAgICAgIGlucHV0czogeyB4OiBpbWFnMkQgfSxcbiAgICAgICAgICAgIGJhY2tlbmQ6IGNwdUJhY2tlbmQsXG4gICAgICAgICAgICBhdHRyczogeyBiZWdpbjogW2IsIDBdLCBzaXplOiBbMSwgaW5uZXJEaW1dIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbnB1dF8xID0gY29tcGxleCh7IGlucHV0czogeyByZWFsOiByLCBpbWFnOiBpIH0sIGJhY2tlbmQ6IGNwdUJhY2tlbmQgfSk7XG4gICAgICAgIC8vIFJ1biBGRlQgYnkgYmF0Y2ggZWxlbWVudC5cbiAgICAgICAgdmFyIF9hID0gZmZ0SW1wbChpbnB1dF8xLCBpbnZlcnNlLCBjcHVCYWNrZW5kKSwgcmVhbF8xID0gX2EucmVhbCwgaW1hZ18xID0gX2EuaW1hZztcbiAgICAgICAgdmFyIHJlcyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5tZXJnZVJlYWxBbmRJbWFnQXJyYXlzKHJlYWxfMSwgaW1hZ18xKTtcbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBpbm5lckRpbTsgZCsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5nZXRDb21wbGV4V2l0aEluZGV4KHJlcywgZCk7XG4gICAgICAgICAgICByZXN1bHRSZWFsW2IgKiBpbm5lckRpbSArIGRdID0gYy5yZWFsO1xuICAgICAgICAgICAgcmVzdWx0SW1hZ1tiICogaW5uZXJEaW0gKyBkXSA9IGMuaW1hZztcbiAgICAgICAgfVxuICAgICAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHIpO1xuICAgICAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGkpO1xuICAgICAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGlucHV0XzEpO1xuICAgIH1cbiAgICB2YXIgJHJlYWxJbmZvID0gY3B1QmFja2VuZC5tYWtlVGVuc29ySW5mbyhyZXN1bHRTaGFwZSwgJ2Zsb2F0MzInLCByZXN1bHRSZWFsKTtcbiAgICB2YXIgJGltYWdJbmZvID0gY3B1QmFja2VuZC5tYWtlVGVuc29ySW5mbyhyZXN1bHRTaGFwZSwgJ2Zsb2F0MzInLCByZXN1bHRJbWFnKTtcbiAgICB2YXIgcmVzdWx0ID0gY29tcGxleCh7IGlucHV0czogeyByZWFsOiAkcmVhbEluZm8sIGltYWc6ICRpbWFnSW5mbyB9LCBiYWNrZW5kOiBjcHVCYWNrZW5kIH0pO1xuICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oJHJlYWxJbmZvKTtcbiAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKCRpbWFnSW5mbyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZmdEltcGwoaW5wdXQsIGludmVyc2UsIGNwdUJhY2tlbmQpIHtcbiAgICB2YXIgaW5wdXRTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKGlucHV0LnNoYXBlKTtcbiAgICB2YXIgaW5wdXRWYWxzID0gY3B1QmFja2VuZC5kYXRhLmdldChpbnB1dC5kYXRhSWQpO1xuICAgIHZhciByZWFsVmFscyA9IGNwdUJhY2tlbmQuZGF0YS5nZXQoaW5wdXRWYWxzLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBpbWFnVmFscyA9IGNwdUJhY2tlbmQuZGF0YS5nZXQoaW5wdXRWYWxzLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLmRhdGFJZCkudmFsdWVzO1xuICAgIGlmIChpc0V4cG9uZW50T2YyKGlucHV0U2l6ZSkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZmdFJhZGl4MihyZWFsVmFscywgaW1hZ1ZhbHMsIGlucHV0U2l6ZSwgaW52ZXJzZSwgY3B1QmFja2VuZCk7XG4gICAgICAgIHZhciByZXN1bHRTaGFwZSA9IFtpbnB1dC5zaGFwZVswXSwgaW5wdXQuc2hhcGVbMV1dO1xuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgdmFyIHJlYWxJbmZvID0gY3B1QmFja2VuZC5tYWtlVGVuc29ySW5mbyhyZXN1bHRTaGFwZSwgJ2Zsb2F0MzInLCByZXN1bHQucmVhbCk7XG4gICAgICAgICAgICB2YXIgaW1hZ0luZm8gPSBjcHVCYWNrZW5kLm1ha2VUZW5zb3JJbmZvKHJlc3VsdFNoYXBlLCAnZmxvYXQzMicsIHJlc3VsdC5pbWFnKTtcbiAgICAgICAgICAgIHZhciBzaXplSW5mbyA9IGNwdUJhY2tlbmQubWFrZVRlbnNvckluZm8oW10sICdmbG9hdDMyJywgdGZqc0NvcmUudXRpbC5jcmVhdGVTY2FsYXJWYWx1ZShpbnB1dFNpemUsICdmbG9hdDMyJykpO1xuICAgICAgICAgICAgdmFyIHNpemVJbmZvQ29weSA9IGlkZW50aXR5KHsgaW5wdXRzOiB7IHg6IHNpemVJbmZvIH0sIGJhY2tlbmQ6IGNwdUJhY2tlbmQgfSk7XG4gICAgICAgICAgICB2YXIgZGl2UmVhbEluZm8gPSByZWFsRGl2Q29uZmlnLmtlcm5lbEZ1bmMoeyBpbnB1dHM6IHsgYTogcmVhbEluZm8sIGI6IHNpemVJbmZvIH0sIGJhY2tlbmQ6IGNwdUJhY2tlbmQgfSk7XG4gICAgICAgICAgICB2YXIgZGl2SW1hZ0luZm8gPSByZWFsRGl2Q29uZmlnLmtlcm5lbEZ1bmMoeyBpbnB1dHM6IHsgYTogaW1hZ0luZm8sIGI6IHNpemVJbmZvQ29weSB9LCBiYWNrZW5kOiBjcHVCYWNrZW5kIH0pO1xuICAgICAgICAgICAgdmFyIGRpdlJlYWxWYWxzID0gY3B1QmFja2VuZC5kYXRhLmdldChkaXZSZWFsSW5mby5kYXRhSWQpLnZhbHVlcztcbiAgICAgICAgICAgIHZhciBkaXZJbWFnVmFscyA9IGNwdUJhY2tlbmQuZGF0YS5nZXQoZGl2SW1hZ0luZm8uZGF0YUlkKS52YWx1ZXM7XG4gICAgICAgICAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlYWxJbmZvKTtcbiAgICAgICAgICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaW1hZ0luZm8pO1xuICAgICAgICAgICAgY3B1QmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhzaXplSW5mbyk7XG4gICAgICAgICAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHNpemVJbmZvQ29weSk7XG4gICAgICAgICAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGRpdlJlYWxJbmZvKTtcbiAgICAgICAgICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZGl2SW1hZ0luZm8pO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVhbDogZGl2UmVhbFZhbHMsIGltYWc6IGRpdkltYWdWYWxzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBkYXRhID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLm1lcmdlUmVhbEFuZEltYWdBcnJheXMocmVhbFZhbHMsIGltYWdWYWxzKTtcbiAgICAgICAgdmFyIHJhd091dHB1dCA9IGZvdXJpZXJUcmFuc2Zvcm1CeU1hdG11bChkYXRhLCBpbnB1dFNpemUsIGludmVyc2UpO1xuICAgICAgICByZXR1cm4gdGZqc0NvcmUuYmFja2VuZF91dGlsLnNwbGl0UmVhbEFuZEltYWdBcnJheXMocmF3T3V0cHV0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0V4cG9uZW50T2YyKHNpemUpIHtcbiAgICByZXR1cm4gKHNpemUgJiBzaXplIC0gMSkgPT09IDA7XG59XG4vLyBGRlQgdXNpbmcgQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBvbiByYWRpeCAyIGRpbWVuc2lvbmFsIGlucHV0LlxuZnVuY3Rpb24gZmZ0UmFkaXgyKHJlYWxWYWxzLCBpbWFnVmFscywgc2l6ZSwgaW52ZXJzZSwgY3B1QmFja2VuZCkge1xuICAgIGlmIChzaXplID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7IHJlYWw6IHJlYWxWYWxzLCBpbWFnOiBpbWFnVmFscyB9O1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5tZXJnZVJlYWxBbmRJbWFnQXJyYXlzKHJlYWxWYWxzLCBpbWFnVmFscyk7XG4gICAgdmFyIGhhbGYgPSBzaXplIC8gMjtcbiAgICB2YXIgZXZlbkNvbXBsZXggPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY29tcGxleFdpdGhFdmVuSW5kZXgoZGF0YSk7XG4gICAgdmFyIGV2ZW5SZWFsVmFscyA9IGV2ZW5Db21wbGV4LnJlYWw7XG4gICAgdmFyIGV2ZW5JbWFnVmFscyA9IGV2ZW5Db21wbGV4LmltYWc7XG4gICAgdmFyIGV2ZW5TaGFwZSA9IFtldmVuUmVhbFZhbHMubGVuZ3RoXTtcbiAgICB2YXIgZXZlblJlYWxJbmZvID0gY3B1QmFja2VuZC5tYWtlVGVuc29ySW5mbyhldmVuU2hhcGUsICdmbG9hdDMyJywgZXZlblJlYWxWYWxzKTtcbiAgICB2YXIgZXZlbkltYWdJbmZvID0gY3B1QmFja2VuZC5tYWtlVGVuc29ySW5mbyhldmVuU2hhcGUsICdmbG9hdDMyJywgZXZlbkltYWdWYWxzKTtcbiAgICB2YXIgZXZlblRlbnNvckluZm8gPSBjb21wbGV4KHsgaW5wdXRzOiB7IHJlYWw6IGV2ZW5SZWFsSW5mbywgaW1hZzogZXZlbkltYWdJbmZvIH0sIGJhY2tlbmQ6IGNwdUJhY2tlbmQgfSk7XG4gICAgdmFyIG9kZENvbXBsZXggPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY29tcGxleFdpdGhPZGRJbmRleChkYXRhKTtcbiAgICB2YXIgb2RkUmVhbFZhbHMgPSBvZGRDb21wbGV4LnJlYWw7XG4gICAgdmFyIG9kZEltYWdWYWxzID0gb2RkQ29tcGxleC5pbWFnO1xuICAgIHZhciBvZGRTaGFwZSA9IFtvZGRSZWFsVmFscy5sZW5ndGhdO1xuICAgIHZhciBvZGRSZWFsSW5mbyA9IGNwdUJhY2tlbmQubWFrZVRlbnNvckluZm8ob2RkU2hhcGUsICdmbG9hdDMyJywgb2RkUmVhbFZhbHMpO1xuICAgIHZhciBvZGRJbWFnSW5mbyA9IGNwdUJhY2tlbmQubWFrZVRlbnNvckluZm8ob2RkU2hhcGUsICdmbG9hdDMyJywgb2RkSW1hZ1ZhbHMpO1xuICAgIHZhciBvZGRUZW5zb3JJbmZvID0gY29tcGxleCh7IGlucHV0czogeyByZWFsOiBvZGRSZWFsSW5mbywgaW1hZzogb2RkSW1hZ0luZm8gfSwgYmFja2VuZDogY3B1QmFja2VuZCB9KTtcbiAgICAvLyBSZWN1cnNpdmUgY2FsbCBmb3IgaGFsZiBwYXJ0IG9mIG9yaWdpbmFsIGlucHV0LlxuICAgIHZhciAkZXZlbkNvbXBsZXggPSBmZnRSYWRpeDIoZXZlblJlYWxWYWxzLCBldmVuSW1hZ1ZhbHMsIGhhbGYsIGludmVyc2UsIGNwdUJhY2tlbmQpO1xuICAgIHZhciAkZXZlblJlYWxWYWxzID0gJGV2ZW5Db21wbGV4LnJlYWw7XG4gICAgdmFyICRldmVuSW1hZ1ZhbHMgPSAkZXZlbkNvbXBsZXguaW1hZztcbiAgICB2YXIgJGV2ZW5TaGFwZSA9IFskZXZlblJlYWxWYWxzLmxlbmd0aF07XG4gICAgdmFyICRldmVuUmVhbEluZm8gPSBjcHVCYWNrZW5kLm1ha2VUZW5zb3JJbmZvKCRldmVuU2hhcGUsICdmbG9hdDMyJywgJGV2ZW5SZWFsVmFscyk7XG4gICAgdmFyICRldmVuSW1hZ0luZm8gPSBjcHVCYWNrZW5kLm1ha2VUZW5zb3JJbmZvKCRldmVuU2hhcGUsICdmbG9hdDMyJywgJGV2ZW5JbWFnVmFscyk7XG4gICAgdmFyICRldmVuVGVuc29ySW5mbyA9IGNvbXBsZXgoe1xuICAgICAgICBpbnB1dHM6IHsgcmVhbDogJGV2ZW5SZWFsSW5mbywgaW1hZzogJGV2ZW5JbWFnSW5mbyB9LFxuICAgICAgICBiYWNrZW5kOiBjcHVCYWNrZW5kXG4gICAgfSk7XG4gICAgdmFyICRvZGRDb21wbGV4ID0gZmZ0UmFkaXgyKG9kZFJlYWxWYWxzLCBvZGRJbWFnVmFscywgaGFsZiwgaW52ZXJzZSwgY3B1QmFja2VuZCk7XG4gICAgdmFyICRvZGRSZWFsVmFscyA9ICRvZGRDb21wbGV4LnJlYWw7XG4gICAgdmFyICRvZGRJbWFnVmFscyA9ICRvZGRDb21wbGV4LmltYWc7XG4gICAgdmFyICRvZGRTaGFwZSA9IFskb2RkUmVhbFZhbHMubGVuZ3RoXTtcbiAgICB2YXIgJG9kZFJlYWxJbmZvID0gY3B1QmFja2VuZC5tYWtlVGVuc29ySW5mbygkb2RkU2hhcGUsICdmbG9hdDMyJywgJG9kZFJlYWxWYWxzKTtcbiAgICB2YXIgJG9kZEltYWdJbmZvID0gY3B1QmFja2VuZC5tYWtlVGVuc29ySW5mbygkb2RkU2hhcGUsICdmbG9hdDMyJywgJG9kZEltYWdWYWxzKTtcbiAgICB2YXIgJG9kZFRlbnNvckluZm8gPSBjb21wbGV4KHsgaW5wdXRzOiB7IHJlYWw6ICRvZGRSZWFsSW5mbywgaW1hZzogJG9kZEltYWdJbmZvIH0sIGJhY2tlbmQ6IGNwdUJhY2tlbmQgfSk7XG4gICAgdmFyIGUgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZXhwb25lbnRzKHNpemUsIGludmVyc2UpO1xuICAgIHZhciBlU2hhcGUgPSBbZS5yZWFsLmxlbmd0aF07XG4gICAgdmFyIGVSZWFsSW5mbyA9IGNwdUJhY2tlbmQubWFrZVRlbnNvckluZm8oZVNoYXBlLCAnZmxvYXQzMicsIGUucmVhbCk7XG4gICAgdmFyIGVJbWFnSW5mbyA9IGNwdUJhY2tlbmQubWFrZVRlbnNvckluZm8oZVNoYXBlLCAnZmxvYXQzMicsIGUuaW1hZyk7XG4gICAgdmFyIGNvbXBsZXhJbmZvID0gY29tcGxleCh7IGlucHV0czogeyByZWFsOiBlUmVhbEluZm8sIGltYWc6IGVJbWFnSW5mbyB9LCBiYWNrZW5kOiBjcHVCYWNrZW5kIH0pO1xuICAgIHZhciBleHBvbmVudEluZm8gPSBtdWx0aXBseSh7IGlucHV0czogeyBhOiBjb21wbGV4SW5mbywgYjogJG9kZFRlbnNvckluZm8gfSwgYmFja2VuZDogY3B1QmFja2VuZCB9KTtcbiAgICB2YXIgYWRkUGFydCA9IGFkZCh7XG4gICAgICAgIGlucHV0czogeyBhOiAkZXZlblRlbnNvckluZm8sIGI6IGV4cG9uZW50SW5mbyB9LFxuICAgICAgICBiYWNrZW5kOiBjcHVCYWNrZW5kXG4gICAgfSk7XG4gICAgdmFyIHN1YlBhcnQgPSBzdWIoe1xuICAgICAgICBpbnB1dHM6IHsgYTogJGV2ZW5UZW5zb3JJbmZvLCBiOiBleHBvbmVudEluZm8gfSxcbiAgICAgICAgYmFja2VuZDogY3B1QmFja2VuZFxuICAgIH0pO1xuICAgIHZhciBhZGRQYXJ0UmVhbCA9IHJlYWwoeyBpbnB1dHM6IHsgaW5wdXQ6IGFkZFBhcnQgfSwgYmFja2VuZDogY3B1QmFja2VuZCB9KTtcbiAgICB2YXIgc3ViUGFydFJlYWwgPSByZWFsKHsgaW5wdXRzOiB7IGlucHV0OiBzdWJQYXJ0IH0sIGJhY2tlbmQ6IGNwdUJhY2tlbmQgfSk7XG4gICAgdmFyIGFkZFBhcnRJbWFnID0gaW1hZyh7IGlucHV0czogeyBpbnB1dDogYWRkUGFydCB9LCBiYWNrZW5kOiBjcHVCYWNrZW5kIH0pO1xuICAgIHZhciBzdWJQYXJ0SW1hZyA9IGltYWcoeyBpbnB1dHM6IHsgaW5wdXQ6IHN1YlBhcnQgfSwgYmFja2VuZDogY3B1QmFja2VuZCB9KTtcbiAgICB2YXIgJHJlYWwgPSBjb25jYXQoe1xuICAgICAgICBpbnB1dHM6IFthZGRQYXJ0UmVhbCwgc3ViUGFydFJlYWxdLFxuICAgICAgICBiYWNrZW5kOiBjcHVCYWNrZW5kLFxuICAgICAgICBhdHRyczogeyBheGlzOiAwIH1cbiAgICB9KTtcbiAgICB2YXIgJGltYWcgPSBjb25jYXQoe1xuICAgICAgICBpbnB1dHM6IFthZGRQYXJ0SW1hZywgc3ViUGFydEltYWddLFxuICAgICAgICBiYWNrZW5kOiBjcHVCYWNrZW5kLFxuICAgICAgICBhdHRyczogeyBheGlzOiAwIH1cbiAgICB9KTtcbiAgICB2YXIgJHJlYWxWYWxzID0gY3B1QmFja2VuZC5kYXRhLmdldCgkcmVhbC5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgJGltYWdWYWxzID0gY3B1QmFja2VuZC5kYXRhLmdldCgkaW1hZy5kYXRhSWQpLnZhbHVlcztcbiAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGV2ZW5SZWFsSW5mbyk7XG4gICAgY3B1QmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhldmVuSW1hZ0luZm8pO1xuICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZXZlblRlbnNvckluZm8pO1xuICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ob2RkUmVhbEluZm8pO1xuICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ob2RkSW1hZ0luZm8pO1xuICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ob2RkVGVuc29ySW5mbyk7XG4gICAgY3B1QmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbygkZXZlblJlYWxJbmZvKTtcbiAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKCRldmVuSW1hZ0luZm8pO1xuICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oJGV2ZW5UZW5zb3JJbmZvKTtcbiAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKCRvZGRSZWFsSW5mbyk7XG4gICAgY3B1QmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbygkb2RkSW1hZ0luZm8pO1xuICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oJG9kZFRlbnNvckluZm8pO1xuICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZVJlYWxJbmZvKTtcbiAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGVJbWFnSW5mbyk7XG4gICAgY3B1QmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhjb21wbGV4SW5mbyk7XG4gICAgY3B1QmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhleHBvbmVudEluZm8pO1xuICAgIGNwdUJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYWRkUGFydCk7XG4gICAgY3B1QmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhzdWJQYXJ0KTtcbiAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGFkZFBhcnRSZWFsKTtcbiAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGFkZFBhcnRJbWFnKTtcbiAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHN1YlBhcnRSZWFsKTtcbiAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHN1YlBhcnRJbWFnKTtcbiAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKCRyZWFsKTtcbiAgICBjcHVCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKCRpbWFnKTtcbiAgICByZXR1cm4geyByZWFsOiAkcmVhbFZhbHMsIGltYWc6ICRpbWFnVmFscyB9O1xufVxuLy8gQ2FsY3VsYXRlIGZvdXJpZXIgdHJhbnNmb3JtIGJ5IG11bHRwbHlpbmcgc2ludXNvaWQgbWF0cml4LlxuZnVuY3Rpb24gZm91cmllclRyYW5zZm9ybUJ5TWF0bXVsKGRhdGEsIHNpemUsIGludmVyc2UpIHtcbiAgICB2YXIgcmV0ID0gbmV3IEZsb2F0MzJBcnJheShzaXplICogMik7XG4gICAgLy8gVE9ETzogVXNlIG1hdG11bCBpbnN0ZWFkIG9uY2UgaXQgc3VwcG9ydHMgY29tcGxleDY0IHR5cGUuXG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBzaXplOyByKyspIHtcbiAgICAgICAgdmFyIHJlYWxfMiA9IDAuMDtcbiAgICAgICAgdmFyIGltYWdfMiA9IDAuMDtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzaXplOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBlID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmV4cG9uZW50KHIgKiBjLCBzaXplLCBpbnZlcnNlKTtcbiAgICAgICAgICAgIHZhciB0ZXJtID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmdldENvbXBsZXhXaXRoSW5kZXgoZGF0YSwgYyk7XG4gICAgICAgICAgICByZWFsXzIgKz0gdGVybS5yZWFsICogZS5yZWFsIC0gdGVybS5pbWFnICogZS5pbWFnO1xuICAgICAgICAgICAgaW1hZ18yICs9IHRlcm0ucmVhbCAqIGUuaW1hZyArIHRlcm0uaW1hZyAqIGUucmVhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgcmVhbF8yIC89IHNpemU7XG4gICAgICAgICAgICBpbWFnXzIgLz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuYXNzaWduVG9UeXBlZEFycmF5KHJldCwgcmVhbF8yLCBpbWFnXzIsIHIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBmZnQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgaW5wdXQgPSBpbnB1dHMuaW5wdXQ7XG4gICAgdmFyIGlucHV0U2l6ZSA9IHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShpbnB1dC5zaGFwZSk7XG4gICAgLy8gQ29sbGFwc2UgYWxsIG91dGVyIGRpbWVuc2lvbnMgdG8gYSBzaW5nbGUgYmF0Y2ggZGltZW5zaW9uLlxuICAgIHZhciBpbm5lckRpbWVuc2lvblNpemUgPSBpbnB1dC5zaGFwZVtpbnB1dC5zaGFwZS5sZW5ndGggLSAxXTtcbiAgICB2YXIgYmF0Y2ggPSBpbnB1dFNpemUgLyBpbm5lckRpbWVuc2lvblNpemU7XG4gICAgdmFyIGlucHV0MkQgPSByZXNoYXBlKHtcbiAgICAgICAgaW5wdXRzOiB7IHg6IGlucHV0IH0sXG4gICAgICAgIGJhY2tlbmQ6IGJhY2tlbmQsXG4gICAgICAgIGF0dHJzOiB7IHNoYXBlOiBbYmF0Y2gsIGlubmVyRGltZW5zaW9uU2l6ZV0gfVxuICAgIH0pO1xuICAgIHZhciByZXN1bHQgPSBmZnRCYXRjaChpbnB1dDJELCBmYWxzZSwgYmFja2VuZCk7XG4gICAgdmFyIHJlc3VsdFJlc2hhcGVkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiByZXN1bHQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IGlucHV0LnNoYXBlIH0gfSk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpbnB1dDJEKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdFJlc2hhcGVkO1xufVxudmFyIGZmdENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5GRlQsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGZmdFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZmlsbChhcmdzKSB7XG4gICAgdmFyIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgc2hhcGUgPSBhdHRycy5zaGFwZSwgdmFsdWUgPSBhdHRycy52YWx1ZSwgZHR5cGUgPSBhdHRycy5kdHlwZTtcbiAgICB2YXIgJGR0eXBlID0gZHR5cGUgfHwgdGZqc0NvcmUudXRpbC5pbmZlckR0eXBlKHZhbHVlKTtcbiAgICB2YXIgdmFsdWVzID0gdGZqc0NvcmUudXRpbC5nZXRBcnJheUZyb21EVHlwZSgkZHR5cGUsIHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSkpO1xuICAgIGZpbGxWYWx1ZXModmFsdWVzLCB2YWx1ZSwgJGR0eXBlKTtcbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhzaGFwZSwgJGR0eXBlLCB2YWx1ZXMpO1xufVxudmFyIGZpbGxDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuRmlsbCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZmlsbFxufTtcbmZ1bmN0aW9uIGZpbGxWYWx1ZXModmFsdWVzLCB2YWx1ZSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbHVlcy5maWxsKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbHVlcy5maWxsKHZhbHVlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBmbGlwTGVmdFJpZ2h0Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkZsaXBMZWZ0UmlnaHQsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaW5wdXRzID0gX2EuaW5wdXRzLCBhdHRycyA9IF9hLmF0dHJzLCBiYWNrZW5kID0gX2EuYmFja2VuZDtcbiAgICAgICAgdmFyIGltYWdlID0gaW5wdXRzLmltYWdlO1xuICAgICAgICB2YXIgY3B1QmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0ZmpzQ29yZS51dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoaW1hZ2UuZHR5cGUsIHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShpbWFnZS5zaGFwZSkpO1xuICAgICAgICB2YXIgX2IgPSBpbWFnZS5zaGFwZSwgYmF0Y2ggPSBfYlswXSwgaW1hZ2VIZWlnaHQgPSBfYlsxXSwgaW1hZ2VXaWR0aCA9IF9iWzJdLCBudW1DaGFubmVscyA9IF9iWzNdO1xuICAgICAgICB2YXIgaW1hZ2VWYWxzID0gY3B1QmFja2VuZC5kYXRhLmdldChpbWFnZS5kYXRhSWQpLnZhbHVlcztcbiAgICAgICAgZm9yICh2YXIgYmF0Y2hJZHggPSAwOyBiYXRjaElkeCA8IGJhdGNoOyBiYXRjaElkeCsrKSB7XG4gICAgICAgICAgICB2YXIgYmF0Y2hPZmZzZXQgPSBiYXRjaElkeCAqIGltYWdlV2lkdGggKiBpbWFnZUhlaWdodCAqIG51bUNoYW5uZWxzO1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgaW1hZ2VIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvd09mZnNldCA9IHJvdyAqIChpbWFnZVdpZHRoICogbnVtQ2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGltYWdlV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xPZmZzZXQgPSBjb2wgKiBudW1DaGFubmVscztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBudW1DaGFubmVsczsgY2hhbm5lbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRzID0gW2JhdGNoLCByb3csIGNvbCwgY2hhbm5lbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGNvb3Jkc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZFggPSBNYXRoLnJvdW5kKGltYWdlV2lkdGggLSB4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRJZHggPSBiYXRjaE9mZnNldCArIHJvd09mZnNldCArIGNvbE9mZnNldCArIGNoYW5uZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0VmFsdWUgPSBpbWFnZVZhbHNbb3V0SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb29yZGluYXRlIHBvc2l0aW9uIGZhbGxzIHdpdGhpbiB0aGUgaW1hZ2UgYm91bmRhcmllcy4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkWCA+PSAwICYmIGNvb3JkWCA8IGltYWdlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIG91dHB1dCB0byB0aGUgaW1hZ2UgdmFsdWUgYXQgdGhlIGNvb3JkaW5hdGUgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0ZWRDb2xPZmZzZXQgPSBjb29yZFggKiBudW1DaGFubmVscztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VJZHggPSBiYXRjaE9mZnNldCArIHJvd09mZnNldCArIHJvdGF0ZWRDb2xPZmZzZXQgKyBjaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFZhbHVlID0gaW1hZ2VWYWxzW2ltYWdlSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtvdXRJZHhdID0gb3V0cHV0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGFJZCA9IGNwdUJhY2tlbmQud3JpdGUob3V0cHV0LCBpbWFnZS5zaGFwZSwgaW1hZ2UuZHR5cGUpO1xuICAgICAgICByZXR1cm4geyBkYXRhSWQ6IGRhdGFJZCwgc2hhcGU6IGltYWdlLnNoYXBlLCBkdHlwZTogaW1hZ2UuZHR5cGUgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZmxvb3JEaXZJbXBsID0gY3JlYXRlU2ltcGxlQmluYXJ5S2VybmVsSW1wbChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gTWF0aC5mbG9vcihhIC8gYik7IH0pO1xudmFyIGZsb29yRGl2ID0gYmluYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5GbG9vckRpdiwgZmxvb3JEaXZJbXBsLCBudWxsIC8qIGNvbXBsZXhJbXBsICovLCAnaW50MzInKTtcbnZhciBmbG9vckRpdkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5GbG9vckRpdixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZmxvb3JEaXZcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGZ1c2VkQ29udjJEKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54LCBmaWx0ZXIgPSBpbnB1dHMuZmlsdGVyLCBiaWFzID0gaW5wdXRzLmJpYXMsIHByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBpbnB1dHMucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztcbiAgICB2YXIgc3RyaWRlcyA9IGF0dHJzLnN0cmlkZXMsIHBhZCA9IGF0dHJzLnBhZCwgZGF0YUZvcm1hdCA9IGF0dHJzLmRhdGFGb3JtYXQsIGRpbGF0aW9ucyA9IGF0dHJzLmRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlLCBhY3RpdmF0aW9uID0gYXR0cnMuYWN0aXZhdGlvbiwgbGVha3lyZWx1QWxwaGEgPSBhdHRycy5sZWFreXJlbHVBbHBoYTtcbiAgICB2YXIgcmVzdWx0ID0gY29udjJEKHtcbiAgICAgICAgaW5wdXRzOiB7IHg6IHgsIGZpbHRlcjogZmlsdGVyIH0sXG4gICAgICAgIGJhY2tlbmQ6IGJhY2tlbmQsXG4gICAgICAgIGF0dHJzOiB7IHN0cmlkZXM6IHN0cmlkZXMsIHBhZDogcGFkLCBkYXRhRm9ybWF0OiBkYXRhRm9ybWF0LCBkaWxhdGlvbnM6IGRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlOiBkaW1Sb3VuZGluZ01vZGUgfVxuICAgIH0pO1xuICAgIGlmIChiaWFzKSB7XG4gICAgICAgIHZhciByZXN1bHRPbGQgPSByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IGFkZCh7IGlucHV0czogeyBhOiByZXN1bHQsIGI6IGJpYXMgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyZXN1bHRPbGQpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZhdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0T2xkID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBhcHBseUFjdGl2YXRpb24oYmFja2VuZCwgcmVzdWx0LCBhY3RpdmF0aW9uLCBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLCBsZWFreXJlbHVBbHBoYSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzdWx0T2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBmdXNlZENvbnYyRENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5GdXNlZENvbnYyRCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZnVzZWRDb252MkRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGZ1c2VkRGVwdGh3aXNlQ29udjJEKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54LCBmaWx0ZXIgPSBpbnB1dHMuZmlsdGVyLCBiaWFzID0gaW5wdXRzLmJpYXMsIHByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBpbnB1dHMucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztcbiAgICB2YXIgc3RyaWRlcyA9IGF0dHJzLnN0cmlkZXMsIHBhZCA9IGF0dHJzLnBhZCwgZGF0YUZvcm1hdCA9IGF0dHJzLmRhdGFGb3JtYXQsIGRpbGF0aW9ucyA9IGF0dHJzLmRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlLCBhY3RpdmF0aW9uID0gYXR0cnMuYWN0aXZhdGlvbiwgbGVha3lyZWx1QWxwaGEgPSBhdHRycy5sZWFreXJlbHVBbHBoYTtcbiAgICB2YXIgcmVzdWx0ID0gZGVwdGh3aXNlQ29udjJkTmF0aXZlKHtcbiAgICAgICAgaW5wdXRzOiB7IHg6IHgsIGZpbHRlcjogZmlsdGVyIH0sXG4gICAgICAgIGJhY2tlbmQ6IGJhY2tlbmQsXG4gICAgICAgIGF0dHJzOiB7IHN0cmlkZXM6IHN0cmlkZXMsIHBhZDogcGFkLCBkYXRhRm9ybWF0OiBkYXRhRm9ybWF0LCBkaWxhdGlvbnM6IGRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlOiBkaW1Sb3VuZGluZ01vZGUgfVxuICAgIH0pO1xuICAgIGlmIChiaWFzKSB7XG4gICAgICAgIHZhciBvbGRSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IGFkZCh7IGlucHV0czogeyBhOiByZXN1bHQsIGI6IGJpYXMgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvbGRSZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZhdGlvbikge1xuICAgICAgICB2YXIgb2xkUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBhcHBseUFjdGl2YXRpb24oYmFja2VuZCwgcmVzdWx0LCBhY3RpdmF0aW9uLCBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLCBsZWFreXJlbHVBbHBoYSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ob2xkUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBmdXNlZERlcHRod2lzZUNvbnYyRENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5GdXNlZERlcHRod2lzZUNvbnYyRCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZnVzZWREZXB0aHdpc2VDb252MkRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGdhdGhlck5kKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQ7XG4gICAgdmFyIHBhcmFtcyA9IGlucHV0cy5wYXJhbXMsIGluZGljZXMgPSBpbnB1dHMuaW5kaWNlcztcbiAgICB2YXIgcGFyYW1zU2l6ZSA9IHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShwYXJhbXMuc2hhcGUpO1xuICAgIHZhciBpbmRpY2VzU2hhcGUgPSBpbmRpY2VzLnNoYXBlO1xuICAgIHZhciBzbGljZVJhbmsgPSBpbmRpY2VzU2hhcGVbaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDFdO1xuICAgIHZhciBfYSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5wcmVwYXJlQW5kVmFsaWRhdGUocGFyYW1zLCBpbmRpY2VzKSwgcmVzdWx0U2hhcGUgPSBfYVswXSwgbnVtU2xpY2VzID0gX2FbMV0sIHNsaWNlU2l6ZSA9IF9hWzJdLCBzdHJpZGVzID0gX2FbM107XG4gICAgaWYgKG51bVNsaWNlcyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhyZXN1bHRTaGFwZSwgcGFyYW1zLmR0eXBlLCBbXSk7XG4gICAgfVxuICAgIHZhciBvdXRCdWYgPSB0ZmpzQ29yZS5idWZmZXIoW251bVNsaWNlcywgc2xpY2VTaXplXSwgcGFyYW1zLmR0eXBlKTtcbiAgICB2YXIgaW5kaWNlc0RhdGEgPSBiYWNrZW5kLmRhdGEuZ2V0KGluZGljZXMuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIHBhcmFtc0RhdGEgPSBiYWNrZW5kLmRhdGEuZ2V0KHBhcmFtcy5kYXRhSWQpLnZhbHVlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNsaWNlczsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IFtdO1xuICAgICAgICB2YXIgZmxhdHRlbkluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzbGljZVJhbms7IGorKykge1xuICAgICAgICAgICAgdmFyIGRpbSA9IGluZGljZXNEYXRhW2kgKiBzbGljZVJhbmsgKyBqXTtcbiAgICAgICAgICAgIGZsYXR0ZW5JbmRleCArPSBkaW0gKiBzdHJpZGVzW2pdO1xuICAgICAgICAgICAgaW5kZXgucHVzaChkaW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGF0dGVuSW5kZXggPCAwIHx8IGZsYXR0ZW5JbmRleCA+PSBwYXJhbXNTaXplIC8gc2xpY2VTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGljZXM6IFwiICsgaW5kZXggKyBcIiBkb2VzIG5vdCBpbmRleCBpbnRvIFwiICsgcGFyYW1zLnNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNsaWNlU2l6ZTsgaysrKSB7XG4gICAgICAgICAgICBvdXRCdWYudmFsdWVzW2kgKiBzbGljZVNpemUgKyBrXSA9XG4gICAgICAgICAgICAgICAgcGFyYW1zRGF0YVtmbGF0dGVuSW5kZXggKiBzbGljZVNpemUgKyBrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhyZXN1bHRTaGFwZSwgb3V0QnVmLmR0eXBlLCBvdXRCdWYudmFsdWVzKTtcbn1cbnZhciBnYXRoZXJOZENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5HYXRoZXJOZCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZ2F0aGVyTmRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGdhdGhlclYyKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54LCBpbmRpY2VzID0gaW5wdXRzLmluZGljZXM7XG4gICAgdmFyIGF4aXMgPSBhdHRycy5heGlzLCBiYXRjaERpbXMgPSBhdHRycy5iYXRjaERpbXM7XG4gICAgYXNzZXJ0Tm90Q29tcGxleChbeCwgaW5kaWNlc10sICdnYXRoZXJWMicpO1xuICAgIHZhciAkYmF0Y2hEaW1zID0gYmF0Y2hEaW1zO1xuICAgIGlmIChiYXRjaERpbXMgPT0gbnVsbCkge1xuICAgICAgICAkYmF0Y2hEaW1zID0gMDtcbiAgICB9XG4gICAgdmFyIGluZGljZXNTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKGluZGljZXMuc2hhcGUpO1xuICAgIHZhciBwYXJzZWRBeGlzID0gdGZqc0NvcmUudXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKVswXTtcbiAgICB2YXIgc2hhcGVJbmZvID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLnNlZ21lbnRfdXRpbC5jb2xsZWN0R2F0aGVyT3BTaGFwZUluZm8oeCwgaW5kaWNlcywgcGFyc2VkQXhpcywgJGJhdGNoRGltcyk7XG4gICAgdmFyIGZsYXR0ZW5YID0gcmVzaGFwZSh7XG4gICAgICAgIGlucHV0czogeyB4OiB4IH0sXG4gICAgICAgIGJhY2tlbmQ6IGJhY2tlbmQsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBzaGFwZTogW1xuICAgICAgICAgICAgICAgIHNoYXBlSW5mby5iYXRjaFNpemUsIHNoYXBlSW5mby5vdXRlclNpemUsIHNoYXBlSW5mby5kaW1TaXplLFxuICAgICAgICAgICAgICAgIHNoYXBlSW5mby5zbGljZVNpemVcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBmbGF0dGVuSW5kZXggPSByZXNoYXBlKHtcbiAgICAgICAgaW5wdXRzOiB7IHg6IGluZGljZXMgfSxcbiAgICAgICAgYmFja2VuZDogYmFja2VuZCxcbiAgICAgICAgYXR0cnM6IHsgc2hhcGU6IFtzaGFwZUluZm8uYmF0Y2hTaXplLCBpbmRpY2VzU2l6ZSAvIHNoYXBlSW5mby5iYXRjaFNpemVdIH1cbiAgICB9KTtcbiAgICB2YXIgZmxhdHRlbk91dHB1dFNoYXBlID0gW1xuICAgICAgICBzaGFwZUluZm8uYmF0Y2hTaXplLCBzaGFwZUluZm8ub3V0ZXJTaXplLCBpbmRpY2VzU2l6ZSAvIHNoYXBlSW5mby5iYXRjaFNpemUsXG4gICAgICAgIHNoYXBlSW5mby5zbGljZVNpemVcbiAgICBdO1xuICAgIHZhciBpbmRpY2VzQnVmID0gYmFja2VuZC5idWZmZXJTeW5jKGZsYXR0ZW5JbmRleCk7XG4gICAgdmFyIHhCdWYgPSBiYWNrZW5kLmJ1ZmZlclN5bmMoZmxhdHRlblgpO1xuICAgIHZhciBvdXRCdWYgPSBnYXRoZXJWMkltcGwoeEJ1ZiwgaW5kaWNlc0J1ZiwgZmxhdHRlbk91dHB1dFNoYXBlKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGZsYXR0ZW5YKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGZsYXR0ZW5JbmRleCk7XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oc2hhcGVJbmZvLm91dHB1dFNoYXBlLCBvdXRCdWYuZHR5cGUsIG91dEJ1Zi52YWx1ZXMpO1xufVxudmFyIGdhdGhlclYyQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkdhdGhlclYyLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBnYXRoZXJWMlxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGdyZWF0ZXJFcXVhbEltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYSA+PSBiKSA/IDEgOiAwOyB9KTtcbnZhciBncmVhdGVyRXF1YWwgPSBiaW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLkdyZWF0ZXJFcXVhbCwgZ3JlYXRlckVxdWFsSW1wbCwgbnVsbCAvKiBjb21wbGV4SW1wbCAqLywgJ2Jvb2wnKTtcbnZhciBncmVhdGVyRXF1YWxDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuR3JlYXRlckVxdWFsLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBncmVhdGVyRXF1YWxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGlmZnQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgaW5wdXQgPSBpbnB1dHMuaW5wdXQ7XG4gICAgdmFyIGlucHV0U2l6ZSA9IHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShpbnB1dC5zaGFwZSk7XG4gICAgLy8gQ29sbGFwc2UgYWxsIG91dGVyIGRpbWVuc2lvbnMgdG8gYSBzaW5nbGUgYmF0Y2ggZGltZW5zaW9uLlxuICAgIHZhciBpbm5lckRpbWVuc2lvblNpemUgPSBpbnB1dC5zaGFwZVtpbnB1dC5zaGFwZS5sZW5ndGggLSAxXTtcbiAgICB2YXIgYmF0Y2ggPSBpbnB1dFNpemUgLyBpbm5lckRpbWVuc2lvblNpemU7XG4gICAgdmFyIGlucHV0MkQgPSByZXNoYXBlKHtcbiAgICAgICAgaW5wdXRzOiB7IHg6IGlucHV0IH0sXG4gICAgICAgIGJhY2tlbmQ6IGJhY2tlbmQsXG4gICAgICAgIGF0dHJzOiB7IHNoYXBlOiBbYmF0Y2gsIGlubmVyRGltZW5zaW9uU2l6ZV0gfVxuICAgIH0pO1xuICAgIHZhciByZXN1bHQgPSBmZnRCYXRjaChpbnB1dDJELCB0cnVlLCBiYWNrZW5kKTtcbiAgICB2YXIgcmVzdWx0UmVzaGFwZWQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHJlc3VsdCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogaW5wdXQuc2hhcGUgfSB9KTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGlucHV0MkQpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0UmVzaGFwZWQ7XG59XG52YXIgaWZmdENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5JRkZULFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBpZmZ0XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGlzRmluaXRlID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLklzRmluaXRlLCBmdW5jdGlvbiAoeGkpIHsgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh4aSkgPyAxIDogMDsgfSwgJ2Jvb2wnKTtcbnZhciBpc0Zpbml0ZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Jc0Zpbml0ZSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogaXNGaW5pdGUsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGlzSW5mID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLklzSW5mLCBmdW5jdGlvbiAoeGkpIHsgcmV0dXJuIE1hdGguYWJzKHhpKSA9PT0gSW5maW5pdHkgPyAxIDogMDsgfSwgJ2Jvb2wnKTtcbnZhciBpc0luZkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Jc0luZixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogaXNJbmYsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGlzTmFOJDEgPSB1bmFyeUtlcm5lbEZ1bmModGZqc0NvcmUuSXNOYW4sIGZ1bmN0aW9uICh4aSkgeyByZXR1cm4gTnVtYmVyLmlzTmFOKHhpKSA/IDEgOiAwOyB9LCAnYm9vbCcpO1xudmFyIGlzTmFOQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLklzTmFuLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBpc05hTiQxLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGxlc3NFcXVhbEltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYSA8PSBiKSA/IDEgOiAwOyB9KTtcbnZhciBsZXNzRXF1YWwgPSBiaW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLkxlc3NFcXVhbCwgbGVzc0VxdWFsSW1wbCwgbnVsbCAvKiBjb21wbGV4SW1wbCAqLywgJ2Jvb2wnKTtcbnZhciBsZXNzRXF1YWxDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuTGVzc0VxdWFsLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBsZXNzRXF1YWxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGxpblNwYWNlKGFyZ3MpIHtcbiAgICB2YXIgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBzdGFydCA9IGF0dHJzLnN0YXJ0LCBzdG9wID0gYXR0cnMuc3RvcCwgbnVtID0gYXR0cnMubnVtO1xuICAgIHZhciBvdXRWYWxzID0gbGluU3BhY2VJbXBsKHN0YXJ0LCBzdG9wLCBudW0pO1xuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtvdXRWYWxzLmxlbmd0aF0sICdmbG9hdDMyJywgb3V0VmFscyk7XG59XG52YXIgbGluU3BhY2VDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuTGluU3BhY2UsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGxpblNwYWNlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGxvZzFwID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLkxvZzFwLCBmdW5jdGlvbiAoeGkpIHsgcmV0dXJuIE1hdGgubG9nMXAoeGkpOyB9KTtcbnZhciBsb2cxcENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Mb2cxcCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogbG9nMXAsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgbG9naWNhbEFuZEltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICYmIGI7IH0pO1xudmFyIGxvZ2ljYWxBbmQgPSBiaW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLkxvZ2ljYWxBbmQsIGxvZ2ljYWxBbmRJbXBsLCBudWxsIC8qIGNvbXBsZXhJbXBsICovLCAnYm9vbCcpO1xudmFyIGxvZ2ljYWxBbmRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuTG9naWNhbEFuZCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogbG9naWNhbEFuZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBsb2dpY2FsTm90ID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLkxvZ2ljYWxOb3QsIGZ1bmN0aW9uICh4aSkgeyByZXR1cm4geGkgPyAwIDogMTsgfSwgJ2Jvb2wnKTtcbnZhciBsb2dpY2FsTm90Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkxvZ2ljYWxOb3QsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IGxvZ2ljYWxOb3QsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgbG9naWNhbE9ySW1wbCA9IGNyZWF0ZVNpbXBsZUJpbmFyeUtlcm5lbEltcGwoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgfHwgYjsgfSk7XG52YXIgbG9naWNhbE9yID0gYmluYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5Mb2dpY2FsT3IsIGxvZ2ljYWxPckltcGwsIG51bGwgLyogY29tcGxleEltcGwgKi8sICdib29sJyk7XG52YXIgbG9naWNhbE9yQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkxvZ2ljYWxPcixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogbG9naWNhbE9yXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBsUk4oYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGRlcHRoUmFkaXVzID0gYXR0cnMuZGVwdGhSYWRpdXMsIGJpYXMgPSBhdHRycy5iaWFzLCBhbHBoYSA9IGF0dHJzLmFscGhhLCBiZXRhID0gYXR0cnMuYmV0YTtcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICdMUk4nKTtcbiAgICB2YXIgY2hhbm5lbHMgPSB4LnNoYXBlWzNdO1xuICAgIHZhciBtYXhEID0gY2hhbm5lbHMgLSAxO1xuICAgIHZhciB4VmFsdWVzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBzaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKHguc2hhcGUpO1xuICAgIHZhciByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIGZ1bmN0aW9uIHN1bUFjcm9zc0NoYW5uZWxzKG9mZnNldCkge1xuICAgICAgICB2YXIgY3VycmVudENoYW5uZWwgPSBvZmZzZXQgJSBjaGFubmVscztcbiAgICAgICAgdmFyIGJlZ2luU3VtT2Zmc2V0ID0gb2Zmc2V0IC0gY3VycmVudENoYW5uZWwgKyBNYXRoLm1heCgwLCBjdXJyZW50Q2hhbm5lbCAtIGRlcHRoUmFkaXVzKTtcbiAgICAgICAgdmFyIGVuZFN1bU9mZnNldCA9IG9mZnNldCAtIGN1cnJlbnRDaGFubmVsICsgTWF0aC5taW4oY3VycmVudENoYW5uZWwgKyBkZXB0aFJhZGl1cywgbWF4RCk7XG4gICAgICAgIHZhciBzdW0gPSAwLjA7XG4gICAgICAgIGZvciAoOyBiZWdpblN1bU9mZnNldCA8PSBlbmRTdW1PZmZzZXQ7IGJlZ2luU3VtT2Zmc2V0KyspIHtcbiAgICAgICAgICAgIHZhciB6ID0geFZhbHVlc1tiZWdpblN1bU9mZnNldF07XG4gICAgICAgICAgICBzdW0gKz0geiAqIHo7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG4gICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgc2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgICAgdmFyIHN1bSA9IHN1bUFjcm9zc0NoYW5uZWxzKG9mZnNldCk7XG4gICAgICAgIHZhciB2YWwgPSB4VmFsdWVzW29mZnNldF0gKiBNYXRoLnBvdyhiaWFzICsgYWxwaGEgKiBzdW0sIC1iZXRhKTtcbiAgICAgICAgcmVzdWx0W29mZnNldF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKHguc2hhcGUsIHguZHR5cGUsIHJlc3VsdCk7XG59XG52YXIgbFJOQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLkxSTixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogbFJOXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBsUk5HcmFkKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54LCB5ID0gaW5wdXRzLnksIGR5ID0gaW5wdXRzLmR5O1xuICAgIHZhciBkZXB0aFJhZGl1cyA9IGF0dHJzLmRlcHRoUmFkaXVzLCBiaWFzID0gYXR0cnMuYmlhcywgYWxwaGEgPSBhdHRycy5hbHBoYSwgYmV0YSA9IGF0dHJzLmJldGE7XG4gICAgYXNzZXJ0Tm90Q29tcGxleChkeSwgJ0xSTkdyYWQnKTtcbiAgICB2YXIgZHlTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKGR5LnNoYXBlKTtcbiAgICB2YXIgY2hhbm5lbHMgPSBkeS5zaGFwZVszXTtcbiAgICB2YXIgZHlWYWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KGR5LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciB4VmFsdWVzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciB5VmFsdWVzID0gYmFja2VuZC5kYXRhLmdldCh5LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGR5U2l6ZSk7XG4gICAgdmFyIHNpemUgPSBkeVNpemU7XG4gICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgc2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRDaGFubmVsID0gb2Zmc2V0ICUgY2hhbm5lbHM7XG4gICAgICAgIHZhciBkZXB0aEJlZ2luID0gKG9mZnNldCAtIGN1cnJlbnRDaGFubmVsKSArIE1hdGgubWF4KDAsIGN1cnJlbnRDaGFubmVsIC0gZGVwdGhSYWRpdXMpO1xuICAgICAgICB2YXIgZGVwdGhFbmQgPSAob2Zmc2V0IC0gY3VycmVudENoYW5uZWwpICtcbiAgICAgICAgICAgIE1hdGgubWluKGNoYW5uZWxzLCBjdXJyZW50Q2hhbm5lbCArIGRlcHRoUmFkaXVzICsgMSk7XG4gICAgICAgIHZhciBub3JtID0gMDtcbiAgICAgICAgZm9yICh2YXIgayA9IGRlcHRoQmVnaW47IGsgPCBkZXB0aEVuZDsgaysrKSB7XG4gICAgICAgICAgICBub3JtICs9IE1hdGgucG93KHhWYWx1ZXNba10sIDIpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm0gPSBhbHBoYSAqIG5vcm0gKyBiaWFzO1xuICAgICAgICBmb3IgKHZhciBrID0gZGVwdGhCZWdpbjsgayA8IGRlcHRoRW5kOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBkeWkgPSAtMiAqIGFscGhhICogYmV0YSAqIHhWYWx1ZXNba10gKiB5VmFsdWVzW29mZnNldF0gLyBub3JtO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gaykge1xuICAgICAgICAgICAgICAgIGR5aSArPSBNYXRoLnBvdyhub3JtLCAtYmV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkeWkgKj0gZHlWYWx1ZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIHJlc3VsdFtrXSArPSBkeWk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oZHkuc2hhcGUsIHguZHR5cGUsIHJlc3VsdCk7XG59XG52YXIgbFJOR3JhZENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5MUk5HcmFkLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBsUk5HcmFkXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBtYXgoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIHJlZHVjdGlvbkluZGljZXMgPSBhdHRycy5yZWR1Y3Rpb25JbmRpY2VzLCBrZWVwRGltcyA9IGF0dHJzLmtlZXBEaW1zO1xuICAgIHZhciBjcHVCYWNrZW5kID0gYmFja2VuZDtcbiAgICB2YXIgeFNoYXBlID0geC5zaGFwZTtcbiAgICB2YXIgeFJhbmsgPSB4U2hhcGUubGVuZ3RoO1xuICAgIHZhciBvcmlnQXhlcyA9IHRmanNDb3JlLnV0aWwucGFyc2VBeGlzUGFyYW0ocmVkdWN0aW9uSW5kaWNlcywgeFNoYXBlKTtcbiAgICB2YXIgYXhlcyA9IG9yaWdBeGVzO1xuICAgIHZhciBwZXJtdXRlZEF4ZXMgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHhSYW5rKTtcbiAgICB2YXIgeFZhbHMgPSBjcHVCYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IG5ldyBBcnJheSh4UmFuayk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1NoYXBlW2ldID0geFNoYXBlW3Blcm11dGVkQXhlc1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgeFZhbHMgPSB0cmFuc3Bvc2VJbXBsKHhWYWxzLCB4U2hhcGUsIHguZHR5cGUsIHBlcm11dGVkQXhlcywgbmV3U2hhcGUpO1xuICAgICAgICBheGVzID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIHhSYW5rKTtcbiAgICAgICAgeFNoYXBlID0gbmV3U2hhcGU7XG4gICAgfVxuICAgIGFzc2VydE5vdENvbXBsZXgoeCwgJ21heCcpO1xuICAgIHRmanNDb3JlLmJhY2tlbmRfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnbWF4JywgYXhlcywgeFJhbmspO1xuICAgIHZhciBfYSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHhTaGFwZSwgYXhlcyksIG1heE91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgdmFyIHJlZHVjZVNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgIHZhciByZXN1bHQgPSBtYXhJbXBsKHhWYWxzLCByZWR1Y2VTaXplLCBtYXhPdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgdmFyIGRhdGFJZCA9IGNwdUJhY2tlbmQud3JpdGUocmVzdWx0LCBtYXhPdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgdmFyIG91dFNoYXBlID0gbWF4T3V0U2hhcGU7XG4gICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIC8vIHJlc2hhcGVcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKG1heE91dFNoYXBlLCBvcmlnQXhlcyk7XG4gICAgICAgIG91dFNoYXBlID0gbmV3U2hhcGU7XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGFJZDogZGF0YUlkLCBzaGFwZTogb3V0U2hhcGUsIGR0eXBlOiB4LmR0eXBlIH07XG59XG52YXIgbWF4Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLk1heCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogbWF4XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBtYXhQb29sKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIGFzc2VydE5vdENvbXBsZXgoeCwgJ21heFBvb2wnKTtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGF0dHJzLmZpbHRlclNpemUsIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZTtcbiAgICB2YXIgZGlsYXRpb25zID0gMTtcbiAgICB0ZmpzQ29yZS51dGlsLmFzc2VydCh0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKHN0cmlkZXMsIGRpbGF0aW9ucyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdFcnJvciBpbiBtYXhQb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiAnICtcbiAgICAgICAgKFwiR290IHN0cmlkZXMgXCIgKyBzdHJpZGVzICsgXCIgYW5kIGRpbGF0aW9ucyAnXCIgKyBkaWxhdGlvbnMgKyBcIidcIik7IH0pO1xuICAgIHZhciBjb252SW5mbyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlUG9vbDJESW5mbyh4LnNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChjb252SW5mby5maWx0ZXJXaWR0aCA9PT0gMSAmJiBjb252SW5mby5maWx0ZXJIZWlnaHQgPT09IDEgJiZcbiAgICAgICAgdGZqc0NvcmUudXRpbC5hcnJheXNFcXVhbChjb252SW5mby5pblNoYXBlLCBjb252SW5mby5vdXRTaGFwZSkpIHtcbiAgICAgICAgcmVzID0gaWRlbnRpdHkoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHhWYWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgICAgIHZhciBzdHJpZGVzXzEgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKHguc2hhcGUpO1xuICAgICAgICB2YXIgYnVmZmVyID0gcG9vbCh4VmFsdWVzLCB4LnNoYXBlLCB4LmR0eXBlLCBzdHJpZGVzXzEsIGNvbnZJbmZvLCAnbWF4Jyk7XG4gICAgICAgIHJlcyA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8oY29udkluZm8ub3V0U2hhcGUsIHguZHR5cGUsIGJ1ZmZlci52YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxudmFyIG1heFBvb2xDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuTWF4UG9vbCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogbWF4UG9vbFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbWF4UG9vbDNEKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBmaWx0ZXJTaXplID0gYXR0cnMuZmlsdGVyU2l6ZSwgc3RyaWRlcyA9IGF0dHJzLnN0cmlkZXMsIHBhZCA9IGF0dHJzLnBhZCwgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlLCBkYXRhRm9ybWF0ID0gYXR0cnMuZGF0YUZvcm1hdCwgZGlsYXRpb25zID0gYXR0cnMuZGlsYXRpb25zO1xuICAgIGFzc2VydE5vdENvbXBsZXgoeCwgJ21heFBvb2wzZCcpO1xuICAgIHZhciAkZGlsYXRpb25zID0gZGlsYXRpb25zO1xuICAgIGlmICgkZGlsYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgJGRpbGF0aW9ucyA9IFsxLCAxLCAxXTtcbiAgICB9XG4gICAgdmFyIGNvbnZJbmZvID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmNvbXB1dGVQb29sM0RJbmZvKHguc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsICRkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlLCBkYXRhRm9ybWF0KTtcbiAgICB2YXIgeFZhbHVlcyA9IGJhY2tlbmQuZGF0YS5nZXQoeC5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgb3V0QnVmID0gcG9vbDNkKHhWYWx1ZXMsIHguc2hhcGUsIHguZHR5cGUsIHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoeC5zaGFwZSksIGNvbnZJbmZvLCAnbWF4Jyk7XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8ob3V0QnVmLnNoYXBlLCAnZmxvYXQzMicsIG91dEJ1Zi52YWx1ZXMpO1xufVxudmFyIG1heFBvb2wzRENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5NYXhQb29sM0QsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IG1heFBvb2wzRFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbWF4UG9vbDNER3JhZChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGR5ID0gaW5wdXRzLmR5LCBpbnB1dCA9IGlucHV0cy5pbnB1dDtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGF0dHJzLmZpbHRlclNpemUsIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGRpbGF0aW9ucyA9IGF0dHJzLmRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlO1xuICAgIGFzc2VydE5vdENvbXBsZXgoW2R5LCBpbnB1dF0sICdtYXhQb29sM0RHcmFkJyk7XG4gICAgdmFyIGNvbnZJbmZvID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmNvbXB1dGVQb29sM0RJbmZvKGlucHV0LnNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB2YXIgaW5wdXRCdWYgPSBiYWNrZW5kLmJ1ZmZlclN5bmMoaW5wdXQpO1xuICAgIHZhciBtYXhQb3NCdWYgPSBtYXhQb29sM2RQb3NpdGlvbnMoaW5wdXRCdWYsIGNvbnZJbmZvKTtcbiAgICB2YXIgc3RyaWRlRGVwdGggPSBjb252SW5mby5zdHJpZGVEZXB0aDtcbiAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgIHZhciBkaWxhdGlvbkRlcHRoID0gY29udkluZm8uZGlsYXRpb25EZXB0aDtcbiAgICB2YXIgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodDtcbiAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgdmFyIGVmZmVjdGl2ZUZpbHRlckRlcHRoID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVyRGVwdGg7XG4gICAgdmFyIGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlckhlaWdodDtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJXaWR0aDtcbiAgICB2YXIgcGFkRnJvbnQgPSBlZmZlY3RpdmVGaWx0ZXJEZXB0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmZyb250O1xuICAgIHZhciBwYWRMZWZ0ID0gZWZmZWN0aXZlRmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgIHZhciBwYWRUb3AgPSBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgdmFyIGR4ID0gdGZqc0NvcmUuYnVmZmVyKGlucHV0LnNoYXBlLCAnZmxvYXQzMicpO1xuICAgIHZhciBkeUJ1ZiA9IGJhY2tlbmQuYnVmZmVyU3luYyhkeSk7XG4gICAgZm9yICh2YXIgYmF0Y2ggPSAwOyBiYXRjaCA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiYXRjaCkge1xuICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrY2hhbm5lbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZHhEZXB0aCA9IDA7IGR4RGVwdGggPCBjb252SW5mby5pbkRlcHRoOyArK2R4RGVwdGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkeFJvdyA9IDA7IGR4Um93IDwgY29udkluZm8uaW5IZWlnaHQ7ICsrZHhSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZHhDb2wgPSAwOyBkeENvbCA8IGNvbnZJbmZvLmluV2lkdGg7ICsrZHhDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWRlciBjb2RlIGJlZ2luc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5RGVwdGhDb3JuZXIgPSBkeERlcHRoIC0gcGFkRnJvbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlSb3dDb3JuZXIgPSBkeFJvdyAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUNvbENvcm5lciA9IGR4Q29sIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdEZXB0aCA9IDA7IHdEZXB0aCA8IGVmZmVjdGl2ZUZpbHRlckRlcHRoOyB3RGVwdGggKz0gZGlsYXRpb25EZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeURlcHRoID0gKGR5RGVwdGhDb3JuZXIgKyB3RGVwdGgpIC8gc3RyaWRlRGVwdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5RGVwdGggPCAwIHx8IGR5RGVwdGggPj0gY29udkluZm8ub3V0RGVwdGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkeURlcHRoKSAhPT0gZHlEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd1JvdyA9IDA7IHdSb3cgPCBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ7IHdSb3cgKz0gZGlsYXRpb25IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5Um93ID0gKGR5Um93Q29ybmVyICsgd1JvdykgLyBzdHJpZGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeVJvdyA8IDAgfHwgZHlSb3cgPj0gY29udkluZm8ub3V0SGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGR5Um93KSAhPT0gZHlSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDb2wgPSAwOyB3Q29sIDwgZWZmZWN0aXZlRmlsdGVyV2lkdGg7IHdDb2wgKz0gZGlsYXRpb25XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5Q29sID0gKGR5Q29sQ29ybmVyICsgd0NvbCkgLyBzdHJpZGVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeUNvbCA8IDAgfHwgZHlDb2wgPj0gY29udkluZm8ub3V0V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGR5Q29sKSAhPT0gZHlDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhQb3MgPSBlZmZlY3RpdmVGaWx0ZXJEZXB0aCAqIGVmZmVjdGl2ZUZpbHRlckhlaWdodCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0aXZlRmlsdGVyV2lkdGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFBvc0J1Zi5nZXQoYmF0Y2gsIGR5RGVwdGgsIGR5Um93LCBkeUNvbCwgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyUG9zID0gd0RlcHRoICogZWZmZWN0aXZlRmlsdGVySGVpZ2h0ICogZWZmZWN0aXZlRmlsdGVyV2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdSb3cgKiBlZmZlY3RpdmVGaWx0ZXJXaWR0aCArIHdDb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFzayA9IG1heFBvcyA9PT0gY3VyUG9zID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFzayA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gZHlCdWYuZ2V0KGJhdGNoLCBkeURlcHRoLCBkeVJvdywgZHlDb2wsIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIG1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkeC5zZXQoZG90UHJvZCwgYmF0Y2gsIGR4RGVwdGgsIGR4Um93LCBkeENvbCwgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oZHguc2hhcGUsIGR4LmR0eXBlLCBkeC52YWx1ZXMpO1xufVxudmFyIG1heFBvb2wzREdyYWRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuTWF4UG9vbDNER3JhZCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogbWF4UG9vbDNER3JhZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbWF4UG9vbEdyYWQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBkeSA9IGlucHV0cy5keSwgaW5wdXQgPSBpbnB1dHMuaW5wdXQsIG91dHB1dCA9IGlucHV0cy5vdXRwdXQ7XG4gICAgdmFyIHggPSBpbnB1dDtcbiAgICBhc3NlcnROb3RDb21wbGV4KFtpbnB1dCwgb3V0cHV0XSwgJ21heFBvb2xHcmFkJyk7XG4gICAgdmFyIGZpbHRlclNpemUgPSBhdHRycy5maWx0ZXJTaXplLCBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBkaW1Sb3VuZGluZ01vZGUgPSBhdHRycy5kaW1Sb3VuZGluZ01vZGU7XG4gICAgdmFyIGNvbnZJbmZvID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmNvbXB1dGVQb29sMkRJbmZvKHguc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIDEgLyogZGlsYXRpb25zICovLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgdmFyIHhWYWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIG1heFBvc0J1ZiA9IHRmanNDb3JlLmJ1ZmZlcihjb252SW5mby5vdXRTaGFwZSwgeC5kdHlwZSwgbWF4UG9vbFBvc2l0aW9ucyh4VmFsdWVzLCB4LnNoYXBlLCB4LmR0eXBlLCBjb252SW5mbykudmFsdWVzKTtcbiAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgIHZhciBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVySGVpZ2h0O1xuICAgIHZhciBlZmZlY3RpdmVGaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlcldpZHRoO1xuICAgIHZhciBwYWRMZWZ0ID0gZWZmZWN0aXZlRmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgIHZhciBwYWRUb3AgPSBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgdmFyIGR4ID0gdGZqc0NvcmUuYnVmZmVyKHguc2hhcGUsICdmbG9hdDMyJyk7XG4gICAgdmFyIGR5RGF0YSA9IGJhY2tlbmQuZGF0YS5nZXQoZHkuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIGR5QnVmID0gdGZqc0NvcmUuYnVmZmVyKGR5LnNoYXBlLCAnZmxvYXQzMicsIGR5RGF0YSk7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZHhSID0gMDsgZHhSIDwgY29udkluZm8uaW5IZWlnaHQ7ICsrZHhSKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZHhDID0gMDsgZHhDIDwgY29udkluZm8uaW5XaWR0aDsgKytkeEMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hhZGVyIGNvZGUgYmVnaW5zLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZHlSQ29ybmVyID0gZHhSIC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHlDQ29ybmVyID0gZHhDIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZWZmZWN0aXZlRmlsdGVySGVpZ2h0OyB3UiArPSBkaWxhdGlvbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UiA9IChkeVJDb3JuZXIgKyB3UikgLyBzdHJpZGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gY29udkluZm8ub3V0SGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkeVIpICE9PSBkeVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBlZmZlY3RpdmVGaWx0ZXJXaWR0aDsgd0MgKz0gZGlsYXRpb25XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUMgPSAoZHlDQ29ybmVyICsgd0MpIC8gc3RyaWRlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IGNvbnZJbmZvLm91dFdpZHRoIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZHlDKSAhPT0gZHlDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4UG9zID0gZWZmZWN0aXZlRmlsdGVySGVpZ2h0ICogZWZmZWN0aXZlRmlsdGVyV2lkdGggLSAxIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4UG9zQnVmLmdldChiLCBkeVIsIGR5QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1clBvcyA9IHdSICogZWZmZWN0aXZlRmlsdGVyV2lkdGggKyB3QztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFzayA9IG1heFBvcyA9PT0gY3VyUG9zID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2sgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGR5QnVmLmdldChiLCBkeVIsIGR5QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIG1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHguc2V0KGRvdFByb2QsIGIsIGR4UiwgZHhDLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oZHguc2hhcGUsIGR4LmR0eXBlLCBkeC52YWx1ZXMpO1xufVxudmFyIG1heFBvb2xHcmFkQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLk1heFBvb2xHcmFkLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBtYXhQb29sR3JhZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbWF4UG9vbFdpdGhBcmdtYXhJbXBsKHhWYWx1ZXMsIHhTaGFwZSwgZHR5cGUsIGluY2x1ZGVCYXRjaEluSW5kZXgsIGNvbnZJbmZvKSB7XG4gICAgdmFyIHN0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKHhTaGFwZSk7XG4gICAgdmFyIG1heFBvb2xzID0gcG9vbCh4VmFsdWVzLCB4U2hhcGUsIGR0eXBlLCBzdHJpZGVzLCBjb252SW5mbywgJ21heCcpO1xuICAgIHZhciBtYXhQb3NpdGlvbnMgPSBtYXhQb29sUG9zaXRpb25zKHhWYWx1ZXMsIHhTaGFwZSwgZHR5cGUsIGNvbnZJbmZvLCB0cnVlLCBpbmNsdWRlQmF0Y2hJbkluZGV4KTtcbiAgICByZXR1cm4gW21heFBvb2xzLnZhbHVlcywgbWF4UG9zaXRpb25zLnZhbHVlc107XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBtYXhQb29sV2l0aEFyZ21heENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5NYXhQb29sV2l0aEFyZ21heCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBfYS5pbnB1dHMsIGF0dHJzID0gX2EuYXR0cnMsIGJhY2tlbmQgPSBfYS5iYWNrZW5kO1xuICAgICAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgICAgICB2YXIgX2IgPSBhdHRycywgZmlsdGVyU2l6ZSA9IF9iLmZpbHRlclNpemUsIHN0cmlkZXMgPSBfYi5zdHJpZGVzLCBwYWQgPSBfYi5wYWQsIGluY2x1ZGVCYXRjaEluSW5kZXggPSBfYi5pbmNsdWRlQmF0Y2hJbkluZGV4O1xuICAgICAgICB2YXIgY3B1QmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgICAgIGFzc2VydE5vdENvbXBsZXgoeCwgJ01heFBvb2xXaXRoQXJnbWF4Jyk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBjcHVCYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgICAgIHZhciBjb252SW5mbyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlUG9vbDJESW5mbyh4LnNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBbMSwgMV0sIHBhZCk7XG4gICAgICAgIHZhciBfYyA9IG1heFBvb2xXaXRoQXJnbWF4SW1wbCh2YWx1ZXMsIHguc2hhcGUsIHguZHR5cGUsIGluY2x1ZGVCYXRjaEluSW5kZXgsIGNvbnZJbmZvKSwgcG9vbGVkID0gX2NbMF0sIGluZGV4ZXMgPSBfY1sxXTtcbiAgICAgICAgdmFyIHBvb2xlZERhdGFJZCA9IGNwdUJhY2tlbmQud3JpdGUocG9vbGVkLCBjb252SW5mby5vdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciBpbmRleGVzRGF0YUlkID0gY3B1QmFja2VuZC53cml0ZShpbmRleGVzLCBjb252SW5mby5vdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IGRhdGFJZDogcG9vbGVkRGF0YUlkLCBzaGFwZTogY29udkluZm8ub3V0U2hhcGUsIGR0eXBlOiB4LmR0eXBlIH0sXG4gICAgICAgICAgICB7IGRhdGFJZDogaW5kZXhlc0RhdGFJZCwgc2hhcGU6IGNvbnZJbmZvLm91dFNoYXBlLCBkdHlwZTogJ2ludDMyJyB9XG4gICAgICAgIF07XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gc3VtKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBheGlzID0gYXR0cnMuYXhpcywga2VlcERpbXMgPSBhdHRycy5rZWVwRGltcztcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICdzdW0nKTtcbiAgICB2YXIgJHg7XG4gICAgaWYgKHguZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAkeCA9IGNhc3QoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBkdHlwZTogJ2ludDMyJyB9IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgJHggPSBpZGVudGl0eSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgfVxuICAgIHZhciB4UmFuayA9ICR4LnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgYXhlcyA9IHRmanNDb3JlLnV0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgJHguc2hhcGUpO1xuICAgIHZhciBwZXJtdXRhdGlvbiA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeFJhbmspO1xuICAgIHZhciByZWR1Y3Rpb25BeGVzID0gYXhlcztcbiAgICB2YXIgcGVybXV0ZWRYID0gJHg7XG4gICAgaWYgKHBlcm11dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgcGVybXV0ZWRYID1cbiAgICAgICAgICAgIHRyYW5zcG9zZSh7IGlucHV0czogeyB4OiAkeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBwZXJtOiBwZXJtdXRhdGlvbiB9IH0pO1xuICAgICAgICByZWR1Y3Rpb25BeGVzID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmdldElubmVyTW9zdEF4ZXMocmVkdWN0aW9uQXhlcy5sZW5ndGgsIHhSYW5rKTtcbiAgICB9XG4gICAgdGZqc0NvcmUuYmFja2VuZF91dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdzdW0nLCByZWR1Y3Rpb25BeGVzLCBwZXJtdXRlZFguc2hhcGUubGVuZ3RoKTtcbiAgICB2YXIgX2EgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhwZXJtdXRlZFguc2hhcGUsIHJlZHVjdGlvbkF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgIHZhciByZXN1bHREdHlwZSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC51cGNhc3RUeXBlKHBlcm11dGVkWC5kdHlwZSwgJ2ludDMyJyk7XG4gICAgdmFyIHJlc3VsdCA9IHplcm9zKGJhY2tlbmQsIG91dFNoYXBlLCByZXN1bHREdHlwZSk7XG4gICAgdmFyIHJlZHVjZVNpemUgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgIHZhciB2YWxzID0gYmFja2VuZC5kYXRhLmdldChyZXN1bHQuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIGFWYWxzID0gYmFja2VuZC5kYXRhLmdldChwZXJtdXRlZFguZGF0YUlkKS52YWx1ZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgdmFyIHN1bV8xID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgIHN1bV8xICs9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICB9XG4gICAgICAgIHZhbHNbaV0gPSBzdW1fMTtcbiAgICB9XG4gICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShyZXN1bHQuc2hhcGUsIGF4ZXMpO1xuICAgICAgICB2YXIgb2xkUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHJlc3VsdCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogbmV3U2hhcGUgfSB9KTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvbGRSZXN1bHQpO1xuICAgIH1cbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKCR4KTtcbiAgICBpZiAocGVybXV0YXRpb24gIT0gbnVsbCkge1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHBlcm11dGVkWCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG52YXIgc3VtQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlN1bSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogc3VtXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBtZWFuKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBheGlzID0gYXR0cnMuYXhpcywga2VlcERpbXMgPSBhdHRycy5rZWVwRGltcztcbiAgICB2YXIgYXhlcyA9IHRmanNDb3JlLnV0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgdmFyIHNoYXBlcyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpO1xuICAgIHZhciByZWR1Y2VTaGFwZSA9IHNoYXBlc1sxXTtcbiAgICB2YXIgcmVkdWNlU2l6ZSA9IHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgdmFyIHRvRGlzcG9zZSA9IFtdO1xuICAgIHZhciByZWR1Y2VTaXplU2NhbGFyID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhbXSwgJ2Zsb2F0MzInLCBuZXcgRmxvYXQzMkFycmF5KFtyZWR1Y2VTaXplXSkpO1xuICAgIHRvRGlzcG9zZS5wdXNoKHJlZHVjZVNpemVTY2FsYXIpO1xuICAgIHZhciAkeCA9IGNhc3QoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBkdHlwZTogJ2Zsb2F0MzInIH0gfSk7XG4gICAgdG9EaXNwb3NlLnB1c2goJHgpO1xuICAgIHZhciByZXMgPSBkaXYoeyBpbnB1dHM6IHsgYTogJHgsIGI6IHJlZHVjZVNpemVTY2FsYXIgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB0b0Rpc3Bvc2UucHVzaChyZXMpO1xuICAgIHZhciByZXN1bHQgPSBzdW0oeyBpbnB1dHM6IHsgeDogcmVzIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGF4aXM6IGF4aXMsIGtlZXBEaW1zOiBrZWVwRGltcyB9IH0pO1xuICAgIHRvRGlzcG9zZS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IHJldHVybiBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHQpOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIG1lYW5Db25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuTWVhbixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogbWVhblxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbWluKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBheGlzID0gYXR0cnMuYXhpcywga2VlcERpbXMgPSBhdHRycy5rZWVwRGltcztcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICdtaW4nKTtcbiAgICB2YXIgb3JpZ0F4ZXMgPSB0ZmpzQ29yZS51dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgIHZhciBheGVzID0gb3JpZ0F4ZXM7XG4gICAgdmFyIHBlcm11dGVkQXhlcyA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5zaGFwZS5sZW5ndGgpO1xuICAgIHZhciAkeCA9IHg7XG4gICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICR4ID0gdHJhbnNwb3NlKHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgcGVybTogcGVybXV0ZWRBeGVzIH0gfSk7XG4gICAgICAgIGF4ZXMgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeC5zaGFwZS5sZW5ndGgpO1xuICAgIH1cbiAgICB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21pbicsIGF4ZXMsICR4LnNoYXBlLmxlbmd0aCk7XG4gICAgdmFyIF9hID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoJHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgIHZhciByZWR1Y2VTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICB2YXIgdmFscyA9IHRmanNDb3JlLnV0aWwubWFrZVplcm9zVHlwZWRBcnJheSh0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUob3V0U2hhcGUpLCAkeC5kdHlwZSk7XG4gICAgdmFyIGFWYWxzID0gYmFja2VuZC5kYXRhLmdldCgkeC5kYXRhSWQpLnZhbHVlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICB2YXIgbWluXzEgPSBhVmFsc1tvZmZzZXRdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYVZhbHNbb2Zmc2V0ICsgal07XG4gICAgICAgICAgICBpZiAodmFsdWUgPCBtaW5fMSkge1xuICAgICAgICAgICAgICAgIG1pbl8xID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsc1tpXSA9IG1pbl8xO1xuICAgIH1cbiAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbygkeCk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dFNoYXBlLCAkeC5kdHlwZSwgdmFscyk7XG4gICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIHZhciBleHBhbmRlZFNoYXBlID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKG91dFNoYXBlLCBvcmlnQXhlcyk7XG4gICAgICAgIHZhciByZXNoYXBlZFJlc3VsdCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogcmVzdWx0IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBleHBhbmRlZFNoYXBlIH0gfSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc2hhcGVkUmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIG1pbkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5NaW4sXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IG1pblxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbWlycm9yUGFkKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBwYWRkaW5ncyA9IGF0dHJzLnBhZGRpbmdzLCBtb2RlID0gYXR0cnMubW9kZTtcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICdtaXJyb3JQYWQnKTtcbiAgICB2YXIgb3V0U2hhcGUgPSBwYWRkaW5ncy5tYXAoZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIHBbMF0gLyogYmVmb3JlUGFkICovICsgeC5zaGFwZVtpXSArIHBbMV07IH0gLyogYWZ0ZXJQYWQgKi8pO1xuICAgIHZhciBzdGFydCA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfSk7XG4gICAgdmFyIGVuZCA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gcFswXSArIHguc2hhcGVbaV07IH0pO1xuICAgIHZhciBvZmZzZXQgPSBtb2RlID09PSAncmVmbGVjdCcgPyAwIDogMTtcbiAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIHhSYW5rID0geC5zaGFwZS5sZW5ndGg7XG4gICAgdmFyIHhTdHJpZGVzID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyh4LnNoYXBlKTtcbiAgICB2YXIgcmVzdWx0U2l6ZSA9IHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZShvdXRTaGFwZSk7XG4gICAgdmFyIHJlc3VsdFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdFN0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKG91dFNoYXBlKTtcbiAgICB2YXIgcmVzVmFscyA9IHRmanNDb3JlLnV0aWwuZ2V0VHlwZWRBcnJheUZyb21EVHlwZSh4LmR0eXBlLCByZXN1bHRTaXplKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdFNpemU7IGkrKykge1xuICAgICAgICB2YXIgY29vcmRzID0gdGZqc0NvcmUudXRpbC5pbmRleFRvTG9jKGksIHJlc3VsdFJhbmssIHJlc3VsdFN0cmlkZXMpO1xuICAgICAgICBmb3IgKHZhciBpXzEgPSAwOyBpXzEgPCByZXN1bHRSYW5rOyBpXzErKykge1xuICAgICAgICAgICAgaWYgKGNvb3Jkc1tpXzFdIDwgc3RhcnRbaV8xXSkge1xuICAgICAgICAgICAgICAgIGNvb3Jkc1tpXzFdID0gc3RhcnRbaV8xXSAqIDIgLSBjb29yZHNbaV8xXSAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvb3Jkc1tpXzFdID49IGVuZFtpXzFdKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzW2lfMV0gPSAoZW5kW2lfMV0gLSAxKSAqIDIgLSBjb29yZHNbaV8xXSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb29yZHMgPSBjb29yZHMubWFwKGZ1bmN0aW9uIChjLCBpKSB7IHJldHVybiBjIC0gc3RhcnRbaV07IH0pO1xuICAgICAgICB2YXIgaW5JbmRleCA9IHRmanNDb3JlLnV0aWwubG9jVG9JbmRleChjb29yZHMsIHhSYW5rLCB4U3RyaWRlcyk7XG4gICAgICAgIHJlc1ZhbHNbaV0gPSB4VmFsc1tpbkluZGV4XTtcbiAgICB9XG4gICAgdmFyIG91dElkID0gYmFja2VuZC53cml0ZShyZXNWYWxzLCBvdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgcmV0dXJuIHsgZGF0YUlkOiBvdXRJZCwgc2hhcGU6IG91dFNoYXBlLCBkdHlwZTogeC5kdHlwZSB9O1xufVxudmFyIG1pcnJvclBhZENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5NaXJyb3JQYWQsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IG1pcnJvclBhZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIG1vZEltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKChmdW5jdGlvbiAoYVZhbHVlLCBiVmFsdWUpIHtcbiAgICB2YXIgcmVtID0gYVZhbHVlICUgYlZhbHVlO1xuICAgIGlmICgoYVZhbHVlIDwgMCAmJiBiVmFsdWUgPCAwKSB8fCAoYVZhbHVlID49IDAgJiYgYlZhbHVlID49IDApKSB7XG4gICAgICAgIHJldHVybiByZW07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKHJlbSArIGJWYWx1ZSkgJSBiVmFsdWU7XG4gICAgfVxufSkpO1xudmFyIG1vZCA9IGJpbmFyeUtlcm5lbEZ1bmModGZqc0NvcmUuTW9kLCBtb2RJbXBsKTtcbnZhciBtb2RDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuTW9kLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBtb2Rcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHNvZnRtYXgoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBsb2dpdHMgPSBpbnB1dHMubG9naXRzO1xuICAgIHZhciBkaW0gPSBhdHRycy5kaW07XG4gICAgdmFyIGxvZ2l0c1JhbmsgPSBsb2dpdHMuc2hhcGUubGVuZ3RoO1xuICAgIHZhciAkZGltID0gZGltO1xuICAgIGlmICgkZGltID09PSAtMSkge1xuICAgICAgICAkZGltID0gbG9naXRzUmFuayAtIDE7XG4gICAgfVxuICAgIGlmICgkZGltICE9PSBsb2dpdHNSYW5rIC0gMSkge1xuICAgICAgICB0aHJvdyBFcnJvcignU29mdG1heCBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gJyArXG4gICAgICAgICAgICAoXCJMb2dpdHMgd2FzIHJhbmsgXCIgKyBsb2dpdHNSYW5rICsgXCIgYW5kIGRpbSB3YXMgXCIgKyAkZGltKSk7XG4gICAgfVxuICAgIHZhciBheGVzID0gdGZqc0NvcmUudXRpbC5wYXJzZUF4aXNQYXJhbShbJGRpbV0sIGxvZ2l0cy5zaGFwZSk7XG4gICAgdmFyIG1heExvZ2l0ID0gbWF4KHtcbiAgICAgICAgaW5wdXRzOiB7IHg6IGxvZ2l0cyB9LFxuICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICBhdHRyczogeyByZWR1Y3Rpb25JbmRpY2VzOiBheGVzLCBrZWVwRGltczogZmFsc2UgfVxuICAgIH0pO1xuICAgIHZhciBleHBhbmRlZFNoYXBlID0gdGZqc0NvcmUuYmFja2VuZF91dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKG1heExvZ2l0LnNoYXBlLCBheGVzKTtcbiAgICB2YXIgbWF4TG9naXRSZXNoYXBlZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogbWF4TG9naXQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IGV4cGFuZGVkU2hhcGUgfSB9KTtcbiAgICB2YXIgYSA9IHN1Yih7IGlucHV0czogeyBhOiBsb2dpdHMsIGI6IG1heExvZ2l0UmVzaGFwZWQgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB2YXIgYiA9IGV4cCh7IGlucHV0czogeyB4OiBhIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgdmFyIHN1bUV4cCA9IHN1bSh7IGlucHV0czogeyB4OiBiIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGF4aXM6IGF4ZXMsIGtlZXBEaW1zOiBmYWxzZSB9IH0pO1xuICAgIHZhciBzdW1SZXNoYXBlZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogc3VtRXhwIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBleHBhbmRlZFNoYXBlIH0gfSk7XG4gICAgdmFyIHJlc3VsdCA9IGRpdih7IGlucHV0czogeyBhOiBiLCBiOiBzdW1SZXNoYXBlZCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obWF4TG9naXQpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obWF4TG9naXRSZXNoYXBlZCk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhhKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGIpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oc3VtRXhwKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHN1bVJlc2hhcGVkKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIHNvZnRtYXhDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuU29mdG1heCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogc29mdG1heFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbXVsdGlub21pYWwoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBsb2dpdHMgPSBpbnB1dHMubG9naXRzO1xuICAgIHZhciBudW1TYW1wbGVzID0gYXR0cnMubnVtU2FtcGxlcywgc2VlZCA9IGF0dHJzLnNlZWQsIG5vcm1hbGl6ZWQgPSBhdHRycy5ub3JtYWxpemVkO1xuICAgIGFzc2VydE5vdENvbXBsZXgobG9naXRzLCAnbXVsdGlub21pYWwnKTtcbiAgICB2YXIgcHJvYmFiaWxpdGllcyA9IG5vcm1hbGl6ZWQgP1xuICAgICAgICBsb2dpdHMgOlxuICAgICAgICBzb2Z0bWF4KHsgaW5wdXRzOiB7IGxvZ2l0czogbG9naXRzIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGRpbTogLTEgfSB9KTtcbiAgICB2YXIgYmF0Y2hTaXplID0gcHJvYmFiaWxpdGllcy5zaGFwZVswXTtcbiAgICB2YXIgbnVtRXZlbnRzID0gcHJvYmFiaWxpdGllcy5zaGFwZVsxXTtcbiAgICB2YXIgcHJvYlZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHByb2JhYmlsaXRpZXMuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIHJlc1NoYXBlID0gW2JhdGNoU2l6ZSwgbnVtU2FtcGxlc107XG4gICAgdmFyIHJlc1ZhbHMgPSB0ZmpzQ29yZS51dGlsLm1ha2VaZXJvc1R5cGVkQXJyYXkodGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKHJlc1NoYXBlKSwgJ2ludDMyJyk7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaFNpemU7ICsrYikge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gYiAqIG51bUV2ZW50cztcbiAgICAgICAgLy8gVGhlIGNkZiB3b24ndCBpbmNsdWRlIHRoZSBsYXN0IGV2ZW50LiBJdCB3aWxsIGJlIGltcGxpY2l0IGlmIG5vIG90aGVyXG4gICAgICAgIC8vIGV2ZW50IGhhcHBlbmVkLlxuICAgICAgICB2YXIgY2RmID0gbmV3IEZsb2F0MzJBcnJheShudW1FdmVudHMgLSAxKTtcbiAgICAgICAgY2RmWzBdID0gcHJvYlZhbHNbb2Zmc2V0XTtcbiAgICAgICAgZm9yICh2YXIgZXZlbnRfMSA9IDE7IGV2ZW50XzEgPCBjZGYubGVuZ3RoOyArK2V2ZW50XzEpIHtcbiAgICAgICAgICAgIGNkZltldmVudF8xXSA9IGNkZltldmVudF8xIC0gMV0gKyBwcm9iVmFsc1tvZmZzZXQgKyBldmVudF8xXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZG9tID0gc2VlZHJhbmRvbS5hbGVhKHNlZWQudG9TdHJpbmcoKSk7XG4gICAgICAgIHZhciBvdXRPZmZzZXQgPSBiICogbnVtU2FtcGxlcztcbiAgICAgICAgZm9yICh2YXIgc2FtcGxlSWQgPSAwOyBzYW1wbGVJZCA8IG51bVNhbXBsZXM7ICsrc2FtcGxlSWQpIHtcbiAgICAgICAgICAgIHZhciByID0gcmFuZG9tKCk7XG4gICAgICAgICAgICAvLyBBc3N1bWUgbGFzdCBldmVudCBoYXBwZW5lZCBieSBkZWZhdWx0LlxuICAgICAgICAgICAgcmVzVmFsc1tvdXRPZmZzZXQgKyBzYW1wbGVJZF0gPSBjZGYubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRfMiA9IDA7IGV2ZW50XzIgPCBjZGYubGVuZ3RoOyBldmVudF8yKyspIHtcbiAgICAgICAgICAgICAgICBpZiAociA8IGNkZltldmVudF8yXSkge1xuICAgICAgICAgICAgICAgICAgICByZXNWYWxzW291dE9mZnNldCArIHNhbXBsZUlkXSA9IGV2ZW50XzI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5vcm1hbGl6ZWQpIHtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwcm9iYWJpbGl0aWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8ocmVzU2hhcGUsICdpbnQzMicsIHJlc1ZhbHMpO1xufVxudmFyIG11bHRpbm9taWFsQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLk11bHRpbm9taWFsLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBtdWx0aW5vbWlhbFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIG5vbk1heFN1cHByZXNzaW9uVjNJbXBsID0gdGZqc0NvcmUua2VybmVsX2ltcGxzLm5vbk1heFN1cHByZXNzaW9uVjNJbXBsO1xuZnVuY3Rpb24gbm9uTWF4U3VwcHJlc3Npb25WMyhhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGJveGVzID0gaW5wdXRzLmJveGVzLCBzY29yZXMgPSBpbnB1dHMuc2NvcmVzO1xuICAgIHZhciBtYXhPdXRwdXRTaXplID0gYXR0cnMubWF4T3V0cHV0U2l6ZSwgaW91VGhyZXNob2xkID0gYXR0cnMuaW91VGhyZXNob2xkLCBzY29yZVRocmVzaG9sZCA9IGF0dHJzLnNjb3JlVGhyZXNob2xkO1xuICAgIGFzc2VydE5vdENvbXBsZXgoYm94ZXMsICdOb25NYXhTdXBwcmVzc2lvbicpO1xuICAgIHZhciBib3hlc1ZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KGJveGVzLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBzY29yZXNWYWxzID0gYmFja2VuZC5kYXRhLmdldChzY29yZXMuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIHNlbGVjdGVkSW5kaWNlcyA9IG5vbk1heFN1cHByZXNzaW9uVjNJbXBsKGJveGVzVmFscywgc2NvcmVzVmFscywgbWF4T3V0cHV0U2l6ZSwgaW91VGhyZXNob2xkLCBzY29yZVRocmVzaG9sZCkuc2VsZWN0ZWRJbmRpY2VzO1xuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtzZWxlY3RlZEluZGljZXMubGVuZ3RoXSwgJ2ludDMyJywgbmV3IEludDMyQXJyYXkoc2VsZWN0ZWRJbmRpY2VzKSk7XG59XG52YXIgbm9uTWF4U3VwcHJlc3Npb25WM0NvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Ob25NYXhTdXBwcmVzc2lvblYzLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBub25NYXhTdXBwcmVzc2lvblYzXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgbm9uTWF4U3VwcHJlc3Npb25WNEltcGwgPSB0ZmpzQ29yZS5rZXJuZWxfaW1wbHMubm9uTWF4U3VwcHJlc3Npb25WNEltcGw7XG5mdW5jdGlvbiBub25NYXhTdXBwcmVzc2lvblY0KGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgYm94ZXMgPSBpbnB1dHMuYm94ZXMsIHNjb3JlcyA9IGlucHV0cy5zY29yZXM7XG4gICAgdmFyIG1heE91dHB1dFNpemUgPSBhdHRycy5tYXhPdXRwdXRTaXplLCBpb3VUaHJlc2hvbGQgPSBhdHRycy5pb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkID0gYXR0cnMuc2NvcmVUaHJlc2hvbGQsIHBhZFRvTWF4T3V0cHV0U2l6ZSA9IGF0dHJzLnBhZFRvTWF4T3V0cHV0U2l6ZTtcbiAgICBhc3NlcnROb3RDb21wbGV4KGJveGVzLCAnTm9uTWF4U3VwcHJlc3Npb25QYWRkZWQnKTtcbiAgICB2YXIgYm94ZXNWYWxzID0gYmFja2VuZC5kYXRhLmdldChib3hlcy5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgc2NvcmVzVmFscyA9IGJhY2tlbmQuZGF0YS5nZXQoc2NvcmVzLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBfYSA9IG5vbk1heFN1cHByZXNzaW9uVjRJbXBsKGJveGVzVmFscywgc2NvcmVzVmFscywgbWF4T3V0cHV0U2l6ZSwgaW91VGhyZXNob2xkLCBzY29yZVRocmVzaG9sZCwgcGFkVG9NYXhPdXRwdXRTaXplKSwgc2VsZWN0ZWRJbmRpY2VzID0gX2Euc2VsZWN0ZWRJbmRpY2VzLCB2YWxpZE91dHB1dHMgPSBfYS52YWxpZE91dHB1dHM7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYmFja2VuZC5tYWtlVGVuc29ySW5mbyhbc2VsZWN0ZWRJbmRpY2VzLmxlbmd0aF0sICdpbnQzMicsIG5ldyBJbnQzMkFycmF5KHNlbGVjdGVkSW5kaWNlcykpLFxuICAgICAgICBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtdLCAnaW50MzInLCBuZXcgSW50MzJBcnJheShbdmFsaWRPdXRwdXRzXSkpXG4gICAgXTtcbn1cbnZhciBub25NYXhTdXBwcmVzc2lvblY0Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLk5vbk1heFN1cHByZXNzaW9uVjQsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IG5vbk1heFN1cHByZXNzaW9uVjRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBub25NYXhTdXBwcmVzc2lvblY1SW1wbCA9IHRmanNDb3JlLmtlcm5lbF9pbXBscy5ub25NYXhTdXBwcmVzc2lvblY1SW1wbDtcbmZ1bmN0aW9uIG5vbk1heFN1cHByZXNzaW9uVjUoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBib3hlcyA9IGlucHV0cy5ib3hlcywgc2NvcmVzID0gaW5wdXRzLnNjb3JlcztcbiAgICB2YXIgbWF4T3V0cHV0U2l6ZSA9IGF0dHJzLm1heE91dHB1dFNpemUsIGlvdVRocmVzaG9sZCA9IGF0dHJzLmlvdVRocmVzaG9sZCwgc2NvcmVUaHJlc2hvbGQgPSBhdHRycy5zY29yZVRocmVzaG9sZCwgc29mdE5tc1NpZ21hID0gYXR0cnMuc29mdE5tc1NpZ21hO1xuICAgIGFzc2VydE5vdENvbXBsZXgoYm94ZXMsICdOb25NYXhTdXBwcmVzc2lvbldpdGhTY29yZScpO1xuICAgIHZhciBib3hlc1ZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KGJveGVzLmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBzY29yZXNWYWxzID0gYmFja2VuZC5kYXRhLmdldChzY29yZXMuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIG1heE91dHB1dFNpemVWYWwgPSBtYXhPdXRwdXRTaXplO1xuICAgIHZhciBpb3VUaHJlc2hvbGRWYWwgPSBpb3VUaHJlc2hvbGQ7XG4gICAgdmFyIHNjb3JlVGhyZXNob2xkVmFsID0gc2NvcmVUaHJlc2hvbGQ7XG4gICAgdmFyIHNvZnRObXNTaWdtYVZhbCA9IHNvZnRObXNTaWdtYTtcbiAgICB2YXIgX2EgPSBub25NYXhTdXBwcmVzc2lvblY1SW1wbChib3hlc1ZhbHMsIHNjb3Jlc1ZhbHMsIG1heE91dHB1dFNpemVWYWwsIGlvdVRocmVzaG9sZFZhbCwgc2NvcmVUaHJlc2hvbGRWYWwsIHNvZnRObXNTaWdtYVZhbCksIHNlbGVjdGVkSW5kaWNlcyA9IF9hLnNlbGVjdGVkSW5kaWNlcywgc2VsZWN0ZWRTY29yZXMgPSBfYS5zZWxlY3RlZFNjb3JlcztcbiAgICByZXR1cm4gW1xuICAgICAgICBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtzZWxlY3RlZEluZGljZXMubGVuZ3RoXSwgJ2ludDMyJywgbmV3IEludDMyQXJyYXkoc2VsZWN0ZWRJbmRpY2VzKSksXG4gICAgICAgIGJhY2tlbmQubWFrZVRlbnNvckluZm8oW3NlbGVjdGVkU2NvcmVzLmxlbmd0aF0sICdmbG9hdDMyJywgbmV3IEZsb2F0MzJBcnJheShzZWxlY3RlZFNjb3JlcykpXG4gICAgXTtcbn1cbnZhciBub25NYXhTdXBwcmVzc2lvblY1Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLk5vbk1heFN1cHByZXNzaW9uVjUsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IG5vbk1heFN1cHByZXNzaW9uVjVcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIG9uZUhvdChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGluZGljZXMgPSBpbnB1dHMuaW5kaWNlcztcbiAgICB2YXIgZGVwdGggPSBhdHRycy5kZXB0aCwgb25WYWx1ZSA9IGF0dHJzLm9uVmFsdWUsIG9mZlZhbHVlID0gYXR0cnMub2ZmVmFsdWU7XG4gICAgYXNzZXJ0Tm90Q29tcGxleChpbmRpY2VzLCAnb25lSG90Jyk7XG4gICAgdmFyIGluZGljZXNTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKGluZGljZXMuc2hhcGUpO1xuICAgIHZhciByZXMgPSBuZXcgRmxvYXQzMkFycmF5KGluZGljZXNTaXplICogZGVwdGgpO1xuICAgIHJlcy5maWxsKG9mZlZhbHVlKTtcbiAgICB2YXIgaW5kaWNlc1ZhbCA9IGJhY2tlbmQuZGF0YS5nZXQoaW5kaWNlcy5kYXRhSWQpLnZhbHVlcztcbiAgICBmb3IgKHZhciBldmVudF8xID0gMDsgZXZlbnRfMSA8IGluZGljZXNTaXplOyArK2V2ZW50XzEpIHtcbiAgICAgICAgaWYgKGluZGljZXNWYWxbZXZlbnRfMV0gPj0gMCAmJiBpbmRpY2VzVmFsW2V2ZW50XzFdIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIHJlc1tldmVudF8xICogZGVwdGggKyBpbmRpY2VzVmFsW2V2ZW50XzFdXSA9IG9uVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oaW5kaWNlcy5zaGFwZS5jb25jYXQoW2RlcHRoXSksICdpbnQzMicsIHJlcyk7XG59XG52YXIgb25lSG90Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLk9uZUhvdCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogb25lSG90XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiB6ZXJvc0xpa2UoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIGlmICh4LmR0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3plcm9zTGlrZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBzdHJpbmcgdGVuc29ycycpO1xuICAgIH1cbiAgICBlbHNlIGlmICh4LmR0eXBlID09PSAnY29tcGxleDY0Jykge1xuICAgICAgICB2YXIgcmVhbFBhcnQgPSByZWFsKHsgaW5wdXRzOiB7IGlucHV0OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIHZhciByID0gemVyb3NMaWtlKHsgaW5wdXRzOiB7IHg6IHJlYWxQYXJ0IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIHZhciBpbWFnUGFydCA9IGltYWcoeyBpbnB1dHM6IHsgaW5wdXQ6IHggfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgdmFyIGkgPSB6ZXJvc0xpa2UoeyBpbnB1dHM6IHsgeDogaW1hZ1BhcnQgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBsZXgoeyBpbnB1dHM6IHsgcmVhbDogciwgaW1hZzogaSB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlYWxQYXJ0KTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyKTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpbWFnUGFydCk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmlsbCh7IGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiB4LnNoYXBlLCB2YWx1ZTogMCwgZHR5cGU6IHguZHR5cGUgfSB9KTtcbiAgICB9XG59XG52YXIgemVyb3NMaWtlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlplcm9zTGlrZSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogemVyb3NMaWtlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBvbmVzTGlrZShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgaWYgKHguZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb25lc0xpa2UgaXMgbm90IHN1cHBvcnRlZCBmb3Igc3RyaW5nIHRlbnNvcnMnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeC5kdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgICAgdmFyIHJlYWxQYXJ0ID0gcmVhbCh7IGlucHV0czogeyBpbnB1dDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICB2YXIgciA9IG9uZXNMaWtlKHsgaW5wdXRzOiB7IHg6IHJlYWxQYXJ0IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIHZhciBpbWFnUGFydCA9IGltYWcoeyBpbnB1dHM6IHsgaW5wdXQ6IHggfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgdmFyIGkgPSB6ZXJvc0xpa2UoeyBpbnB1dHM6IHsgeDogaW1hZ1BhcnQgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBsZXgoeyBpbnB1dHM6IHsgcmVhbDogciwgaW1hZzogaSB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlYWxQYXJ0KTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyKTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpbWFnUGFydCk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmlsbCh7IGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiB4LnNoYXBlLCB2YWx1ZTogMSwgZHR5cGU6IHguZHR5cGUgfSB9KTtcbiAgICB9XG59XG52YXIgb25lc0xpa2VDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuT25lc0xpa2UsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IG9uZXNMaWtlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBwYWNrKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgYXhpcyA9IGF0dHJzLmF4aXM7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZERpbXMoeyBpbnB1dHM6IHsgaW5wdXQ6IGlucHV0c1swXSB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBkaW06IGF4aXMgfSB9KTtcbiAgICB9XG4gICAgdmFyIHNoYXBlID0gaW5wdXRzWzBdLnNoYXBlO1xuICAgIHZhciBkdHlwZSA9IGlucHV0c1swXS5kdHlwZTtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB0ZmpzQ29yZS51dGlsLmFzc2VydFNoYXBlc01hdGNoKHNoYXBlLCB0LnNoYXBlLCAnQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBzaGFwZXMnKTtcbiAgICAgICAgdGZqc0NvcmUudXRpbC5hc3NlcnQoZHR5cGUgPT09IHQuZHR5cGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIGR0eXBlcyc7IH0pO1xuICAgIH0pO1xuICAgIHZhciBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcyA9IFtdO1xuICAgIHZhciBleHBhbmRlZFRlbnNvcnMgPSBpbnB1dHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBleHBhbmRlZFQgPSBleHBhbmREaW1zKHsgaW5wdXRzOiB7IGlucHV0OiB0IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGRpbTogYXhpcyB9IH0pO1xuICAgICAgICBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcy5wdXNoKGV4cGFuZGVkVCk7XG4gICAgICAgIHJldHVybiBleHBhbmRlZFQ7XG4gICAgfSk7XG4gICAgdmFyIHJlc3VsdCA9IGNvbmNhdCh7IGlucHV0czogZXhwYW5kZWRUZW5zb3JzLCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBheGlzOiBheGlzIH0gfSk7XG4gICAgaW50ZXJtZWRpYXRlVGVuc29ySW5mb3MuZm9yRWFjaChmdW5jdGlvbiAodCkgeyByZXR1cm4gYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh0KTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBwYWNrQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlBhY2ssXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IHBhY2tcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHBhZFYyKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBwYWRkaW5ncyA9IGF0dHJzLnBhZGRpbmdzLCBjb25zdGFudFZhbHVlID0gYXR0cnMuY29uc3RhbnRWYWx1ZTtcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICdwYWQnKTtcbiAgICB2YXIgb3V0U2hhcGUgPSBwYWRkaW5ncy5tYXAoZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIHBbMF0gLyogYmVmb3JlUGFkICovICsgeC5zaGFwZVtpXSArIHBbMV07IH0gLyogYWZ0ZXJQYWQgKi8pO1xuICAgIHZhciBzdGFydCA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfSk7XG4gICAgdmFyIHhWYWxzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciB4U2l6ZSA9IHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZSh4LnNoYXBlKTtcbiAgICB2YXIgeFJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgeFN0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKHguc2hhcGUpO1xuICAgIHZhciByZXN1bHRTaXplID0gdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKG91dFNoYXBlKTtcbiAgICB2YXIgcmVzdWx0UmFuayA9IG91dFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0U3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMob3V0U2hhcGUpO1xuICAgIHZhciByZXNWYWxzID0gdGZqc0NvcmUudXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKHguZHR5cGUsIHJlc3VsdFNpemUpO1xuICAgIGlmIChjb25zdGFudFZhbHVlICE9PSAwKSB7XG4gICAgICAgIHJlc1ZhbHMuZmlsbChjb25zdGFudFZhbHVlKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4U2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB0ZmpzQ29yZS51dGlsLmluZGV4VG9Mb2MoaSwgeFJhbmssIHhTdHJpZGVzKTtcbiAgICAgICAgdmFyIG91dENvb3JkcyA9IGNvb3Jkcy5tYXAoZnVuY3Rpb24gKGMsIGkpIHsgcmV0dXJuIGMgKyBzdGFydFtpXTsgfSk7XG4gICAgICAgIHZhciBvdXRJbmRleCA9IHRmanNDb3JlLnV0aWwubG9jVG9JbmRleChvdXRDb29yZHMsIHJlc3VsdFJhbmssIHJlc3VsdFN0cmlkZXMpO1xuICAgICAgICByZXNWYWxzW291dEluZGV4XSA9IHhWYWxzW2ldO1xuICAgIH1cbiAgICB2YXIgb3V0SWQgPSBiYWNrZW5kLndyaXRlKHJlc1ZhbHMsIG91dFNoYXBlLCB4LmR0eXBlKTtcbiAgICByZXR1cm4geyBkYXRhSWQ6IG91dElkLCBzaGFwZTogb3V0U2hhcGUsIGR0eXBlOiB4LmR0eXBlIH07XG59XG52YXIgcGFkVjJDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuUGFkVjIsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IHBhZFYyXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgcG93SW1wbCA9IGNyZWF0ZVNpbXBsZUJpbmFyeUtlcm5lbEltcGwoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE1hdGgucG93KGEsIGIpOyB9KTtcbnZhciBwb3cgPSBiaW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLlBvdywgcG93SW1wbCk7XG52YXIgcG93Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlBvdyxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogcG93XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiByYW5nZShhcmdzKSB7XG4gICAgdmFyIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgc3RhcnQgPSBhdHRycy5zdGFydCwgc3RvcCA9IGF0dHJzLnN0b3AsIGR0eXBlID0gYXR0cnMuZHR5cGUsIHN0ZXAgPSBhdHRycy5zdGVwO1xuICAgIHZhciB2YWx1ZXMgPSByYW5nZUltcGwoc3RhcnQsIHN0b3AsIHN0ZXAsIGR0eXBlKTtcbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhbdmFsdWVzLmxlbmd0aF0sIGR0eXBlLCB2YWx1ZXMpO1xufVxudmFyIHJhbmdlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlJhbmdlLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiByYW5nZVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciByZWNpcHJvY2FsID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLlJlY2lwcm9jYWwsIGZ1bmN0aW9uICh4aSkgeyByZXR1cm4gMSAvIHhpOyB9KTtcbnZhciByZWNpcHJvY2FsQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlJlY2lwcm9jYWwsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IHJlY2lwcm9jYWwsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiByZXNpemVCaWxpbmVhcihhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGltYWdlcyA9IGlucHV0cy5pbWFnZXM7XG4gICAgdmFyIGFsaWduQ29ybmVycyA9IGF0dHJzLmFsaWduQ29ybmVycywgaGFsZlBpeGVsQ2VudGVycyA9IGF0dHJzLmhhbGZQaXhlbENlbnRlcnMsIHNpemUgPSBhdHRycy5zaXplO1xuICAgIGFzc2VydE5vdENvbXBsZXgoaW1hZ2VzLCAncmVzaXplQmlsaW5lYXInKTtcbiAgICB2YXIgaW1hZ2VzU3RyaWRlcyA9IHRmanNDb3JlLnV0aWwuY29tcHV0ZVN0cmlkZXMoaW1hZ2VzLnNoYXBlKTtcbiAgICB2YXIgbmV3SGVpZ2h0ID0gc2l6ZVswXSwgbmV3V2lkdGggPSBzaXplWzFdO1xuICAgIHZhciBfYSA9IGltYWdlcy5zaGFwZSwgYmF0Y2ggPSBfYVswXSwgb2xkSGVpZ2h0ID0gX2FbMV0sIG9sZFdpZHRoID0gX2FbMl0sIG51bUNoYW5uZWxzID0gX2FbM107XG4gICAgdmFyIHhWYWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KGltYWdlcy5kYXRhSWQpLnZhbHVlcztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSh0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUoW2JhdGNoLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBudW1DaGFubmVsc10pKTtcbiAgICB2YXIgZWZmZWN0aXZlSW5wdXRTaXplID0gW1xuICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld0hlaWdodCA+IDEpID8gb2xkSGVpZ2h0IC0gMSA6IG9sZEhlaWdodCxcbiAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdXaWR0aCA+IDEpID8gb2xkV2lkdGggLSAxIDogb2xkV2lkdGhcbiAgICBdO1xuICAgIHZhciBlZmZlY3RpdmVPdXRwdXRTaXplID0gW1xuICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld0hlaWdodCA+IDEpID8gbmV3SGVpZ2h0IC0gMSA6IG5ld0hlaWdodCxcbiAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdXaWR0aCA+IDEpID8gbmV3V2lkdGggLSAxIDogbmV3V2lkdGhcbiAgICBdO1xuICAgIHZhciBvdXRwdXRJZHggPSAwO1xuICAgIHZhciBlZmZlY3RpdmVSb3dTaXplUmF0aW8gPSBlZmZlY3RpdmVJbnB1dFNpemVbMF0gLyBlZmZlY3RpdmVPdXRwdXRTaXplWzBdO1xuICAgIHZhciBlZmZlY3RpdmVDb2xTaXplUmF0aW8gPSBlZmZlY3RpdmVJbnB1dFNpemVbMV0gLyBlZmZlY3RpdmVPdXRwdXRTaXplWzFdO1xuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYmF0Y2g7IGIrKykge1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG5ld0hlaWdodDsgcisrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlRnJhY1JvdyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChoYWxmUGl4ZWxDZW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgc291cmNlRnJhY1JvdyA9IGVmZmVjdGl2ZVJvd1NpemVSYXRpbyAqIChyICsgMC41KSAtIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZUZyYWNSb3cgPSBlZmZlY3RpdmVSb3dTaXplUmF0aW8gKiByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvdXJjZVJvd0Zsb29yID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihzb3VyY2VGcmFjUm93KSk7XG4gICAgICAgICAgICB2YXIgcm93RnJhYyA9IHNvdXJjZUZyYWNSb3cgLSBzb3VyY2VSb3dGbG9vcjtcbiAgICAgICAgICAgIHZhciBzb3VyY2VSb3dDZWlsID0gTWF0aC5taW4ob2xkSGVpZ2h0IC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNSb3cpKTtcbiAgICAgICAgICAgIHZhciB0b3BSb3dPZmZzZXQgPSBiICogaW1hZ2VzU3RyaWRlc1swXSArIHNvdXJjZVJvd0Zsb29yICogaW1hZ2VzU3RyaWRlc1sxXTtcbiAgICAgICAgICAgIHZhciBib3RSb3dPZmZzZXQgPSBiICogaW1hZ2VzU3RyaWRlc1swXSArIHNvdXJjZVJvd0NlaWwgKiBpbWFnZXNTdHJpZGVzWzFdO1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBuZXdXaWR0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUZyYWNDb2wgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGhhbGZQaXhlbENlbnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRnJhY0NvbCA9IGVmZmVjdGl2ZUNvbFNpemVSYXRpbyAqIChjICsgMC41KSAtIDAuNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUZyYWNDb2wgPSBlZmZlY3RpdmVDb2xTaXplUmF0aW8gKiBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc291cmNlQ29sRmxvb3IgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHNvdXJjZUZyYWNDb2wpKTtcbiAgICAgICAgICAgICAgICB2YXIgY29sRnJhYyA9IHNvdXJjZUZyYWNDb2wgLSBzb3VyY2VDb2xGbG9vcjtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlQ29sQ2VpbCA9IE1hdGgubWluKG9sZFdpZHRoIC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNDb2wpKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9wTGVmdE9mZmVzdCA9IHRvcFJvd09mZnNldCArIHNvdXJjZUNvbEZsb29yICogaW1hZ2VzU3RyaWRlc1syXTtcbiAgICAgICAgICAgICAgICB2YXIgYm90TGVmdE9mZnNldCA9IGJvdFJvd09mZnNldCArIHNvdXJjZUNvbEZsb29yICogaW1hZ2VzU3RyaWRlc1syXTtcbiAgICAgICAgICAgICAgICB2YXIgdG9wUmlnaHRPZmZzZXQgPSB0b3BSb3dPZmZzZXQgKyBzb3VyY2VDb2xDZWlsICogaW1hZ2VzU3RyaWRlc1syXTtcbiAgICAgICAgICAgICAgICB2YXIgYm90UmlnaHRPZmZlc3QgPSBib3RSb3dPZmZzZXQgKyBzb3VyY2VDb2xDZWlsICogaW1hZ2VzU3RyaWRlc1syXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IG51bUNoYW5uZWxzOyBkKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVnaW4gc2hhZGVyLlxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBmcmFjdGlvbmFsIGluZGV4IG9mIHRoZSBzb3VyY2UuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BMZWZ0ID0geFZhbHVlc1t0b3BMZWZ0T2ZmZXN0ICsgZF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3R0b21MZWZ0ID0geFZhbHVlc1tib3RMZWZ0T2Zmc2V0ICsgZF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BSaWdodCA9IHhWYWx1ZXNbdG9wUmlnaHRPZmZzZXQgKyBkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0geFZhbHVlc1tib3RSaWdodE9mZmVzdCArIGRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wXzEgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBjb2xGcmFjO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogY29sRnJhYztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9wXzEgKyAoYm90dG9tIC0gdG9wXzEpICogcm93RnJhYztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W291dHB1dElkeCsrXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhbYmF0Y2gsIG5ld0hlaWdodCwgbmV3V2lkdGgsIG51bUNoYW5uZWxzXSwgJ2Zsb2F0MzInLCByZXN1bHQpO1xufVxudmFyIHJlc2l6ZUJpbGluZWFyQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlJlc2l6ZUJpbGluZWFyLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiByZXNpemVCaWxpbmVhclxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gcmVzaXplQmlsaW5lYXJHcmFkKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgaW1hZ2VzID0gaW5wdXRzLmltYWdlcywgZHkgPSBpbnB1dHMuZHk7XG4gICAgdmFyIGFsaWduQ29ybmVycyA9IGF0dHJzLmFsaWduQ29ybmVycztcbiAgICBhc3NlcnROb3RDb21wbGV4KFtkeSwgaW1hZ2VzXSwgJ3Jlc2l6ZUJpbGluZWFyR3JhZCcpO1xuICAgIHZhciBpbWFnZXNTdHJpZGVzID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyhpbWFnZXMuc2hhcGUpO1xuICAgIHZhciBfYSA9IGltYWdlcy5zaGFwZSwgYmF0Y2ggPSBfYVswXSwgeEhlaWdodCA9IF9hWzFdLCB4V2lkdGggPSBfYVsyXSwgZGVwdGggPSBfYVszXTtcbiAgICB2YXIgX2IgPSBkeS5zaGFwZSwgeUhlaWdodCA9IF9iWzFdLCB5V2lkdGggPSBfYlsyXTtcbiAgICB2YXIgb3V0cHV0ID0gbmV3IEZsb2F0MzJBcnJheShiYXRjaCAqIHhIZWlnaHQgKiB4V2lkdGggKiBkZXB0aCk7XG4gICAgLy8gSW4gdGhlIGJhY2t3YXJkcyBwYXNzLCB3ZSB3YW50IHRvIGZpbmQgdGhlIHBpeGVscyB0aGF0IHdlcmUgZ2VuZXJhdGVkXG4gICAgLy8gZm9yIGVhY2ggcGl4ZWwgaW4gdGhlIGlucHV0IGltYWdlIHRoZSBmb3J3YXJkIHBhc3MgYW5kIGFkZCB0aGVcbiAgICAvLyBjb3JyZXNwb25kaW5nIGNvZWZmaWNpZW50IGZyb20gZHkgdG8gdGhlIGdyYWRpZW50ICh3aXRoIHNvbWVcbiAgICAvLyBpbnRlcnBvbGF0aW9uKS5cbiAgICB2YXIgZWZmZWN0aXZlWFNpemUgPSBbXG4gICAgICAgIChhbGlnbkNvcm5lcnMgJiYgeUhlaWdodCA+IDEpID8geEhlaWdodCAtIDEgOiB4SGVpZ2h0LFxuICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlXaWR0aCA+IDEpID8geFdpZHRoIC0gMSA6IHhXaWR0aFxuICAgIF07XG4gICAgdmFyIGVmZmVjdGl2ZVlTaXplID0gW1xuICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlIZWlnaHQgPiAxKSA/IHlIZWlnaHQgLSAxIDogeUhlaWdodCxcbiAgICAgICAgKGFsaWduQ29ybmVycyAmJiB5V2lkdGggPiAxKSA/IHlXaWR0aCAtIDEgOiB5V2lkdGhcbiAgICBdO1xuICAgIHZhciBoZWlnaHRTY2FsZSA9IGVmZmVjdGl2ZVhTaXplWzBdIC8gZWZmZWN0aXZlWVNpemVbMF07XG4gICAgdmFyIHdpZHRoU2NhbGUgPSBlZmZlY3RpdmVYU2l6ZVsxXSAvIGVmZmVjdGl2ZVlTaXplWzFdO1xuICAgIC8vIFJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvblxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZW5zb3JmbG93L2Jsb2IvMzAzOTM3NWM4NmE1YmJjOTYxMGM3NzI1ZGNhYTk1ZDYzNWY4N2JhMi90ZW5zb3JmbG93L2NvcmUva2VybmVscy9yZXNpemVfYmlsaW5lYXJfb3AuY2MjTDI3NVxuICAgIHZhciBkeVZhbHVlcyA9IGJhY2tlbmQuZGF0YS5nZXQoZHkuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaDsgYisrKSB7XG4gICAgICAgIHZhciBiT2Zmc2V0ID0gYiAqIGltYWdlc1N0cmlkZXNbMF07XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgeUhlaWdodDsgcisrKSB7XG4gICAgICAgICAgICB2YXIgZHhSID0gciAqIGhlaWdodFNjYWxlO1xuICAgICAgICAgICAgdmFyIHRvcER4UkluZGV4ID0gTWF0aC5mbG9vcihkeFIpO1xuICAgICAgICAgICAgdmFyIGJvdHRvbUR4UkluZGV4ID0gTWF0aC5taW4oTWF0aC5jZWlsKGR4UiksIHhIZWlnaHQgLSAxKTtcbiAgICAgICAgICAgIHZhciB0b3BEeFJPZmZzZXQgPSBiT2Zmc2V0ICsgdG9wRHhSSW5kZXggKiBpbWFnZXNTdHJpZGVzWzFdO1xuICAgICAgICAgICAgdmFyIGJvdHRvbUR4Uk9mZnNldCA9IGJPZmZzZXQgKyBib3R0b21EeFJJbmRleCAqIGltYWdlc1N0cmlkZXNbMV07XG4gICAgICAgICAgICB2YXIgZHhSTGVycCA9IGR4UiAtIHRvcER4UkluZGV4O1xuICAgICAgICAgICAgdmFyIGludmVyc2VEeFJMZXJwID0gMS4wIC0gZHhSTGVycDtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgeVdpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZHhDID0gYyAqIHdpZHRoU2NhbGU7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnREeENJbmRleCA9IE1hdGguZmxvb3IoZHhDKTtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHREeENJbmRleCA9IE1hdGgubWluKE1hdGguY2VpbChkeEMpLCB4V2lkdGggLSAxKTtcbiAgICAgICAgICAgICAgICB2YXIgZHhDTGVycCA9IGR4QyAtIGxlZnREeENJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgaW52ZXJzZUR4Q0xlcnAgPSAxLjAgLSBkeENMZXJwO1xuICAgICAgICAgICAgICAgIHZhciB0b3BMZWZ0UkNPZmZzZXQgPSB0b3BEeFJPZmZzZXQgKyBsZWZ0RHhDSW5kZXggKiBpbWFnZXNTdHJpZGVzWzJdO1xuICAgICAgICAgICAgICAgIHZhciB0b3BSaWdodFJDT2Zmc2V0ID0gdG9wRHhST2Zmc2V0ICsgcmlnaHREeENJbmRleCAqIGltYWdlc1N0cmlkZXNbMl07XG4gICAgICAgICAgICAgICAgdmFyIGJvdHRvbUxlZnRSQ09mZnNldCA9IGJvdHRvbUR4Uk9mZnNldCArIGxlZnREeENJbmRleCAqIGltYWdlc1N0cmlkZXNbMl07XG4gICAgICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0UkNPZmZzZXQgPSBib3R0b21EeFJPZmZzZXQgKyByaWdodER4Q0luZGV4ICogaW1hZ2VzU3RyaWRlc1syXTtcbiAgICAgICAgICAgICAgICB2YXIgaW52ZXJzZUR4UkxlcnBUaW1lc0ludmVyc2VEeENMZXJwID0gaW52ZXJzZUR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcbiAgICAgICAgICAgICAgICB2YXIgaW52ZXJzZUR4UkxlcnBUaW1lc0R4Q0xlcnAgPSBpbnZlcnNlRHhSTGVycCAqIGR4Q0xlcnA7XG4gICAgICAgICAgICAgICAgdmFyIGR4UkxlcnBUaW1lc0ludmVyc2VEeENMZXJwID0gZHhSTGVycCAqIGludmVyc2VEeENMZXJwO1xuICAgICAgICAgICAgICAgIHZhciBkeFJMZXJwVGltZXNEeENMZXJwID0gZHhSTGVycCAqIGR4Q0xlcnA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeVZhbCA9IGR5VmFsdWVzW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W3RvcExlZnRSQ09mZnNldCArIGRdICs9XG4gICAgICAgICAgICAgICAgICAgICAgICBkeVZhbCAqIGludmVyc2VEeFJMZXJwVGltZXNJbnZlcnNlRHhDTGVycDtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W3RvcFJpZ2h0UkNPZmZzZXQgKyBkXSArPSBkeVZhbCAqIGludmVyc2VEeFJMZXJwVGltZXNEeENMZXJwO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbYm90dG9tTGVmdFJDT2Zmc2V0ICsgZF0gKz0gZHlWYWwgKiBkeFJMZXJwVGltZXNJbnZlcnNlRHhDTGVycDtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2JvdHRvbVJpZ2h0UkNPZmZzZXQgKyBkXSArPSBkeVZhbCAqIGR4UkxlcnBUaW1lc0R4Q0xlcnA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtiYXRjaCwgeFdpZHRoLCB4SGVpZ2h0LCBkZXB0aF0sICdmbG9hdDMyJywgb3V0cHV0KTtcbn1cbnZhciByZXNpemVCaWxpbmVhckdyYWRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuUmVzaXplQmlsaW5lYXJHcmFkLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiByZXNpemVCaWxpbmVhckdyYWRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcihhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGltYWdlcyA9IGlucHV0cy5pbWFnZXM7XG4gICAgdmFyIGFsaWduQ29ybmVycyA9IGF0dHJzLmFsaWduQ29ybmVycywgaGFsZlBpeGVsQ2VudGVycyA9IGF0dHJzLmhhbGZQaXhlbENlbnRlcnMsIHNpemUgPSBhdHRycy5zaXplO1xuICAgIGFzc2VydE5vdENvbXBsZXgoaW1hZ2VzLCAncmVzaXplTmVhcmVzdE5laWdoYm9yJyk7XG4gICAgdmFyIGltYWdlc1N0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKGltYWdlcy5zaGFwZSk7XG4gICAgdmFyIG5ld0hlaWdodCA9IHNpemVbMF0sIG5ld1dpZHRoID0gc2l6ZVsxXTtcbiAgICB2YXIgX2EgPSBpbWFnZXMuc2hhcGUsIGJhdGNoID0gX2FbMF0sIG9sZEhlaWdodCA9IF9hWzFdLCBvbGRXaWR0aCA9IF9hWzJdLCBudW1DaGFubmVscyA9IF9hWzNdO1xuICAgIHZhciB4VmFsdWVzID0gYmFja2VuZC5kYXRhLmdldChpbWFnZXMuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIG91dHB1dCA9IG5ldyBGbG9hdDMyQXJyYXkoYmF0Y2ggKiBuZXdIZWlnaHQgKiBuZXdXaWR0aCAqIG51bUNoYW5uZWxzKTtcbiAgICB2YXIgZWZmZWN0aXZlSW5wdXRTaXplID0gW1xuICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld0hlaWdodCA+IDEpID8gb2xkSGVpZ2h0IC0gMSA6IG9sZEhlaWdodCxcbiAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdXaWR0aCA+IDEpID8gb2xkV2lkdGggLSAxIDogb2xkV2lkdGhcbiAgICBdO1xuICAgIHZhciBlZmZlY3RpdmVPdXRwdXRTaXplID0gW1xuICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld0hlaWdodCA+IDEpID8gbmV3SGVpZ2h0IC0gMSA6IG5ld0hlaWdodCxcbiAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdXaWR0aCA+IDEpID8gbmV3V2lkdGggLSAxIDogbmV3V2lkdGhcbiAgICBdO1xuICAgIHZhciBlZmZlY3RpdmVSb3dTaXplUmF0aW8gPSBlZmZlY3RpdmVJbnB1dFNpemVbMF0gLyBlZmZlY3RpdmVPdXRwdXRTaXplWzBdO1xuICAgIHZhciBlZmZlY3RpdmVDb2xTaXplUmF0aW8gPSBlZmZlY3RpdmVJbnB1dFNpemVbMV0gLyBlZmZlY3RpdmVPdXRwdXRTaXplWzFdO1xuICAgIHZhciBvdXRwdXRPZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYmF0Y2g7IGIrKykge1xuICAgICAgICB2YXIgYmF0Y2hPZmZzZXQgPSBiICogaW1hZ2VzU3RyaWRlc1swXTtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBuZXdIZWlnaHQ7IHIrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZUZyYWNSb3cgPSBoYWxmUGl4ZWxDZW50ZXJzID9cbiAgICAgICAgICAgICAgICBlZmZlY3RpdmVSb3dTaXplUmF0aW8gKiAociArIDAuNSkgOlxuICAgICAgICAgICAgICAgIGVmZmVjdGl2ZVJvd1NpemVSYXRpbyAqIHI7XG4gICAgICAgICAgICB2YXIgc291cmNlTmVhcmVzdFJvdyA9IE1hdGgubWluKG9sZEhlaWdodCAtIDEsIGFsaWduQ29ybmVycyA/IE1hdGgucm91bmQoc291cmNlRnJhY1JvdykgOiBNYXRoLmZsb29yKHNvdXJjZUZyYWNSb3cpKTtcbiAgICAgICAgICAgIGlmIChoYWxmUGl4ZWxDZW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgc291cmNlTmVhcmVzdFJvdyA9IE1hdGgubWF4KDAsIHNvdXJjZU5lYXJlc3RSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvd09mZnNldCA9IGJhdGNoT2Zmc2V0ICsgc291cmNlTmVhcmVzdFJvdyAqIGltYWdlc1N0cmlkZXNbMV07XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG5ld1dpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY0NvbCA9IGhhbGZQaXhlbENlbnRlcnMgP1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3RpdmVDb2xTaXplUmF0aW8gKiAoYyArIDAuNSkgOlxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RpdmVDb2xTaXplUmF0aW8gKiBjO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VOZWFyZXN0Q29sID0gTWF0aC5taW4ob2xkV2lkdGggLSAxLCBhbGlnbkNvcm5lcnMgPyBNYXRoLnJvdW5kKHNvdXJjZUZyYWNDb2wpIDpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihzb3VyY2VGcmFjQ29sKSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbGZQaXhlbENlbnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTmVhcmVzdENvbCA9IE1hdGgubWF4KDAsIHNvdXJjZU5lYXJlc3RDb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29sT2Zmc2V0ID0gcm93T2Zmc2V0ICsgc291cmNlTmVhcmVzdENvbCAqIGltYWdlc1N0cmlkZXNbMl07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBudW1DaGFubmVsczsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJlZ2luIHNoYWRlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZnJhY3Rpb25hbCBpbmRleCBvZiB0aGUgc291cmNlLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsID0geFZhbHVlc1tjb2xPZmZzZXQgKyBkXTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W291dHB1dE9mZnNldCsrXSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oW2JhdGNoLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBudW1DaGFubmVsc10sIGltYWdlcy5kdHlwZSwgb3V0cHV0KTtcbn1cbnZhciByZXNpemVOZWFyZXN0TmVpZ2hib3JDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuUmVzaXplTmVhcmVzdE5laWdoYm9yLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiByZXNpemVOZWFyZXN0TmVpZ2hib3Jcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBpbWFnZXMgPSBpbnB1dHMuaW1hZ2VzLCBkeSA9IGlucHV0cy5keTtcbiAgICB2YXIgYWxpZ25Db3JuZXJzID0gYXR0cnMuYWxpZ25Db3JuZXJzO1xuICAgIGFzc2VydE5vdENvbXBsZXgoW2R5LCBpbWFnZXNdLCAncmVzaXplTmVhcmVzdE5laWdoYm9yR3JhZCcpO1xuICAgIHZhciBpbWFnZXNTdHJpZGVzID0gdGZqc0NvcmUudXRpbC5jb21wdXRlU3RyaWRlcyhpbWFnZXMuc2hhcGUpO1xuICAgIHZhciBkeVN0cmlkZXMgPSB0ZmpzQ29yZS51dGlsLmNvbXB1dGVTdHJpZGVzKGR5LnNoYXBlKTtcbiAgICB2YXIgX2EgPSBpbWFnZXMuc2hhcGUsIGJhdGNoID0gX2FbMF0sIHhIZWlnaHQgPSBfYVsxXSwgeFdpZHRoID0gX2FbMl0sIGRlcHRoID0gX2FbM107XG4gICAgdmFyIF9iID0gZHkuc2hhcGUsIHlIZWlnaHQgPSBfYlsxXSwgeVdpZHRoID0gX2JbMl07XG4gICAgdmFyIG91dHB1dCA9IG5ldyBGbG9hdDMyQXJyYXkoYmF0Y2ggKiB4SGVpZ2h0ICogeFdpZHRoICogZGVwdGgpO1xuICAgIHZhciBkeVZhbHVlcyA9IGJhY2tlbmQuZGF0YS5nZXQoZHkuZGF0YUlkKS52YWx1ZXM7XG4gICAgLy8gSW4gdGhlIGJhY2t3YXJkcyBwYXNzLCB3ZSB3YW50IHRvIGZpbmQgdGhlIHBpeGVscyB0aGF0IHdlcmUgZ2VuZXJhdGVkXG4gICAgLy8gZm9yIGVhY2ggcGl4ZWwgaW4gdGhlIGlucHV0IGltYWdlIHRoZSBmb3J3YXJkIHBhc3NcbiAgICB2YXIgZWZmZWN0aXZlWFNpemUgPSBbXG4gICAgICAgIChhbGlnbkNvcm5lcnMgJiYgeUhlaWdodCA+IDEpID8geEhlaWdodCAtIDEgOiB4SGVpZ2h0LFxuICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlXaWR0aCA+IDEpID8geFdpZHRoIC0gMSA6IHhXaWR0aFxuICAgIF07XG4gICAgdmFyIGVmZmVjdGl2ZVlTaXplID0gW1xuICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlIZWlnaHQgPiAxKSA/IHlIZWlnaHQgLSAxIDogeUhlaWdodCxcbiAgICAgICAgKGFsaWduQ29ybmVycyAmJiB5V2lkdGggPiAxKSA/IHlXaWR0aCAtIDEgOiB5V2lkdGhcbiAgICBdO1xuICAgIHZhciBoZWlnaHRTY2FsZSA9IGVmZmVjdGl2ZVhTaXplWzBdIC8gZWZmZWN0aXZlWVNpemVbMF07XG4gICAgdmFyIHdpZHRoU2NhbGUgPSBlZmZlY3RpdmVYU2l6ZVsxXSAvIGVmZmVjdGl2ZVlTaXplWzFdO1xuICAgIHZhciBpbnZIZWlnaHRTY2FsZSA9IDEgLyBoZWlnaHRTY2FsZTtcbiAgICB2YXIgaW52V2lkdGhTY2FsZSA9IDEgLyB3aWR0aFNjYWxlO1xuICAgIC8vIFRoaXMgZGVmaW5lcyB0aGUgc2l6ZSBvZiB0aGUgd2luZG93IG9mIHZhbHVlcyBhcm91bmQgYSBwYXJ0aWN1bGFyXG4gICAgLy8gaW5kZXggaW4gZHkgdGhhdCB3ZSB3YW50IHRvIHNlYXJjaCBmb3IgY29udHJpYnV0aW9ucyB0byBkeC5cbiAgICB2YXIgd2luSGVpZ2h0ID0gKE1hdGguY2VpbChpbnZIZWlnaHRTY2FsZSkgKiAyKSArIDI7XG4gICAgdmFyIHdpbldpZHRoID0gKE1hdGguY2VpbChpbnZXaWR0aFNjYWxlKSAqIDIpICsgMjtcbiAgICAvLyBMb29wIG92ZXIgdGhlIG91dHB1dCBzcGFjZS5cbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoOyBiKyspIHtcbiAgICAgICAgdmFyIGJhdGNoT2Zmc2V0ID0gYiAqIGltYWdlc1N0cmlkZXNbMF07XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgeEhlaWdodDsgcisrKSB7XG4gICAgICAgICAgICB2YXIgcm93T2Zmc2V0ID0gYmF0Y2hPZmZzZXQgKyByICogaW1hZ2VzU3RyaWRlc1sxXTtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgYm91bmRzIGZvciB3aGVyZSBpbiBkeSB3ZSB3aWxsIGxvb2tcbiAgICAgICAgICAgIHZhciBzdGFydFJMZXJwID0gTWF0aC5mbG9vcihyICogaW52SGVpZ2h0U2NhbGUpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0RHlSID0gTWF0aC5mbG9vcihzdGFydFJMZXJwIC0gKHdpbkhlaWdodCAvIDIpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgeFdpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sT2Zmc2V0ID0gcm93T2Zmc2V0ICsgYyAqIGltYWdlc1N0cmlkZXNbMl07XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBib3VuZHMgZm9yIHdoZXJlIGluIGR5IHdlIHdpbGwgbG9va1xuICAgICAgICAgICAgICAgIHZhciBzdGFydENMZXJwID0gTWF0aC5mbG9vcihjICogaW52V2lkdGhTY2FsZSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RHlDID0gTWF0aC5mbG9vcihzdGFydENMZXJwIC0gKHdpbldpZHRoIC8gMikpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGVwdGg7IGQrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWNjdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBsb29wIG92ZXIgZHlcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZHlSSW5kZXggPSAwOyBkeVJJbmRleCA8IHdpbkhlaWdodDsgZHlSSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UiA9IGR5UkluZGV4ICsgc3RhcnREeVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSB5SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlST2Zmc2V0ID0gYmF0Y2hPZmZzZXQgKyBkeVIgKiBkeVN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY1JvdyA9IGR5UiAqIGhlaWdodFNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU5lYXJlc3RSb3cgPSBNYXRoLm1pbih4SGVpZ2h0IC0gMSwgYWxpZ25Db3JuZXJzID8gTWF0aC5yb3VuZChzb3VyY2VGcmFjUm93KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihzb3VyY2VGcmFjUm93KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociAhPT0gc291cmNlTmVhcmVzdFJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZHlDSW5kZXggPSAwOyBkeUNJbmRleCA8IHdpbldpZHRoOyBkeUNJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5QyA9IGR5Q0luZGV4ICsgc3RhcnREeUM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IHlXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5Q09mZnNldCA9IGR5Uk9mZnNldCArIGR5QyAqIGR5U3RyaWRlc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY0NvbCA9IGR5QyAqIHdpZHRoU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU5lYXJlc3RDb2wgPSBNYXRoLm1pbih4V2lkdGggLSAxLCBhbGlnbkNvcm5lcnMgPyBNYXRoLnJvdW5kKHNvdXJjZUZyYWNDb2wpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihzb3VyY2VGcmFjQ29sKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IHNvdXJjZU5lYXJlc3RDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW0gKz0gZHlWYWx1ZXNbZHlDT2Zmc2V0ICsgZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtjb2xPZmZzZXQgKyBkXSA9IGFjY3VtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhpbWFnZXMuc2hhcGUsIGltYWdlcy5kdHlwZSwgb3V0cHV0KTtcbn1cbnZhciByZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWQsXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IHJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHJldmVyc2UoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGRpbXMgPSBhdHRycy5kaW1zO1xuICAgIGFzc2VydE5vdENvbXBsZXgoeCwgJ3JldmVyc2UnKTtcbiAgICB2YXIgeFJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgJGRpbXMgPSB0ZmpzQ29yZS51dGlsLnBhcnNlQXhpc1BhcmFtKGRpbXMsIHguc2hhcGUpO1xuICAgIGlmICh4UmFuayA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHkoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgIH1cbiAgICB2YXIgb3V0QnVmID0gbmV3IHRmanNDb3JlLlRlbnNvckJ1ZmZlcih4LnNoYXBlLCB4LmR0eXBlKTtcbiAgICB2YXIgeEJ1ZiA9IGJhY2tlbmQuYnVmZmVyU3luYyh4KTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBvdXRMb2MgPSBvdXRCdWYuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgdmFyIGluTG9jID0gb3V0TG9jLnNsaWNlKCk7XG4gICAgICAgICRkaW1zLmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGluTG9jW2RdID0geC5zaGFwZVtkXSAtIDEgLSBpbkxvY1tkXTsgfSk7XG4gICAgICAgIG91dEJ1Zi5zZXQuYXBwbHkob3V0QnVmLCBbeEJ1Zi5nZXQuYXBwbHkoeEJ1ZiwgaW5Mb2MpXS5jb25jYXQob3V0TG9jKSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dEJ1Zi5zaXplOyBpKyspIHtcbiAgICAgICAgX2xvb3BfMShpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8ob3V0QnVmLnNoYXBlLCBvdXRCdWYuZHR5cGUsIG91dEJ1Zi52YWx1ZXMpO1xufVxudmFyIHJldmVyc2VDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuUmV2ZXJzZSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogcmV2ZXJzZVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIHJvdGF0ZVdpdGhPZmZzZXRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuUm90YXRlV2l0aE9mZnNldCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBfYS5pbnB1dHMsIGF0dHJzID0gX2EuYXR0cnMsIGJhY2tlbmQgPSBfYS5iYWNrZW5kO1xuICAgICAgICB2YXIgaW1hZ2UgPSBpbnB1dHMuaW1hZ2U7XG4gICAgICAgIHZhciBfYiA9IGF0dHJzLCByYWRpYW5zID0gX2IucmFkaWFucywgZmlsbFZhbHVlID0gX2IuZmlsbFZhbHVlLCBjZW50ZXIgPSBfYi5jZW50ZXI7XG4gICAgICAgIHZhciBjcHVCYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRmanNDb3JlLnV0aWwuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShpbWFnZS5kdHlwZSwgdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKGltYWdlLnNoYXBlKSk7XG4gICAgICAgIHZhciBfYyA9IGltYWdlLnNoYXBlLCBiYXRjaCA9IF9jWzBdLCBpbWFnZUhlaWdodCA9IF9jWzFdLCBpbWFnZVdpZHRoID0gX2NbMl0sIG51bUNoYW5uZWxzID0gX2NbM107XG4gICAgICAgIHZhciBfZCA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5nZXRJbWFnZUNlbnRlcihjZW50ZXIsIGltYWdlSGVpZ2h0LCBpbWFnZVdpZHRoKSwgY2VudGVyWCA9IF9kWzBdLCBjZW50ZXJZID0gX2RbMV07XG4gICAgICAgIHZhciBmdWxsT3BhY2l0eVZhbHVlID0gMjU1O1xuICAgICAgICB2YXIgc2luRmFjdG9yID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgICAgIHZhciBjb3NGYWN0b3IgPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgICAgICAgdmFyIGltYWdlVmFscyA9IGNwdUJhY2tlbmQuZGF0YS5nZXQoaW1hZ2UuZGF0YUlkKS52YWx1ZXM7XG4gICAgICAgIGZvciAodmFyIGJhdGNoSWR4ID0gMDsgYmF0Y2hJZHggPCBiYXRjaDsgYmF0Y2hJZHgrKykge1xuICAgICAgICAgICAgdmFyIGJhdGNoT2Zmc2V0ID0gYmF0Y2hJZHggKiBpbWFnZVdpZHRoICogaW1hZ2VIZWlnaHQgKiBudW1DaGFubmVscztcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGltYWdlSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgIHZhciByb3dPZmZzZXQgPSByb3cgKiAoaW1hZ2VXaWR0aCAqIG51bUNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBpbWFnZVdpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sT2Zmc2V0ID0gY29sICogbnVtQ2hhbm5lbHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgbnVtQ2hhbm5lbHM7IGNoYW5uZWwrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IFtiYXRjaCwgcm93LCBjb2wsIGNoYW5uZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBjb29yZHNbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGNvb3Jkc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvb3JkWC9jb29yZFkgYXJlIHRoZSByZXN1bHQgb2Ygcm90YXRpbmcgYW5kIHRyYW5zbGF0aW5nIHgveS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZFggPSAoeCAtIGNlbnRlclgpICogY29zRmFjdG9yIC0gKHkgLSBjZW50ZXJZKSAqIHNpbkZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZFkgPSAoeCAtIGNlbnRlclgpICogc2luRmFjdG9yICsgKHkgLSBjZW50ZXJZKSAqIGNvc0ZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkWCA9IE1hdGgucm91bmQoY29vcmRYICsgY2VudGVyWCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZFkgPSBNYXRoLnJvdW5kKGNvb3JkWSArIGNlbnRlclkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dFZhbHVlID0gZmlsbFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxsVmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VmFsdWUgPSBmdWxsT3BhY2l0eVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VmFsdWUgPSBmaWxsVmFsdWVbY2hhbm5lbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvb3JkaW5hdGUgcG9zaXRpb24gZmFsbHMgd2l0aGluIHRoZSBpbWFnZSBib3VuZGFyaWVzLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRYID49IDAgJiYgY29vcmRYIDwgaW1hZ2VXaWR0aCAmJiBjb29yZFkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkWSA8IGltYWdlSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBvdXRwdXQgdG8gdGhlIGltYWdlIHZhbHVlIGF0IHRoZSBjb29yZGluYXRlIHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGVkUm93T2Zmc2V0ID0gY29vcmRZICogKGltYWdlV2lkdGggKiBudW1DaGFubmVscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0ZWRDb2xPZmZzZXQgPSBjb29yZFggKiBudW1DaGFubmVscztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VJZHggPSBiYXRjaE9mZnNldCArIHJvdGF0ZWRSb3dPZmZzZXQgKyByb3RhdGVkQ29sT2Zmc2V0ICsgY2hhbm5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRWYWx1ZSA9IGltYWdlVmFsc1tpbWFnZUlkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0SWR4ID0gYmF0Y2hPZmZzZXQgKyByb3dPZmZzZXQgKyBjb2xPZmZzZXQgKyBjaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W291dElkeF0gPSBvdXRwdXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YUlkID0gY3B1QmFja2VuZC53cml0ZShvdXRwdXQsIGltYWdlLnNoYXBlLCBpbWFnZS5kdHlwZSk7XG4gICAgICAgIHJldHVybiB7IGRhdGFJZDogZGF0YUlkLCBzaGFwZTogaW1hZ2Uuc2hhcGUsIGR0eXBlOiBpbWFnZS5kdHlwZSB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgcm91bmQgPSB1bmFyeUtlcm5lbEZ1bmModGZqc0NvcmUuUm91bmQsIGZ1bmN0aW9uICh4aSkge1xuICAgIC8vIFRoZSBhbGdvcml0aG0gaXMgYmFzZWQgb24gYmFua2VyJ3Mgcm91bmRpbmcuXG4gICAgdmFyIGJhc2UgPSBNYXRoLmZsb29yKHhpKTtcbiAgICBpZiAoeGkgLSBiYXNlIDwgMC41KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHhpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeGkgLSBiYXNlID4gMC41KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoeGkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGJhc2UgJSAyLjAgPT09IDAuMCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZSArIDEuMDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xudmFyIHJvdW5kQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlJvdW5kLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiByb3VuZCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHNjYXR0ZXJJbXBsKGluZGljZXMsIHVwZGF0ZXMsIHNoYXBlLCBvdXRwdXRTaXplLCBzbGljZVNpemUsIG51bVVwZGF0ZXMsIHNsaWNlUmFuaywgc3RyaWRlcywgZGVmYXVsdFZhbHVlLCBzdW1EdXBlSW5kaWNlcykge1xuICAgIHZhciBmbGF0dGVuU2hhcGUgPSBbb3V0cHV0U2l6ZSAvIHNsaWNlU2l6ZSwgc2xpY2VTaXplXTtcbiAgICB2YXIgaW5kaWNlc0RhdGEgPSBpbmRpY2VzLnZhbHVlcztcbiAgICB2YXIgdXBkYXRlc0RhdGEgPSB1cGRhdGVzLnZhbHVlcztcbiAgICBpZiAob3V0cHV0U2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGZqc0NvcmUuYnVmZmVyKHNoYXBlLCB1cGRhdGVzLmR0eXBlKTtcbiAgICB9XG4gICAgdmFyIG91dEJ1ZiA9IHRmanNDb3JlLmJ1ZmZlcihmbGF0dGVuU2hhcGUsIHVwZGF0ZXMuZHR5cGUpO1xuICAgIG91dEJ1Zi52YWx1ZXMuZmlsbChkZWZhdWx0VmFsdWUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVXBkYXRlczsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IFtdO1xuICAgICAgICB2YXIgZmxhdHRlbkluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzbGljZVJhbms7IGorKykge1xuICAgICAgICAgICAgdmFyIGRpbSA9IGluZGljZXNEYXRhW2kgKiBzbGljZVJhbmsgKyBqXTtcbiAgICAgICAgICAgIGluZGV4LnB1c2goZGltKTtcbiAgICAgICAgICAgIGZsYXR0ZW5JbmRleCArPSBkaW0gKiBzdHJpZGVzW2pdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGF0dGVuSW5kZXggPCAwIHx8IGZsYXR0ZW5JbmRleCA+PSBvdXRwdXRTaXplIC8gc2xpY2VTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGljZXM6IFwiICsgaW5kZXggKyBcIiBkb2VzIG5vdCBpbmRleCBpbnRvIFwiICsgc2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2xpY2VTaXplOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChzdW1EdXBlSW5kaWNlcykge1xuICAgICAgICAgICAgICAgIG91dEJ1Zi52YWx1ZXNbZmxhdHRlbkluZGV4ICogc2xpY2VTaXplICsga10gKz1cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlc0RhdGFbaSAqIHNsaWNlU2l6ZSArIGtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0QnVmLnZhbHVlc1tmbGF0dGVuSW5kZXggKiBzbGljZVNpemUgKyBrXSA9IHVwZGF0ZXMucmFuayA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZXNEYXRhWzBdIDpcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlc0RhdGFbaSAqIHNsaWNlU2l6ZSArIGtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRCdWY7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHNjYXR0ZXJOZChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGluZGljZXMgPSBpbnB1dHMuaW5kaWNlcywgdXBkYXRlcyA9IGlucHV0cy51cGRhdGVzO1xuICAgIHZhciBzaGFwZSA9IGF0dHJzLnNoYXBlO1xuICAgIHZhciBfYSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5jYWxjdWxhdGVTaGFwZXModXBkYXRlcywgaW5kaWNlcywgc2hhcGUpLCBzbGljZVJhbmsgPSBfYS5zbGljZVJhbmssIG51bVVwZGF0ZXMgPSBfYS5udW1VcGRhdGVzLCBzbGljZVNpemUgPSBfYS5zbGljZVNpemUsIHN0cmlkZXMgPSBfYS5zdHJpZGVzLCBvdXRwdXRTaXplID0gX2Eub3V0cHV0U2l6ZTtcbiAgICB2YXIgc3VtRHVwZUluZGljZXMgPSB0cnVlO1xuICAgIHZhciBpbmRpY2VzQnVmID0gYmFja2VuZC5idWZmZXJTeW5jKGluZGljZXMpO1xuICAgIHZhciB1cGRhdGVzQnVmID0gYmFja2VuZC5idWZmZXJTeW5jKHVwZGF0ZXMpO1xuICAgIHZhciBvdXRCdWYgPSBzY2F0dGVySW1wbChpbmRpY2VzQnVmLCB1cGRhdGVzQnVmLCBzaGFwZSwgb3V0cHV0U2l6ZSwgc2xpY2VTaXplLCBudW1VcGRhdGVzLCBzbGljZVJhbmssIHN0cmlkZXMsIDAgLyogZGVmYXVsdFZhbHVlICovLCBzdW1EdXBlSW5kaWNlcyk7XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oc2hhcGUsIG91dEJ1Zi5kdHlwZSwgb3V0QnVmLnZhbHVlcyk7XG59XG52YXIgc2NhdHRlck5kQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlNjYXR0ZXJOZCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogc2NhdHRlck5kXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBzZWxlY3QoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgY29uZGl0aW9uID0gaW5wdXRzLmNvbmRpdGlvbiwgdCA9IGlucHV0cy50LCBlID0gaW5wdXRzLmU7XG4gICAgYXNzZXJ0Tm90Q29tcGxleChbY29uZGl0aW9uLCB0LCBlXSwgJ3NlbGVjdCcpO1xuICAgIHZhciBjb25kaXRpb25SYW5rID0gY29uZGl0aW9uLnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gYmFja2VuZC5kYXRhLmdldChjb25kaXRpb24uZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIHRWYWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KHQuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIGVWYWx1ZXMgPSBiYWNrZW5kLmRhdGEuZ2V0KGUuZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIHJlc3VsdER0eXBlID0gdGZqc0NvcmUudXBjYXN0VHlwZSh0LmR0eXBlLCBlLmR0eXBlKTtcbiAgICB2YXIgbmV3VmFsdWVzID0gdGZqc0NvcmUudXRpbC5tYWtlWmVyb3NUeXBlZEFycmF5KHRmanNDb3JlLnV0aWwuc2l6ZUZyb21TaGFwZSh0LnNoYXBlKSwgcmVzdWx0RHR5cGUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIG9mZnNldCA9IGNvbmRpdGlvblJhbmsgPT09IDAgfHwgY29uZGl0aW9uUmFuayA+IDEgfHwgdC5zaGFwZS5sZW5ndGggPT09IDEgP1xuICAgICAgICAxIDpcbiAgICAgICAgdGZqc0NvcmUudXRpbC5zaXplRnJvbVNoYXBlKHQuc2hhcGUuc2xpY2UoMSkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2Zmc2V0OyBqKyspIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZXNbaW5kZXgrK10gPSB0VmFsdWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWVzW2luZGV4KytdID0gZVZhbHVlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyh0LnNoYXBlLCByZXN1bHREdHlwZSwgbmV3VmFsdWVzKTtcbn1cbnZhciBzZWxlY3RDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuU2VsZWN0LFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBzZWxlY3Rcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgc2NhbGVBbHBoYSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5TRUxVX1NDQUxFQUxQSEE7XG52YXIgc2NhbGUgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuU0VMVV9TQ0FMRTtcbnZhciBzZWx1ID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLlNlbHUsIGZ1bmN0aW9uICh4aSkge1xuICAgIGlmICh4aSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBzY2FsZSAqIHhpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQWxwaGEgKiAoTWF0aC5leHAoeGkpIC0gMSk7XG4gICAgfVxufSk7XG52YXIgc2VsdUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5TZWx1LFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBzZWx1LFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBzaWdtb2lkID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLlNpZ21vaWQsIGZ1bmN0aW9uICh4aSkgeyByZXR1cm4gMSAvICgxICsgTWF0aC5leHAoLXhpKSk7IH0pO1xudmFyIHNpZ21vaWRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuU2lnbW9pZCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogc2lnbW9pZCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgc2lnbiA9IHVuYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5TaWduLCBmdW5jdGlvbiAoeGkpIHtcbiAgICBpZiAoeGkgPCAwKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeGkgPiAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufSk7XG52YXIgc2lnbkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5TaWduLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBzaWduLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBzaW4gPSB1bmFyeUtlcm5lbEZ1bmModGZqc0NvcmUuU2luLCBmdW5jdGlvbiAoeGkpIHsgcmV0dXJuIE1hdGguc2luKHhpKTsgfSk7XG52YXIgc2luQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlNpbixcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogc2luLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBzaW5oID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLlNpbmgsIGZ1bmN0aW9uICh4aSkgeyByZXR1cm4gTWF0aC5zaW5oKHhpKTsgfSk7XG52YXIgc2luaENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5TaW5oLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBzaW5oLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8vIG1pcnJvcnMgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRmLm5uLnNvZnRwbHVzOiBodHRwczovL2dvby5nbC92a2N2d1hcbi8vIGVwc2lsb24gaXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAxLjAgYW5kIHRoZSBuZXh0IHJlcHJlc2VudGFibGUgZmxvYXQuXG4vLyBGb3IgYSBzaW5nbGUgcHJlY2lzaW9uIDMyIGJpdCBmbG9hdCB0aGlzIHNob3VsZCBiZSAyXi0yMywgc2VlOlxuLy8gaHR0cHM6Ly9tYXRoLmJ5dS5lZHUvfnNjaG93L3dvcmsvSUVFRUZsb2F0aW5nUG9pbnQuaHRtXG52YXIgZXBzaWxvbiA9IDEuMTkyMDkyODk1NTA3ODEyNWUtNztcbnZhciB0aHJlc2hvbGQgPSBNYXRoLmxvZyhlcHNpbG9uKSArIDIuMDtcbnZhciBzb2Z0cGx1cyA9IHVuYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5Tb2Z0cGx1cywgZnVuY3Rpb24gKHhpKSB7XG4gICAgLy8gVmFsdWUgYWJvdmUgd2hpY2ggZXhwKHgpIG1heSBvdmVyZmxvdywgYnV0IHNvZnRwbHVzKHgpID09IHhcbiAgICAvLyBpcyB3aXRoaW4gbWFjaGluZSBlcHNpbG9uLlxuICAgIHZhciB0b29MYXJnZSA9IHhpID4gLXRocmVzaG9sZDtcbiAgICAvLyBWYWx1ZSBiZWxvdyB3aGljaCBleHAoeCkgbWF5IHVuZGVyZmxvdywgYnV0IHNvZnRwbHVzKHgpID09IGV4cCh4KVxuICAgIC8vIGlzIHdpdGhpbiBtYWNoaW5lIGVwc2lsb24uXG4gICAgdmFyIHRvb1NtYWxsID0geGkgPCB0aHJlc2hvbGQ7XG4gICAgdmFyIGV4cFggPSBNYXRoLmV4cCh4aSk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgcmVzdWx0ID0gZXhwWDtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9vTGFyZ2UpIHtcbiAgICAgICAgcmVzdWx0ID0geGk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBNYXRoLmxvZygxLjAgKyBleHBYKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xudmFyIHNvZnRwbHVzQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlNvZnRwbHVzLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBzb2Z0cGx1cyxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHNwYWNlVG9CYXRjaE5EKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBibG9ja1NoYXBlID0gYXR0cnMuYmxvY2tTaGFwZSwgcGFkZGluZ3MgPSBhdHRycy5wYWRkaW5ncztcbiAgICBhc3NlcnROb3RDb21wbGV4KFt4XSwgJ3NwYWNlVG9CYXRjaE5EJyk7XG4gICAgdmFyIHByb2QgPSB0ZmpzQ29yZS51dGlsLnNpemVGcm9tU2hhcGUoYmxvY2tTaGFwZSk7XG4gICAgdmFyIGNvbXBsZXRlUGFkZGluZ3MgPSBbWzAsIDBdXTtcbiAgICBjb21wbGV0ZVBhZGRpbmdzLnB1c2guYXBwbHkoY29tcGxldGVQYWRkaW5ncywgcGFkZGluZ3MpO1xuICAgIGZvciAodmFyIGkgPSAxICsgYmxvY2tTaGFwZS5sZW5ndGg7IGkgPCB4LnNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbXBsZXRlUGFkZGluZ3MucHVzaChbMCwgMF0pO1xuICAgIH1cbiAgICB2YXIgcGFkZGVkWCA9IHBhZFYyQ29uZmlnLmtlcm5lbEZ1bmMoe1xuICAgICAgICBpbnB1dHM6IHsgeDogeCB9LFxuICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICBhdHRyczogeyBwYWRkaW5nczogY29tcGxldGVQYWRkaW5ncywgY29uc3RhbnRWYWx1ZTogMCB9XG4gICAgfSk7XG4gICAgdmFyIHJlc2hhcGVkUGFkZGVkU2hhcGUgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0UmVzaGFwZWQocGFkZGVkWC5zaGFwZSwgYmxvY2tTaGFwZSwgcHJvZCwgZmFsc2UpO1xuICAgIHZhciBwZXJtdXRlZFJlc2hhcGVkUGFkZGVkUGVybXV0YXRpb24gPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuZ2V0UGVybXV0ZWQocmVzaGFwZWRQYWRkZWRTaGFwZS5sZW5ndGgsIGJsb2NrU2hhcGUubGVuZ3RoLCBmYWxzZSk7XG4gICAgdmFyIGZsYXR0ZW5TaGFwZSA9IHRmanNDb3JlLmJhY2tlbmRfdXRpbC5nZXRSZXNoYXBlZFBlcm11dGVkKHBhZGRlZFguc2hhcGUsIGJsb2NrU2hhcGUsIHByb2QsIGZhbHNlKTtcbiAgICB2YXIgcmVzaGFwZUlucHV0cyA9IHsgeDogcGFkZGVkWCB9O1xuICAgIHZhciByZXNoYXBlQXR0cnMgPSB7IHNoYXBlOiByZXNoYXBlZFBhZGRlZFNoYXBlIH07XG4gICAgdmFyIHBhZGRlZFhSZXNoYXBlZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHJlc2hhcGVJbnB1dHMsIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiByZXNoYXBlQXR0cnMgfSk7XG4gICAgdmFyIHRyYW5zcG9zZUlucHV0cyA9IHsgeDogcGFkZGVkWFJlc2hhcGVkIH07XG4gICAgdmFyIHRyYW5zcG9zZUF0dHJzID0geyBwZXJtOiBwZXJtdXRlZFJlc2hhcGVkUGFkZGVkUGVybXV0YXRpb24gfTtcbiAgICB2YXIgcGFkZGVkWFQgPSB0cmFuc3Bvc2UoeyBpbnB1dHM6IHRyYW5zcG9zZUlucHV0cywgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHRyYW5zcG9zZUF0dHJzIH0pO1xuICAgIHZhciByZXN1bHRSZXNoYXBlSW5wdXRzID0geyB4OiBwYWRkZWRYVCB9O1xuICAgIHZhciByZXN1bHRSZXNoYXBlQXR0cnMgPSB7IHNoYXBlOiBmbGF0dGVuU2hhcGUgfTtcbiAgICB2YXIgcmVzdWx0ID0gcmVzaGFwZSh7IGlucHV0czogcmVzdWx0UmVzaGFwZUlucHV0cywgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHJlc3VsdFJlc2hhcGVBdHRycyB9KTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHBhZGRlZFgpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocGFkZGVkWFJlc2hhcGVkKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHBhZGRlZFhUKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIHNwYWNlVG9CYXRjaE5EQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlNwYWNlVG9CYXRjaE5ELFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBzcGFjZVRvQmF0Y2hORFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gc3BhcnNlVG9EZW5zZShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHNwYXJzZUluZGljZXMgPSBpbnB1dHMuc3BhcnNlSW5kaWNlcywgc3BhcnNlVmFsdWVzID0gaW5wdXRzLnNwYXJzZVZhbHVlcywgZGVmYXVsdFZhbHVlID0gaW5wdXRzLmRlZmF1bHRWYWx1ZTtcbiAgICB2YXIgb3V0cHV0U2hhcGUgPSBhdHRycy5vdXRwdXRTaGFwZTtcbiAgICB2YXIgX2EgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwuY2FsY3VsYXRlU2hhcGVzKHNwYXJzZVZhbHVlcywgc3BhcnNlSW5kaWNlcywgb3V0cHV0U2hhcGUpLCBzbGljZVJhbmsgPSBfYS5zbGljZVJhbmssIG51bVVwZGF0ZXMgPSBfYS5udW1VcGRhdGVzLCBzbGljZVNpemUgPSBfYS5zbGljZVNpemUsIHN0cmlkZXMgPSBfYS5zdHJpZGVzLCBvdXRwdXRTaXplID0gX2Eub3V0cHV0U2l6ZTtcbiAgICB2YXIgc3VtRHVwZUluZGljZXMgPSBmYWxzZTtcbiAgICB2YXIgaW5kaWNlc0J1ZiA9IGJhY2tlbmQuYnVmZmVyU3luYyhzcGFyc2VJbmRpY2VzKTtcbiAgICB2YXIgdXBkYXRlc0J1ZiA9IGJhY2tlbmQuYnVmZmVyU3luYyhzcGFyc2VWYWx1ZXMpO1xuICAgIHZhciAkZGVmYXVsdFZhbHVlID0gYmFja2VuZC5kYXRhLmdldChkZWZhdWx0VmFsdWUuZGF0YUlkKS52YWx1ZXNbMF07XG4gICAgdmFyIG91dEJ1ZiA9IHNjYXR0ZXJJbXBsKGluZGljZXNCdWYsIHVwZGF0ZXNCdWYsIG91dHB1dFNoYXBlLCBvdXRwdXRTaXplLCBzbGljZVNpemUsIG51bVVwZGF0ZXMsIHNsaWNlUmFuaywgc3RyaWRlcywgJGRlZmF1bHRWYWx1ZSwgc3VtRHVwZUluZGljZXMpO1xuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dHB1dFNoYXBlLCBvdXRCdWYuZHR5cGUsIG91dEJ1Zi52YWx1ZXMpO1xufVxudmFyIHNwYXJzZVRvRGVuc2VDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuU3BhcnNlVG9EZW5zZSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogc3BhcnNlVG9EZW5zZVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gc3BsaXRWKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBudW1PclNpemVTcGxpdHMgPSBhdHRycy5udW1PclNpemVTcGxpdHMsIGF4aXMgPSBhdHRycy5heGlzO1xuICAgIHZhciAkYXhpcyA9IHRmanNDb3JlLnV0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSlbMF07XG4gICAgdmFyIHNwbGl0U2l6ZXMgPSB0ZmpzQ29yZS5iYWNrZW5kX3V0aWwucHJlcGFyZVNwbGl0U2l6ZSh4LCBudW1PclNpemVTcGxpdHMsICRheGlzKTtcbiAgICB2YXIgYmVnaW4gPSBuZXcgQXJyYXkoeC5zaGFwZS5sZW5ndGgpLmZpbGwoMCk7XG4gICAgdmFyIHNpemUgPSB4LnNoYXBlLnNsaWNlKCk7XG4gICAgcmV0dXJuIHNwbGl0U2l6ZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBzbGljZVNpemUgPSBzaXplLnNsaWNlKCk7XG4gICAgICAgIHNsaWNlU2l6ZVskYXhpc10gPSBzO1xuICAgICAgICB2YXIgc2xpY2VUID0gc2xpY2UoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBiZWdpbjogYmVnaW4sIHNpemU6IHNsaWNlU2l6ZSB9IH0pO1xuICAgICAgICBiZWdpblskYXhpc10gKz0gcztcbiAgICAgICAgcmV0dXJuIHNsaWNlVDtcbiAgICB9KTtcbn1cbnZhciBzcGxpdFZDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuU3BsaXRWLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBzcGxpdFZcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgc3FydCA9IHVuYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5TcXJ0LCBmdW5jdGlvbiAoeGkpIHsgcmV0dXJuIE1hdGguc3FydCh4aSk7IH0pO1xudmFyIHNxcnRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuU3FydCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogc3FydCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBzcXVhcmVDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuU3F1YXJlLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGlucHV0cyA9IF9hLmlucHV0cywgYmFja2VuZCA9IF9hLmJhY2tlbmQ7XG4gICAgICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgICAgIHZhciBjcHVCYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgYXNzZXJ0Tm90Q29tcGxleCh4LCAnc3F1YXJlJyk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBjcHVCYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gdmFsdWUgKiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YUlkID0gY3B1QmFja2VuZC53cml0ZShuZXdWYWx1ZXMsIHguc2hhcGUsIHguZHR5cGUpO1xuICAgICAgICByZXR1cm4geyBkYXRhSWQ6IGRhdGFJZCwgc2hhcGU6IHguc2hhcGUsIGR0eXBlOiB4LmR0eXBlIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBzdGVwID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLlN0ZXAsIGZ1bmN0aW9uICh4aSwgYXR0cnMpIHtcbiAgICB2YXIgc3RlcEF0dHJzID0gYXR0cnM7XG4gICAgaWYgKGlzTmFOKHhpKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHhpID4gMCA/IDEgOiBzdGVwQXR0cnMuYWxwaGE7XG4gICAgfVxufSk7XG52YXIgc3RlcENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5TdGVwLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBzdGVwLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gc3RyaWRlZFNsaWNlKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBiZWdpbiA9IGF0dHJzLmJlZ2luLCBlbmQgPSBhdHRycy5lbmQsIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBiZWdpbk1hc2sgPSBhdHRycy5iZWdpbk1hc2ssIGVuZE1hc2sgPSBhdHRycy5lbmRNYXNrLCBlbGxpcHNpc01hc2sgPSBhdHRycy5lbGxpcHNpc01hc2ssIG5ld0F4aXNNYXNrID0gYXR0cnMubmV3QXhpc01hc2ssIHNocmlua0F4aXNNYXNrID0gYXR0cnMuc2hyaW5rQXhpc01hc2s7XG4gICAgYXNzZXJ0Tm90Q29tcGxleCh4LCAnc3RyaWRlZFNsaWNlJyk7XG4gICAgdmFyIF9hID0gdGZqc0NvcmUuc2xpY2VfdXRpbC5zbGljZUluZm8oeC5zaGFwZSwgYmVnaW4sIGVuZCwgc3RyaWRlcywgYmVnaW5NYXNrLCBlbmRNYXNrLCBlbGxpcHNpc01hc2ssIG5ld0F4aXNNYXNrLCBzaHJpbmtBeGlzTWFzayksIG5vblN0cmlkZWQgPSBfYS5ub25TdHJpZGVkLCAkYmVnaW4gPSBfYS4kYmVnaW4sICRzdHJpZGVzID0gX2EuJHN0cmlkZXMsIHNpemUgPSBfYS5zaXplLCBuZXdTaGFwZSA9IF9hLm5ld1NoYXBlLCBvdXRTaGFwZSA9IF9hLm91dFNoYXBlO1xuICAgIHZhciAkeCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogbmV3U2hhcGUgfSB9KTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChub25TdHJpZGVkKSB7XG4gICAgICAgIHZhciBzbGljZWQgPSBzbGljZSh7IGlucHV0czogeyB4OiAkeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBiZWdpbjogJGJlZ2luLCBzaXplOiBzaXplIH0gfSk7XG4gICAgICAgIHJlc3VsdCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogc2xpY2VkIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBvdXRTaGFwZSB9IH0pO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHNsaWNlZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dFNoYXBlLnNvbWUoZnVuY3Rpb24gKGF4aXMpIHsgcmV0dXJuIGF4aXMgPT09IDA7IH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8ob3V0U2hhcGUsIHguZHR5cGUsIFtdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB4QnVmID0gYmFja2VuZC5idWZmZXJTeW5jKCR4KTtcbiAgICAgICAgdmFyIG91dEJ1ZiA9IHN0cmlkZWRTbGljZUltcGwob3V0U2hhcGUsIHhCdWYsICRzdHJpZGVzLCAkYmVnaW4pO1xuICAgICAgICByZXN1bHQgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dEJ1Zi5zaGFwZSwgb3V0QnVmLmR0eXBlLCBvdXRCdWYudmFsdWVzKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdFJlc2hhcGVkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiByZXN1bHQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IG91dFNoYXBlIH0gfSk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbygkeCk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHRSZXNoYXBlZDtcbn1cbnZhciBzdHJpZGVkU2xpY2VDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuU3RyaWRlZFNsaWNlLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiBzdHJpZGVkU2xpY2Vcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgdGFuID0gdW5hcnlLZXJuZWxGdW5jKHRmanNDb3JlLlRhbiwgZnVuY3Rpb24gKHhpKSB7IHJldHVybiBNYXRoLnRhbih4aSk7IH0pO1xudmFyIHRhbkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5UYW4sXG4gICAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICAgIGtlcm5lbEZ1bmM6IHRhbixcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgdGFuaCA9IHVuYXJ5S2VybmVsRnVuYyh0ZmpzQ29yZS5UYW5oLCBmdW5jdGlvbiAoeGkpIHsgcmV0dXJuIE1hdGgudGFuaCh4aSk7IH0pO1xudmFyIHRhbmhDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGZqc0NvcmUuVGFuaCxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogdGFuaCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHRpbGUoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIHJlcHMgPSBhdHRycy5yZXBzO1xuICAgIGFzc2VydE5vdENvbXBsZXgoeCwgJ3RpbGUnKTtcbiAgICB2YXIgb3V0QnVmID0gdGlsZUltcGwoYmFja2VuZC5idWZmZXJTeW5jKHgpLCByZXBzKTtcbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRCdWYuc2hhcGUsIG91dEJ1Zi5kdHlwZSwgb3V0QnVmLnZhbHVlcyk7XG59XG52YXIgdGlsZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5UaWxlLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiB0aWxlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiB0b3BLKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBrID0gYXR0cnMuaywgc29ydGVkID0gYXR0cnMuc29ydGVkO1xuICAgIGFzc2VydE5vdENvbXBsZXgoeCwgJ3RvcGsnKTtcbiAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLmRhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXM7XG4gICAgdmFyIF9hID0gdG9wS0ltcGwoeFZhbHMsIHguc2hhcGUsIHguZHR5cGUsIGspLCBhbGxUb3BLVmFscyA9IF9hWzBdLCBhbGxUb3BLSW5kaWNlcyA9IF9hWzFdO1xuICAgIHJldHVybiBbXG4gICAgICAgIGJhY2tlbmQubWFrZVRlbnNvckluZm8oYWxsVG9wS1ZhbHMuc2hhcGUsIGFsbFRvcEtWYWxzLmR0eXBlLCBhbGxUb3BLVmFscy52YWx1ZXMpLFxuICAgICAgICBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKGFsbFRvcEtJbmRpY2VzLnNoYXBlLCBhbGxUb3BLSW5kaWNlcy5kdHlwZSwgYWxsVG9wS0luZGljZXMudmFsdWVzKVxuICAgIF07XG59XG52YXIgdG9wS0NvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0ZmpzQ29yZS5Ub3BLLFxuICAgIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAgICBrZXJuZWxGdW5jOiB0b3BLXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGF0dHJzID0gYXJncy5hdHRycywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgYXhpcyA9IGF0dHJzLmF4aXM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICd1bmlxdWUnKTtcbiAgICB2YXIgdmFsdWVzID0gYmFja2VuZC5kYXRhLmdldCh4LmRhdGFJZCkudmFsdWVzO1xuICAgIHZhciBfYSA9IHVuaXF1ZUltcGwodmFsdWVzLCBheGlzLCB4LnNoYXBlLCB4LmR0eXBlKSwgb3V0cHV0VmFsdWVzID0gX2Eub3V0cHV0VmFsdWVzLCBvdXRwdXRTaGFwZSA9IF9hLm91dHB1dFNoYXBlLCBpbmRpY2VzID0gX2EuaW5kaWNlcztcbiAgICByZXR1cm4gW1xuICAgICAgICBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dHB1dFNoYXBlLCB4LmR0eXBlLCBvdXRwdXRWYWx1ZXMpLFxuICAgICAgICBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtpbmRpY2VzLmxlbmd0aF0sICdpbnQzMicsIGluZGljZXMpLFxuICAgIF07XG59XG52YXIgdW5pcXVlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlVuaXF1ZSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogdW5pcXVlLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gdW5wYWNrKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgdmFsdWUgPSBpbnB1dHMudmFsdWU7XG4gICAgdmFyIGF4aXMgPSBhdHRycy5heGlzO1xuICAgIGlmIChheGlzIDwgMCkge1xuICAgICAgICBheGlzICs9IHZhbHVlLnNoYXBlLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIHZhbHVlUmFuayA9IHZhbHVlLnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgbnVtID0gdmFsdWUuc2hhcGVbYXhpc107XG4gICAgdmFyIG91dFNoYXBlID0gbmV3IEFycmF5KHZhbHVlUmFuayAtIDEpO1xuICAgIHZhciBvdXRJbmRleCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVJhbms7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gYXhpcykge1xuICAgICAgICAgICAgb3V0U2hhcGVbb3V0SW5kZXgrK10gPSB2YWx1ZS5zaGFwZVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYmVnaW4gPSBuZXcgQXJyYXkodmFsdWVSYW5rKS5maWxsKDApO1xuICAgIHZhciBzaXplID0gdmFsdWUuc2hhcGUuc2xpY2UoKTtcbiAgICBzaXplW2F4aXNdID0gMTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KG51bSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmVnaW5bYXhpc10gPSBpO1xuICAgICAgICB2YXIgdGVtcFJlcyA9IHNsaWNlKHsgaW5wdXRzOiB7IHg6IHZhbHVlIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGJlZ2luOiBiZWdpbiwgc2l6ZTogc2l6ZSB9IH0pO1xuICAgICAgICByZXNbaV0gPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHRlbXBSZXMgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IG91dFNoYXBlIH0gfSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odGVtcFJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG52YXIgdW5wYWNrQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlVucGFjayxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogdW5wYWNrXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiB1bnNvcnRlZFNlZ21lbnRTdW0oYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLngsIHNlZ21lbnRJZHMgPSBpbnB1dHMuc2VnbWVudElkcztcbiAgICB2YXIgbnVtU2VnbWVudHMgPSBhdHRycy5udW1TZWdtZW50cztcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICd1bnNvcnRlZFNlZ21lbnRTdW0nKTtcbiAgICB2YXIgeFJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgc2VnbWVudElkc1JhbmsgPSBzZWdtZW50SWRzLnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGludGVybWVkaWF0ZXMgPSBbXTtcbiAgICAvLyBSZXNoYXBlIHRoZSBzZWdtZW50IGlkJ3Mgc28gdGhhdCB0aGV5IGNhbiBiZSBicm9hZGNhc3Qgd2l0aFxuICAgIC8vIHguIFRoZSBuZXcgc2hhcGUgc2hvdWxkIGJlIFtzZWdtZW50SWRzLnNoYXBlLCAxLCAuLi4sIDFdXG4gICAgdmFyIG51bUl0ZXJzID0geFJhbmsgLSBzZWdtZW50SWRzUmFuaztcbiAgICB2YXIgJHNlZ21lbnRJZHMgPSBzZWdtZW50SWRzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtSXRlcnM7ICsraSkge1xuICAgICAgICB2YXIgZXhwYW5kZWQgPSBleHBhbmREaW1zKHsgaW5wdXRzOiB7IGlucHV0OiAkc2VnbWVudElkcyB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBkaW06IGkgKyAxIH0gfSk7XG4gICAgICAgICRzZWdtZW50SWRzID0gZXhwYW5kZWQ7XG4gICAgICAgIGludGVybWVkaWF0ZXMucHVzaChleHBhbmRlZCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7ICsraSkge1xuICAgICAgICB2YXIgc2NhbGFyVmFsdWUgPSB0ZmpzQ29yZS51dGlsLmNyZWF0ZVNjYWxhclZhbHVlKGksICdpbnQzMicpO1xuICAgICAgICB2YXIgc2VnbWVudElkID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhbXSwgJ2ludDMyJywgc2NhbGFyVmFsdWUpO1xuICAgICAgICB2YXIgbWFzayA9IGVxdWFsKHsgaW5wdXRzOiB7IGE6IHNlZ21lbnRJZCwgYjogJHNlZ21lbnRJZHMgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgdmFyIG1hc2tDYXN0ZWQgPSBjYXN0KHsgaW5wdXRzOiB7IHg6IG1hc2sgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgZHR5cGU6ICdmbG9hdDMyJyB9IH0pO1xuICAgICAgICB2YXIgbXVsID0gbXVsdGlwbHkoeyBpbnB1dHM6IHsgYTogbWFza0Nhc3RlZCwgYjogeCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICB2YXIgc3VtVGVuc29ySW5mbyA9IHN1bSh7IGlucHV0czogeyB4OiBtdWwgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgYXhpczogMCwga2VlcERpbXM6IGZhbHNlIH0gfSk7XG4gICAgICAgIHJlcy5wdXNoKHN1bVRlbnNvckluZm8pO1xuICAgICAgICBpbnRlcm1lZGlhdGVzLnB1c2goc2VnbWVudElkKTtcbiAgICAgICAgaW50ZXJtZWRpYXRlcy5wdXNoKG1hc2spO1xuICAgICAgICBpbnRlcm1lZGlhdGVzLnB1c2gobWFza0Nhc3RlZCk7XG4gICAgICAgIGludGVybWVkaWF0ZXMucHVzaChtdWwpO1xuICAgICAgICBpbnRlcm1lZGlhdGVzLnB1c2goc3VtVGVuc29ySW5mbyk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBwYWNrKHsgaW5wdXRzOiByZXMsIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGF4aXM6IDAgfSB9KTtcbiAgICBpbnRlcm1lZGlhdGVzLmZvckVhY2goZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odCk7IH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG52YXIgdW5zb3J0ZWRTZWdtZW50U3VtQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmanNDb3JlLlVuc29ydGVkU2VnbWVudFN1bSxcbiAgICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gICAga2VybmVsRnVuYzogdW5zb3J0ZWRTZWdtZW50U3VtXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vLyBMaXN0IGFsbCBrZXJuZWwgY29uZmlncyBoZXJlXG52YXIga2VybmVsQ29uZmlncyA9IFtcbiAgICBfZnVzZWRNYXRNdWxDb25maWcsXG4gICAgYWJzQ29uZmlnLFxuICAgIGFjb3NDb25maWcsXG4gICAgYWNvc2hDb25maWcsXG4gICAgYWRkQ29uZmlnLFxuICAgIGFkZE5Db25maWcsXG4gICAgYWxsQ29uZmlnLFxuICAgIGFueUNvbmZpZyxcbiAgICBhcmdNYXhDb25maWcsXG4gICAgYXJnTWluQ29uZmlnLFxuICAgIGFzaW5Db25maWcsXG4gICAgYXNpbmhDb25maWcsXG4gICAgYXRhbkNvbmZpZyxcbiAgICBhdGFuMkNvbmZpZyxcbiAgICBhdGFuaENvbmZpZyxcbiAgICBhdmdQb29sQ29uZmlnLFxuICAgIGF2Z1Bvb2wzRENvbmZpZyxcbiAgICBhdmdQb29sM0RHcmFkQ29uZmlnLFxuICAgIGF2Z1Bvb2xHcmFkQ29uZmlnLFxuICAgIGJhdGNoTWF0TXVsQ29uZmlnLFxuICAgIGJhdGNoTm9ybUNvbmZpZyxcbiAgICBiYXRjaFRvU3BhY2VORENvbmZpZyxcbiAgICBiaW5jb3VudENvbmZpZyxcbiAgICBjYXN0Q29uZmlnLFxuICAgIGNlaWxDb25maWcsXG4gICAgY2xpcENvbmZpZyxcbiAgICBjb21wbGV4Q29uZmlnLFxuICAgIGNvbXBsZXhBYnNDb25maWcsXG4gICAgY29uY2F0Q29uZmlnLFxuICAgIGNvbnYyREJhY2twcm9wRmlsdGVyQ29uZmlnLFxuICAgIGNvbnYyREJhY2twcm9wSW5wdXRDb25maWcsXG4gICAgY29udjJEQ29uZmlnLFxuICAgIGNvbnYzREJhY2twcm9wRmlsdGVyVjJDb25maWcsXG4gICAgY29udjNEQmFja3Byb3BJbnB1dFYyQ29uZmlnLFxuICAgIGNvbnYzRENvbmZpZyxcbiAgICBjb3NDb25maWcsXG4gICAgY29zaENvbmZpZyxcbiAgICBjcm9wQW5kUmVzaXplQ29uZmlnLFxuICAgIGN1bXN1bUNvbmZpZyxcbiAgICBkZW5zZUJpbmNvdW50Q29uZmlnLFxuICAgIGRlcHRoVG9TcGFjZUNvbmZpZyxcbiAgICBkZXB0aHdpc2VDb252MmROYXRpdmVDb25maWcsXG4gICAgZGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BGaWx0ZXJDb25maWcsXG4gICAgZGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BJbnB1dENvbmZpZyxcbiAgICBkaWFnQ29uZmlnLFxuICAgIGRpbGF0aW9uMmRDb25maWcsXG4gICAgZGlsYXRpb24yZEJhY2twcm9wSW5wdXRDb25maWcsXG4gICAgZGlsYXRpb24yZEJhY2twcm9wRmlsdGVyQ29uZmlnLFxuICAgIHJlYWxEaXZDb25maWcsXG4gICAgZWx1Q29uZmlnLFxuICAgIGVsdUdyYWRDb25maWcsXG4gICAgZXF1YWxDb25maWcsXG4gICAgZXJmQ29uZmlnLFxuICAgIGV4cENvbmZpZyxcbiAgICBleHBhbmREaW1zQ29uZmlnLFxuICAgIGV4cG0xQ29uZmlnLFxuICAgIGZmdENvbmZpZyxcbiAgICBmaWxsQ29uZmlnLFxuICAgIGZsaXBMZWZ0UmlnaHRDb25maWcsXG4gICAgZmxvb3JDb25maWcsXG4gICAgZmxvb3JEaXZDb25maWcsXG4gICAgZnVzZWRDb252MkRDb25maWcsXG4gICAgZnVzZWREZXB0aHdpc2VDb252MkRDb25maWcsXG4gICAgZ2F0aGVyTmRDb25maWcsXG4gICAgZ2F0aGVyVjJDb25maWcsXG4gICAgZ3JlYXRlckNvbmZpZyxcbiAgICBncmVhdGVyRXF1YWxDb25maWcsXG4gICAgaWRlbnRpdHlDb25maWcsXG4gICAgaWZmdENvbmZpZyxcbiAgICBpbWFnQ29uZmlnLFxuICAgIGlzRmluaXRlQ29uZmlnLFxuICAgIGlzSW5mQ29uZmlnLFxuICAgIGlzTmFOQ29uZmlnLFxuICAgIGxlYWt5UmVsdUNvbmZpZyxcbiAgICBsZXNzQ29uZmlnLFxuICAgIGxlc3NFcXVhbENvbmZpZyxcbiAgICBsaW5TcGFjZUNvbmZpZyxcbiAgICBsb2dDb25maWcsXG4gICAgbG9nMXBDb25maWcsXG4gICAgbG9naWNhbEFuZENvbmZpZyxcbiAgICBsb2dpY2FsTm90Q29uZmlnLFxuICAgIGxvZ2ljYWxPckNvbmZpZyxcbiAgICBsUk5Db25maWcsXG4gICAgbFJOR3JhZENvbmZpZyxcbiAgICBtYXhpbXVtQ29uZmlnLFxuICAgIG1heFBvb2xDb25maWcsXG4gICAgbWF4UG9vbDNEQ29uZmlnLFxuICAgIG1heFBvb2wzREdyYWRDb25maWcsXG4gICAgbWF4UG9vbEdyYWRDb25maWcsXG4gICAgbWF4UG9vbFdpdGhBcmdtYXhDb25maWcsXG4gICAgbWF4Q29uZmlnLFxuICAgIG1lYW5Db25maWcsXG4gICAgbWluQ29uZmlnLFxuICAgIG1pbmltdW1Db25maWcsXG4gICAgbWlycm9yUGFkQ29uZmlnLFxuICAgIG1vZENvbmZpZyxcbiAgICBtdWx0aW5vbWlhbENvbmZpZyxcbiAgICBtdWx0aXBseUNvbmZpZyxcbiAgICBuZWdDb25maWcsXG4gICAgbm9uTWF4U3VwcHJlc3Npb25WM0NvbmZpZyxcbiAgICBub25NYXhTdXBwcmVzc2lvblY0Q29uZmlnLFxuICAgIG5vbk1heFN1cHByZXNzaW9uVjVDb25maWcsXG4gICAgbm90RXF1YWxDb25maWcsXG4gICAgb25lSG90Q29uZmlnLFxuICAgIG9uZXNMaWtlQ29uZmlnLFxuICAgIHBhY2tDb25maWcsXG4gICAgcGFkVjJDb25maWcsXG4gICAgcG93Q29uZmlnLFxuICAgIHByZWx1Q29uZmlnLFxuICAgIHByb2RDb25maWcsXG4gICAgcmFuZ2VDb25maWcsXG4gICAgcmVhbENvbmZpZyxcbiAgICByZWNpcHJvY2FsQ29uZmlnLFxuICAgIHJlbHVDb25maWcsXG4gICAgcmVsdTZDb25maWcsXG4gICAgcmVzaGFwZUNvbmZpZyxcbiAgICByZXNpemVCaWxpbmVhckNvbmZpZyxcbiAgICByZXNpemVCaWxpbmVhckdyYWRDb25maWcsXG4gICAgcmVzaXplTmVhcmVzdE5laWdoYm9yQ29uZmlnLFxuICAgIHJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWRDb25maWcsXG4gICAgcmV2ZXJzZUNvbmZpZyxcbiAgICByb3RhdGVXaXRoT2Zmc2V0Q29uZmlnLFxuICAgIHJvdW5kQ29uZmlnLFxuICAgIHJzcXJ0Q29uZmlnLFxuICAgIHNjYXR0ZXJOZENvbmZpZyxcbiAgICBzZWxlY3RDb25maWcsXG4gICAgc2VsdUNvbmZpZyxcbiAgICBzaWdtb2lkQ29uZmlnLFxuICAgIHNpZ25Db25maWcsXG4gICAgc2luQ29uZmlnLFxuICAgIHNpbmhDb25maWcsXG4gICAgc2xpY2VDb25maWcsXG4gICAgc29mdG1heENvbmZpZyxcbiAgICBzb2Z0cGx1c0NvbmZpZyxcbiAgICBzcGFjZVRvQmF0Y2hORENvbmZpZyxcbiAgICBzcGFyc2VUb0RlbnNlQ29uZmlnLFxuICAgIHNwbGl0VkNvbmZpZyxcbiAgICBzcXJ0Q29uZmlnLFxuICAgIHNxdWFyZUNvbmZpZyxcbiAgICBzcXVhcmVkRGlmZmVyZW5jZUNvbmZpZyxcbiAgICBzdGVwQ29uZmlnLFxuICAgIHN0cmlkZWRTbGljZUNvbmZpZyxcbiAgICBzdWJDb25maWcsXG4gICAgc3VtQ29uZmlnLFxuICAgIHRhbkNvbmZpZyxcbiAgICB0YW5oQ29uZmlnLFxuICAgIHRpbGVDb25maWcsXG4gICAgdG9wS0NvbmZpZyxcbiAgICB0cmFuc3Bvc2VDb25maWcsXG4gICAgdW5pcXVlQ29uZmlnLFxuICAgIHVucGFja0NvbmZpZyxcbiAgICB1bnNvcnRlZFNlZ21lbnRTdW1Db25maWcsXG4gICAgemVyb3NMaWtlQ29uZmlnXG5dO1xuZm9yICh2YXIgX2kgPSAwLCBrZXJuZWxDb25maWdzXzEgPSBrZXJuZWxDb25maWdzOyBfaSA8IGtlcm5lbENvbmZpZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIga2VybmVsQ29uZmlnID0ga2VybmVsQ29uZmlnc18xW19pXTtcbiAgICB0ZmpzQ29yZS5yZWdpc3Rlcktlcm5lbChrZXJuZWxDb25maWcpO1xufVxuXG5leHBvcnRzLk1hdGhCYWNrZW5kQ1BVID0gTWF0aEJhY2tlbmRDUFU7XG5leHBvcnRzLnNoYXJlZCA9IHNoYXJlZDtcbmV4cG9ydHMudmVyc2lvbl9jcHUgPSB2ZXJzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGYtYmFja2VuZC1jcHUubm9kZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@tensorflow+tfjs-backend-cpu@2.8.6_@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-backend-cpu/dist/tf-backend-cpu.node.js\n");

/***/ })

};
;