"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tonal-scale@2.2.2";
exports.ids = ["vendor-chunks/tonal-scale@2.2.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/tonal-scale@2.2.2/node_modules/tonal-scale/build/es5.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/tonal-scale@2.2.2/node_modules/tonal-scale/build/es5.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar tonalNote = __webpack_require__(/*! tonal-note */ \"(ssr)/./node_modules/.pnpm/tonal-note@2.2.2/node_modules/tonal-note/build/es5.js\");\nvar tonalPcset = __webpack_require__(/*! tonal-pcset */ \"(ssr)/./node_modules/.pnpm/tonal-pcset@2.2.2/node_modules/tonal-pcset/build/es5.js\");\nvar tonalDistance = __webpack_require__(/*! tonal-distance */ \"(ssr)/./node_modules/.pnpm/tonal-distance@2.2.2/node_modules/tonal-distance/build/es5.js\");\nvar tonalDictionary = __webpack_require__(/*! tonal-dictionary */ \"(ssr)/./node_modules/.pnpm/tonal-dictionary@2.2.2/node_modules/tonal-dictionary/build/es5.js\");\nvar tonalArray = __webpack_require__(/*! tonal-array */ \"(ssr)/./node_modules/.pnpm/tonal-array@2.2.2/node_modules/tonal-array/build/es5.js\");\n\n/**\n * [![npm version](https://img.shields.io/npm/v/tonal-scale.svg?style=flat-square)](https://www.npmjs.com/package/tonal-scale)\n *\n * A scale is a collection of pitches in ascending or descending order.\n *\n * This module provides functions to get and manipulate scales.\n *\n * @example\n * // es6\n * import * as Scale from \"tonal-scale\"\n * // es5\n * const Scale = require(\"tonal-scale\");\n *\n * @example\n * Scale.notes(\"Ab bebop\") // => [ \"Ab\", \"Bb\", \"C\", \"Db\", \"Eb\", \"F\", \"Gb\", \"G\" ]\n * Scale.names() => [\"major\", \"minor\", ...]\n * @module Scale\n */\n\nvar NO_SCALE = Object.freeze({\n  name: null,\n  intervals: [],\n  names: [],\n  chroma: null,\n  setnum: null\n});\n\nvar properties = function (name) {\n  var intervals = tonalDictionary.scale(name);\n  if (!intervals) { return NO_SCALE; }\n  var s = { intervals: intervals, name: name };\n  s.chroma = tonalPcset.chroma(intervals);\n  s.setnum = parseInt(s.chroma, 2);\n  s.names = tonalDictionary.scale.names(s.chroma);\n  return Object.freeze(s);\n};\n\nvar memoize = function (fn, cache) { return function (str) { return cache[str] || (cache[str] = fn(str)); }; };\n\n/**\n * Get scale properties. It returns an object with:\n * - name: the scale name\n * - names: a list with all possible names (includes the current)\n * - intervals: an array with the scale intervals\n * - chroma:  scale croma (see pcset)\n * - setnum: scale chroma number\n *\n * @function\n * @param {string} name - the scale name (without tonic)\n * @return {Object}\n */\nvar props = memoize(properties, {});\n\n/**\n * Return the available scale names\n *\n * @function\n * @param {boolean} [aliases=false] - true to include aliases\n * @return {Array} the scale names\n *\n * @example\n * Scale.names() // => [\"maj7\", ...]\n */\nvar names = tonalDictionary.scale.names;\n\n/**\n * Given a scale name, return its intervals. The name can be the type and\n * optionally the tonic (which is ignored)\n *\n * It retruns an empty array when no scale found\n *\n * @function\n * @param {string} name - the scale name (tonic and type, tonic is optional)\n * @return {Array<string>} the scale intervals if is a known scale or an empty\n * array if no scale found\n * @example\n * Scale.intervals(\"major\") // => [ \"1P\", \"2M\", \"3M\", \"4P\", \"5P\", \"6M\", \"7M\" ]\n */\nvar intervals = function (name) {\n  var p = tokenize(name);\n  return props(p[1]).intervals;\n};\n\n/**\n * Get the notes (pitch classes) of a scale.\n *\n * Note that it always returns an array, and the values are only pitch classes.\n *\n * @function\n * @param {string} tonic\n * @param {string} nameOrTonic - the scale name or tonic (if 2nd param)\n * @param {string} [name] - the scale name without tonic\n * @return {Array} a pitch classes array\n *\n * @example\n * Scale.notes(\"C\", \"major\") // => [ \"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\" ]\n * Scale.notes(\"C major\") // => [ \"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\" ]\n * Scale.notes(\"C4\", \"major\") // => [ \"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\" ]\n * Scale.notes(\"A4\", \"no-scale\") // => []\n * Scale.notes(\"blah\", \"major\") // => []\n */\nfunction notes(nameOrTonic, name) {\n  var p = tokenize(nameOrTonic);\n  name = name || p[1];\n  return intervals(name).map(tonalDistance.transpose(p[0]));\n}\n\n/**\n * Check if the given name is a known scale from the scales dictionary\n *\n * @function\n * @param {string} name - the scale name\n * @return {Boolean}\n */\nfunction exists(name) {\n  var p = tokenize(name);\n  return tonalDictionary.scale(p[1]) !== undefined;\n}\n\n/**\n * Given a string with a scale name and (optionally) a tonic, split\n * that components.\n *\n * It retuns an array with the form [ name, tonic ] where tonic can be a\n * note name or null and name can be any arbitrary string\n * (this function doesn\"t check if that scale name exists)\n *\n * @function\n * @param {string} name - the scale name\n * @return {Array} an array [tonic, name]\n * @example\n * Scale.tokenize(\"C mixolydean\") // => [\"C\", \"mixolydean\"]\n * Scale.tokenize(\"anything is valid\") // => [\"\", \"anything is valid\"]\n * Scale.tokenize() // => [\"\", \"\"]\n */\nfunction tokenize(str) {\n  if (typeof str !== \"string\") { return [\"\", \"\"]; }\n  var i = str.indexOf(\" \");\n  var tonic = tonalNote.name(str.substring(0, i)) || tonalNote.name(str) || \"\";\n  var name = tonic !== \"\" ? str.substring(tonic.length + 1) : str;\n  return [tonic, name.length ? name : \"\"];\n}\n\n/**\n * Find mode names of a scale\n *\n * @function\n * @param {string} name - scale name\n * @example\n * Scale.modeNames(\"C pentatonic\") // => [\n *   [\"C\", \"major pentatonic\"],\n *   [\"D\", \"egyptian\"],\n *   [\"E\", \"malkos raga\"],\n *   [\"G\", \"ritusen\"],\n *   [\"A\", \"minor pentatonic\"]\n * ]\n */\nvar modeNames = function (name) {\n  var ivls = intervals(name);\n  var tonics = notes(name);\n\n  return tonalPcset.modes(ivls)\n    .map(function (chroma, i) {\n      var name = tonalDictionary.scale.names(chroma)[0];\n      if (name) { return [tonics[i] || ivls[i], name]; }\n    })\n    .filter(function (x) { return x; });\n};\n\n/**\n * Get all chords that fits a given scale\n *\n * @function\n * @param {string} name - the scale name\n * @return {Array<string>} - the chord names\n *\n * @example\n * Scale.chords(\"pentatonic\") // => [\"5\", \"64\", \"M\", \"M6\", \"Madd9\", \"Msus2\"]\n */\nvar chords = function (name) {\n  var inScale = tonalPcset.isSubsetOf(intervals(name));\n  return tonalDictionary.chord.names().filter(function (name) { return inScale(tonalDictionary.chord(name)); });\n};\n\n/**\n * Given an array of notes, return the scale: a pitch class set starting from\n * the first note of the array\n *\n * @function\n * @param {Array} notes\n * @return {Array}\n * @example\n * Scale.toScale(['C4', 'c3', 'C5', 'C4', 'c4']) // => [\"C\"]\n * Scale.toScale(['D4', 'c#5', 'A5', 'F#6']) // => [\"D\", \"F#\", \"A\", \"C#\"]\n */\nvar toScale = function (notes) {\n  var pcset = tonalArray.compact(notes.map(tonalNote.pc));\n  if (!pcset.length) { return pcset; }\n  var tonic = pcset[0];\n  var scale = tonalArray.unique(pcset);\n  return tonalArray.rotate(scale.indexOf(tonic), scale);\n};\n\n/**\n * Get all scales names that are a superset of the given one\n * (has the same notes and at least one more)\n *\n * @function\n * @param {string} name\n * @return {Array} a list of scale names\n * @example\n * Scale.supersets(\"major\") // => [\"bebop\", \"bebop dominant\", \"bebop major\", \"chromatic\", \"ichikosucho\"]\n */\nvar supersets = function (name) {\n  if (!intervals(name).length) { return []; }\n  var isSuperset = tonalPcset.isSupersetOf(intervals(name));\n  return tonalDictionary.scale.names().filter(function (name) { return isSuperset(tonalDictionary.scale(name)); });\n};\n\n/**\n * Find all scales names that are a subset of the given one\n * (has less notes but all from the given scale)\n *\n * @function\n * @param {string} name\n * @return {Array} a list of scale names\n *\n * @example\n * Scale.subsets(\"major\") // => [\"ionian pentatonic\", \"major pentatonic\", \"ritusen\"]\n */\nvar subsets = function (name) {\n  var isSubset = tonalPcset.isSubsetOf(intervals(name));\n  return tonalDictionary.scale.names().filter(function (name) { return isSubset(tonalDictionary.scale(name)); });\n};\n\nexports.props = props;\nexports.names = names;\nexports.intervals = intervals;\nexports.notes = notes;\nexports.exists = exists;\nexports.tokenize = tokenize;\nexports.modeNames = modeNames;\nexports.chords = chords;\nexports.toScale = toScale;\nexports.supersets = supersets;\nexports.subsets = subsets;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdG9uYWwtc2NhbGVAMi4yLjIvbm9kZV9tb2R1bGVzL3RvbmFsLXNjYWxlL2J1aWxkL2VzNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGdCQUFnQixtQkFBTyxDQUFDLG9HQUFZO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLHVHQUFhO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLGdIQUFnQjtBQUM1QyxzQkFBc0IsbUJBQU8sQ0FBQyxzSEFBa0I7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMsdUdBQWE7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLHdCQUF3Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0wsMkJBQTJCLFdBQVc7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw4Q0FBOEM7QUFDOUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsZ0VBQWdFLGlEQUFpRDtBQUNqSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsK0NBQStDO0FBQy9HOztBQUVBLGFBQWE7QUFDYixhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2QsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQixlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9tb25nYWguZ2l0aHViLmlvLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3RvbmFsLXNjYWxlQDIuMi4yL25vZGVfbW9kdWxlcy90b25hbC1zY2FsZS9idWlsZC9lczUuanM/NmQzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0b25hbE5vdGUgPSByZXF1aXJlKCd0b25hbC1ub3RlJyk7XG52YXIgdG9uYWxQY3NldCA9IHJlcXVpcmUoJ3RvbmFsLXBjc2V0Jyk7XG52YXIgdG9uYWxEaXN0YW5jZSA9IHJlcXVpcmUoJ3RvbmFsLWRpc3RhbmNlJyk7XG52YXIgdG9uYWxEaWN0aW9uYXJ5ID0gcmVxdWlyZSgndG9uYWwtZGljdGlvbmFyeScpO1xudmFyIHRvbmFsQXJyYXkgPSByZXF1aXJlKCd0b25hbC1hcnJheScpO1xuXG4vKipcbiAqIFshW25wbSB2ZXJzaW9uXShodHRwczovL2ltZy5zaGllbGRzLmlvL25wbS92L3RvbmFsLXNjYWxlLnN2Zz9zdHlsZT1mbGF0LXNxdWFyZSldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3RvbmFsLXNjYWxlKVxuICpcbiAqIEEgc2NhbGUgaXMgYSBjb2xsZWN0aW9uIG9mIHBpdGNoZXMgaW4gYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGdldCBhbmQgbWFuaXB1bGF0ZSBzY2FsZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGVzNlxuICogaW1wb3J0ICogYXMgU2NhbGUgZnJvbSBcInRvbmFsLXNjYWxlXCJcbiAqIC8vIGVzNVxuICogY29uc3QgU2NhbGUgPSByZXF1aXJlKFwidG9uYWwtc2NhbGVcIik7XG4gKlxuICogQGV4YW1wbGVcbiAqIFNjYWxlLm5vdGVzKFwiQWIgYmVib3BcIikgLy8gPT4gWyBcIkFiXCIsIFwiQmJcIiwgXCJDXCIsIFwiRGJcIiwgXCJFYlwiLCBcIkZcIiwgXCJHYlwiLCBcIkdcIiBdXG4gKiBTY2FsZS5uYW1lcygpID0+IFtcIm1ham9yXCIsIFwibWlub3JcIiwgLi4uXVxuICogQG1vZHVsZSBTY2FsZVxuICovXG5cbnZhciBOT19TQ0FMRSA9IE9iamVjdC5mcmVlemUoe1xuICBuYW1lOiBudWxsLFxuICBpbnRlcnZhbHM6IFtdLFxuICBuYW1lczogW10sXG4gIGNocm9tYTogbnVsbCxcbiAgc2V0bnVtOiBudWxsXG59KTtcblxudmFyIHByb3BlcnRpZXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgaW50ZXJ2YWxzID0gdG9uYWxEaWN0aW9uYXJ5LnNjYWxlKG5hbWUpO1xuICBpZiAoIWludGVydmFscykgeyByZXR1cm4gTk9fU0NBTEU7IH1cbiAgdmFyIHMgPSB7IGludGVydmFsczogaW50ZXJ2YWxzLCBuYW1lOiBuYW1lIH07XG4gIHMuY2hyb21hID0gdG9uYWxQY3NldC5jaHJvbWEoaW50ZXJ2YWxzKTtcbiAgcy5zZXRudW0gPSBwYXJzZUludChzLmNocm9tYSwgMik7XG4gIHMubmFtZXMgPSB0b25hbERpY3Rpb25hcnkuc2NhbGUubmFtZXMocy5jaHJvbWEpO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShzKTtcbn07XG5cbnZhciBtZW1vaXplID0gZnVuY3Rpb24gKGZuLCBjYWNoZSkgeyByZXR1cm4gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gY2FjaGVbc3RyXSB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpOyB9OyB9O1xuXG4vKipcbiAqIEdldCBzY2FsZSBwcm9wZXJ0aWVzLiBJdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoOlxuICogLSBuYW1lOiB0aGUgc2NhbGUgbmFtZVxuICogLSBuYW1lczogYSBsaXN0IHdpdGggYWxsIHBvc3NpYmxlIG5hbWVzIChpbmNsdWRlcyB0aGUgY3VycmVudClcbiAqIC0gaW50ZXJ2YWxzOiBhbiBhcnJheSB3aXRoIHRoZSBzY2FsZSBpbnRlcnZhbHNcbiAqIC0gY2hyb21hOiAgc2NhbGUgY3JvbWEgKHNlZSBwY3NldClcbiAqIC0gc2V0bnVtOiBzY2FsZSBjaHJvbWEgbnVtYmVyXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBzY2FsZSBuYW1lICh3aXRob3V0IHRvbmljKVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgcHJvcHMgPSBtZW1vaXplKHByb3BlcnRpZXMsIHt9KTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGF2YWlsYWJsZSBzY2FsZSBuYW1lc1xuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbYWxpYXNlcz1mYWxzZV0gLSB0cnVlIHRvIGluY2x1ZGUgYWxpYXNlc1xuICogQHJldHVybiB7QXJyYXl9IHRoZSBzY2FsZSBuYW1lc1xuICpcbiAqIEBleGFtcGxlXG4gKiBTY2FsZS5uYW1lcygpIC8vID0+IFtcIm1hajdcIiwgLi4uXVxuICovXG52YXIgbmFtZXMgPSB0b25hbERpY3Rpb25hcnkuc2NhbGUubmFtZXM7XG5cbi8qKlxuICogR2l2ZW4gYSBzY2FsZSBuYW1lLCByZXR1cm4gaXRzIGludGVydmFscy4gVGhlIG5hbWUgY2FuIGJlIHRoZSB0eXBlIGFuZFxuICogb3B0aW9uYWxseSB0aGUgdG9uaWMgKHdoaWNoIGlzIGlnbm9yZWQpXG4gKlxuICogSXQgcmV0cnVucyBhbiBlbXB0eSBhcnJheSB3aGVuIG5vIHNjYWxlIGZvdW5kXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBzY2FsZSBuYW1lICh0b25pYyBhbmQgdHlwZSwgdG9uaWMgaXMgb3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSB0aGUgc2NhbGUgaW50ZXJ2YWxzIGlmIGlzIGEga25vd24gc2NhbGUgb3IgYW4gZW1wdHlcbiAqIGFycmF5IGlmIG5vIHNjYWxlIGZvdW5kXG4gKiBAZXhhbXBsZVxuICogU2NhbGUuaW50ZXJ2YWxzKFwibWFqb3JcIikgLy8gPT4gWyBcIjFQXCIsIFwiMk1cIiwgXCIzTVwiLCBcIjRQXCIsIFwiNVBcIiwgXCI2TVwiLCBcIjdNXCIgXVxuICovXG52YXIgaW50ZXJ2YWxzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHAgPSB0b2tlbml6ZShuYW1lKTtcbiAgcmV0dXJuIHByb3BzKHBbMV0pLmludGVydmFscztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBub3RlcyAocGl0Y2ggY2xhc3Nlcykgb2YgYSBzY2FsZS5cbiAqXG4gKiBOb3RlIHRoYXQgaXQgYWx3YXlzIHJldHVybnMgYW4gYXJyYXksIGFuZCB0aGUgdmFsdWVzIGFyZSBvbmx5IHBpdGNoIGNsYXNzZXMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9uaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lT3JUb25pYyAtIHRoZSBzY2FsZSBuYW1lIG9yIHRvbmljIChpZiAybmQgcGFyYW0pXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gdGhlIHNjYWxlIG5hbWUgd2l0aG91dCB0b25pY1xuICogQHJldHVybiB7QXJyYXl9IGEgcGl0Y2ggY2xhc3NlcyBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBTY2FsZS5ub3RlcyhcIkNcIiwgXCJtYWpvclwiKSAvLyA9PiBbIFwiQ1wiLCBcIkRcIiwgXCJFXCIsIFwiRlwiLCBcIkdcIiwgXCJBXCIsIFwiQlwiIF1cbiAqIFNjYWxlLm5vdGVzKFwiQyBtYWpvclwiKSAvLyA9PiBbIFwiQ1wiLCBcIkRcIiwgXCJFXCIsIFwiRlwiLCBcIkdcIiwgXCJBXCIsIFwiQlwiIF1cbiAqIFNjYWxlLm5vdGVzKFwiQzRcIiwgXCJtYWpvclwiKSAvLyA9PiBbIFwiQ1wiLCBcIkRcIiwgXCJFXCIsIFwiRlwiLCBcIkdcIiwgXCJBXCIsIFwiQlwiIF1cbiAqIFNjYWxlLm5vdGVzKFwiQTRcIiwgXCJuby1zY2FsZVwiKSAvLyA9PiBbXVxuICogU2NhbGUubm90ZXMoXCJibGFoXCIsIFwibWFqb3JcIikgLy8gPT4gW11cbiAqL1xuZnVuY3Rpb24gbm90ZXMobmFtZU9yVG9uaWMsIG5hbWUpIHtcbiAgdmFyIHAgPSB0b2tlbml6ZShuYW1lT3JUb25pYyk7XG4gIG5hbWUgPSBuYW1lIHx8IHBbMV07XG4gIHJldHVybiBpbnRlcnZhbHMobmFtZSkubWFwKHRvbmFsRGlzdGFuY2UudHJhbnNwb3NlKHBbMF0pKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gbmFtZSBpcyBhIGtub3duIHNjYWxlIGZyb20gdGhlIHNjYWxlcyBkaWN0aW9uYXJ5XG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBzY2FsZSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBleGlzdHMobmFtZSkge1xuICB2YXIgcCA9IHRva2VuaXplKG5hbWUpO1xuICByZXR1cm4gdG9uYWxEaWN0aW9uYXJ5LnNjYWxlKHBbMV0pICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBzdHJpbmcgd2l0aCBhIHNjYWxlIG5hbWUgYW5kIChvcHRpb25hbGx5KSBhIHRvbmljLCBzcGxpdFxuICogdGhhdCBjb21wb25lbnRzLlxuICpcbiAqIEl0IHJldHVucyBhbiBhcnJheSB3aXRoIHRoZSBmb3JtIFsgbmFtZSwgdG9uaWMgXSB3aGVyZSB0b25pYyBjYW4gYmUgYVxuICogbm90ZSBuYW1lIG9yIG51bGwgYW5kIG5hbWUgY2FuIGJlIGFueSBhcmJpdHJhcnkgc3RyaW5nXG4gKiAodGhpcyBmdW5jdGlvbiBkb2VzblwidCBjaGVjayBpZiB0aGF0IHNjYWxlIG5hbWUgZXhpc3RzKVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgc2NhbGUgbmFtZVxuICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IFt0b25pYywgbmFtZV1cbiAqIEBleGFtcGxlXG4gKiBTY2FsZS50b2tlbml6ZShcIkMgbWl4b2x5ZGVhblwiKSAvLyA9PiBbXCJDXCIsIFwibWl4b2x5ZGVhblwiXVxuICogU2NhbGUudG9rZW5pemUoXCJhbnl0aGluZyBpcyB2YWxpZFwiKSAvLyA9PiBbXCJcIiwgXCJhbnl0aGluZyBpcyB2YWxpZFwiXVxuICogU2NhbGUudG9rZW5pemUoKSAvLyA9PiBbXCJcIiwgXCJcIl1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemUoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7IHJldHVybiBbXCJcIiwgXCJcIl07IH1cbiAgdmFyIGkgPSBzdHIuaW5kZXhPZihcIiBcIik7XG4gIHZhciB0b25pYyA9IHRvbmFsTm90ZS5uYW1lKHN0ci5zdWJzdHJpbmcoMCwgaSkpIHx8IHRvbmFsTm90ZS5uYW1lKHN0cikgfHwgXCJcIjtcbiAgdmFyIG5hbWUgPSB0b25pYyAhPT0gXCJcIiA/IHN0ci5zdWJzdHJpbmcodG9uaWMubGVuZ3RoICsgMSkgOiBzdHI7XG4gIHJldHVybiBbdG9uaWMsIG5hbWUubGVuZ3RoID8gbmFtZSA6IFwiXCJdO1xufVxuXG4vKipcbiAqIEZpbmQgbW9kZSBuYW1lcyBvZiBhIHNjYWxlXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHNjYWxlIG5hbWVcbiAqIEBleGFtcGxlXG4gKiBTY2FsZS5tb2RlTmFtZXMoXCJDIHBlbnRhdG9uaWNcIikgLy8gPT4gW1xuICogICBbXCJDXCIsIFwibWFqb3IgcGVudGF0b25pY1wiXSxcbiAqICAgW1wiRFwiLCBcImVneXB0aWFuXCJdLFxuICogICBbXCJFXCIsIFwibWFsa29zIHJhZ2FcIl0sXG4gKiAgIFtcIkdcIiwgXCJyaXR1c2VuXCJdLFxuICogICBbXCJBXCIsIFwibWlub3IgcGVudGF0b25pY1wiXVxuICogXVxuICovXG52YXIgbW9kZU5hbWVzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGl2bHMgPSBpbnRlcnZhbHMobmFtZSk7XG4gIHZhciB0b25pY3MgPSBub3RlcyhuYW1lKTtcblxuICByZXR1cm4gdG9uYWxQY3NldC5tb2RlcyhpdmxzKVxuICAgIC5tYXAoZnVuY3Rpb24gKGNocm9tYSwgaSkge1xuICAgICAgdmFyIG5hbWUgPSB0b25hbERpY3Rpb25hcnkuc2NhbGUubmFtZXMoY2hyb21hKVswXTtcbiAgICAgIGlmIChuYW1lKSB7IHJldHVybiBbdG9uaWNzW2ldIHx8IGl2bHNbaV0sIG5hbWVdOyB9XG4gICAgfSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcbn07XG5cbi8qKlxuICogR2V0IGFsbCBjaG9yZHMgdGhhdCBmaXRzIGEgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIHNjYWxlIG5hbWVcbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IC0gdGhlIGNob3JkIG5hbWVzXG4gKlxuICogQGV4YW1wbGVcbiAqIFNjYWxlLmNob3JkcyhcInBlbnRhdG9uaWNcIikgLy8gPT4gW1wiNVwiLCBcIjY0XCIsIFwiTVwiLCBcIk02XCIsIFwiTWFkZDlcIiwgXCJNc3VzMlwiXVxuICovXG52YXIgY2hvcmRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGluU2NhbGUgPSB0b25hbFBjc2V0LmlzU3Vic2V0T2YoaW50ZXJ2YWxzKG5hbWUpKTtcbiAgcmV0dXJuIHRvbmFsRGljdGlvbmFyeS5jaG9yZC5uYW1lcygpLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gaW5TY2FsZSh0b25hbERpY3Rpb25hcnkuY2hvcmQobmFtZSkpOyB9KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2Ygbm90ZXMsIHJldHVybiB0aGUgc2NhbGU6IGEgcGl0Y2ggY2xhc3Mgc2V0IHN0YXJ0aW5nIGZyb21cbiAqIHRoZSBmaXJzdCBub3RlIG9mIHRoZSBhcnJheVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtBcnJheX0gbm90ZXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGV4YW1wbGVcbiAqIFNjYWxlLnRvU2NhbGUoWydDNCcsICdjMycsICdDNScsICdDNCcsICdjNCddKSAvLyA9PiBbXCJDXCJdXG4gKiBTY2FsZS50b1NjYWxlKFsnRDQnLCAnYyM1JywgJ0E1JywgJ0YjNiddKSAvLyA9PiBbXCJEXCIsIFwiRiNcIiwgXCJBXCIsIFwiQyNcIl1cbiAqL1xudmFyIHRvU2NhbGUgPSBmdW5jdGlvbiAobm90ZXMpIHtcbiAgdmFyIHBjc2V0ID0gdG9uYWxBcnJheS5jb21wYWN0KG5vdGVzLm1hcCh0b25hbE5vdGUucGMpKTtcbiAgaWYgKCFwY3NldC5sZW5ndGgpIHsgcmV0dXJuIHBjc2V0OyB9XG4gIHZhciB0b25pYyA9IHBjc2V0WzBdO1xuICB2YXIgc2NhbGUgPSB0b25hbEFycmF5LnVuaXF1ZShwY3NldCk7XG4gIHJldHVybiB0b25hbEFycmF5LnJvdGF0ZShzY2FsZS5pbmRleE9mKHRvbmljKSwgc2NhbGUpO1xufTtcblxuLyoqXG4gKiBHZXQgYWxsIHNjYWxlcyBuYW1lcyB0aGF0IGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBnaXZlbiBvbmVcbiAqIChoYXMgdGhlIHNhbWUgbm90ZXMgYW5kIGF0IGxlYXN0IG9uZSBtb3JlKVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0FycmF5fSBhIGxpc3Qgb2Ygc2NhbGUgbmFtZXNcbiAqIEBleGFtcGxlXG4gKiBTY2FsZS5zdXBlcnNldHMoXCJtYWpvclwiKSAvLyA9PiBbXCJiZWJvcFwiLCBcImJlYm9wIGRvbWluYW50XCIsIFwiYmVib3AgbWFqb3JcIiwgXCJjaHJvbWF0aWNcIiwgXCJpY2hpa29zdWNob1wiXVxuICovXG52YXIgc3VwZXJzZXRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFpbnRlcnZhbHMobmFtZSkubGVuZ3RoKSB7IHJldHVybiBbXTsgfVxuICB2YXIgaXNTdXBlcnNldCA9IHRvbmFsUGNzZXQuaXNTdXBlcnNldE9mKGludGVydmFscyhuYW1lKSk7XG4gIHJldHVybiB0b25hbERpY3Rpb25hcnkuc2NhbGUubmFtZXMoKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGlzU3VwZXJzZXQodG9uYWxEaWN0aW9uYXJ5LnNjYWxlKG5hbWUpKTsgfSk7XG59O1xuXG4vKipcbiAqIEZpbmQgYWxsIHNjYWxlcyBuYW1lcyB0aGF0IGFyZSBhIHN1YnNldCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiAoaGFzIGxlc3Mgbm90ZXMgYnV0IGFsbCBmcm9tIHRoZSBnaXZlbiBzY2FsZSlcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtBcnJheX0gYSBsaXN0IG9mIHNjYWxlIG5hbWVzXG4gKlxuICogQGV4YW1wbGVcbiAqIFNjYWxlLnN1YnNldHMoXCJtYWpvclwiKSAvLyA9PiBbXCJpb25pYW4gcGVudGF0b25pY1wiLCBcIm1ham9yIHBlbnRhdG9uaWNcIiwgXCJyaXR1c2VuXCJdXG4gKi9cbnZhciBzdWJzZXRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGlzU3Vic2V0ID0gdG9uYWxQY3NldC5pc1N1YnNldE9mKGludGVydmFscyhuYW1lKSk7XG4gIHJldHVybiB0b25hbERpY3Rpb25hcnkuc2NhbGUubmFtZXMoKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGlzU3Vic2V0KHRvbmFsRGljdGlvbmFyeS5zY2FsZShuYW1lKSk7IH0pO1xufTtcblxuZXhwb3J0cy5wcm9wcyA9IHByb3BzO1xuZXhwb3J0cy5uYW1lcyA9IG5hbWVzO1xuZXhwb3J0cy5pbnRlcnZhbHMgPSBpbnRlcnZhbHM7XG5leHBvcnRzLm5vdGVzID0gbm90ZXM7XG5leHBvcnRzLmV4aXN0cyA9IGV4aXN0cztcbmV4cG9ydHMudG9rZW5pemUgPSB0b2tlbml6ZTtcbmV4cG9ydHMubW9kZU5hbWVzID0gbW9kZU5hbWVzO1xuZXhwb3J0cy5jaG9yZHMgPSBjaG9yZHM7XG5leHBvcnRzLnRvU2NhbGUgPSB0b1NjYWxlO1xuZXhwb3J0cy5zdXBlcnNldHMgPSBzdXBlcnNldHM7XG5leHBvcnRzLnN1YnNldHMgPSBzdWJzZXRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/tonal-scale@2.2.2/node_modules/tonal-scale/build/es5.js\n");

/***/ })

};
;