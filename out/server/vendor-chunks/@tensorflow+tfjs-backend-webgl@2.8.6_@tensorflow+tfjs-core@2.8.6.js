"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tensorflow+tfjs-backend-webgl@2.8.6_@tensorflow+tfjs-core@2.8.6";
exports.ids = ["vendor-chunks/@tensorflow+tfjs-backend-webgl@2.8.6_@tensorflow+tfjs-core@2.8.6"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@tensorflow+tfjs-backend-webgl@2.8.6_@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-backend-webgl/dist/tf-backend-webgl.node.js":
/*!***********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tensorflow+tfjs-backend-webgl@2.8.6_@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-backend-webgl/dist/tf-backend-webgl.node.js ***!
  \***********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar tf = __webpack_require__(/*! @tensorflow/tfjs-core */ \"(ssr)/./node_modules/.pnpm/@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-core/dist/tf-core.node.js\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar contexts = {};\nvar WEBGL_ATTRIBUTES = {\n    alpha: false,\n    antialias: false,\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: false,\n    depth: false,\n    stencil: false,\n    failIfMajorPerformanceCaveat: true\n};\nfunction setWebGLContext(webGLVersion, gl) {\n    contexts[webGLVersion] = gl;\n}\nfunction getWebGLContext(webGLVersion) {\n    if (!(webGLVersion in contexts)) {\n        var newCtx = getWebGLRenderingContext(webGLVersion);\n        if (newCtx !== null) {\n            contexts[webGLVersion] = newCtx;\n        }\n        else {\n            console.log('Could not get context for WebGL version', webGLVersion);\n            return null;\n        }\n    }\n    var gl = contexts[webGLVersion];\n    if (gl.isContextLost()) {\n        delete contexts[webGLVersion];\n        return getWebGLContext(webGLVersion);\n    }\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.STENCIL_TEST);\n    gl.disable(gl.BLEND);\n    gl.disable(gl.DITHER);\n    gl.disable(gl.POLYGON_OFFSET_FILL);\n    gl.disable(gl.SAMPLE_COVERAGE);\n    gl.enable(gl.SCISSOR_TEST);\n    gl.enable(gl.CULL_FACE);\n    gl.cullFace(gl.BACK);\n    return contexts[webGLVersion];\n}\nfunction createCanvas(webGLVersion) {\n    if (typeof OffscreenCanvas !== 'undefined' && webGLVersion === 2) {\n        return new OffscreenCanvas(300, 150);\n    }\n    else if (typeof document !== 'undefined') {\n        return document.createElement('canvas');\n    }\n    else {\n        throw new Error('Cannot create a canvas in this context');\n    }\n}\nfunction getWebGLRenderingContext(webGLVersion) {\n    if (webGLVersion !== 1 && webGLVersion !== 2) {\n        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');\n    }\n    var canvas = createCanvas(webGLVersion);\n    canvas.addEventListener('webglcontextlost', function (ev) {\n        ev.preventDefault();\n        delete contexts[webGLVersion];\n    }, false);\n    if (webGLVersion === 1) {\n        return (canvas.getContext('webgl', WEBGL_ATTRIBUTES) ||\n            canvas.getContext('experimental-webgl', WEBGL_ATTRIBUTES));\n    }\n    return canvas.getContext('webgl2', WEBGL_ATTRIBUTES);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar PackingScheme;\n(function (PackingScheme) {\n    /**\n     * All values in a single texel are densely packed without any constraints.\n     *\n     * This is how the shader encodes a tensor with shape = [2, 3, 4]\n     * (indices are [batch, row, col]).\n     *\n     * 000|001   010|011   020|021\n     * -------   -------   -------\n     * 002|003   012|013   022|023\n     *\n     * 100|101   110|111   120|121\n     * -------   -------   -------\n     * 102|103   112|113   122|123\n     *\n     */\n    PackingScheme[PackingScheme[\"DENSE\"] = 0] = \"DENSE\";\n    /**\n     * Single texels contain only values from the same batch, and from adjacent\n     * rows and columns.\n     *\n     * This is how the shader encodes a tensor with shape = [2, 3, 5]\n     * (indices are [batch, row, col]).\n     *\n     * 000|001   002|003   004|xxx   020|021   022|023   024|xxx\n     * -------   -------   -------   -------   -------   -------\n     * 010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n     *\n     * 100|101   102|103   104|xxx   120|121   122|123   124|xxx\n     * -------   -------   -------   -------   -------   -------\n     * 110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n     *\n     */\n    PackingScheme[PackingScheme[\"SHARED_BATCH\"] = 1] = \"SHARED_BATCH\";\n})(PackingScheme || (PackingScheme = {}));\nvar TextureUsage;\n(function (TextureUsage) {\n    TextureUsage[TextureUsage[\"RENDER\"] = 0] = \"RENDER\";\n    TextureUsage[TextureUsage[\"UPLOAD\"] = 1] = \"UPLOAD\";\n    TextureUsage[TextureUsage[\"PIXELS\"] = 2] = \"PIXELS\";\n    TextureUsage[TextureUsage[\"DOWNLOAD\"] = 3] = \"DOWNLOAD\";\n})(TextureUsage || (TextureUsage = {}));\nvar PhysicalTextureType;\n(function (PhysicalTextureType) {\n    PhysicalTextureType[PhysicalTextureType[\"UNPACKED_FLOAT16\"] = 0] = \"UNPACKED_FLOAT16\";\n    PhysicalTextureType[PhysicalTextureType[\"UNPACKED_FLOAT32\"] = 1] = \"UNPACKED_FLOAT32\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_4X1_UNSIGNED_BYTE\"] = 2] = \"PACKED_4X1_UNSIGNED_BYTE\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_2X2_FLOAT32\"] = 3] = \"PACKED_2X2_FLOAT32\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_2X2_FLOAT16\"] = 4] = \"PACKED_2X2_FLOAT16\";\n})(PhysicalTextureType || (PhysicalTextureType = {}));\nfunction getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {\n    return [columns, rows];\n}\nfunction getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {\n    return matrixSize * channelsPerTexture;\n}\n/**\n * Get shape for densely packed RGBA texture.\n */\nfunction getDenseTexShape(shape) {\n    var size = tf.util.sizeFromShape(shape);\n    var texelsNeeded = Math.ceil(size / 4);\n    return tf.util.sizeToSquarishShape(texelsNeeded);\n}\nfunction getPackedMatrixTextureShapeWidthHeight(rows, columns) {\n    return [\n        Math.max(1, Math.ceil(columns / 2)), Math.max(1, Math.ceil(rows / 2))\n    ];\n}\nfunction getPackedRGBAArraySizeFromMatrixShape(rows, columns) {\n    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];\n    return w * h * 4;\n}\nfunction getTextureConfig(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n    // tslint:disable-next-line:no-any\n    var glany = gl;\n    var internalFormatFloat;\n    var internalFormatHalfFloat;\n    var internalFormatPackedHalfFloat;\n    var internalFormatPackedFloat;\n    var textureFormatFloat;\n    var downloadTextureFormat;\n    var downloadUnpackNumChannels;\n    var defaultNumChannels;\n    var textureTypeHalfFloat;\n    var textureTypeFloat;\n    if (tf.env().getNumber('WEBGL_VERSION') === 2) {\n        internalFormatFloat = glany.R32F;\n        internalFormatHalfFloat = glany.R16F;\n        internalFormatPackedHalfFloat = glany.RGBA16F;\n        internalFormatPackedFloat = glany.RGBA32F;\n        textureFormatFloat = glany.RED;\n        downloadUnpackNumChannels = 4;\n        defaultNumChannels = 1;\n        textureTypeHalfFloat = glany.HALF_FLOAT;\n        textureTypeFloat = glany.FLOAT;\n    }\n    else {\n        internalFormatFloat = gl.RGBA;\n        internalFormatHalfFloat = gl.RGBA;\n        internalFormatPackedHalfFloat = gl.RGBA;\n        internalFormatPackedFloat = glany.RGBA;\n        textureFormatFloat = gl.RGBA;\n        downloadUnpackNumChannels = 4;\n        defaultNumChannels = 4;\n        textureTypeHalfFloat = textureHalfFloatExtension != null ?\n            textureHalfFloatExtension.HALF_FLOAT_OES :\n            null;\n        textureTypeFloat = gl.FLOAT;\n    }\n    downloadTextureFormat = gl.RGBA;\n    return {\n        internalFormatFloat: internalFormatFloat,\n        internalFormatHalfFloat: internalFormatHalfFloat,\n        internalFormatPackedHalfFloat: internalFormatPackedHalfFloat,\n        internalFormatPackedFloat: internalFormatPackedFloat,\n        textureFormatFloat: textureFormatFloat,\n        downloadTextureFormat: downloadTextureFormat,\n        downloadUnpackNumChannels: downloadUnpackNumChannels,\n        defaultNumChannels: defaultNumChannels,\n        textureTypeHalfFloat: textureTypeHalfFloat,\n        textureTypeFloat: textureTypeFloat\n    };\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction callAndCheck(gl, func) {\n    var returnValue = func();\n    if (tf.env().getBool('DEBUG')) {\n        checkWebGLError(gl);\n    }\n    return returnValue;\n}\nfunction checkWebGLError(gl) {\n    var error = gl.getError();\n    if (error !== gl.NO_ERROR) {\n        throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n    }\n}\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nvar MIN_FLOAT16 = 5.96e-8;\nvar MAX_FLOAT16 = 65504;\nfunction canBeRepresented(num) {\n    if (tf.env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n        (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n        return true;\n    }\n    return false;\n}\nfunction getWebGLErrorMessage(gl, status) {\n    switch (status) {\n        case gl.NO_ERROR:\n            return 'NO_ERROR';\n        case gl.INVALID_ENUM:\n            return 'INVALID_ENUM';\n        case gl.INVALID_VALUE:\n            return 'INVALID_VALUE';\n        case gl.INVALID_OPERATION:\n            return 'INVALID_OPERATION';\n        case gl.INVALID_FRAMEBUFFER_OPERATION:\n            return 'INVALID_FRAMEBUFFER_OPERATION';\n        case gl.OUT_OF_MEMORY:\n            return 'OUT_OF_MEMORY';\n        case gl.CONTEXT_LOST_WEBGL:\n            return 'CONTEXT_LOST_WEBGL';\n        default:\n            return \"Unknown error code \" + status;\n    }\n}\nfunction getExtensionOrThrow(gl, extensionName) {\n    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nfunction createVertexShader(gl, vertexShaderSource) {\n    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');\n    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });\n    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });\n    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n        console.log(gl.getShaderInfoLog(vertexShader));\n        throw new Error('Failed to compile vertex shader.');\n    }\n    return vertexShader;\n}\nfunction createFragmentShader(gl, fragmentShaderSource) {\n    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');\n    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });\n    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });\n    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n        throw new Error('Failed to compile fragment shader.');\n    }\n    return fragmentShader;\n}\nvar lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n    var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n    if (lineNumberRegexResult == null) {\n        console.log(\"Couldn't parse line number in error: \" + shaderInfoLog);\n        console.log(shaderSource);\n        return;\n    }\n    var lineNumber = +lineNumberRegexResult[1];\n    var shaderLines = shaderSource.split('\\n');\n    var pad = shaderLines.length.toString().length + 2;\n    var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {\n        return tf.util.rightPad((lineNumber + 1).toString(), pad) + line;\n    });\n    var maxLineLength = 0;\n    for (var i = 0; i < linesWithLineNumbers.length; i++) {\n        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n    }\n    var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n    var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n    var afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n    console.log(beforeErrorLines.join('\\n'));\n    console.log(shaderInfoLog.split('\\n')[0]);\n    console.log(\"%c \" + tf.util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n    console.log(afterErrorLines.join('\\n'));\n}\nfunction createProgram(gl) {\n    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');\n}\nfunction linkProgram(gl, program) {\n    callAndCheck(gl, function () { return gl.linkProgram(program); });\n    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Failed to link vertex and fragment shaders.');\n    }\n}\nfunction validateProgram(gl, program) {\n    callAndCheck(gl, function () { return gl.validateProgram(program); });\n    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Shader program validation failed.');\n    }\n}\nfunction createStaticVertexBuffer(gl, data) {\n    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');\n    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });\n    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });\n    return buffer;\n}\nfunction createStaticIndexBuffer(gl, data) {\n    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');\n    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });\n    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });\n    return buffer;\n}\nfunction getNumChannels() {\n    if (tf.env().getNumber('WEBGL_VERSION') === 2) {\n        return 1;\n    }\n    return 4;\n}\nfunction createTexture(gl) {\n    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');\n}\nfunction validateTextureSize(width, height) {\n    var maxTextureSize = tf.env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if ((width <= 0) || (height <= 0)) {\n        var requested = \"[\" + width + \"x\" + height + \"]\";\n        throw new Error('Requested texture size ' + requested + ' is invalid.');\n    }\n    if ((width > maxTextureSize) || (height > maxTextureSize)) {\n        var requested = \"[\" + width + \"x\" + height + \"]\";\n        var max = \"[\" + maxTextureSize + \"x\" + maxTextureSize + \"]\";\n        throw new Error('Requested texture size ' + requested +\n            ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n    }\n}\nfunction createFramebuffer(gl) {\n    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');\n}\nfunction bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n    var loc = gl.getAttribLocation(program, attribute);\n    if (loc === -1) {\n        // The GPU compiler decided to strip out this attribute because it's unused,\n        // thus no need to bind.\n        return false;\n    }\n    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });\n    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });\n    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });\n    return true;\n}\nfunction bindTextureUnit(gl, texture, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });\n    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });\n}\nfunction unbindTextureUnit(gl, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });\n    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });\n}\nfunction getProgramUniformLocationOrThrow(gl, program, uniformName) {\n    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform \"' + uniformName + '\" not present in program.');\n}\nfunction getProgramUniformLocation(gl, program, uniformName) {\n    return gl.getUniformLocation(program, uniformName);\n}\nfunction bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });\n    callAndCheck(gl, function () { return gl.uniform1i(uniformSamplerLocation, textureUnit); });\n}\nfunction bindCanvasToFramebuffer(gl) {\n    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });\n    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });\n    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });\n}\nfunction bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });\n    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });\n}\nfunction unbindColorTextureFromFramebuffer(gl, framebuffer) {\n    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });\n    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });\n}\nfunction validateFramebuffer(gl) {\n    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n    }\n}\nfunction getFramebufferErrorMessage(gl, status) {\n    switch (status) {\n        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n        case gl.FRAMEBUFFER_UNSUPPORTED:\n            return 'FRAMEBUFFER_UNSUPPORTED';\n        default:\n            return \"unknown error \" + status;\n    }\n}\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });\n    if (tOrNull == null) {\n        throw new Error(failureMessage);\n    }\n    return tOrNull;\n}\nfunction validateTextureUnit(gl, textureUnit) {\n    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n    var glTextureUnit = textureUnit + gl.TEXTURE0;\n    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n        var textureUnitRange = \"[gl.TEXTURE0, gl.TEXTURE\" + maxTextureUnit + \"]\";\n        throw new Error(\"textureUnit must be in \" + textureUnitRange + \".\");\n    }\n}\nfunction getBatchDim(shape, dimsToSkip) {\n    if (dimsToSkip === void 0) { dimsToSkip = 2; }\n    return tf.util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nfunction getRowsCols(shape) {\n    if (shape.length === 0) {\n        throw Error('Cannot get rows and columns of an empty shape array.');\n    }\n    return [\n        shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n    ];\n}\nfunction getShapeAs3D(shape) {\n    var shapeAs3D = [1, 1, 1];\n    var isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n    if (!isScalar) {\n        shapeAs3D =\n            [getBatchDim(shape)].concat(getRowsCols(shape));\n    }\n    return shapeAs3D;\n}\nfunction getTextureShapeFromLogicalShape(logShape, isPacked) {\n    var _a;\n    if (isPacked === void 0) { isPacked = false; }\n    var maxTexSize = tf.env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if (isPacked) {\n        maxTexSize = maxTexSize * 2;\n        // This logic ensures we accurately count the number of packed texels needed\n        // to accommodate the tensor. We can only pack values in the same texel if\n        // they are from adjacent pairs of rows/cols within the same batch. So if a\n        // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n        // fact that the texels containing the third row are half empty.\n        logShape = logShape.map(function (d, i) { return i >= logShape.length - 2 ?\n            tf.util.nearestLargerEven(logShape[i]) :\n            logShape[i]; });\n        // Packed texture height is at least 2 (the channel height of a single\n        // texel).\n        if (logShape.length === 1) {\n            logShape = [2, logShape[0]];\n        }\n    }\n    // If logical shape is 2, we don't squeeze, since we want to match physical.\n    if (logShape.length !== 2) {\n        var squeezeResult = tf.util.squeezeShape(logShape);\n        logShape = squeezeResult.newShape;\n    }\n    var size = tf.util.sizeFromShape(logShape);\n    if (logShape.length <= 1 && size <= maxTexSize) {\n        return [1, size];\n    }\n    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&\n        logShape[1] <= maxTexSize) {\n        return logShape;\n    }\n    else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n        logShape[2] <= maxTexSize) {\n        return [logShape[0] * logShape[1], logShape[2]];\n    }\n    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2]];\n    }\n    else if (logShape.length === 4 &&\n        logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n        logShape[3] <= maxTexSize) {\n        return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n    }\n    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    }\n    else {\n        if (isPacked) {\n            // For packed textures size equals the number of channels required to\n            // accommodate the texture data. However in order to squarify such that\n            // inner dimensions stay even, we rewrite size to equal the number of\n            // texels. Then in the return statement we rehydrate the squarified\n            // dimensions to channel units.\n            var batchDim = getBatchDim(logShape);\n            var rows = 2, cols = 2;\n            if (logShape.length) {\n                _a = getRowsCols(logShape), rows = _a[0], cols = _a[1];\n            }\n            size = batchDim * (rows / 2) * (cols / 2);\n            return tf.util.sizeToSquarishShape(size).map(function (d) { return d * 2; });\n        }\n        return tf.util.sizeToSquarishShape(size);\n    }\n}\nfunction isEven(n) {\n    return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nfunction isReshapeFree(shape1, shape2) {\n    shape1 = shape1.slice(-2);\n    shape2 = shape2.slice(-2);\n    if (tf.util.arraysEqual(shape1, shape2)) {\n        return true;\n    }\n    if (!shape1.length || !shape2.length) { // One of the shapes is a scalar.\n        return true;\n    }\n    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n        shape2[1] === 0) {\n        return true;\n    }\n    if (shape1.length !== shape2.length) { // One of the shapes is a vector.\n        var shape1Cols = shape1.slice(-1)[0];\n        var shape2Cols = shape2.slice(-1)[0];\n        if (shape1Cols === shape2Cols) {\n            return true;\n        }\n        if (isEven(shape1Cols) && isEven(shape2Cols) &&\n            (shape1[0] === 1 || shape2[0] === 1)) {\n            return true;\n        }\n    }\n    return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nvar MAX_TEXTURE_SIZE;\nvar MAX_TEXTURES_IN_SHADER;\nfunction getWebGLMaxTextureSize(webGLVersion) {\n    if (MAX_TEXTURE_SIZE == null) {\n        var gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    }\n    return MAX_TEXTURE_SIZE;\n}\nfunction resetMaxTextureSize() {\n    MAX_TEXTURE_SIZE = null;\n}\nfunction resetMaxTexturesInShader() {\n    MAX_TEXTURES_IN_SHADER = null;\n}\nfunction getMaxTexturesInShader(webGLVersion) {\n    if (MAX_TEXTURES_IN_SHADER == null) {\n        var gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    }\n    // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n    return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nfunction getWebGLDisjointQueryTimerVersion(webGLVersion) {\n    if (webGLVersion === 0) {\n        return 0;\n    }\n    var queryTimerVersion;\n    var gl = getWebGLContext(webGLVersion);\n    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n        webGLVersion === 2) {\n        queryTimerVersion = 2;\n    }\n    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n        queryTimerVersion = 1;\n    }\n    else {\n        queryTimerVersion = 0;\n    }\n    return queryTimerVersion;\n}\nfunction hasExtension(gl, extensionName) {\n    var ext = gl.getExtension(extensionName);\n    return ext != null;\n}\nfunction isWebGLVersionEnabled(webGLVersion) {\n    try {\n        var gl = getWebGLContext(webGLVersion);\n        if (gl != null) {\n            return true;\n        }\n    }\n    catch (e) {\n        console.log('Error when getting WebGL context: ', e);\n        return false;\n    }\n    return false;\n}\nfunction isCapableOfRenderingToFloatTexture(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    var gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n    }\n    else {\n        if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n            return false;\n        }\n    }\n    var isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nfunction isDownloadFloatTextureEnabled(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    var gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n        if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n            return false;\n        }\n    }\n    else {\n        if (hasExtension(gl, 'EXT_color_buffer_float')) {\n            return createFloatTextureAndBindToFramebuffer(gl);\n        }\n        var COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n            var textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n        }\n        return false;\n    }\n    var isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n    var texConfig = getTextureConfig(gl);\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    var width = 1;\n    var height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n    var frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    var isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nfunction createHalfFloatTextureAndBindToFramebuffer(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n    var texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    var width = 1;\n    var height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n    var frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    var isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nfunction isWebGLFenceEnabled(webGLVersion) {\n    if (webGLVersion !== 2) {\n        return false;\n    }\n    var gl = getWebGLContext(webGLVersion);\n    // tslint:disable-next-line:no-any\n    var isEnabled = gl.fenceSync != null;\n    return isEnabled;\n}\nfunction assertNotComplex(tensor, opName) {\n    if (!Array.isArray(tensor)) {\n        tensor = [tensor];\n    }\n    tensor.forEach(function (t) {\n        if (t != null) {\n            tf.util.assert(t.dtype !== 'complex64', function () { return opName + \" does not support complex64 tensors \" +\n                'in the WebGL backend.'; });\n        }\n    });\n}\n\nvar webgl_util = {\n    __proto__: null,\n    callAndCheck: callAndCheck,\n    canBeRepresented: canBeRepresented,\n    getWebGLErrorMessage: getWebGLErrorMessage,\n    getExtensionOrThrow: getExtensionOrThrow,\n    createVertexShader: createVertexShader,\n    createFragmentShader: createFragmentShader,\n    createProgram: createProgram,\n    linkProgram: linkProgram,\n    validateProgram: validateProgram,\n    createStaticVertexBuffer: createStaticVertexBuffer,\n    createStaticIndexBuffer: createStaticIndexBuffer,\n    getNumChannels: getNumChannels,\n    createTexture: createTexture,\n    validateTextureSize: validateTextureSize,\n    createFramebuffer: createFramebuffer,\n    bindVertexBufferToProgramAttribute: bindVertexBufferToProgramAttribute,\n    bindTextureUnit: bindTextureUnit,\n    unbindTextureUnit: unbindTextureUnit,\n    getProgramUniformLocationOrThrow: getProgramUniformLocationOrThrow,\n    getProgramUniformLocation: getProgramUniformLocation,\n    bindTextureToProgramUniformSampler: bindTextureToProgramUniformSampler,\n    bindCanvasToFramebuffer: bindCanvasToFramebuffer,\n    bindColorTextureToFramebuffer: bindColorTextureToFramebuffer,\n    unbindColorTextureFromFramebuffer: unbindColorTextureFromFramebuffer,\n    validateFramebuffer: validateFramebuffer,\n    getFramebufferErrorMessage: getFramebufferErrorMessage,\n    getBatchDim: getBatchDim,\n    getRowsCols: getRowsCols,\n    getShapeAs3D: getShapeAs3D,\n    getTextureShapeFromLogicalShape: getTextureShapeFromLogicalShape,\n    isReshapeFree: isReshapeFree,\n    getWebGLMaxTextureSize: getWebGLMaxTextureSize,\n    resetMaxTextureSize: resetMaxTextureSize,\n    resetMaxTexturesInShader: resetMaxTexturesInShader,\n    getMaxTexturesInShader: getMaxTexturesInShader,\n    getWebGLDisjointQueryTimerVersion: getWebGLDisjointQueryTimerVersion,\n    hasExtension: hasExtension,\n    isWebGLVersionEnabled: isWebGLVersionEnabled,\n    isCapableOfRenderingToFloatTexture: isCapableOfRenderingToFloatTexture,\n    isDownloadFloatTextureEnabled: isDownloadFloatTextureEnabled,\n    isWebGLFenceEnabled: isWebGLFenceEnabled,\n    assertNotComplex: assertNotComplex\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ENV = tf.env();\n/**\n * This file contains WebGL-specific flag registrations.\n */\n/**\n * True if WebGL is supported.\n */\nENV.registerFlag('HAS_WEBGL', function () { return ENV.getNumber('WEBGL_VERSION') > 0; });\n/** 0: No WebGL, 1: WebGL 1.0, 2: WebGL 2.0. */\nENV.registerFlag('WEBGL_VERSION', function () {\n    if (isWebGLVersionEnabled(2)) {\n        return 2;\n    }\n    else if (isWebGLVersionEnabled(1)) {\n        return 1;\n    }\n    return 0;\n});\n/** Whether to check for numerical representation problems. */\nENV.registerFlag('WEBGL_CHECK_NUMERICAL_PROBLEMS', function () { return false; });\nENV.registerFlag('WEBGL_BUFFER_SUPPORTED', function () { return ENV.get('WEBGL_VERSION') === 2; });\n/** Whether the WebGL backend will sometimes forward ops to the CPU. */\nENV.registerFlag('WEBGL_CPU_FORWARD', function () { return true; });\n/** Whether the WebGL backend will always use f16 textures for rendering. */\nENV.registerFlag('WEBGL_FORCE_F16_TEXTURES', function () { return false; });\n/** Whether to turn all packing related flags on. */\nENV.registerFlag('WEBGL_PACK', function () { return ENV.getBool('HAS_WEBGL'); });\n/** Whether we will pack the batchnormalization op. */\nENV.registerFlag('WEBGL_PACK_NORMALIZATION', function () { return ENV.getBool('WEBGL_PACK'); });\n/** Whether we will pack the clip op. */\nENV.registerFlag('WEBGL_PACK_CLIP', function () { return ENV.getBool('WEBGL_PACK'); });\n/** Whether we will pack the depthwise conv op. */\n// TODO: https://github.com/tensorflow/tfjs/issues/1679\nENV.registerFlag('WEBGL_PACK_DEPTHWISECONV', function () { return false; });\n/** Whether we will pack binary ops. */\nENV.registerFlag('WEBGL_PACK_BINARY_OPERATIONS', function () { return ENV.getBool('WEBGL_PACK'); });\n/** Whether we will pack unary ops. */\nENV.registerFlag('WEBGL_PACK_UNARY_OPERATIONS', function () { return ENV.getBool('WEBGL_PACK'); });\n/** Whether we will pack array ops. */\nENV.registerFlag('WEBGL_PACK_ARRAY_OPERATIONS', function () { return ENV.getBool('WEBGL_PACK'); });\n/** Whether we will pack image ops. */\nENV.registerFlag('WEBGL_PACK_IMAGE_OPERATIONS', function () { return ENV.getBool('WEBGL_PACK'); });\n/** Whether we will pack reduce ops. */\nENV.registerFlag('WEBGL_PACK_REDUCE', function () { return ENV.getBool('WEBGL_PACK'); });\n/** Whether packed WebGL kernels lazily unpack their outputs. */\nENV.registerFlag('WEBGL_LAZILY_UNPACK', function () { return ENV.getBool('WEBGL_PACK'); });\n/** Whether we will use the im2col algorithm to speed up convolutions. */\nENV.registerFlag('WEBGL_CONV_IM2COL', function () { return ENV.getBool('WEBGL_PACK'); });\n/** The maximum texture dimension. */\nENV.registerFlag('WEBGL_MAX_TEXTURE_SIZE', function () { return getWebGLMaxTextureSize(ENV.getNumber('WEBGL_VERSION')); });\n/** The maximum texture dimension. */\nENV.registerFlag('WEBGL_MAX_TEXTURES_IN_SHADER', function () { return getMaxTexturesInShader(ENV.getNumber('WEBGL_VERSION')); });\n/**\n * The disjoint_query_timer extension version.\n * 0: disabled, 1: EXT_disjoint_timer_query, 2:\n * EXT_disjoint_timer_query_webgl2.\n * In Firefox with WebGL 2.0,\n * EXT_disjoint_timer_query_webgl2 is not available, so we must use the\n * WebGL 1.0 extension.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', function () {\n    var webGLVersion = ENV.getNumber('WEBGL_VERSION');\n    if (webGLVersion === 0) {\n        return 0;\n    }\n    return getWebGLDisjointQueryTimerVersion(webGLVersion);\n});\n/**\n * Whether the timer object from the disjoint_query_timer extension gives\n * timing information that is reliable.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', function () { return ENV.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&\n    !tf.device_util.isMobile(); });\n/**\n * Whether the device is physically capable of rendering to float32 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_CAPABLE', function () { return isCapableOfRenderingToFloatTexture(ENV.getNumber('WEBGL_VERSION')); });\n/**\n * Whether rendering to float32 textures is enabled. If disabled, renders to\n * float16 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_ENABLED', function () {\n    return ENV.getBool('WEBGL_FORCE_F16_TEXTURES') ?\n        false :\n        ENV.getBool('WEBGL_RENDER_FLOAT32_CAPABLE');\n});\n/**\n * Whether downloading float textures is enabled (16 or 32 bit). If disabled,\n * uses IEEE 754 encoding of the float32 values to 4 uint8 when downloading.\n */\nENV.registerFlag('WEBGL_DOWNLOAD_FLOAT_ENABLED', function () { return isDownloadFloatTextureEnabled(ENV.getNumber('WEBGL_VERSION')); });\n/** Whether the fence API is available. */\nENV.registerFlag('WEBGL_FENCE_API_ENABLED', function () { return isWebGLFenceEnabled(ENV.getNumber('WEBGL_VERSION')); });\n/**\n * Tensors with size <= than this will be uploaded as uniforms, not textures.\n */\nENV.registerFlag('WEBGL_SIZE_UPLOAD_UNIFORM', function () {\n    // Use uniform uploads only when 32bit floats are supported. In\n    // 16bit\n    // environments there are problems with comparing a 16bit texture value\n    // with a 32bit uniform value.\n    var useUniforms = ENV.getBool('WEBGL_RENDER_FLOAT32_ENABLED');\n    return useUniforms ? 4 : 0;\n});\n/**\n * If the total number of bytes allocated on the GPU is greater than this\n * number, we will aggressively delete textures upon disposal with\n * gl.deleteMatrixTexture, rather than making them available for reuse.\n *\n * Default value -1 indicates that we will never aggressively delete textures.\n */\nENV.registerFlag('WEBGL_DELETE_TEXTURE_THRESHOLD', function () {\n    return -1;\n}, function (threshold) {\n    if (threshold < 0 && threshold !== -1) {\n        throw new Error(\"WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never \" +\n            (\"delete) or at least 0, but got \" + threshold + \".\"));\n    }\n});\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction getGlslDifferences() {\n    var version;\n    var attribute;\n    var varyingVs;\n    var varyingFs;\n    var texture2D;\n    var output;\n    var defineOutput;\n    var defineSpecialNaN;\n    var defineSpecialInf;\n    var defineRound;\n    if (tf.env().getNumber('WEBGL_VERSION') === 2) {\n        version = '#version 300 es';\n        attribute = 'in';\n        varyingVs = 'out';\n        varyingFs = 'in';\n        texture2D = 'texture';\n        output = 'outputColor';\n        defineOutput = 'out vec4 outputColor;';\n        // Use custom isnan definition to work across differences between\n        // implementations on various platforms. While this should happen in ANGLE\n        // we still see differences between android and windows (on chrome) when\n        // using isnan directly.\n        defineSpecialNaN = \"\\n      bool isnan_custom(float val) {\\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\\n      }\\n\\n      bvec4 isnan_custom(vec4 val) {\\n        return bvec4(isnan_custom(val.x),\\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\\n      }\\n\\n      #define isnan(value) isnan_custom(value)\\n    \";\n        // In webgl 2 we do not need to specify a custom isinf so there is no\n        // need for a special INFINITY constant.\n        defineSpecialInf = \"\";\n        defineRound = \"\\n      #define round(value) newRound(value)\\n      int newRound(float value) {\\n        return int(floor(value + 0.5));\\n      }\\n\\n      ivec4 newRound(vec4 value) {\\n        return ivec4(floor(value + vec4(0.5)));\\n      }\\n    \";\n    }\n    else {\n        version = '';\n        attribute = 'attribute';\n        varyingVs = 'varying';\n        varyingFs = 'varying';\n        texture2D = 'texture2D';\n        output = 'gl_FragColor';\n        defineOutput = '';\n        // WebGL1 has no built in isnan so we define one here.\n        defineSpecialNaN = \"\\n      #define isnan(value) isnan_custom(value)\\n      bool isnan_custom(float val) {\\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\\n      }\\n      bvec4 isnan_custom(vec4 val) {\\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\\n      }\\n    \";\n        defineSpecialInf = \"\\n      uniform float INFINITY;\\n\\n      bool isinf(float val) {\\n        return abs(val) == INFINITY;\\n      }\\n      bvec4 isinf(vec4 val) {\\n        return equal(abs(val), vec4(INFINITY));\\n      }\\n    \";\n        defineRound = \"\\n      int round(float value) {\\n        return int(floor(value + 0.5));\\n      }\\n\\n      ivec4 round(vec4 value) {\\n        return ivec4(floor(value + vec4(0.5)));\\n      }\\n    \";\n    }\n    return {\n        version: version,\n        attribute: attribute,\n        varyingVs: varyingVs,\n        varyingFs: varyingFs,\n        texture2D: texture2D,\n        output: output,\n        defineOutput: defineOutput,\n        defineSpecialNaN: defineSpecialNaN,\n        defineSpecialInf: defineSpecialInf,\n        defineRound: defineRound\n    };\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\nfunction getLogicalCoordinatesFromFlatIndex(coords, shape, index) {\n    if (index === void 0) { index = 'index'; }\n    var strides = tf.util.computeStrides(shape);\n    return strides\n        .map(function (stride, i) {\n        var line1 = \"int \" + coords[i] + \" = \" + index + \" / \" + stride;\n        var line2 = i === strides.length - 1 ?\n            \"int \" + coords[i + 1] + \" = \" + index + \" - \" + coords[i] + \" * \" + stride :\n            \"index -= \" + coords[i] + \" * \" + stride;\n        return line1 + \"; \" + line2 + \";\";\n    })\n        .join('');\n}\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\nfunction getFlatIndexFrom3D(shape) {\n    var strides = tf.util.computeStrides(shape).map(function (d) { return d.toString(); });\n    return \"\\n  int getFlatIndex(ivec3 coords) {\\n    return coords.x * \" + strides[0] + \" + coords.y * \" + strides[1] + \" + coords.z;\\n  }\\n\";\n}\nvar ENCODE_FLOAT_SNIPPET = \"\\n  const float FLOAT_MAX = 1.70141184e38;\\n  const float FLOAT_MIN = 1.17549435e-38;\\n\\n  lowp vec4 encode_float(highp float v) {\\n    if (isnan(v)) {\\n      return vec4(255, 255, 255, 255);\\n    }\\n\\n    highp float av = abs(v);\\n\\n    if(av < FLOAT_MIN) {\\n      return vec4(0.0, 0.0, 0.0, 0.0);\\n    } else if(v > FLOAT_MAX) {\\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n    } else if(v < -FLOAT_MAX) {\\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n    }\\n\\n    highp vec4 c = vec4(0,0,0,0);\\n\\n    highp float e = floor(log2(av));\\n    highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n    c[2] = floor(128.0 * m);\\n    m -= c[2] / 128.0;\\n    c[1] = floor(32768.0 * m);\\n    m -= c[1] / 32768.0;\\n    c[0] = floor(8388608.0 * m);\\n\\n    highp float ebias = e + 127.0;\\n    c[3] = floor(ebias / 2.0);\\n    ebias -= c[3] * 2.0;\\n    c[2] += floor(ebias) * 128.0;\\n\\n    c[3] += 128.0 * step(0.0, -v);\\n\\n    return c / 255.0;\\n  }\\n\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar DecodeMatrixProgram = /** @class */ (function () {\n    function DecodeMatrixProgram(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        this.outPackingScheme = PackingScheme.DENSE;\n        var texShape = getDenseTexShape(outputShape);\n        var glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = \"\\n      ivec3 outCoordsFromFlatIndex(int index) {\\n        \" + getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], outputShape) + \"\\n        return ivec3(r, c, d);\\n      }\\n\\n      void main() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n          vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n        int index = 4 * (resTexRC.x * \" + texShape[1] + \" + resTexRC.y);\\n\\n        vec4 result = vec4(0.);\\n\\n        for (int i=0; i<4; i++) {\\n          int flatIndex = index + i;\\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\\n          result[i] = getA(rc.x, rc.y, rc.z);\\n        }\\n\\n        \" + glsl.output + \" = result;\\n      }\\n    \";\n    }\n    return DecodeMatrixProgram;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar DecodeMatrixPackedProgram = /** @class */ (function () {\n    function DecodeMatrixPackedProgram(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outPackingScheme = PackingScheme.DENSE;\n        var texShape = getDenseTexShape(outputShape);\n        var glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = \"\\n      ivec3 outCoordsFromFlatIndex(int index) {\\n        \" + getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], outputShape) + \"\\n        return ivec3(r, c, d);\\n      }\\n\\n      void main() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n          vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n        int index = 4 * (resTexRC.x * \" + texShape[1] + \" + resTexRC.y);\\n\\n        vec4 result = vec4(0.);\\n\\n        for (int i=0; i<4; i++) {\\n          int flatIndex = index + i;\\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\\n        }\\n\\n        \" + glsl.output + \" = result;\\n      }\\n    \";\n    }\n    return DecodeMatrixPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar EncodeFloatProgram = /** @class */ (function () {\n    function EncodeFloatProgram(outputShape) {\n        this.variableNames = ['A'];\n        this.outTexUsage = TextureUsage.DOWNLOAD;\n        var glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = \"\\n      \" + ENCODE_FLOAT_SNIPPET + \"\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        \" + glsl.output + \" = encode_float(x);\\n      }\\n    \";\n    }\n    return EncodeFloatProgram;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar EncodeFloatPackedProgram = /** @class */ (function () {\n    function EncodeFloatPackedProgram(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = false;\n        this.outTexUsage = TextureUsage.DOWNLOAD;\n        var glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = \"\\n      \" + ENCODE_FLOAT_SNIPPET + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\\n        \" + glsl.output + \" = encode_float(x);\\n      }\\n    \";\n    }\n    return EncodeFloatPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar EncodeMatrixProgram = /** @class */ (function () {\n    function EncodeMatrixProgram(outputShape, texShape, inputIsUnsignedByte) {\n        if (inputIsUnsignedByte === void 0) { inputIsUnsignedByte = false; }\n        this.variableNames = ['A'];\n        var glsl = getGlslDifferences();\n        var height = texShape[0], width = texShape[1];\n        this.outputShape = outputShape;\n        var output = \"result\";\n        if (inputIsUnsignedByte) {\n            output = \"floor(result * 255. + 0.5)\";\n        }\n        this.userCode = \"\\n      \" + getFlatIndexFrom3D(outputShape) + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n\\n        int flatIndex = getFlatIndex(coords);\\n        int offset = imod(flatIndex, 4);\\n\\n        flatIndex = idiv(flatIndex, 4, 1.);\\n\\n        int r = flatIndex / \" + width + \";\\n        int c = imod(flatIndex, \" + width + \");\\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(\" + width + \".0, \" + height + \".0);\\n        vec4 values = \" + glsl.texture2D + \"(A, uv);\\n\\n        float result;\\n\\n        if(offset == 0) {\\n          result = values[0];\\n        } else if(offset == 1) {\\n          result = values[1];\\n        } else if(offset == 2) {\\n          result = values[2];\\n        } else {\\n          result = values[3];\\n        }\\n\\n        \" + glsl.output + \" = vec4(\" + output + \", 0., 0., 0.);\\n      }\\n    \";\n    }\n    return EncodeMatrixProgram;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/*\nThis is how the shader encodes a tensor with shape = [2, 3, 5]\n(indices are [batch, row, col]).\n\n000|001   002|003   004|xxx   020|021   022|023   024|xxx\n-------   -------   -------   -------   -------   -------\n010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\n100|101   102|103   104|xxx   120|121   122|123   124|xxx\n-------   -------   -------   -------   -------   -------\n110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\nSingle texels contain only values from the same batch, and from adjacent rows\nand columns.\n */\nvar EncodeMatrixPackedProgram = /** @class */ (function () {\n    function EncodeMatrixPackedProgram(outputShape, texShape, inputIsUnsignedByte) {\n        if (inputIsUnsignedByte === void 0) { inputIsUnsignedByte = false; }\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        var glsl = getGlslDifferences();\n        var height = texShape[0], width = texShape[1];\n        this.outputShape = outputShape;\n        var mainLoop = '';\n        var output = 'result';\n        if (inputIsUnsignedByte) {\n            output = 'floor(result * 255. + 0.5)';\n        }\n        for (var row = 0; row <= 1; row++) {\n            for (var col = 0; col <= 1; col++) {\n                var channel = row * 2 + col;\n                mainLoop += \"\\n          localCoords = coords;\\n          if(localCoords[2] + \" + col + \" < \" + outputShape[2] + \") {\\n            localCoords[2] += \" + col + \";\\n            if(localCoords[1] + \" + row + \" < \" + outputShape[1] + \") {\\n              localCoords[1] += \" + row + \";\\n\\n              flatIndex = getFlatIndex(localCoords);\\n              offset = imod(flatIndex, 4);\\n\\n              flatIndex = idiv(flatIndex, 4, 1.);\\n\\n              r = flatIndex / \" + width + \";\\n              c = imod(flatIndex, \" + width + \");\\n              uv = (vec2(c, r) + halfCR) / vec2(\" + width + \".0, \" + height + \".0);\\n              values = \" + glsl.texture2D + \"(A, uv);\\n\\n              if(offset == 0) {\\n                result[\" + channel + \"] = values[0];\\n              } else if(offset == 1) {\\n                result[\" + channel + \"] = values[1];\\n              } else if(offset == 2) {\\n                result[\" + channel + \"] = values[2];\\n              } else {\\n                result[\" + channel + \"] = values[3];\\n              }\\n            }\\n          }\\n        \";\n            }\n        }\n        this.userCode = \"\\n      \" + getFlatIndexFrom3D(outputShape) + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n\\n        vec4 result = vec4(0.);\\n        int flatIndex, r, c, offset;\\n        ivec3 localCoords;\\n        vec2 uv;\\n        vec4 values;\\n\\n        \" + mainLoop + \"\\n\\n        \" + glsl.output + \" = \" + output + \";\\n      }\\n    \";\n    }\n    return EncodeMatrixPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction createVertexShader$1(gl) {\n    var glsl = getGlslDifferences();\n    var vertexShaderSource = glsl.version + \"\\n    precision highp float;\\n    \" + glsl.attribute + \" vec3 clipSpacePos;\\n    \" + glsl.attribute + \" vec2 uv;\\n    \" + glsl.varyingVs + \" vec2 resultUV;\\n\\n    void main() {\\n      gl_Position = vec4(clipSpacePos, 1);\\n      resultUV = uv;\\n    }\";\n    return createVertexShader(gl, vertexShaderSource);\n}\nfunction createVertexBuffer(gl) {\n    // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n    return createStaticVertexBuffer(gl, vertexArray);\n}\nfunction createIndexBuffer(gl) {\n    // OpenGL (and WebGL) have \"CCW == front\" winding\n    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n    return createStaticIndexBuffer(gl, triangleVertexIndices);\n}\nfunction createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {\n    validateTextureSize(width, height);\n    var texture = createTexture(gl);\n    var tex2d = gl.TEXTURE_2D;\n    callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });\n    callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });\n    callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });\n    callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });\n    callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });\n    callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null); });\n    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });\n    return texture;\n}\nfunction getInternalFormatForFloat32MatrixTexture(textureConfig) {\n    return textureConfig.internalFormatFloat;\n}\nfunction createFloat32MatrixTexture(gl, rows, columns, textureConfig) {\n    var _a = getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);\n}\nfunction getInternalFormatForFloat16MatrixTexture(textureConfig) {\n    return textureConfig.internalFormatHalfFloat;\n}\nfunction createFloat16MatrixTexture(gl, rows, columns, textureConfig) {\n    var _a = getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\nfunction getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {\n    return textureConfig.downloadTextureFormat;\n}\nfunction createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {\n    var _a = getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);\n}\nfunction getInternalFormatForPackedMatrixTexture(textureConfig) {\n    return textureConfig.internalFormatPackedFloat;\n}\nfunction createPackedMatrixTexture(gl, rows, columns, textureConfig) {\n    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);\n}\nfunction getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {\n    return textureConfig.internalFormatPackedHalfFloat;\n}\nfunction createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {\n    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);\n}\nfunction bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {\n    var posOffset = 0; // x is the first buffer element\n    var uvOffset = 3 * 4; // uv comes after [x y z]\n    var stride = (3 * 4) + (2 * 4); // xyz + uv, each entry is 4-byte float.\n    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });\n    var success = bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n    return success &&\n        bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\nfunction uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {\n    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });\n    var dataForUpload, texelDataType, internalFormat;\n    if (data instanceof Uint8Array) {\n        dataForUpload = new Uint8Array(width * height * 4);\n        texelDataType = gl.UNSIGNED_BYTE;\n        internalFormat = gl.RGBA;\n    }\n    else {\n        dataForUpload = new Float32Array(width * height * 4);\n        texelDataType = gl.FLOAT;\n        internalFormat = textureConfig.internalFormatPackedFloat;\n    }\n    dataForUpload.set(data);\n    callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload); });\n    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });\n}\nfunction uploadPixelDataToTexture(gl, texture, pixels) {\n    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });\n    if (pixels.data instanceof Uint8Array) {\n        callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data); });\n    }\n    else {\n        callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels); });\n    }\n    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });\n}\nfunction createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {\n    // Create and bind the buffer.\n    var buffer = gl2.createBuffer();\n    callAndCheck(gl2, function () { return gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer); });\n    // Initialize the buffer to the size of the texture in bytes.\n    var bytesPerFloat = 4;\n    var valuesPerTexel = 4;\n    var bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n    callAndCheck(gl2, function () { return gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ); });\n    // Enqueue a command on the GPU command queue to copy of texture into the\n    // buffer.\n    callAndCheck(gl2, function () { return gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0); });\n    callAndCheck(gl2, function () { return gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null); });\n    return buffer;\n}\nfunction downloadFloat32MatrixFromBuffer(gl, buffer, size) {\n    var gl2 = gl;\n    var downloadTarget = new Float32Array(size);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nfunction downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {\n    var _a = getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];\n    var numChannels = 4;\n    var downloadTarget = new Uint8Array(getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n    callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget); });\n    // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n    // decoding of the 4 bytes that back each 32 bit float.\n    return new Float32Array(downloadTarget.buffer);\n}\nfunction downloadPackedMatrixFromBuffer(gl, buffer, batch, rows, cols, physicalRows, physicalCols, textureConfig) {\n    var gl2 = gl;\n    var downloadTarget = new Float32Array(getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nfunction downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {\n    var packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n    callAndCheck(gl, function () { return gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA); });\n    return packedRGBA;\n}\n\nvar gpgpu_util = {\n    __proto__: null,\n    createVertexShader: createVertexShader$1,\n    createVertexBuffer: createVertexBuffer,\n    createIndexBuffer: createIndexBuffer,\n    getInternalFormatForFloat32MatrixTexture: getInternalFormatForFloat32MatrixTexture,\n    createFloat32MatrixTexture: createFloat32MatrixTexture,\n    getInternalFormatForFloat16MatrixTexture: getInternalFormatForFloat16MatrixTexture,\n    createFloat16MatrixTexture: createFloat16MatrixTexture,\n    getInternalFormatForUnsignedBytesMatrixTexture: getInternalFormatForUnsignedBytesMatrixTexture,\n    createUnsignedBytesMatrixTexture: createUnsignedBytesMatrixTexture,\n    getInternalFormatForPackedMatrixTexture: getInternalFormatForPackedMatrixTexture,\n    createPackedMatrixTexture: createPackedMatrixTexture,\n    getInternalFormatForFloat16PackedMatrixTexture: getInternalFormatForFloat16PackedMatrixTexture,\n    createFloat16PackedMatrixTexture: createFloat16PackedMatrixTexture,\n    bindVertexProgramAttributeStreams: bindVertexProgramAttributeStreams,\n    uploadDenseMatrixToTexture: uploadDenseMatrixToTexture,\n    uploadPixelDataToTexture: uploadPixelDataToTexture,\n    createBufferFromOutputTexture: createBufferFromOutputTexture,\n    downloadFloat32MatrixFromBuffer: downloadFloat32MatrixFromBuffer,\n    downloadByteEncodedFloatMatrixFromOutputTexture: downloadByteEncodedFloatMatrixFromOutputTexture,\n    downloadPackedMatrixFromBuffer: downloadPackedMatrixFromBuffer,\n    downloadMatrixFromPackedOutputTexture: downloadMatrixFromPackedOutputTexture\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar GPGPUContext = /** @class */ (function () {\n    function GPGPUContext(gl) {\n        this.outputTexture = null;\n        this.program = null;\n        this.disposed = false;\n        this.vertexAttrsAreBound = false;\n        this.itemsToPoll = [];\n        var glVersion = tf.env().getNumber('WEBGL_VERSION');\n        if (gl != null) {\n            this.gl = gl;\n            setWebGLContext(glVersion, gl);\n        }\n        else {\n            this.gl = getWebGLContext(glVersion);\n        }\n        // WebGL 2.0 enables texture floats without an extension.\n        var COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n        var COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (tf.env().getNumber('WEBGL_VERSION') === 1) {\n            var TEXTURE_FLOAT = 'OES_texture_float';\n            var TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n            this.textureFloatExtension =\n                getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n            if (hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n                this.textureHalfFloatExtension =\n                    getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n            }\n            else if (tf.env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support half float textures, yet the ' +\n                    'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n            this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n            }\n            else if (tf.env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support color renderable half floats, yet ' +\n                    'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n        }\n        else {\n            COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n            if (hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n                this.colorBufferFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            }\n            else if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            }\n            else {\n                throw new Error('GL context does not support color renderable floats');\n            }\n        }\n        this.vertexBuffer = createVertexBuffer(this.gl);\n        this.indexBuffer = createIndexBuffer(this.gl);\n        this.framebuffer = createFramebuffer(this.gl);\n        this.textureConfig =\n            getTextureConfig(this.gl, this.textureHalfFloatExtension);\n    }\n    Object.defineProperty(GPGPUContext.prototype, \"debug\", {\n        get: function () {\n            return tf.env().getBool('DEBUG');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GPGPUContext.prototype.dispose = function () {\n        var _this = this;\n        if (this.disposed) {\n            return;\n        }\n        if (this.program != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n                ' This is probably a resource leak, delete the program with ' +\n                'GPGPUContext.deleteProgram before disposing.');\n        }\n        if (this.outputTexture != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +\n                'texture.  This is probably a resource leak, delete the output ' +\n                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n                'disposing.');\n        }\n        var gl = this.gl;\n        callAndCheck(gl, function () { return gl.finish(); });\n        callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });\n        callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });\n        callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });\n        callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });\n        callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });\n        this.disposed = true;\n    };\n    GPGPUContext.prototype.createFloat32MatrixTexture = function (rows, columns) {\n        this.throwIfDisposed();\n        return createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    };\n    GPGPUContext.prototype.createFloat16MatrixTexture = function (rows, columns) {\n        this.throwIfDisposed();\n        return createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    };\n    GPGPUContext.prototype.createUnsignedBytesMatrixTexture = function (rows, columns) {\n        this.throwIfDisposed();\n        return createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    };\n    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {\n        this.throwIfDisposed();\n        uploadPixelDataToTexture(this.gl, texture, pixels);\n    };\n    GPGPUContext.prototype.uploadDenseMatrixToTexture = function (texture, width, height, data) {\n        this.throwIfDisposed();\n        uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n    };\n    GPGPUContext.prototype.createFloat16PackedMatrixTexture = function (rows, columns) {\n        this.throwIfDisposed();\n        return createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    };\n    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {\n        this.throwIfDisposed();\n        return createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    };\n    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {\n        var _this = this;\n        this.throwIfDisposed();\n        if (this.outputTexture === texture) {\n            unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n            this.outputTexture = null;\n        }\n        callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });\n    };\n    GPGPUContext.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (texture, rows, columns) {\n        var _this = this;\n        return this.downloadMatrixDriver(texture, function () { return downloadByteEncodedFloatMatrixFromOutputTexture(_this.gl, rows, columns, _this.textureConfig); });\n    };\n    GPGPUContext.prototype.downloadPackedMatrixFromBuffer = function (buffer, batch, rows, columns, physicalRows, physicalCols) {\n        return downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n    };\n    GPGPUContext.prototype.downloadFloat32MatrixFromBuffer = function (buffer, size) {\n        return downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n    };\n    GPGPUContext.prototype.createBufferFromTexture = function (texture, rows, columns) {\n        this.bindTextureToFrameBuffer(texture);\n        var result = createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n        this.unbindTextureToFrameBuffer();\n        return result;\n    };\n    GPGPUContext.prototype.createAndWaitForFence = function () {\n        var fenceContext = this.createFence(this.gl);\n        return this.pollFence(fenceContext);\n    };\n    GPGPUContext.prototype.createFence = function (gl) {\n        var _this = this;\n        var query;\n        var isFencePassed;\n        if (tf.env().getBool('WEBGL_FENCE_API_ENABLED')) {\n            var gl2_1 = gl;\n            var sync_1 = gl2_1.fenceSync(gl2_1.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            gl.flush();\n            isFencePassed = function () {\n                var status = gl2_1.clientWaitSync(sync_1, 0, 0);\n                return status === gl2_1.ALREADY_SIGNALED ||\n                    status === gl2_1.CONDITION_SATISFIED;\n            };\n            query = sync_1;\n        }\n        else if (tf.env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n            query = this.beginQuery();\n            this.endQuery();\n            isFencePassed = function () { return _this.isQueryAvailable(query, tf.env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')); };\n        }\n        else {\n            // If we have no way to fence, return true immediately. This will fire in\n            // WebGL 1.0 when there is no disjoint query timer. In this case, because\n            // the fence passes immediately, we'll immediately ask for a download of\n            // the texture, which will cause the UI thread to hang.\n            isFencePassed = function () { return true; };\n        }\n        return { query: query, isFencePassed: isFencePassed };\n    };\n    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, physicalRows, physicalCols) {\n        var _this = this;\n        return this.downloadMatrixDriver(texture, function () { return downloadMatrixFromPackedOutputTexture(_this.gl, physicalRows, physicalCols); });\n    };\n    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {\n        this.throwIfDisposed();\n        var gl = this.gl;\n        var fragmentShader = createFragmentShader(gl, fragmentShaderSource);\n        var vertexShader = createVertexShader$1(gl);\n        var program = createProgram(gl);\n        callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });\n        callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });\n        linkProgram(gl, program);\n        if (this.debug) {\n            validateProgram(gl, program);\n        }\n        if (!this.vertexAttrsAreBound) {\n            this.setProgram(program);\n            this.vertexAttrsAreBound = bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);\n        }\n        return program;\n    };\n    GPGPUContext.prototype.deleteProgram = function (program) {\n        var _this = this;\n        this.throwIfDisposed();\n        if (program === this.program) {\n            this.program = null;\n        }\n        if (program != null) {\n            callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });\n        }\n    };\n    GPGPUContext.prototype.setProgram = function (program) {\n        var _this = this;\n        this.throwIfDisposed();\n        this.program = program;\n        if ((this.program != null) && this.debug) {\n            validateProgram(this.gl, this.program);\n        }\n        callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });\n    };\n    GPGPUContext.prototype.getUniformLocation = function (program, uniformName, shouldThrow) {\n        if (shouldThrow === void 0) { shouldThrow = true; }\n        this.throwIfDisposed();\n        if (shouldThrow) {\n            return getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n        }\n        else {\n            return getProgramUniformLocation(this.gl, program, uniformName);\n        }\n    };\n    GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {\n        var _this = this;\n        this.throwIfDisposed();\n        return callAndCheck(this.gl, function () { return _this.gl.getAttribLocation(program, attribute); });\n    };\n    GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {\n        this.throwIfDisposed();\n        return this.gl.getUniformLocation(program, uniformName);\n    };\n    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n    };\n    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {\n        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n    };\n    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {\n        this.throwIfDisposed();\n        var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];\n        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n    };\n    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {\n        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n    };\n    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {\n        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n    };\n    GPGPUContext.prototype.debugValidate = function () {\n        if (this.program != null) {\n            validateProgram(this.gl, this.program);\n        }\n        validateFramebuffer(this.gl);\n    };\n    GPGPUContext.prototype.executeProgram = function () {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        var gl = this.gl;\n        if (this.debug) {\n            this.debugValidate();\n        }\n        callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });\n    };\n    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {\n        var _this = this;\n        this.throwIfDisposed();\n        callAndCheck(this.gl, function () { return _this.gl.finish(); });\n    };\n    GPGPUContext.prototype.getQueryTimerExtension = function () {\n        if (this.disjointQueryTimerExtension == null) {\n            this.disjointQueryTimerExtension =\n                getExtensionOrThrow(this.gl, tf.env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                    'EXT_disjoint_timer_query_webgl2' :\n                    'EXT_disjoint_timer_query');\n        }\n        return this.disjointQueryTimerExtension;\n    };\n    GPGPUContext.prototype.getQueryTimerExtensionWebGL2 = function () {\n        return this.getQueryTimerExtension();\n    };\n    GPGPUContext.prototype.getQueryTimerExtensionWebGL1 = function () {\n        return this.getQueryTimerExtension();\n    };\n    GPGPUContext.prototype.beginQuery = function () {\n        if (tf.env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            var gl2 = this.gl;\n            var ext_1 = this.getQueryTimerExtensionWebGL2();\n            var query_1 = gl2.createQuery();\n            gl2.beginQuery(ext_1.TIME_ELAPSED_EXT, query_1);\n            return query_1;\n        }\n        var ext = this.getQueryTimerExtensionWebGL1();\n        var query = ext.createQueryEXT();\n        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n        return query;\n    };\n    GPGPUContext.prototype.endQuery = function () {\n        if (tf.env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            var gl2 = this.gl;\n            var ext_2 = this.getQueryTimerExtensionWebGL2();\n            gl2.endQuery(ext_2.TIME_ELAPSED_EXT);\n            return;\n        }\n        var ext = this.getQueryTimerExtensionWebGL1();\n        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n    };\n    GPGPUContext.prototype.waitForQueryAndGetTime = function (query) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, tf.util.repeatedTry(function () { return _this.disposed || // while testing contexts are created / disposed\n                            // in rapid succession, so without this check we\n                            // may poll for the query timer indefinitely\n                            _this.isQueryAvailable(query, tf.env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')); })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, this.getQueryTime(query, tf.env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'))];\n                }\n            });\n        });\n    };\n    GPGPUContext.prototype.getQueryTime = function (query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return null;\n        }\n        if (queryTimerVersion === 2) {\n            var gl2 = this.gl;\n            var timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n        else {\n            var ext = this.getQueryTimerExtensionWebGL1();\n            var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n    };\n    GPGPUContext.prototype.isQueryAvailable = function (query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return true;\n        }\n        if (queryTimerVersion === 2) {\n            var gl2 = this.gl;\n            var ext = this.getQueryTimerExtensionWebGL2();\n            var available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n        else {\n            var ext = this.getQueryTimerExtensionWebGL1();\n            var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n    };\n    GPGPUContext.prototype.pollFence = function (fenceContext) {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this.addItemToPoll(function () { return fenceContext.isFencePassed(); }, function () { return resolve(); });\n        });\n    };\n    GPGPUContext.prototype.pollItems = function () {\n        // Find the last query that has finished.\n        var index = linearSearchLastTrue(this.itemsToPoll.map(function (x) { return x.isDoneFn; }));\n        for (var i = 0; i <= index; ++i) {\n            var resolveFn = this.itemsToPoll[i].resolveFn;\n            resolveFn();\n        }\n        this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n    };\n    GPGPUContext.prototype.addItemToPoll = function (isDoneFn, resolveFn) {\n        var _this = this;\n        this.itemsToPoll.push({ isDoneFn: isDoneFn, resolveFn: resolveFn });\n        if (this.itemsToPoll.length > 1) {\n            // We already have a running loop that polls.\n            return;\n        }\n        // Start a new loop that polls.\n        tf.util.repeatedTry(function () {\n            _this.pollItems();\n            // End the loop if no more items to poll.\n            return _this.itemsToPoll.length === 0;\n        });\n    };\n    GPGPUContext.prototype.bindTextureToFrameBuffer = function (texture) {\n        this.throwIfDisposed();\n        bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n        if (this.debug) {\n            validateFramebuffer(this.gl);\n        }\n    };\n    GPGPUContext.prototype.unbindTextureToFrameBuffer = function () {\n        if (this.outputTexture != null) {\n            bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n            if (this.debug) {\n                validateFramebuffer(this.gl);\n            }\n        }\n        else {\n            unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n        }\n    };\n    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {\n        this.bindTextureToFrameBuffer(texture);\n        var result = downloadAndDecode();\n        this.unbindTextureToFrameBuffer();\n        return result;\n    };\n    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {\n        this.throwIfDisposed();\n        var gl = this.gl;\n        bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n        if (this.debug) {\n            validateFramebuffer(gl);\n        }\n        this.outputTexture = outputMatrixTextureMaybePacked;\n        callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });\n        callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });\n    };\n    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {\n        var _this = this;\n        this.throwIfDisposed();\n        callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });\n    };\n    GPGPUContext.prototype.throwIfDisposed = function () {\n        if (this.disposed) {\n            throw new Error('Attempted to use disposed GPGPUContext.');\n        }\n    };\n    GPGPUContext.prototype.throwIfNoProgram = function () {\n        if (this.program == null) {\n            throw new Error('No GPU program is currently set.');\n        }\n    };\n    return GPGPUContext;\n}());\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nfunction linearSearchLastTrue(arr) {\n    var i = 0;\n    for (; i < arr.length; ++i) {\n        var isDone = arr[i]();\n        if (!isDone) {\n            break;\n        }\n    }\n    return i - 1;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar getBroadcastDims = tf.backend_util.getBroadcastDims;\nfunction makeShader(inputsInfo, outputShape, userCode, usesPackedTextures) {\n    var prefixSnippets = [];\n    inputsInfo.forEach(function (x) {\n        var size = tf.util.sizeFromShape(x.shapeInfo.logicalShape);\n        // Snippet when we decided to upload the values as uniform.\n        if (x.shapeInfo.isUniform) {\n            prefixSnippets.push(\"uniform float \" + x.name + (size > 1 ? \"[\" + size + \"]\" : '') + \";\");\n        }\n        else {\n            prefixSnippets.push(\"uniform sampler2D \" + x.name + \";\");\n            prefixSnippets.push(\"uniform int offset\" + x.name + \";\");\n        }\n    });\n    var inputPrefixSnippet = prefixSnippets.join('\\n');\n    var inputSamplingSnippet = inputsInfo\n        .map(function (x) { return getInputSamplingSnippet(x, outputShape, usesPackedTextures); })\n        .join('\\n');\n    var outTexShape = outputShape.texShape;\n    var glsl = getGlslDifferences();\n    var floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);\n    var outputSamplingSnippet;\n    var floatTextureSetOutputSnippet;\n    var shaderPrefix = getShaderPrefix(glsl);\n    if (outputShape.isPacked) {\n        outputSamplingSnippet =\n            getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n        floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);\n    }\n    else {\n        outputSamplingSnippet =\n            getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n        floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);\n    }\n    if (usesPackedTextures) {\n        shaderPrefix += SHADER_PACKED_PREFIX;\n    }\n    var source = [\n        shaderPrefix, floatTextureSampleSnippet, floatTextureSetOutputSnippet,\n        inputPrefixSnippet, outputSamplingSnippet, inputSamplingSnippet, userCode\n    ].join('\\n');\n    return source;\n}\nfunction getSamplerFromInInfo(inInfo) {\n    var shape = inInfo.shapeInfo.logicalShape;\n    switch (shape.length) {\n        case 0:\n            return getSamplerScalar(inInfo);\n        case 1:\n            return getSampler1D(inInfo);\n        case 2:\n            return getSampler2D(inInfo);\n        case 3:\n            return getSampler3D(inInfo);\n        case 4:\n            return getSampler4D(inInfo);\n        case 5:\n            return getSampler5D(inInfo);\n        case 6:\n            return getSampler6D(inInfo);\n        default:\n            throw new Error(shape.length + \"-D input sampling\" +\n                \" is not yet supported\");\n    }\n}\nfunction getPackedSamplerFromInInfo(inInfo) {\n    var shape = inInfo.shapeInfo.logicalShape;\n    switch (shape.length) {\n        case 0:\n            return getPackedSamplerScalar(inInfo);\n        case 1:\n            return getPackedSampler1D(inInfo);\n        case 2:\n            return getPackedSampler2D(inInfo);\n        case 3:\n            return getPackedSampler3D(inInfo);\n        default:\n            return getPackedSamplerND(inInfo);\n    }\n}\nfunction getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures) {\n    if (usesPackedTextures === void 0) { usesPackedTextures = false; }\n    var res = '';\n    if (usesPackedTextures) {\n        res += getPackedSamplerFromInInfo(inInfo);\n    }\n    else {\n        res += getSamplerFromInInfo(inInfo);\n    }\n    var inShape = inInfo.shapeInfo.logicalShape;\n    var outShape = outShapeInfo.logicalShape;\n    if (inShape.length <= outShape.length) {\n        if (usesPackedTextures) {\n            res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);\n        }\n        else {\n            res += getSamplerAtOutputCoords(inInfo, outShapeInfo);\n        }\n    }\n    return res;\n}\nfunction getPackedOutputSamplingSnippet(outShape, outTexShape) {\n    switch (outShape.length) {\n        case 0:\n            return getOutputScalarCoords();\n        case 1:\n            return getOutputPacked1DCoords(outShape, outTexShape);\n        case 2:\n            return getOutputPacked2DCoords(outShape, outTexShape);\n        case 3:\n            return getOutputPacked3DCoords(outShape, outTexShape);\n        default:\n            return getOutputPackedNDCoords(outShape, outTexShape);\n    }\n}\nfunction getOutputSamplingSnippet(outShape, outTexShape) {\n    switch (outShape.length) {\n        case 0:\n            return getOutputScalarCoords();\n        case 1:\n            return getOutput1DCoords(outShape, outTexShape);\n        case 2:\n            return getOutput2DCoords(outShape, outTexShape);\n        case 3:\n            return getOutput3DCoords(outShape, outTexShape);\n        case 4:\n            return getOutput4DCoords(outShape, outTexShape);\n        case 5:\n            return getOutput5DCoords(outShape, outTexShape);\n        case 6:\n            return getOutput6DCoords(outShape, outTexShape);\n        default:\n            throw new Error(outShape.length + \"-D output sampling is not yet supported\");\n    }\n}\nfunction getFloatTextureSampleSnippet(glsl) {\n    return \"\\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n      return \" + glsl.texture2D + \"(textureSampler, uv).r;\\n    }\\n  \";\n}\nfunction getFloatTextureSetRSnippet(glsl) {\n    return \"\\n    void setOutput(float val) {\\n      \" + glsl.output + \" = vec4(val, 0, 0, 0);\\n    }\\n  \";\n}\nfunction getFloatTextureSetRGBASnippet(glsl) {\n    return \"\\n    void setOutput(vec4 val) {\\n      \" + glsl.output + \" = val;\\n    }\\n  \";\n}\nfunction getShaderPrefix(glsl) {\n    var SHADER_PREFIX = glsl.version + \"\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n    \" + glsl.varyingFs + \" vec2 resultUV;\\n    \" + glsl.defineOutput + \"\\n    const vec2 halfCR = vec2(0.5, 0.5);\\n\\n    struct ivec5\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n    };\\n\\n    struct ivec6\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n      int v;\\n    };\\n\\n    uniform float NAN;\\n    \" + glsl.defineSpecialNaN + \"\\n    \" + glsl.defineSpecialInf + \"\\n    \" + glsl.defineRound + \"\\n\\n    int imod(int x, int y) {\\n      return x - y * (x / y);\\n    }\\n\\n    int idiv(int a, int b, float sign) {\\n      int res = a / b;\\n      int mod = imod(a, b);\\n      if (sign < 0. && mod != 0) {\\n        res -= 1;\\n      }\\n      return res;\\n    }\\n\\n    //Based on the work of Dave Hoskins\\n    //https://www.shadertoy.com/view/4djSRW\\n    #define HASHSCALE1 443.8975\\n    float random(float seed){\\n      vec2 p = resultUV * seed;\\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n      p3 += dot(p3, p3.yzx + 19.19);\\n      return fract((p3.x + p3.y) * p3.z);\\n    }\\n\\n    \" + SAMPLE_1D_SNIPPET + \"\\n    \" + SAMPLE_2D_SNIPPET + \"\\n    \" + SAMPLE_3D_SNIPPET + \"\\n  \";\n    return SHADER_PREFIX;\n}\nvar SAMPLE_1D_SNIPPET = \"\\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n  int texelIndex = index / 2;\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar SAMPLE_2D_SNIPPET = \"\\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\\n  int texNumC, int row, int col) {\\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar SAMPLE_3D_SNIPPET = \"\\nvec2 packedUVfrom3D(int texNumR, int texNumC,\\n    int texelsInBatch, int texelsInLogicalRow, int b,\\n    int row, int col) {\\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar SHADER_PACKED_PREFIX = \"\\n  float getChannel(vec4 frag, vec2 innerDims) {\\n    vec2 modCoord = mod(innerDims, 2.);\\n    return modCoord.x == 0. ?\\n      (modCoord.y == 0. ? frag.r : frag.g) :\\n      (modCoord.y == 0. ? frag.b : frag.a);\\n  }\\n  float getChannel(vec4 frag, int dim) {\\n    float modCoord = mod(float(dim), 2.);\\n    return modCoord == 0. ? frag.r : frag.g;\\n  }\\n\";\nfunction getOutputScalarCoords() {\n    return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \";\n}\nfunction getOutputPacked1DCoords(shape, texShape) {\n    var packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (packedTexShape[0] === 1) {\n        return \"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.x * \" + packedTexShape[1] + \".0);\\n      }\\n    \";\n    }\n    if (packedTexShape[1] === 1) {\n        return \"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.y * \" + packedTexShape[0] + \".0);\\n      }\\n    \";\n    }\n    return \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + packedTexShape[0] + \", \" + packedTexShape[1] + \"));\\n      return 2 * (resTexRC.x * \" + packedTexShape[1] + \" + resTexRC.y);\\n    }\\n  \";\n}\nfunction getOutput1DCoords(shape, texShape) {\n    if (texShape[0] === 1) {\n        return \"\\n      int getOutputCoords() {\\n        return int(resultUV.x * \" + texShape[1] + \".0);\\n      }\\n    \";\n    }\n    if (texShape[1] === 1) {\n        return \"\\n      int getOutputCoords() {\\n        return int(resultUV.y * \" + texShape[0] + \".0);\\n      }\\n    \";\n    }\n    return \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      return resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n    }\\n  \";\n}\nfunction getOutputPacked3DCoords(shape, texShape) {\n    var packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    var texelsInLogicalRow = Math.ceil(shape[2] / 2);\n    var texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n    return \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + packedTexShape[0] + \", \" + packedTexShape[1] + \"));\\n      int index = resTexRC.x * \" + packedTexShape[1] + \" + resTexRC.y;\\n\\n      int b = index / \" + texelsInBatch + \";\\n      index -= b * \" + texelsInBatch + \";\\n\\n      int r = 2 * (index / \" + texelsInLogicalRow + \");\\n      int c = imod(index, \" + texelsInLogicalRow + \") * 2;\\n\\n      return ivec3(b, r, c);\\n    }\\n  \";\n}\nfunction getOutput3DCoords(shape, texShape) {\n    var coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n    return \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n      \" + coordsFromIndexSnippet + \"\\n      return ivec3(r, c, d);\\n    }\\n  \";\n}\nfunction getOutputPackedNDCoords(shape, texShape) {\n    var packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    var texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n    var texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n    var texelsInBatchN = texelsInBatch;\n    var batches = \"\";\n    var coords = 'b, r, c';\n    for (var b = 2; b < shape.length - 1; b++) {\n        texelsInBatchN *= shape[shape.length - b - 1];\n        batches = \"\\n      int b\" + b + \" = index / \" + texelsInBatchN + \";\\n      index -= b\" + b + \" * \" + texelsInBatchN + \";\\n    \" + batches;\n        coords = \"b\" + b + \", \" + coords;\n    }\n    return \"\\n    ivec\" + shape.length + \" getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + packedTexShape[0] + \", \" + packedTexShape[1] + \"));\\n      int index = resTexRC.x * \" + packedTexShape[1] + \" + resTexRC.y;\\n\\n      \" + batches + \"\\n\\n      int b = index / \" + texelsInBatch + \";\\n      index -= b * \" + texelsInBatch + \";\\n\\n      int r = 2 * (index / \" + texelsInLogicalRow + \");\\n      int c = imod(index, \" + texelsInLogicalRow + \") * 2;\\n\\n      return ivec\" + shape.length + \"(\" + coords + \");\\n    }\\n  \";\n}\nfunction getOutput4DCoords(shape, texShape) {\n    var coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2'], shape);\n    return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n      \" + coordsFromIndexSnippet + \"\\n      return ivec4(r, c, d, d2);\\n    }\\n  \";\n}\nfunction getOutput5DCoords(shape, texShape) {\n    var coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2', 'd3'], shape);\n    return \"\\n    ivec5 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(\" + texShape[0] + \",\\n                             \" + texShape[1] + \"));\\n\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n\\n      \" + coordsFromIndexSnippet + \"\\n\\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\\n      return outShape;\\n    }\\n  \";\n}\nfunction getOutput6DCoords(shape, texShape) {\n    var coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2', 'd3', 'd4'], shape);\n    return \"\\n    ivec6 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n\\n      \" + coordsFromIndexSnippet + \"\\n\\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\\n      return result;\\n    }\\n  \";\n}\nfunction getOutputPacked2DCoords(shape, texShape) {\n    var packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (tf.util.arraysEqual(shape, texShape)) {\n        return \"\\n      ivec2 getOutputCoords() {\\n        return 2 * ivec2(resultUV.yx * vec2(\" + packedTexShape[0] + \", \" + packedTexShape[1] + \"));\\n      }\\n    \";\n    }\n    // texels needed to accommodate a logical row\n    var texelsInLogicalRow = Math.ceil(shape[1] / 2);\n    /**\n     * getOutputCoords\n     *\n     * resTexRC: The rows and columns of the texels. If you move over one\n     * texel to the right in the packed texture, you are moving over one column\n     * (not two).\n     *\n     * index: The texel index\n     */\n    return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + packedTexShape[0] + \", \" + packedTexShape[1] + \"));\\n\\n      int index = resTexRC.x * \" + packedTexShape[1] + \" + resTexRC.y;\\n      int r = 2 * (index / \" + texelsInLogicalRow + \");\\n      int c = imod(index, \" + texelsInLogicalRow + \") * 2;\\n\\n      return ivec2(r, c);\\n    }\\n  \";\n}\nfunction getOutput2DCoords(shape, texShape) {\n    if (tf.util.arraysEqual(shape, texShape)) {\n        return \"\\n      ivec2 getOutputCoords() {\\n        return ivec2(resultUV.yx * vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      }\\n    \";\n    }\n    if (shape[1] === 1) {\n        return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n        int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n        return ivec2(index, 0);\\n      }\\n    \";\n    }\n    if (shape[0] === 1) {\n        return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n        int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n        return ivec2(0, index);\\n      }\\n    \";\n    }\n    return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n      int r = index / \" + shape[1] + \";\\n      int c = index - r * \" + shape[1] + \";\\n      return ivec2(r, c);\\n    }\\n  \";\n}\nfunction getFlatOffsetUniformName(texName) {\n    return \"offset\" + texName;\n}\nfunction getPackedSamplerScalar(inputInfo) {\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var glsl = getGlslDifferences();\n    return \"\\n    vec4 \" + funcName + \"() {\\n      return \" + glsl.texture2D + \"(\" + texName + \", halfCR);\\n    }\\n  \";\n}\nfunction getSamplerScalar(inputInfo) {\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    if (inputInfo.shapeInfo.isUniform) {\n        return \"float \" + funcName + \"() {return \" + texName + \";}\";\n    }\n    var _a = inputInfo.shapeInfo.texShape, texNumR = _a[0], texNumC = _a[1];\n    if (texNumR === 1 && texNumC === 1) {\n        return \"\\n      float \" + funcName + \"() {\\n        return sampleTexture(\" + texName + \", halfCR);\\n      }\\n    \";\n    }\n    var _b = inputInfo.shapeInfo.texShape, tNumR = _b[0], tNumC = _b[1];\n    var offset = getFlatOffsetUniformName(texName);\n    return \"\\n    float \" + funcName + \"() {\\n      vec2 uv = uvFromFlat(\" + tNumR + \", \" + tNumC + \", \" + offset + \");\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getPackedSampler1D(inputInfo) {\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var texShape = inputInfo.shapeInfo.texShape;\n    var packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    var glsl = getGlslDifferences();\n    return \"\\n    vec4 \" + funcName + \"(int index) {\\n      vec2 uv = packedUVfrom1D(\\n        \" + packedTexShape[0] + \", \" + packedTexShape[1] + \", index);\\n      return \" + glsl.texture2D + \"(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSampler1D(inputInfo) {\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int index) {\\n        \" + getUniformSampler(inputInfo) + \"\\n      }\\n    \";\n    }\n    var texShape = inputInfo.shapeInfo.texShape;\n    var tNumR = texShape[0];\n    var tNumC = texShape[1];\n    if (tNumC === 1 && tNumR === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        return sampleTexture(\" + texName + \", halfCR);\\n      }\\n    \";\n    }\n    var offset = getFlatOffsetUniformName(texName);\n    if (tNumC === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        vec2 uv = vec2(0.5, (float(index + \" + offset + \") + 0.5) / \" + tNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    if (tNumR === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        vec2 uv = vec2((float(index + \" + offset + \") + 0.5) / \" + tNumC + \".0, 0.5);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    return \"\\n    float \" + funcName + \"(int index) {\\n      vec2 uv = uvFromFlat(\" + tNumR + \", \" + tNumC + \", index + \" + offset + \");\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getPackedSampler2D(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var texShape = inputInfo.shapeInfo.texShape;\n    var texNumR = texShape[0];\n    var texNumC = texShape[1];\n    var glsl = getGlslDifferences();\n    if (texShape != null && tf.util.arraysEqual(shape, texShape)) {\n        return \"\\n      vec4 \" + funcName + \"(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n\\n        return \" + glsl.texture2D + \"(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    var packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    var valuesPerRow = Math.ceil(shape[1] / 2);\n    return \"\\n    vec4 \" + funcName + \"(int row, int col) {\\n      vec2 uv = packedUVfrom2D(\" + valuesPerRow + \", \" + packedTexShape[0] + \", \" + packedTexShape[1] + \", row, col);\\n      return \" + glsl.texture2D + \"(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSampler2D(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var texShape = inputInfo.shapeInfo.texShape;\n    if (texShape != null && tf.util.arraysEqual(shape, texShape)) {\n        var texNumR_1 = texShape[0];\n        var texNumC_1 = texShape[1];\n        return \"\\n    float \" + funcName + \"(int row, int col) {\\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + texNumC_1 + \".0, \" + texNumR_1 + \".0);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n    }\n    var _a = tf.util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\n    var squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        var params = ['row', 'col'];\n        return \"\\n      \" + getSamplerFromInInfo(newInputInfo) + \"\\n      float \" + funcName + \"(int row, int col) {\\n        return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n      }\\n    \";\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int row, int col) {\\n        int index = round(dot(vec2(row, col), vec2(\" + shape[1] + \", 1)));\\n        \" + getUniformSampler(inputInfo) + \"\\n      }\\n    \";\n    }\n    var texNumR = texShape[0];\n    var texNumC = texShape[1];\n    var offset = getFlatOffsetUniformName(texName);\n    if (texNumC === 1) {\n        // index is used directly as physical (no risk of float16 overflow).\n        return \"\\n    float \" + funcName + \"(int row, int col) {\\n      float index = dot(vec3(row, col, \" + offset + \"), vec3(\" + shape[1] + \", 1, 1));\\n      vec2 uv = vec2(0.5, (index + 0.5) / \" + texNumR + \".0);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n    }\n    if (texNumR === 1) {\n        // index is used directly as physical (no risk of float16 overflow).\n        return \"\\n    float \" + funcName + \"(int row, int col) {\\n      float index = dot(vec3(row, col, \" + offset + \"), vec3(\" + shape[1] + \", 1, 1));\\n      vec2 uv = vec2((index + 0.5) / \" + texNumC + \".0, 0.5);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n    }\n    return \"\\n  float \" + funcName + \"(int row, int col) {\\n    // Explicitly use integer operations as dot() only works on floats.\\n    int index = row * \" + shape[1] + \" + col + \" + offset + \";\\n    vec2 uv = uvFromFlat(\" + texNumR + \", \" + texNumC + \", index);\\n    return sampleTexture(\" + texName + \", uv);\\n  }\\n\";\n}\nfunction getPackedSampler3D(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var texShape = inputInfo.shapeInfo.texShape;\n    var packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (shape[0] === 1) {\n        var squeezedShape = shape.slice(1);\n        var keptDims = [1, 2];\n        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        var params = ['b', 'row', 'col'];\n        return \"\\n        \" + getPackedSamplerFromInInfo(newInputInfo) + \"\\n        vec4 \" + funcName + \"(int b, int row, int col) {\\n          return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n        }\\n      \";\n    }\n    var texNumR = packedTexShape[0];\n    var texNumC = packedTexShape[1];\n    var valuesPerRow = Math.ceil(shape[2] / 2);\n    var texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n    var glsl = getGlslDifferences();\n    return \"\\n    vec4 \" + funcName + \"(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        \" + texNumR + \", \" + texNumC + \", \" + texelsInBatch + \", \" + valuesPerRow + \", b, row, col);\\n      return \" + glsl.texture2D + \"(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSampler3D(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var stride0 = shape[1] * shape[2];\n    var stride1 = shape[2];\n    var _a = tf.util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\n    var squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        var params = ['row', 'col', 'depth'];\n        return \"\\n        \" + getSamplerFromInInfo(newInputInfo) + \"\\n        float \" + funcName + \"(int row, int col, int depth) {\\n          return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n        }\\n      \";\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth) {\\n        int index = round(dot(vec3(row, col, depth),\\n                          vec3(\" + stride0 + \", \" + stride1 + \", 1)));\\n        \" + getUniformSampler(inputInfo) + \"\\n      }\\n    \";\n    }\n    var texShape = inputInfo.shapeInfo.texShape;\n    var texNumR = texShape[0];\n    var texNumC = texShape[1];\n    var flatOffset = inputInfo.shapeInfo.flatOffset;\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return \"\\n        float \" + funcName + \"(int row, int col, int depth) {\\n          float texR = float(row);\\n          float texC = dot(vec2(col, depth), vec2(\" + stride1 + \", 1));\\n          vec2 uv = (vec2(texC, texR) + halfCR) /\\n                     vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n          return sampleTexture(\" + texName + \", uv);\\n        }\\n      \";\n    }\n    if (texNumC === stride1 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return \"\\n    float \" + funcName + \"(int row, int col, int depth) {\\n      float texR = dot(vec2(row, col), vec2(\" + shape[1] + \", 1));\\n      float texC = float(depth);\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n    }\n    var offset = getFlatOffsetUniformName(texName);\n    return \"\\n      float \" + funcName + \"(int row, int col, int depth) {\\n        // Explicitly use integer operations as dot() only works on floats.\\n        int index = row * \" + stride0 + \" + col * \" + stride1 + \" + depth + \" + offset + \";\\n        vec2 uv = uvFromFlat(\" + texNumR + \", \" + texNumC + \", index);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n  \";\n}\nfunction getPackedSamplerND(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var rank = shape.length;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var texShape = inputInfo.shapeInfo.texShape;\n    var packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    var texNumR = packedTexShape[0];\n    var texNumC = packedTexShape[1];\n    var valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n    var texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n    var params = \"int b, int row, int col\";\n    var index = \"b * \" + texelsInBatch + \" + (row / 2) * \" + valuesPerRow + \" + (col / 2)\";\n    for (var b = 2; b < rank - 1; b++) {\n        params = \"int b\" + b + \", \" + params;\n        texelsInBatch *= shape[rank - b - 1];\n        index = \"b\" + b + \" * \" + texelsInBatch + \" + \" + index;\n    }\n    var glsl = getGlslDifferences();\n    return \"\\n    vec4 \" + funcName + \"(\" + params + \") {\\n      int index = \" + index + \";\\n      int texR = index / \" + texNumC + \";\\n      int texC = index - texR * \" + texNumC + \";\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + texNumC + \", \" + texNumR + \");\\n      return \" + glsl.texture2D + \"(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSampler4D(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var stride2 = shape[3];\n    var stride1 = shape[2] * stride2;\n    var stride0 = shape[1] * stride1;\n    var _a = tf.util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\n    if (newShape.length < shape.length) {\n        var newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        var params = ['row', 'col', 'depth', 'depth2'];\n        return \"\\n      \" + getSamplerFromInInfo(newInputInfo) + \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n      }\\n    \";\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        int index = round(dot(vec4(row, col, depth, depth2),\\n                          vec4(\" + stride0 + \", \" + stride1 + \", \" + stride2 + \", 1)));\\n        \" + getUniformSampler(inputInfo) + \"\\n      }\\n    \";\n    }\n    var flatOffset = inputInfo.shapeInfo.flatOffset;\n    var texShape = inputInfo.shapeInfo.texShape;\n    var texNumR = texShape[0];\n    var texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        float texR = float(row);\\n        float texC =\\n            dot(vec3(col, depth, depth2),\\n                vec3(\" + stride1 + \", \" + stride2 + \", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    if (texNumC === stride2 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        float texR = dot(vec3(row, col, depth),\\n                         vec3(\" + shape[1] * shape[2] + \", \" + shape[2] + \", 1));\\n        float texC = float(depth2);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    var offset = getFlatOffsetUniformName(texName);\n    return \"\\n    float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + stride0 + \" + col * \" + stride1 + \" +\\n          depth * \" + stride2 + \" + depth2;\\n      vec2 uv = uvFromFlat(\" + texNumR + \", \" + texNumC + \", index + \" + offset + \");\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSampler5D(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var stride3 = shape[4];\n    var stride2 = shape[3] * stride3;\n    var stride1 = shape[2] * stride2;\n    var stride0 = shape[1] * stride1;\n    var _a = tf.util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\n    if (newShape.length < shape.length) {\n        var newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        var params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n        return \"\\n      \" + getSamplerFromInInfo(newInputInfo) + \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2, int depth3) {\\n        return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n      }\\n    \";\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2, int depth3) {\\n        float index = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + stride0 + \", \" + stride1 + \", \" + stride2 + \", \" + stride3 + \")) +\\n          depth3;\\n        \" + getUniformSampler(inputInfo) + \"\\n      }\\n    \";\n    }\n    var flatOffset = inputInfo.shapeInfo.flatOffset;\n    var texShape = inputInfo.shapeInfo.texShape;\n    var texNumR = texShape[0];\n    var texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2, int depth3) {\\n        int texR = row;\\n        float texC = dot(vec4(col, depth, depth2, depth3),\\n                         vec4(\" + stride1 + \", \" + stride2 + \", \" + stride3 + \", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    if (texNumC === stride3 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2, int depth3) {\\n        float texR = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + shape[1] * shape[2] * shape[3] + \",\\n               \" + shape[2] * shape[3] + \", \" + shape[3] + \", 1));\\n        int texC = depth3;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    var offset = getFlatOffsetUniformName(texName);\n    return \"\\n    float \" + funcName + \"(int row, int col, int depth, int depth2, int depth3) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + stride0 + \" + col * \" + stride1 + \" + depth * \" + stride2 + \" +\\n          depth2 * \" + stride3 + \" + depth3 + \" + offset + \";\\n      vec2 uv = uvFromFlat(\" + texNumR + \", \" + texNumC + \", index);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSampler6D(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var _a = tf.util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\n    if (newShape.length < shape.length) {\n        var newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        var params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n        return \"\\n      \" + getSamplerFromInInfo(newInputInfo) + \"\\n      float \" + funcName + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n      }\\n    \";\n    }\n    var stride4 = shape[5];\n    var stride3 = shape[4] * stride4;\n    var stride2 = shape[3] * stride3;\n    var stride1 = shape[2] * stride2;\n    var stride0 = shape[1] * stride1;\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n        int index = round(dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + stride0 + \", \" + stride1 + \", \" + stride2 + \", \" + stride3 + \")) +\\n          dot(\\n            vec2(depth3, depth4),\\n            vec2(\" + stride4 + \", 1)));\\n        \" + getUniformSampler(inputInfo) + \"\\n      }\\n    \";\n    }\n    var flatOffset = inputInfo.shapeInfo.flatOffset;\n    var texShape = inputInfo.shapeInfo.texShape;\n    var texNumR = texShape[0];\n    var texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        int texR = row;\\n        float texC = dot(vec4(col, depth, depth2, depth3),\\n          vec4(\" + stride1 + \", \" + stride2 + \", \" + stride3 + \", \" + stride4 + \")) +\\n               float(depth4);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    if (texNumC === stride4 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        float texR = dot(vec4(row, col, depth, depth2),\\n          vec4(\" + shape[1] * shape[2] * shape[3] * shape[4] + \",\\n               \" + shape[2] * shape[3] * shape[4] + \",\\n               \" + shape[3] * shape[4] + \",\\n               \" + shape[4] + \")) + float(depth3);\\n        int texC = depth4;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    var offset = getFlatOffsetUniformName(texName);\n    return \"\\n    float \" + funcName + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + stride0 + \" + col * \" + stride1 + \" + depth * \" + stride2 + \" +\\n          depth2 * \" + stride3 + \" + depth3 * \" + stride4 + \" + depth4 + \" + offset + \";\\n      vec2 uv = uvFromFlat(\" + texNumR + \", \" + texNumC + \", index);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getUniformSampler(inputInfo) {\n    var texName = inputInfo.name;\n    var inSize = tf.util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n    if (inSize < 2) {\n        return \"return \" + texName + \";\";\n    }\n    return \"\\n    for (int i = 0; i < \" + inSize + \"; i++) {\\n      if (i == index) {\\n        return \" + texName + \"[i];\\n      }\\n    }\\n  \";\n}\nfunction getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {\n    var texName = inputInfo.name;\n    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n    var inRank = inputInfo.shapeInfo.logicalShape.length;\n    var outRank = outShapeInfo.logicalShape.length;\n    var broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n    var type = getCoordsDataType(outRank);\n    var rankDiff = outRank - inRank;\n    var coordsSnippet;\n    var fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n    if (inRank === 0) {\n        coordsSnippet = '';\n    }\n    else if (outRank < 2 && broadcastDims.length >= 1) {\n        coordsSnippet = 'coords = 0;';\n    }\n    else {\n        coordsSnippet =\n            broadcastDims.map(function (d) { return \"coords.\" + fields[d + rankDiff] + \" = 0;\"; })\n                .join('\\n');\n    }\n    var unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n        unpackedCoordsSnippet = 'coords';\n    }\n    else {\n        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n            .map(function (s, i) { return \"coords.\" + fields[i + rankDiff]; })\n            .join(', ');\n    }\n    var output = \"return outputValue;\";\n    var inSize = tf.util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n    var isInputScalar = inSize === 1;\n    var outSize = tf.util.sizeFromShape(outShapeInfo.logicalShape);\n    var isOutputScalar = outSize === 1;\n    if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n        output = \"\\n      return vec4(outputValue.xy, outputValue.xy);\\n    \";\n    }\n    else if (isInputScalar && !isOutputScalar) {\n        if (outRank === 1) {\n            output = \"\\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\\n      \";\n        }\n        else {\n            output = \"\\n        return vec4(outputValue.x);\\n      \";\n        }\n    }\n    else if (broadcastDims.length) {\n        var rows = inRank - 2;\n        var cols = inRank - 1;\n        if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n            output = \"return vec4(outputValue.x);\";\n        }\n        else if (broadcastDims.indexOf(rows) > -1) {\n            output = \"return vec4(outputValue.x, outputValue.y, \" +\n                \"outputValue.x, outputValue.y);\";\n        }\n        else if (broadcastDims.indexOf(cols) > -1) {\n            output = \"return vec4(outputValue.xx, outputValue.zz);\";\n        }\n    }\n    return \"\\n    vec4 \" + funcName + \"() {\\n      \" + type + \" coords = getOutputCoords();\\n      \" + coordsSnippet + \"\\n      vec4 outputValue = get\" + texFuncSnippet + \"(\" + unpackedCoordsSnippet + \");\\n      \" + output + \"\\n    }\\n  \";\n}\nfunction getSamplerAtOutputCoords(inputInfo, outShapeInfo) {\n    var texName = inputInfo.name;\n    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n    var outTexShape = outShapeInfo.texShape;\n    var inTexShape = inputInfo.shapeInfo.texShape;\n    var inRank = inputInfo.shapeInfo.logicalShape.length;\n    var outRank = outShapeInfo.logicalShape.length;\n    if (!inputInfo.shapeInfo.isUniform && inRank === outRank &&\n        inputInfo.shapeInfo.flatOffset == null &&\n        tf.util.arraysEqual(inTexShape, outTexShape)) {\n        return \"\\n      float \" + funcName + \"() {\\n        return sampleTexture(\" + texName + \", resultUV);\\n      }\\n    \";\n    }\n    var type = getCoordsDataType(outRank);\n    var broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n    var rankDiff = outRank - inRank;\n    var coordsSnippet;\n    var fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n    if (inRank === 0) {\n        coordsSnippet = '';\n    }\n    else if (outRank < 2 && broadcastDims.length >= 1) {\n        coordsSnippet = 'coords = 0;';\n    }\n    else {\n        coordsSnippet =\n            broadcastDims.map(function (d) { return \"coords.\" + fields[d + rankDiff] + \" = 0;\"; })\n                .join('\\n');\n    }\n    var unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n        unpackedCoordsSnippet = 'coords';\n    }\n    else {\n        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n            .map(function (s, i) { return \"coords.\" + fields[i + rankDiff]; })\n            .join(', ');\n    }\n    return \"\\n    float \" + funcName + \"() {\\n      \" + type + \" coords = getOutputCoords();\\n      \" + coordsSnippet + \"\\n      return get\" + texFuncSnippet + \"(\" + unpackedCoordsSnippet + \");\\n    }\\n  \";\n}\nfunction getCoordsDataType(rank) {\n    if (rank <= 1) {\n        return 'int';\n    }\n    else if (rank === 2) {\n        return 'ivec2';\n    }\n    else if (rank === 3) {\n        return 'ivec3';\n    }\n    else if (rank === 4) {\n        return 'ivec4';\n    }\n    else if (rank === 5) {\n        return 'ivec5';\n    }\n    else if (rank === 6) {\n        return 'ivec6';\n    }\n    else {\n        throw Error(\"GPU for rank \" + rank + \" is not yet supported\");\n    }\n}\n/** Returns a new input info (a copy) that has a squeezed logical shape. */\nfunction squeezeInputInfo(inInfo, squeezedShape) {\n    // Deep copy.\n    var newInputInfo = JSON.parse(JSON.stringify(inInfo));\n    newInputInfo.shapeInfo.logicalShape = squeezedShape;\n    return newInputInfo;\n}\nfunction getSqueezedParams(params, keptDims) {\n    return keptDims.map(function (d) { return params[d]; }).join(', ');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction compileProgram(gpgpu, program, inputs, output) {\n    var userCode = program.userCode;\n    var inputInfos = inputs.map(function (input, i) {\n        var shapeInfo = {\n            logicalShape: input.shape,\n            texShape: input.isUniform ? null : input.texData.texShape,\n            isUniform: input.isUniform,\n            isPacked: input.isUniform ? false : input.texData.isPacked,\n            flatOffset: null\n        };\n        if (input.texData != null && input.texData.slice != null &&\n            input.texData.slice.flatOffset > 0) {\n            shapeInfo.flatOffset = input.texData.slice.flatOffset;\n        }\n        return { name: program.variableNames[i], shapeInfo: shapeInfo };\n    });\n    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });\n    var outShapeInfo = {\n        logicalShape: output.shape,\n        texShape: output.texData.texShape,\n        isUniform: false,\n        isPacked: output.texData.isPacked,\n        flatOffset: null\n    };\n    var source = makeShader(inputInfos, outShapeInfo, userCode, program.packedInputs);\n    var webGLProgram = gpgpu.createProgram(source);\n    // Add special uniforms (NAN, INFINITY)\n    var infLoc = null;\n    var nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n    if (tf.env().getNumber('WEBGL_VERSION') === 1) {\n        infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n    }\n    // Add user-defined uniforms\n    var uniformLocations = {};\n    for (var i = 0; i < program.variableNames.length; i++) {\n        var varName = program.variableNames[i];\n        var shouldThrow = false;\n        uniformLocations[varName] =\n            gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n        uniformLocations[\"offset\" + varName] =\n            gpgpu.getUniformLocation(webGLProgram, \"offset\" + varName, shouldThrow);\n    }\n    return {\n        program: program,\n        source: source,\n        webGLProgram: webGLProgram,\n        uniformLocations: uniformLocations,\n        inShapeInfos: inShapeInfos,\n        outShapeInfo: outShapeInfo,\n        infLoc: infLoc,\n        nanLoc: nanLoc,\n    };\n}\nfunction validateBinaryAndProgram(shapeInfos, inputs) {\n    if (shapeInfos.length !== inputs.length) {\n        throw Error(\"Binary was compiled with \" + shapeInfos.length + \" inputs, but \" +\n            (\"was executed with \" + inputs.length + \" inputs\"));\n    }\n    shapeInfos.forEach(function (s, i) {\n        var shapeA = s.logicalShape;\n        var input = inputs[i];\n        var shapeB = input.shape;\n        if (!tf.util.arraysEqual(shapeA, shapeB)) {\n            throw Error(\"Binary was compiled with different shapes than \" +\n                (\"the current args. Shapes \" + shapeA + \" and \" + shapeB + \" must match\"));\n        }\n        // The input is uploaded as uniform.\n        if (s.isUniform && input.isUniform) {\n            return;\n        }\n        var texShapeA = s.texShape;\n        var texShapeB = input.isUniform ? null : input.texData.texShape;\n        if (!tf.util.arraysEqual(texShapeA, texShapeB)) {\n            throw Error(\"Binary was compiled with different texture shapes than the\" +\n                (\" current args. Shape \" + texShapeA + \" and \" + texShapeB + \" must match\"));\n        }\n    });\n}\nfunction runProgram(gpgpu, binary, inputs, output, customSetup) {\n    validateBinaryAndProgram(binary.inShapeInfos, inputs);\n    validateBinaryAndProgram([binary.outShapeInfo], [output]);\n    var outTex = output.texData.texture;\n    var outTexShape = output.texData.texShape;\n    if (output.texData.isPacked) {\n        gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n    }\n    else {\n        gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n    }\n    gpgpu.setProgram(binary.webGLProgram);\n    // Set special uniforms (NAN, INFINITY)\n    if (tf.env().getNumber('WEBGL_VERSION') === 1) {\n        if (binary.infLoc !== null) {\n            gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n        }\n    }\n    if (binary.nanLoc !== null) {\n        gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n    }\n    // Set user-defined inputs\n    inputs.forEach(function (input, i) {\n        var varName = binary.program.variableNames[i];\n        var varLoc = binary.uniformLocations[varName];\n        var varOffsetLoc = binary.uniformLocations[\"offset\" + varName];\n        if (varLoc == null) {\n            // The compiler inferred that this variable is not used in this shader.\n            return;\n        }\n        if (input.isUniform) {\n            // Upload the values of the tensor as uniform.\n            if (tf.util.sizeFromShape(input.shape) < 2) {\n                gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n            }\n            else {\n                var vals = input.uniformValues;\n                if (!(vals instanceof Float32Array)) {\n                    vals = new Float32Array(vals);\n                }\n                gpgpu.gl.uniform1fv(varLoc, vals);\n            }\n            return;\n        }\n        // If the input was sliced, upload the flat offset index.\n        if (input.texData.slice != null && varOffsetLoc != null) {\n            gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n        }\n        gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);\n    });\n    if (customSetup != null) {\n        customSetup(gpgpu, binary.webGLProgram);\n    }\n    gpgpu.executeProgram();\n}\nfunction makeShaderKey(program, inputs, output) {\n    var keyInputs = '';\n    inputs.concat(output).forEach(function (x) {\n        var hasOffset = x.texData != null && x.texData.slice != null &&\n            x.texData.slice.flatOffset > 0;\n        var texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n        keyInputs += x.shape + \"_\" + texShape + \"_\" + hasOffset;\n    });\n    var keyUserCode = program.userCode;\n    var key = program.constructor.name;\n    // Fast string concat. See https://jsperf.com/string-concatenation/14.\n    key += '_' + keyInputs + '_' + keyUserCode;\n    return key;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction simpleAbsImpl(vals) {\n    const resultValues = new Float32Array(vals.length);\n    for (let i = 0; i < vals.length; ++i) {\n        resultValues[i] = Math.abs(vals[i]);\n    }\n    return resultValues;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Template that creates implementation for binary ops. Supports broadcast.\n */\nfunction createSimpleBinaryKernelImpl(op) {\n    return (aShape, bShape, aVals, bVals, dtype) => {\n        const newShape = tf.backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        const resultRank = newShape.length;\n        const resultStrides = tf.util.computeStrides(newShape);\n        const resultSize = tf.util.sizeFromShape(newShape);\n        const result = tf.util.getTypedArrayFromDType(dtype, resultSize);\n        const aRank = aShape.length;\n        const bRank = bShape.length;\n        const aStrides = tf.util.computeStrides(aShape);\n        const bStrides = tf.util.computeStrides(bShape);\n        const aBroadcastDims = tf.backend_util.getBroadcastDims(aShape, newShape);\n        const bBroadcastDims = tf.backend_util.getBroadcastDims(bShape, newShape);\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < result.length; ++i) {\n                result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n            }\n        }\n        else {\n            for (let i = 0; i < result.length; ++i) {\n                const loc = tf.util.indexToLoc(i, resultRank, resultStrides);\n                const aLoc = loc.slice(-aRank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = tf.util.locToIndex(aLoc, aRank, aStrides);\n                const bLoc = loc.slice(-bRank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = tf.util.locToIndex(bLoc, bRank, bStrides);\n                result[i] = op(aVals[aIndex], bVals[bIndex]);\n            }\n        }\n        return [result, newShape];\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst addImpl = createSimpleBinaryKernelImpl(((a, b) => a + b));\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction bincountImpl(xVals, weightsVals, weightsDtype, weightsShape, size) {\n    const weightsSize = tf.util.sizeFromShape(weightsShape);\n    const outVals = tf.util.makeZerosTypedArray(size, weightsDtype);\n    for (let i = 0; i < xVals.length; i++) {\n        const value = xVals[i];\n        if (value < 0) {\n            throw new Error('Input x must be non-negative!');\n        }\n        if (value >= size) {\n            continue;\n        }\n        if (weightsSize > 0) {\n            outVals[value] += weightsVals[i];\n        }\n        else {\n            outVals[value] += 1;\n        }\n    }\n    return outVals;\n}\nfunction bincountReduceImpl(xBuf, weightsBuf, size, binaryOutput = false) {\n    const numRows = xBuf.shape[0];\n    const numCols = xBuf.shape[1];\n    const outBuf = tf.buffer([numRows, size], weightsBuf.dtype);\n    for (let i = 0; i < numRows; i++) {\n        for (let j = 0; j < numCols; j++) {\n            const value = xBuf.get(i, j);\n            if (value < 0) {\n                throw new Error('Input x must be non-negative!');\n            }\n            if (value >= size) {\n                continue;\n            }\n            if (binaryOutput) {\n                outBuf.set(1, i, value);\n            }\n            else {\n                if (weightsBuf.size > 0) {\n                    outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j), i, value);\n                }\n                else {\n                    outBuf.set(outBuf.get(i, value) + 1, i, value);\n                }\n            }\n        }\n    }\n    return outBuf;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Template that creates implementation for unary op.\n */\nfunction createSimpleUnaryImpl(op) {\n    return (values, dtype, attrs) => {\n        const newValues = tf.util.getTypedArrayFromDType(dtype, values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = op(values[i], attrs);\n        }\n        return newValues;\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction concatImpl(inputs, outShape, dtype, simplyConcat) {\n    const outVals = tf.util.getArrayFromDType(dtype, tf.util.sizeFromShape(outShape));\n    if (simplyConcat && dtype !== 'string') {\n        // Use built-in TypedArray.set() method for speed.\n        let offset = 0;\n        inputs.forEach(input => {\n            const size = tf.util.sizeFromShape(input.shape);\n            outVals.set(input.vals, offset);\n            offset += size;\n        });\n    }\n    else {\n        let colOffset = 0;\n        inputs.forEach(input => {\n            const decodedData = dtype === 'string' ?\n                tf.backend_util.fromUint8ToStringArray(input.vals) :\n                input.vals;\n            let tIdx = 0;\n            for (let row = 0; row < input.shape[0]; ++row) {\n                const resIdx = row * outShape[1] + colOffset;\n                for (let col = 0; col < input.shape[1]; ++col) {\n                    outVals[resIdx + col] = decodedData[tIdx++];\n                }\n            }\n            colOffset += input.shape[1];\n        });\n    }\n    return outVals;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction gatherV2Impl(xBuf, indicesBuf, flattenOutputShape) {\n    const outBuf = tf.buffer(flattenOutputShape, xBuf.dtype);\n    for (let i = 0; i < outBuf.size; ++i) {\n        const newLoc = outBuf.indexToLoc(i);\n        const originalLoc = newLoc.slice();\n        const batchIdx = originalLoc[0];\n        const indicesIdx = originalLoc[2];\n        const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);\n        originalLoc[2] = indicesBuf.values[indicesIndex];\n        const originalIndex = xBuf.locToIndex(originalLoc);\n        outBuf.values[i] = xBuf.values[originalIndex];\n    }\n    return outBuf;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst greaterImpl = createSimpleBinaryKernelImpl((a, b) => (a > b) ? 1 : 0);\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst lessImpl = createSimpleBinaryKernelImpl((a, b) => (a < b) ? 1 : 0);\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction linSpaceImpl(start, stop, num) {\n    const step = (stop - start) / (num - 1);\n    const values = tf.util.makeZerosTypedArray(num, 'float32');\n    values[0] = start;\n    for (let i = 1; i < values.length; i++) {\n        values[i] = values[i - 1] + step;\n    }\n    return values;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxImpl(aVals, reduceSize, outShape, dtype) {\n    const vals = tf.util.getTypedArrayFromDType(dtype, tf.util.sizeFromShape(outShape));\n    for (let i = 0; i < vals.length; ++i) {\n        const offset = i * reduceSize;\n        let max = aVals[offset];\n        for (let j = 0; j < reduceSize; ++j) {\n            const value = aVals[offset + j];\n            if (value > max) {\n                max = value;\n            }\n        }\n        vals[i] = max;\n    }\n    return vals;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst maximumImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => Math.max(aValue, bValue)));\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst minimumImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => Math.min(aValue, bValue)));\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst multiplyImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => aValue * bValue));\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction negImpl(xVals, xShape, xDtype) {\n    const minusOne = tf.util.createScalarValue(-1, xDtype);\n    return multiplyImpl([], xShape, minusOne, xVals, xDtype);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction transposeImpl(xVals, xShape, dtype, perm, newShape) {\n    const xRank = xShape.length;\n    const xSize = tf.util.sizeFromShape(xShape);\n    const xStrides = tf.util.computeStrides(xShape);\n    const newStrides = tf.util.computeStrides(newShape);\n    const result = tf.util.getTypedArrayFromDType(dtype, tf.util.sizeFromShape(newShape));\n    for (let i = 0; i < xSize; ++i) {\n        const loc = tf.util.indexToLoc(i, xRank, xStrides);\n        // Permute location.\n        const newLoc = new Array(loc.length);\n        for (let i = 0; i < newLoc.length; i++) {\n            newLoc[i] = loc[perm[i]];\n        }\n        const newIndex = tf.util.locToIndex(newLoc, xRank, newStrides);\n        result[newIndex] = xVals[i];\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction prodImpl(xShape, xDtype, xVals, reductionAxes) {\n    const [outShape, reduceShape] = tf.backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n    const outDtype = tf.upcastType(xDtype, 'int32');\n    const outVals = tf.util.makeZerosTypedArray(tf.util.sizeFromShape(outShape), outDtype);\n    const reduceSize = tf.util.sizeFromShape(reduceShape);\n    for (let i = 0; i < outVals.length; ++i) {\n        const offset = i * reduceSize;\n        let prod = 1;\n        for (let j = 0; j < reduceSize; ++j) {\n            prod *= xVals[offset + j];\n        }\n        outVals[i] = prod;\n    }\n    return { outVals, outShape, outDtype };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction rangeImpl(start, stop, step, dtype) {\n    const sameStartStop = start === stop;\n    const increasingRangeNegativeStep = start < stop && step < 0;\n    const decreasingRangePositiveStep = stop < start && step > 1;\n    if (sameStartStop || increasingRangeNegativeStep ||\n        decreasingRangePositiveStep) {\n        return tf.util.makeZerosTypedArray(0, dtype);\n    }\n    const numElements = Math.abs(Math.ceil((stop - start) / step));\n    const values = tf.util.makeZerosTypedArray(numElements, dtype);\n    if (stop < start && step === 1) {\n        // Auto adjust the step's sign if it hasn't been set\n        // (or was set to 1)\n        step = -1;\n    }\n    values[0] = start;\n    for (let i = 1; i < values.length; i++) {\n        values[i] = values[i - 1] + step;\n    }\n    return values;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction sliceImpl(vals, begin, size, shape, dtype) {\n    const isContinous = tf.slice_util.isSliceContinous(shape, begin, size);\n    const length = tf.util.sizeFromShape(size);\n    const xStrides = tf.util.computeStrides(shape);\n    if (isContinous) {\n        const flatOffset = tf.slice_util.computeFlatOffset(begin, xStrides);\n        if (dtype === 'string') {\n            return vals.slice(flatOffset, flatOffset + length);\n        }\n        return vals.subarray(flatOffset, flatOffset + length);\n    }\n    const decodedData = dtype === 'string' ?\n        tf.backend_util.fromUint8ToStringArray(vals) :\n        vals;\n    const inBuf = tf.buffer(shape, dtype, decodedData);\n    const outBuf = tf.buffer(size, dtype);\n    for (let i = 0; i < outBuf.size; ++i) {\n        const outLoc = outBuf.indexToLoc(i);\n        const inLoc = outLoc.map((idx, j) => idx + begin[j]);\n        outBuf.set(inBuf.get(...inLoc), ...outLoc);\n    }\n    if (dtype === 'string') {\n        return tf.backend_util.fromStringArrayToUint8(outBuf.values);\n    }\n    return outBuf.values;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction stridedSliceImpl(outShape, xBuf, strides, begin) {\n    const outBuf = tf.buffer(outShape, xBuf.dtype);\n    for (let i = 0; i < outBuf.size; i++) {\n        const loc = outBuf.indexToLoc(i);\n        const newLoc = new Array(loc.length);\n        for (let j = 0; j < newLoc.length; j++) {\n            newLoc[j] = loc[j] * strides[j] + begin[j];\n        }\n        outBuf.set(xBuf.get(...newLoc), ...loc);\n    }\n    return outBuf;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst subImpl = createSimpleBinaryKernelImpl(((aValue, bValue) => aValue - bValue));\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * An implementation of the tile kernel shared between webgl and cpu for string\n * tensors only.\n */\nfunction tileImpl(xBuf, reps) {\n    const newShape = new Array(xBuf.rank);\n    for (let i = 0; i < newShape.length; i++) {\n        newShape[i] = xBuf.shape[i] * reps[i];\n    }\n    const result = tf.buffer(newShape, xBuf.dtype);\n    for (let i = 0; i < result.values.length; ++i) {\n        const newLoc = result.indexToLoc(i);\n        const originalLoc = new Array(xBuf.rank);\n        for (let j = 0; j < originalLoc.length; j++) {\n            originalLoc[j] = newLoc[j] % xBuf.shape[j];\n        }\n        const originalIndex = xBuf.locToIndex(originalLoc);\n        result.values[i] = xBuf.values[originalIndex];\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction topKImpl(x, xShape, xDtype, k, sorted) {\n    // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n    const lastDim = xShape[xShape.length - 1];\n    const [batch, size] = [x.length / lastDim, lastDim];\n    const allTopKVals = tf.util.getTypedArrayFromDType(xDtype, batch * k);\n    const allTopKIndices = tf.util.getTypedArrayFromDType('int32', batch * k);\n    for (let b = 0; b < batch; b++) {\n        const offset = b * size;\n        const vals = x.subarray(offset, offset + size);\n        const valAndInd = [];\n        for (let i = 0; i < vals.length; i++) {\n            valAndInd.push({ value: vals[i], index: i });\n        }\n        valAndInd.sort((a, b) => b.value - a.value);\n        const outOffset = b * k;\n        const topKVals = allTopKVals.subarray(outOffset, outOffset + k);\n        const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);\n        for (let i = 0; i < k; i++) {\n            topKVals[i] = valAndInd[i].value;\n            topKIndices[i] = valAndInd[i].index;\n        }\n    }\n    // Reshape back to the original input shape, except that the last\n    // dimension is k.\n    const outputShape = xShape.slice();\n    outputShape[outputShape.length - 1] = k;\n    return [\n        tf.buffer(outputShape, xDtype, allTopKVals),\n        tf.buffer(outputShape, 'int32', allTopKIndices)\n    ];\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction uniqueImpl(values, axis, shape, dtype) {\n    // Normalize and validate axis.\n    const $axis = tf.util.parseAxisParam(axis, shape)[0];\n    // Calculate the new shape that is suitable for extracting data along the\n    // given axis.\n    //\n    // The rank is 3.\n    // The size of the 1st dimension is the size of all the axes < the given axis.\n    // The size of the 2nd dimension is the same as the size of the given axis.\n    // The size of the 3rd dimension is the size of all the axes > the given axis.\n    //\n    // For example, for a 4D tensor with shape=[2, 3, 5, 4] and axis=2, the\n    // newShape would be: [2*3, 5, 4].\n    //\n    // Note that this is not the final output shape. This will be the shape for an\n    // intermediate TensorBuffer (see inputBuffer below) to allow us to extract\n    // values along the given axis. To demonstrate how it works, consider the\n    // following example:\n    //\n    // Input: a 3D tensor, with shape [1, 2, 3]\n    // [\n    //   [\n    //      [1,2,3],\n    //      [4,5,6]\n    //   ]\n    // ]\n    // Axis: 2 (the last axis).\n    // Along axis 2, we expect to extract 3 tensors: [1,4], [2,5], [3,6].\n    //\n    // For this example, newShape would be: [2, 3, 1], where 2 is calculated from\n    // 1*2. The re-shaped data would look like:\n    //\n    // [\n    //   [\n    //     [1], [2], [3]\n    //   ],\n    //   [\n    //     [4], [5], [6]\n    //   ]\n    // ]\n    //\n    // Then, we can construct a 3-level nested loop by the following dimension\n    // order to extract the values along the axis (dimension1):\n    // i: dimension1       // 0,1,2 (newShape[1])\n    //   m: dimension0     // 0,1   (newShape[0])\n    //     n: dimension2   // 0     (newShape[2])\n    //\n    //                       m, i, n\n    //                      ---------\n    // Iteration 0: data at [0, 0, 0] => \"1\"\n    // Iteration 1: data at [1, 0, 0] => \"4\"\n    // We got [1,4].\n    // Iteration 2: data at [0, 1, 0] => \"2\"\n    // Iteration 3: data at [1, 1, 0] => \"5\"\n    // We got [2,5].\n    // Iteration 4: data at [0, 2, 0] => \"3\"\n    // Iteration 5: data at [1, 2, 0] => \"6\"\n    // We got [3,6].\n    const newShape = [1, shape[0], 1];\n    for (let i = 0; i < $axis; i++) {\n        newShape[0] *= shape[i];\n    }\n    newShape[1] = shape[$axis];\n    for (let i = $axis + 1; i < shape.length; i++) {\n        newShape[2] *= shape[i];\n    }\n    // A map from unique elements (their string representations) to their values\n    // in \"indices\" (below).\n    const uniqueElements = {};\n    // The indices of each unique element in the original tensor along the given\n    // axis. It is 1D and has the same size as the given axis.\n    const indices = new Int32Array(shape[$axis]);\n    // Create a buffer so we can easily extract value at a given location.\n    const inputBuffer = new tf.TensorBuffer(newShape, dtype, values);\n    // The indices along the given axis that have unique elements. This is a\n    // de-duped version of \"indices\" above.\n    const uniqueIndices = [];\n    const is1DTensor = newShape[0] === 1 && newShape[2] === 1;\n    for (let i = 0; i < shape[$axis]; i++) {\n        // Extract values along the axis.\n        let element;\n        if (is1DTensor) {\n            // Fast path for 1D tensor input.\n            element = values[i].toString();\n        }\n        else {\n            const axisValues = [];\n            for (let m = 0; m < newShape[0]; m++) {\n                for (let n = 0; n < newShape[2]; n++) {\n                    axisValues.push(inputBuffer.get(m, i, n));\n                }\n            }\n            element = axisValues.join(',');\n        }\n        // Dedup and update various indices.\n        if (uniqueElements[element] !== undefined) {\n            indices[i] = uniqueElements[element];\n        }\n        else {\n            const uniqueIndex = Object.keys(uniqueElements).length;\n            uniqueElements[element] = uniqueIndex;\n            indices[i] = uniqueIndex;\n            uniqueIndices.push(i);\n        }\n    }\n    // Now we know where each of the unique elements are located along the axis\n    // (uniqueIndices). Extract them from input buffer and store them in the\n    // output buffer.\n    const outputTmpShape = newShape.slice();\n    outputTmpShape[1] = Object.keys(uniqueElements).length;\n    const outputBuffer = new tf.TensorBuffer(outputTmpShape, dtype);\n    uniqueIndices.forEach((uniqueElementIndex, i) => {\n        for (let m = 0; m < newShape[0]; m++) {\n            for (let n = 0; n < newShape[2]; n++) {\n                outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);\n            }\n        }\n    });\n    // The output shape can be calculated from the input shape with the size of\n    // the given axis replaced by the number of unique elements along that axis.\n    const outputShape = shape.slice();\n    outputShape[$axis] = outputTmpShape[1];\n    return {\n        outputValues: outputBuffer.values,\n        outputShape,\n        indices,\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar addImplCPU = addImpl, bincountImplCPU = bincountImpl, bincountReduceImplCPU = bincountReduceImpl, ceilImplCPU = ceilImpl, concatImplCPU = concatImpl, expImplCPU = expImpl, expm1ImplCPU = expm1Impl, floorImplCPU = floorImpl, gatherV2ImplCPU = gatherV2Impl, greaterImplCPU = greaterImpl, lessImplCPU = lessImpl, linSpaceImplCPU = linSpaceImpl, logImplCPU = logImpl, maxImplCPU = maxImpl, maximumImplCPU = maximumImpl, minimumImplCPU = minimumImpl, multiplyImplCPU = multiplyImpl, negImplCPU = negImpl, prodImplCPU = prodImpl, rangeImplCPU = rangeImpl, rsqrtImplCPU = rsqrtImpl, simpleAbsImplCPU = simpleAbsImpl, sliceImplCPU = sliceImpl, stridedSliceImplCPU = stridedSliceImpl, subImplCPU = subImpl, tileImplCPU = tileImpl, topKImplCPU = topKImpl, transposeImplCPU = transposeImpl, uniqueImplCPU = uniqueImpl;\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction getVecChannels(name, rank) {\n    return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(function (d) { return name + \".\" + d; });\n}\nfunction getChannels(name, rank) {\n    if (rank === 1) {\n        return [name];\n    }\n    return getVecChannels(name, rank);\n}\nfunction getSourceCoords(rank, dims) {\n    if (rank === 1) {\n        return 'rc';\n    }\n    var coords = '';\n    for (var i = 0; i < rank; i++) {\n        coords += dims[i];\n        if (i < rank - 1) {\n            coords += ',';\n        }\n    }\n    return coords;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar PackProgram = /** @class */ (function () {\n    function PackProgram(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        // Only input / output 3D tensors.\n        this.outputShape = outputShape;\n        var rank = outputShape.length;\n        if (rank === 0) {\n            this.userCode = \"\\n        void main() {\\n          setOutput(vec4(getA(), 0., 0., 0.));\\n        }\\n      \";\n        }\n        else {\n            var channels = getChannels('rc', rank);\n            var dtype = getCoordsDataType(rank);\n            var outOfBoundsCondition = getOutOfBoundsCondition(rank, outputShape, channels);\n            var setup = getSetup(rank, outputShape[outputShape.length - 1], outputShape[outputShape.length - 2], channels);\n            var output = getOutput(outputShape, channels);\n            this.userCode = \"\\n        void main() {\\n          \" + dtype + \" rc = getOutputCoords();\\n\\n          if(\" + outOfBoundsCondition + \") {\\n            setOutput(vec4(0));\\n          } else {\\n            \" + setup + \"\\n\\n            setOutput(vec4(\" + output + \"));\\n          }\\n        }\\n      \";\n        }\n    }\n    return PackProgram;\n}());\nfunction getSourceCoordsArr(rank, dims) {\n    var coords = [];\n    for (var row = 0; row <= 1; row++) {\n        for (var col = 0; col <= 1; col++) {\n            var coord = (row === 0 ? 'r' : 'rp1') + \", \" + (col === 0 ? 'c' : 'cp1');\n            for (var d = 2; d < rank; d++) {\n                coord = dims[dims.length - 1 - d] + \",\" + coord;\n            }\n            coords.push(coord);\n        }\n    }\n    return coords;\n}\nfunction getOutOfBoundsCondition(rank, shape, dims) {\n    if (rank === 1) {\n        return \"rc > \" + shape[0];\n    }\n    var cond = '';\n    for (var i = rank - 2; i < rank; i++) {\n        cond += dims[i] + \" >= \" + shape[i];\n        if (i < rank - 1) {\n            cond += '||';\n        }\n    }\n    return cond;\n}\nfunction getSetup(rank, cols, rows, dims) {\n    if (rank === 1) {\n        return '';\n    }\n    var innerDims = dims.slice(-2);\n    return \"\\n    int r = \" + innerDims[0] + \";\\n    int c = \" + innerDims[1] + \";\\n    int rp1 = r + 1;\\n    int cp1 = c + 1;\\n\\n    bool cEdge = cp1 >= \" + cols + \";\\n    bool rEdge = rp1 >= \" + rows + \";\\n  \";\n}\nfunction getOutput(shape, dims) {\n    var rank = shape.length;\n    var sourceCoords = getSourceCoordsArr(rank, dims);\n    if (rank === 1) {\n        return \"getA(rc),\\n            rc + 1 >= \" + shape[0] + \" ? 0. : getA(rc + 1),\\n            0, 0\";\n    }\n    return \"getA(\" + sourceCoords[0] + \"),\\n          cEdge ? 0. : getA(\" + sourceCoords[1] + \"),\\n          rEdge ? 0. : getA(\" + sourceCoords[2] + \"),\\n          rEdge || cEdge ? 0. : getA(\" + sourceCoords[3] + \")\";\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ReshapePackedProgram = /** @class */ (function () {\n    function ReshapePackedProgram(outputShape, inputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        var mainLoop = \"\";\n        for (var i = 0; i < 4; i++) {\n            var thisRC = \"thisRC = rc;\";\n            if (i % 2 === 1) {\n                thisRC += \"thisRC.z += 1;\";\n            }\n            if (i > 1) {\n                thisRC += \"thisRC.y += 1;\";\n            }\n            mainLoop += \"\\n        \" + thisRC + \"\\n        \" + (i > 0 ? \"if(thisRC.y < rows && thisRC.z < cols){\" : '') + \"\\n          int flatIndex = getFlatIndex(thisRC);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[\" + i + \"] =\\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\\n        \" + (i > 0 ? '}' : '') + \"\\n      \";\n        }\n        this.userCode = \"\\n      \" + getReshapedInputCoords(inputShape) + \"\\n      \" + getFlatIndexFrom3D(outputShape) + \"\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.);\\n\\n        ivec3 thisRC;\\n        int rows = \" + outputShape[1] + \";\\n        int cols = \" + outputShape[2] + \";\\n\\n        \" + mainLoop + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return ReshapePackedProgram;\n}());\nfunction getReshapedInputCoords(shape) {\n    var coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n    return \"\\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      \" + coordsFromIndexSnippet + \"\\n      return ivec3(r, c, d);\\n    }\\n  \";\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar TextureManager = /** @class */ (function () {\n    function TextureManager(gpgpu) {\n        this.gpgpu = gpgpu;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0; // How many bytes that have been allocated\n        // are available for reuse.\n        this.freeTextures = {};\n        this.logEnabled = false;\n        this.usedTextures = {};\n    }\n    TextureManager.prototype.acquireTexture = function (shapeRC, usage, isPacked) {\n        var physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n        var shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        if (!(shapeKey in this.usedTextures)) {\n            this.usedTextures[shapeKey] = [];\n        }\n        var texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        if (this.freeTextures[shapeKey].length > 0) {\n            this.numFreeTextures--;\n            this.numUsedTextures++;\n            this._numBytesFree -= texBytes;\n            this.log();\n            var newTexture_1 = this.freeTextures[shapeKey].shift();\n            this.usedTextures[shapeKey].push(newTexture_1);\n            return newTexture_1;\n        }\n        var newTexture;\n        if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n            newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n            newTexture =\n                this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n            newTexture =\n                this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        this.usedTextures[shapeKey].push(newTexture);\n        this.numUsedTextures++;\n        this._numBytesAllocated += texBytes;\n        this.log();\n        return newTexture;\n    };\n    TextureManager.prototype.releaseTexture = function (texture, shape, logicalTexType, isPacked) {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        var physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n        var shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        var texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        var deleteTexThreshold = tf.env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n        if (deleteTexThreshold !== -1 &&\n            this._numBytesAllocated > deleteTexThreshold) {\n            this.gpgpu.deleteMatrixTexture(texture);\n            this._numBytesAllocated -= texBytes;\n        }\n        else {\n            this.freeTextures[shapeKey].push(texture);\n            this.numFreeTextures++;\n            this._numBytesFree += texBytes;\n        }\n        this.numUsedTextures--;\n        var texList = this.usedTextures[shapeKey];\n        var texIndex = texList.indexOf(texture);\n        if (texIndex < 0) {\n            throw new Error('Cannot release a texture that was never provided by this ' +\n                'texture manager');\n        }\n        texList.splice(texIndex, 1);\n        this.log();\n    };\n    TextureManager.prototype.log = function () {\n        if (!this.logEnabled) {\n            return;\n        }\n        var total = this.numFreeTextures + this.numUsedTextures;\n        console.log('Free/Used', this.numFreeTextures + \" / \" + this.numUsedTextures, \"(\" + total + \")\");\n        var freeRatio = this._numBytesFree / this._numBytesAllocated;\n        console.log(\"Bytes allocated: \" + this._numBytesAllocated);\n        console.log(\"Bytes unused: \" + this._numBytesFree + \" (\" + Math.round(100 * freeRatio) + \"%)\");\n    };\n    Object.defineProperty(TextureManager.prototype, \"numBytesAllocated\", {\n        get: function () {\n            return this._numBytesAllocated;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TextureManager.prototype, \"numBytesFree\", {\n        get: function () {\n            return this._numBytesFree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TextureManager.prototype.getNumUsedTextures = function () {\n        return this.numUsedTextures;\n    };\n    TextureManager.prototype.getNumFreeTextures = function () {\n        return this.numFreeTextures;\n    };\n    TextureManager.prototype.dispose = function () {\n        var _this = this;\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        for (var texShape in this.freeTextures) {\n            this.freeTextures[texShape].forEach(function (tex) {\n                _this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        for (var texShape in this.usedTextures) {\n            this.usedTextures[texShape].forEach(function (tex) {\n                _this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        this.freeTextures = null;\n        this.usedTextures = null;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0;\n    };\n    return TextureManager;\n}());\nfunction numBytesForInternalFormat(gl, internalFormat) {\n    // tslint:disable-next-line:no-any\n    var glany = gl;\n    if (internalFormat === glany.R32F) {\n        return 4;\n    }\n    else if (internalFormat === glany.R16F) {\n        return 2;\n    }\n    else if (internalFormat === glany.RGBA32F) {\n        return 16;\n    }\n    else if (internalFormat === gl.RGBA) {\n        return 16;\n    }\n    else if (internalFormat === glany.RGBA16F) {\n        return 8;\n    }\n    throw new Error(\"Unknown internal format \" + internalFormat);\n}\nfunction computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n    // It is not possible to infer packed status from the texture type because\n    // depending on the textureConfig, different  texture types may resolve to the\n    // same internal format (e.g. in WebGL1, the internal format for\n    // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n    // explicitly.\n    var internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n    var numElements;\n    if (isPacked) {\n        var _a = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]), packedWidth = _a[0], packedHeight = _a[1];\n        numElements = packedWidth * packedHeight;\n    }\n    else {\n        var _b = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]), width = _b[0], height = _b[1];\n        numElements = width * height;\n    }\n    var bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n    return numElements * bytesPerElement;\n}\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n    switch (physicalTexType) {\n        case PhysicalTextureType.PACKED_2X2_FLOAT32:\n            return getInternalFormatForPackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_2X2_FLOAT16:\n            return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT32:\n            return getInternalFormatForFloat32MatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT16:\n            return getInternalFormatForFloat16MatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n            return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n        default:\n            throw new Error(\"Unknown physical texture type \" + physicalTexType);\n    }\n}\nfunction getPhysicalTextureForRendering(isPacked) {\n    if (tf.env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n        if (isPacked) {\n            return PhysicalTextureType.PACKED_2X2_FLOAT32;\n        }\n        return PhysicalTextureType.UNPACKED_FLOAT32;\n    }\n    if (isPacked) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT16;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT16;\n}\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n    if (logicalTexType === TextureUsage.UPLOAD) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n        return getPhysicalTextureForRendering(isPacked);\n    }\n    else if (logicalTexType === TextureUsage.DOWNLOAD ||\n        logicalTexType === TextureUsage.PIXELS) {\n        return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n    }\n    throw new Error(\"Unknown logical texture type \" + logicalTexType);\n}\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n    return shapeRowsCol[0] + \"_\" + shapeRowsCol[1] + \"_\" + physicalTexType + \"_\" + isPacked;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar UnaryOpProgram = /** @class */ (function () {\n    function UnaryOpProgram(aShape, opSnippet) {\n        this.variableNames = ['A'];\n        this.outputShape = aShape;\n        this.userCode = \"\\n      float unaryOperation(float x) {\\n        \" + opSnippet + \"\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        float y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n    }\n    return UnaryOpProgram;\n}());\nvar CHECK_NAN_SNIPPET = \"if (isnan(x)) return x;\";\nvar LINEAR = \"return x;\";\nvar ABS = \"return abs(x);\";\nvar ELU = \"return (x >= 0.0) ? x : (exp(x) - 1.0);\";\nvar RELU = CHECK_NAN_SNIPPET + \"\\n  return (x < 0.0) ? 0.0 : x;\\n\";\nvar RELU6 = CHECK_NAN_SNIPPET + \"\\n  return (x < 0.0) ? 0.0 : min(6.0, x);\\n\";\nvar CLONE = 'return x;';\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LINEAR$1 = \"return x;\";\nvar ELU$1 = \"\\n  vec4 result;\\n\\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\\n\\n  return result;\\n\";\nvar RELU$1 = \"\\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\\n  bvec4 isNaN = isnan(x);\\n\\n  result.r = isNaN.r ? x.r : result.r;\\n  result.g = isNaN.g ? x.g : result.g;\\n  result.b = isNaN.b ? x.b : result.b;\\n  result.a = isNaN.a ? x.a : result.a;\\n\\n  return result;\\n\";\nvar RELU6$1 = \"\\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\\n  bvec4 isNaN = isnan(x);\\n\\n  result.r = isNaN.r ? x.r : result.r;\\n  result.g = isNaN.g ? x.g : result.g;\\n  result.b = isNaN.b ? x.b : result.b;\\n  result.a = isNaN.a ? x.a : result.a;\\n\\n  return result;\\n\";\nvar UnaryOpPackedProgram = /** @class */ (function () {\n    function UnaryOpPackedProgram(aShape, opSnippet) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = aShape;\n        this.userCode = \"\\n      vec4 unaryOperation(vec4 x) {\\n        \" + opSnippet + \"\\n      }\\n\\n      void main() {\\n        vec4 x = getAAtOutCoords();\\n        vec4 y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n    }\n    return UnaryOpPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar UnpackProgram = /** @class */ (function () {\n    function UnpackProgram(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = false;\n        this.outputShape = outputShape;\n        var rank = outputShape.length;\n        var channels = getChannels('rc', rank);\n        var dtype = getCoordsDataType(rank);\n        var sourceCoords = getSourceCoords(rank, channels);\n        var innerDims = channels.slice(-2);\n        var coords = rank <= 1 ? 'rc' : \"vec2(\" + innerDims.join(',') + \")\";\n        this.userCode = \"\\n      void main() {\\n        \" + dtype + \" rc = getOutputCoords();\\n        vec4 packedInput = getA(\" + sourceCoords + \");\\n\\n        setOutput(getChannel(packedInput, \" + coords + \"));\\n      }\\n    \";\n    }\n    return UnpackProgram;\n}());\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar whereImpl = tf.kernel_impls.whereImpl;\nvar EPSILON_FLOAT32 = 1e-7;\nvar EPSILON_FLOAT16 = 1e-4;\nvar binaryCaches = {};\nfunction getBinaryCache(webGLVersion) {\n    if (webGLVersion in binaryCaches) {\n        return binaryCaches[webGLVersion];\n    }\n    binaryCaches[webGLVersion] = {};\n    return binaryCaches[webGLVersion];\n}\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nvar CPU_HANDOFF_SIZE_THRESHOLD = 128;\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nvar BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning() {\n    if (tf.env().global.screen == null) {\n        return 1024; // 1 GB.\n    }\n    return (tf.env().global.screen.height * tf.env().global.screen.width *\n        window.devicePixelRatio) *\n        BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\nvar MathBackendWebGL = /** @class */ (function (_super) {\n    __extends(MathBackendWebGL, _super);\n    function MathBackendWebGL(gpgpu) {\n        var _this = _super.call(this) || this;\n        // Maps data ids that have a pending read operation, to list of subscribers.\n        _this.pendingRead = new WeakMap();\n        // List of data ids that are scheduled for disposal, but are waiting on a\n        // pending read operation.\n        _this.pendingDisposal = new WeakSet();\n        // Used to count the number of 'shallow' sliced tensors that point to the\n        // same data id.\n        _this.dataRefCount = new WeakMap();\n        _this.numBytesInGPU = 0;\n        // Accumulated time spent (including blocking) in uploading data to webgl.\n        _this.uploadWaitMs = 0;\n        // Accumulated time spent (including blocking in downloading data from webgl.\n        _this.downloadWaitMs = 0;\n        _this.warnedAboutMemory = false;\n        _this.warnedAboutCPUBackend = false;\n        _this.pendingDeletes = 0;\n        _this.disposed = false;\n        if (!tf.env().getBool('HAS_WEBGL')) {\n            throw new Error('WebGL is not supported on this device');\n        }\n        if (gpgpu == null) {\n            var gl = getWebGLContext(tf.env().getNumber('WEBGL_VERSION'));\n            _this.binaryCache = getBinaryCache(tf.env().getNumber('WEBGL_VERSION'));\n            _this.gpgpu = new GPGPUContext(gl);\n            _this.canvas = gl.canvas;\n            _this.gpgpuCreatedLocally = true;\n        }\n        else {\n            _this.gpgpu = gpgpu;\n            _this.binaryCache = {};\n            _this.gpgpuCreatedLocally = false;\n            _this.canvas = gpgpu.gl.canvas;\n        }\n        _this.textureManager = new TextureManager(_this.gpgpu);\n        _this.numMBBeforeWarning = numMBBeforeWarning();\n        _this.texData = new tf.DataStorage(_this, tf.engine());\n        return _this;\n    }\n    MathBackendWebGL.prototype.numDataIds = function () {\n        return this.texData.numDataIds() +\n            (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) -\n            this.pendingDeletes;\n    };\n    MathBackendWebGL.prototype.write = function (values, shape, dtype) {\n        if (tf.env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') ||\n            tf.env().getBool('DEBUG')) {\n            this.checkNumericalProblems(values);\n        }\n        if (dtype === 'complex64' && values != null) {\n            throw new Error(\"Cannot write to a complex64 dtype. \" +\n                \"Please use tf.complex(real, imag).\");\n        }\n        var dataId = {};\n        this.texData.set(dataId, {\n            shape: shape,\n            dtype: dtype,\n            values: values,\n            usage: TextureUsage.UPLOAD,\n            refCount: 1,\n            complexParentRefCount: 0\n        });\n        return dataId;\n    };\n    /** Increase refCount of a `TextureData`. */\n    MathBackendWebGL.prototype.incRef = function (dataId) {\n        var texData = this.texData.get(dataId);\n        texData.refCount++;\n    };\n    /** Decrease refCount of a `TextureData`. */\n    MathBackendWebGL.prototype.decRef = function (dataId) {\n        if (this.texData.has(dataId)) {\n            var texData = this.texData.get(dataId);\n            texData.refCount--;\n        }\n    };\n    /**\n     * Decrease refCount of a `TextureData` if it is a component of complex\n     * tensor.\n     */\n    MathBackendWebGL.prototype.decComplexRef = function (dataId) {\n        if (this.texData.has(dataId)) {\n            var texData = this.texData.get(dataId);\n            if (texData.complexParentRefCount > 0) {\n                texData.refCount--;\n            }\n        }\n    };\n    MathBackendWebGL.prototype.move = function (dataId, values, shape, dtype) {\n        if (tf.env().getBool('DEBUG')) {\n            this.checkNumericalProblems(values);\n        }\n        if (dtype === 'complex64') {\n            throw new Error(\"Cannot write to a complex64 dtype. \" +\n                \"Please use tf.complex(real, imag).\");\n        }\n        this.texData.set(dataId, {\n            shape: shape,\n            dtype: dtype,\n            values: values,\n            usage: TextureUsage.UPLOAD,\n            refCount: 1,\n            complexParentRefCount: 0\n        });\n    };\n    MathBackendWebGL.prototype.disposeIntermediateTensorInfo = function (tensorInfo) {\n        var dataId = tensorInfo.dataId;\n        if (this.texData.has(dataId)) {\n            var textureData = this.texData.get(dataId);\n            textureData.refCount--;\n            if (textureData.refCount < 1) {\n                this.disposeData(dataId);\n            }\n        }\n    };\n    MathBackendWebGL.prototype.readSync = function (dataId) {\n        var texData = this.texData.get(dataId);\n        var values = texData.values, dtype = texData.dtype, complexTensorInfos = texData.complexTensorInfos, slice = texData.slice, shape = texData.shape, isPacked = texData.isPacked;\n        // The presence of `slice` indicates this tensor is a shallow slice of a\n        // different tensor, and is using that original tensor's texture. Run\n        // `clone` in order to copy that texture and read from it.\n        if (slice != null) {\n            var program = void 0;\n            if (isPacked) {\n                program = new UnaryOpPackedProgram(shape, CLONE);\n            }\n            else {\n                program = new UnaryOpProgram(shape, CLONE);\n            }\n            var res = this.runWebGLProgram(program, [{ dataId: dataId, shape: shape, dtype: dtype }], dtype);\n            var data = this.readSync(res.dataId);\n            this.disposeIntermediateTensorInfo(res);\n            return data;\n        }\n        if (values != null) {\n            return this.convertAndCacheOnCPU(dataId);\n        }\n        if (dtype === 'string') {\n            return values;\n        }\n        var shouldTimeProgram = this.activeTimers != null;\n        var start;\n        if (shouldTimeProgram) {\n            start = tf.util.now();\n        }\n        var result;\n        if (dtype === 'complex64') {\n            var realValues = this.readSync(complexTensorInfos.real.dataId);\n            var imagValues = this.readSync(complexTensorInfos.imag.dataId);\n            result = tf.backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        else {\n            result = this.getValuesFromTexture(dataId);\n        }\n        if (shouldTimeProgram) {\n            this.downloadWaitMs += tf.util.now() - start;\n        }\n        return this.convertAndCacheOnCPU(dataId, result);\n    };\n    MathBackendWebGL.prototype.read = function (dataId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var subscribers_1, texData, values, shape, slice, dtype, complexTensorInfos, isPacked, program, res, data, buffer, tmpDownloadTarget, tmpData, vals, ps, realValues, imagValues, size, dTypeVals, subscribers;\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (this.pendingRead.has(dataId)) {\n                            subscribers_1 = this.pendingRead.get(dataId);\n                            return [2 /*return*/, new Promise(function (resolve) { return subscribers_1.push(resolve); })];\n                        }\n                        texData = this.texData.get(dataId);\n                        values = texData.values, shape = texData.shape, slice = texData.slice, dtype = texData.dtype, complexTensorInfos = texData.complexTensorInfos, isPacked = texData.isPacked;\n                        // The presence of `slice` indicates this tensor is a shallow slice of a\n                        // different tensor, and is using that original tensor's texture. Run\n                        // `clone` in order to copy that texture and read from it.\n                        if (slice != null) {\n                            program = void 0;\n                            if (isPacked) {\n                                program = new UnaryOpPackedProgram(shape, CLONE);\n                            }\n                            else {\n                                program = new UnaryOpProgram(shape, CLONE);\n                            }\n                            res = this.runWebGLProgram(program, [{ dataId: dataId, shape: shape, dtype: dtype }], dtype);\n                            data = this.read(res.dataId);\n                            this.disposeIntermediateTensorInfo(res);\n                            return [2 /*return*/, data];\n                        }\n                        if (values != null) {\n                            return [2 /*return*/, this.convertAndCacheOnCPU(dataId)];\n                        }\n                        if (!tf.env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&\n                            tf.env().getNumber('WEBGL_VERSION') === 2) {\n                            throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and \" +\n                                \"WEBGL_VERSION=2 not yet supported.\");\n                        }\n                        buffer = null;\n                        if (dtype !== 'complex64' && tf.env().get('WEBGL_BUFFER_SUPPORTED')) {\n                            // Possibly copy the texture into a buffer before inserting a fence.\n                            tmpDownloadTarget = this.decode(dataId);\n                            tmpData = this.texData.get(tmpDownloadTarget.dataId);\n                            buffer = (_a = this.gpgpu).createBufferFromTexture.apply(_a, [tmpData.texture].concat(getDenseTexShape(shape)));\n                        }\n                        this.pendingRead.set(dataId, []);\n                        if (!(dtype !== 'complex64')) return [3 /*break*/, 2];\n                        // Create a fence and wait for it to resolve.\n                        return [4 /*yield*/, this.gpgpu.createAndWaitForFence()];\n                    case 1:\n                        // Create a fence and wait for it to resolve.\n                        _b.sent();\n                        _b.label = 2;\n                    case 2:\n                        if (!(dtype === 'complex64')) return [3 /*break*/, 4];\n                        return [4 /*yield*/, Promise.all([\n                                this.read(complexTensorInfos.real.dataId),\n                                this.read(complexTensorInfos.imag.dataId)\n                            ])];\n                    case 3:\n                        ps = _b.sent();\n                        realValues = ps[0];\n                        imagValues = ps[1];\n                        vals = tf.backend_util.mergeRealAndImagArrays(realValues, imagValues);\n                        return [3 /*break*/, 5];\n                    case 4:\n                        if (buffer == null) {\n                            vals = this.getValuesFromTexture(dataId);\n                        }\n                        else {\n                            size = tf.util.sizeFromShape(shape);\n                            vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n                        }\n                        _b.label = 5;\n                    case 5:\n                        if (tmpDownloadTarget != null) {\n                            this.disposeIntermediateTensorInfo(tmpDownloadTarget);\n                        }\n                        dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n                        subscribers = this.pendingRead.get(dataId);\n                        this.pendingRead.delete(dataId);\n                        // Notify all pending reads.\n                        subscribers.forEach(function (resolve) { return resolve(dTypeVals); });\n                        if (this.pendingDisposal.has(dataId)) {\n                            this.pendingDisposal.delete(dataId);\n                            this.disposeData(dataId);\n                            this.pendingDeletes--;\n                        }\n                        return [2 /*return*/, dTypeVals];\n                }\n            });\n        });\n    };\n    MathBackendWebGL.prototype.bufferSync = function (t) {\n        var data = this.readSync(t.dataId);\n        var decodedData = data;\n        if (t.dtype === 'string') {\n            try {\n                // Decode the bytes into string.\n                decodedData = data.map(function (d) { return tf.util.decodeString(d); });\n            }\n            catch (_a) {\n                throw new Error('Failed to decode encoded string bytes into utf-8');\n            }\n        }\n        return tf.buffer(t.shape, t.dtype, decodedData);\n    };\n    MathBackendWebGL.prototype.checkNumericalProblems = function (values) {\n        if (values == null) {\n            return;\n        }\n        for (var i = 0; i < values.length; i++) {\n            var num = values[i];\n            if (!canBeRepresented(num)) {\n                if (tf.env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n                    throw Error(\"The value \" + num + \" cannot be represented with your \" +\n                        \"current settings. Consider enabling float32 rendering: \" +\n                        \"'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'\");\n                }\n                throw Error(\"The value \" + num + \" cannot be represented on this device.\");\n            }\n        }\n    };\n    MathBackendWebGL.prototype.getValuesFromTexture = function (dataId) {\n        var _a;\n        var _b = this.texData.get(dataId), shape = _b.shape, dtype = _b.dtype, isPacked = _b.isPacked;\n        var size = tf.util.sizeFromShape(shape);\n        if (tf.env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n            var tmpTarget = this.decode(dataId);\n            var tmpData_1 = this.texData.get(tmpTarget.dataId);\n            var vals_1 = (_a = this.gpgpu).downloadMatrixFromPackedTexture.apply(_a, [tmpData_1.texture].concat(getDenseTexShape(shape))).subarray(0, size);\n            this.disposeIntermediateTensorInfo(tmpTarget);\n            return vals_1;\n        }\n        var shouldUsePackedProgram = tf.env().getBool('WEBGL_PACK') && isPacked === true;\n        var outputShape = shouldUsePackedProgram ? getShapeAs3D(shape) : shape;\n        var program = shouldUsePackedProgram ?\n            new EncodeFloatPackedProgram(outputShape) :\n            new EncodeFloatProgram(outputShape);\n        var output = this.runWebGLProgram(program, [{ shape: outputShape, dtype: dtype, dataId: dataId }], 'float32');\n        var tmpData = this.texData.get(output.dataId);\n        var vals = this.gpgpu\n            .downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture, tmpData.texShape[0], tmpData.texShape[1])\n            .subarray(0, size);\n        this.disposeIntermediateTensorInfo(output);\n        return vals;\n    };\n    MathBackendWebGL.prototype.time = function (f) {\n        return __awaiter(this, void 0, void 0, function () {\n            var oldActiveTimers, newActiveTimers, outerMostTime, flattenedActiveTimerQueries, flattenedActiveTimerNames, res, kernelMs_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        oldActiveTimers = this.activeTimers;\n                        newActiveTimers = [];\n                        outerMostTime = false;\n                        if (this.programTimersStack == null) {\n                            this.programTimersStack = newActiveTimers;\n                            outerMostTime = true;\n                        }\n                        else {\n                            this.activeTimers.push(newActiveTimers);\n                        }\n                        this.activeTimers = newActiveTimers;\n                        f();\n                        flattenedActiveTimerQueries = tf.util.flatten(this.activeTimers.map(function (d) { return d.query; }))\n                            .filter(function (d) { return d != null; });\n                        flattenedActiveTimerNames = tf.util.flatten(this.activeTimers.map(function (d) { return d.name; }))\n                            .filter(function (d) { return d != null; });\n                        this.activeTimers = oldActiveTimers;\n                        if (outerMostTime) {\n                            this.programTimersStack = null;\n                        }\n                        res = {\n                            uploadWaitMs: this.uploadWaitMs,\n                            downloadWaitMs: this.downloadWaitMs,\n                            kernelMs: null,\n                            wallMs: null // will be filled by the engine\n                        };\n                        if (!(tf.env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, Promise.all(flattenedActiveTimerQueries)];\n                    case 1:\n                        kernelMs_1 = _a.sent();\n                        res['kernelMs'] = tf.util.sum(kernelMs_1);\n                        res['getExtraProfileInfo'] = function () {\n                            return kernelMs_1.map(function (d, i) { return ({ name: flattenedActiveTimerNames[i], ms: d }); })\n                                .map(function (d) { return d.name + \": \" + d.ms; })\n                                .join(', ');\n                        };\n                        return [3 /*break*/, 3];\n                    case 2:\n                        res['kernelMs'] = {\n                            error: 'WebGL query timers are not supported in this environment.'\n                        };\n                        _a.label = 3;\n                    case 3:\n                        this.uploadWaitMs = 0;\n                        this.downloadWaitMs = 0;\n                        return [2 /*return*/, res];\n                }\n            });\n        });\n    };\n    MathBackendWebGL.prototype.memory = function () {\n        return {\n            unreliable: false,\n            numBytesInGPU: this.numBytesInGPU,\n            numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n            numBytesInGPUFree: this.textureManager.numBytesFree\n        };\n    };\n    MathBackendWebGL.prototype.startTimer = function () {\n        if (tf.env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            return this.gpgpu.beginQuery();\n        }\n        return { startMs: tf.util.now(), endMs: null };\n    };\n    MathBackendWebGL.prototype.endTimer = function (query) {\n        if (tf.env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            this.gpgpu.endQuery();\n            return query;\n        }\n        query.endMs = tf.util.now();\n        return query;\n    };\n    MathBackendWebGL.prototype.getQueryTime = function (query) {\n        return __awaiter(this, void 0, void 0, function () {\n            var timerQuery;\n            return __generator(this, function (_a) {\n                if (tf.env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n                    return [2 /*return*/, this.gpgpu.waitForQueryAndGetTime(query)];\n                }\n                timerQuery = query;\n                return [2 /*return*/, timerQuery.endMs - timerQuery.startMs];\n            });\n        });\n    };\n    MathBackendWebGL.prototype.disposeData = function (dataId) {\n        if (this.pendingDisposal.has(dataId)) {\n            return;\n        }\n        if (this.pendingRead.has(dataId)) {\n            this.pendingDisposal.add(dataId);\n            this.pendingDeletes++;\n            return;\n        }\n        // No-op if already disposed.\n        if (!this.texData.has(dataId)) {\n            return;\n        }\n        // Trying to dispose a textureData that has a 'kept' refCount, e.g. trying\n        // to dispose a tensor whose data bucket is shared with a complex tensor. In\n        // this case we are removing a reference to the textureData, but we\n        // shouldn't actually dispose the texture.\n        if (this.texData.get(dataId).complexParentRefCount > 0) {\n            this.texData.get(dataId).refCount--;\n            return;\n        }\n        this.releaseGPUData(dataId);\n        var complexTensorInfos = this.texData.get(dataId).complexTensorInfos;\n        if (complexTensorInfos != null) {\n            this.texData.get(complexTensorInfos.real.dataId).complexParentRefCount--;\n            this.disposeIntermediateTensorInfo(complexTensorInfos.real);\n            this.texData.get(complexTensorInfos.imag.dataId).complexParentRefCount--;\n            this.disposeIntermediateTensorInfo(complexTensorInfos.imag);\n        }\n        this.texData.delete(dataId);\n    };\n    MathBackendWebGL.prototype.releaseGPUData = function (dataId) {\n        var _a = this.texData.get(dataId), texture = _a.texture, dtype = _a.dtype, texShape = _a.texShape, usage = _a.usage, isPacked = _a.isPacked, slice = _a.slice;\n        var key = slice && slice.origDataId || dataId;\n        var refCount = this.dataRefCount.get(key);\n        if (refCount > 1) {\n            this.dataRefCount.set(key, refCount - 1);\n        }\n        else {\n            this.dataRefCount.delete(key);\n            if (texture != null) {\n                this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n                this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n            }\n        }\n        var texData = this.texData.get(dataId);\n        texData.texture = null;\n        texData.texShape = null;\n        texData.isPacked = false;\n        texData.slice = null;\n    };\n    MathBackendWebGL.prototype.getTexture = function (dataId) {\n        this.uploadToGPU(dataId);\n        return this.texData.get(dataId).texture;\n    };\n    /**\n     * Returns internal information for the specific data bucket. Used in unit\n     * tests.\n     */\n    MathBackendWebGL.prototype.getDataInfo = function (dataId) {\n        return this.texData.get(dataId);\n    };\n    MathBackendWebGL.prototype.getCPUBackend = function () {\n        if (!tf.env().getBool('WEBGL_CPU_FORWARD')) {\n            return null;\n        }\n        if (this.cpuBackend == null) {\n            this.cpuBackend = tf.engine().findBackend('cpu');\n        }\n        return this.cpuBackend;\n    };\n    /*\n    Tests whether all the inputs to an op are small and on the CPU. This heuristic\n    determines when it would be faster to execute a kernel on the CPU. WebGL\n    kernels opt into running this check and forwarding when appropriate.\n    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n    sustainable strategy for optimizing backend execution of ops.\n     */\n    MathBackendWebGL.prototype.shouldExecuteOnCPU = function (inputs, sizeThreshold) {\n        var _this = this;\n        if (sizeThreshold === void 0) { sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD; }\n        var cpuBackend = this.getCPUBackend();\n        if (!tf.env().getBool('IS_TEST') && !this.warnedAboutCPUBackend &&\n            cpuBackend == null) {\n            console.warn('Your application contains ops that are small enough to be ' +\n                'executed on the CPU backend, however the CPU backend cannot ' +\n                'be found. Consider importing the CPU backend ' +\n                '(@tensorflow/tfjs-backend-cpu) for better performance.');\n            this.warnedAboutCPUBackend = true;\n        }\n        return cpuBackend != null &&\n            inputs.every(function (input) { return _this.texData.get(input.dataId).texture == null &&\n                tf.util.sizeFromShape(input.shape) < sizeThreshold; });\n    };\n    MathBackendWebGL.prototype.getGPGPUContext = function () {\n        return this.gpgpu;\n    };\n    MathBackendWebGL.prototype.where = function (condition) {\n        tf.backend_util.warn('tf.where() in webgl locks the UI thread. ' +\n            'Call tf.whereAsync() instead');\n        var condVals = condition.dataSync();\n        return whereImpl(condition.shape, condVals);\n    };\n    MathBackendWebGL.prototype.packedUnaryOp = function (x, op, dtype) {\n        var program = new UnaryOpPackedProgram(x.shape, op);\n        return this.compileAndRun(program, [x], dtype);\n    };\n    // TODO(msoulanille) remove this once the backend has been modularized\n    // a copy is needed here to break a circular dependency.\n    // Also remove the op from unary_op.\n    MathBackendWebGL.prototype.abs = function (x) {\n        // TODO: handle cases when x is complex.\n        if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n            var outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);\n            return this.makeOutput(x.shape, x.dtype, outValues);\n        }\n        if (tf.env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n            return this.packedUnaryOp(x, ABS, x.dtype);\n        }\n        var program = new UnaryOpProgram(x.shape, ABS);\n        return this.compileAndRun(program, [x]);\n    };\n    MathBackendWebGL.prototype.makeTensorInfo = function (shape, dtype, values) {\n        var dataId;\n        if (dtype === 'string' && values != null && values.length > 0 &&\n            tf.util.isString(values[0])) {\n            var encodedValues = values.map(function (d) { return tf.util.encodeString(d); });\n            dataId = this.write(encodedValues, shape, dtype);\n        }\n        else {\n            dataId = this.write(values, shape, dtype);\n        }\n        this.texData.get(dataId).usage = null;\n        return { dataId: dataId, shape: shape, dtype: dtype };\n    };\n    MathBackendWebGL.prototype.makeOutput = function (shape, dtype, values) {\n        var dataId = this.makeTensorInfo(shape, dtype, values).dataId;\n        return tf.engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    };\n    MathBackendWebGL.prototype.unpackTensor = function (input) {\n        var program = new UnpackProgram(input.shape);\n        return this.runWebGLProgram(program, [input], input.dtype);\n    };\n    MathBackendWebGL.prototype.packTensor = function (input) {\n        var program = new PackProgram(input.shape);\n        var preventEagerUnpackingOutput = true;\n        return this.runWebGLProgram(program, [input], input.dtype, null /* customSetup */, preventEagerUnpackingOutput);\n    };\n    MathBackendWebGL.prototype.packedReshape = function (input, afterShape) {\n        var input3DShape = [\n            getBatchDim(input.shape)\n        ].concat(getRowsCols(input.shape));\n        var input3D = {\n            dtype: input.dtype,\n            shape: input3DShape,\n            dataId: input.dataId\n        };\n        var afterShapeAs3D = [\n            getBatchDim(afterShape)\n        ].concat(getRowsCols(afterShape));\n        var program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n        var preventEagerUnpackingOfOutput = true;\n        var output = this.runWebGLProgram(program, [input3D], input.dtype, null /* customSetup */, preventEagerUnpackingOfOutput);\n        return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };\n    };\n    MathBackendWebGL.prototype.decode = function (dataId) {\n        var texData = this.texData.get(dataId);\n        var isPacked = texData.isPacked, shape = texData.shape, dtype = texData.dtype;\n        var shapeAs3D = getShapeAs3D(shape);\n        var program;\n        if (isPacked) {\n            program = new DecodeMatrixPackedProgram(shapeAs3D);\n        }\n        else {\n            program = new DecodeMatrixProgram(shapeAs3D);\n        }\n        var preventEagerUnpackingOfOutput = true;\n        var out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype: dtype, dataId: dataId }], dtype, null /* customSetup */, preventEagerUnpackingOfOutput);\n        return { dtype: dtype, shape: shape, dataId: out.dataId };\n    };\n    MathBackendWebGL.prototype.runWebGLProgram = function (program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput) {\n        var _this = this;\n        if (preventEagerUnpackingOfOutput === void 0) { preventEagerUnpackingOfOutput = false; }\n        var output = this.makeTensorInfo(program.outputShape, outputDtype);\n        var outData = this.texData.get(output.dataId);\n        if (program.packedOutput) {\n            outData.isPacked = true;\n        }\n        if (program.outPackingScheme === PackingScheme.DENSE) {\n            var texelShape = getDenseTexShape(program.outputShape);\n            // For a densely packed output, we explicitly set texShape\n            // so it doesn't get assigned later according to our typical packing\n            // scheme wherein a single texel can only contain values from adjacent\n            // rows/cols.\n            outData.texShape = texelShape.map(function (d) { return d * 2; });\n        }\n        if (program.outTexUsage != null) {\n            outData.usage = program.outTexUsage;\n        }\n        if (tf.util.sizeFromShape(output.shape) === 0) {\n            // Short-circuit the computation since the result is empty (has 0 in its\n            // shape).\n            outData.values =\n                tf.util.getTypedArrayFromDType(output.dtype, 0);\n            return output;\n        }\n        var dataToDispose = [];\n        var inputsData = inputs.map(function (input) {\n            if (input.dtype === 'complex64') {\n                throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 \" +\n                    \"dtypes, please separate the program into real and imaginary \" +\n                    \"parts.\");\n            }\n            var texData = _this.texData.get(input.dataId);\n            if (texData.texture == null) {\n                if (!program.packedInputs &&\n                    tf.util.sizeFromShape(input.shape) <=\n                        tf.env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n                    // Upload small tensors that live on the CPU as uniforms, not as\n                    // textures. Do this only when the environment supports 32bit floats\n                    // due to problems when comparing 16bit floats with 32bit floats.\n                    // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n                    // possible for packed shaders to sample from uniforms.\n                    return {\n                        shape: input.shape,\n                        texData: null,\n                        isUniform: true,\n                        uniformValues: texData.values\n                    };\n                }\n                // This ensures that if a packed program's inputs have not yet been\n                // uploaded to the GPU, they get uploaded as packed right off the bat.\n                if (program.packedInputs) {\n                    texData.isPacked = true;\n                    texData.shape = input.shape;\n                }\n            }\n            else if (!!texData.isPacked !== !!program.packedInputs) {\n                input = texData.isPacked ? _this.unpackTensor(input) :\n                    _this.packTensor(input);\n                dataToDispose.push(input);\n                texData = _this.texData.get(input.dataId);\n            }\n            else if (texData.isPacked &&\n                !isReshapeFree(texData.shape, input.shape)) {\n                // This is a special case where a texture exists for a tensor\n                // but the shapes are incompatible (due to packing constraints) because\n                // the tensor did not have a chance to go through the packed reshape\n                // shader. This only happens when we reshape the *same* tensor to form\n                // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n                // case will disappear once packed uploading is the default.\n                var savedInput = input;\n                var targetShape = input.shape;\n                input.shape = texData.shape;\n                input = _this.packedReshape(input, targetShape);\n                dataToDispose.push(input);\n                texData = _this.texData.get(input.dataId);\n                savedInput.shape = targetShape;\n            }\n            _this.uploadToGPU(input.dataId);\n            return { shape: input.shape, texData: texData, isUniform: false };\n        });\n        this.uploadToGPU(output.dataId);\n        var outputData = { shape: output.shape, texData: outData, isUniform: false };\n        var key = makeShaderKey(program, inputsData, outputData);\n        var binary = this.getAndSaveBinary(key, function () {\n            return compileProgram(_this.gpgpu, program, inputsData, outputData);\n        });\n        var shouldTimeProgram = this.activeTimers != null;\n        var query;\n        if (shouldTimeProgram) {\n            query = this.startTimer();\n        }\n        runProgram(this.gpgpu, binary, inputsData, outputData, customSetup);\n        dataToDispose.forEach(function (info) { return _this.disposeIntermediateTensorInfo(info); });\n        if (shouldTimeProgram) {\n            query = this.endTimer(query);\n            this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });\n        }\n        if (!tf.env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&\n            preventEagerUnpackingOfOutput === false) {\n            var unpacked = this.unpackTensor(output);\n            this.disposeIntermediateTensorInfo(output);\n            return unpacked;\n        }\n        return output;\n    };\n    MathBackendWebGL.prototype.compileAndRun = function (program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput) {\n        if (preventEagerUnpackingOfOutput === void 0) { preventEagerUnpackingOfOutput = false; }\n        outputDtype = outputDtype || inputs[0].dtype;\n        var outInfo = this.runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput);\n        return tf.engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);\n    };\n    MathBackendWebGL.prototype.getAndSaveBinary = function (key, getBinary) {\n        if (!(key in this.binaryCache)) {\n            this.binaryCache[key] = getBinary();\n        }\n        return this.binaryCache[key];\n    };\n    MathBackendWebGL.prototype.getTextureManager = function () {\n        return this.textureManager;\n    };\n    MathBackendWebGL.prototype.dispose = function () {\n        var _this = this;\n        if (this.disposed) {\n            return;\n        }\n        // Avoid disposing the compiled webgl programs during unit testing because\n        // it slows down test execution.\n        if (!tf.env().getBool('IS_TEST')) {\n            var allKeys = Object.keys(this.binaryCache);\n            allKeys.forEach(function (key) {\n                _this.gpgpu.deleteProgram(_this.binaryCache[key].webGLProgram);\n                delete _this.binaryCache[key];\n            });\n        }\n        this.textureManager.dispose();\n        if (this.canvas != null &&\n            (typeof (HTMLCanvasElement) !== 'undefined' &&\n                this.canvas instanceof HTMLCanvasElement)) {\n            this.canvas.remove();\n        }\n        else {\n            this.canvas = null;\n        }\n        if (this.gpgpuCreatedLocally) {\n            this.gpgpu.program = null;\n            this.gpgpu.dispose();\n        }\n        this.disposed = true;\n    };\n    MathBackendWebGL.prototype.floatPrecision = function () {\n        var _this = this;\n        if (this.floatPrecisionValue == null) {\n            this.floatPrecisionValue = tf.tidy(function () {\n                if (!tf.env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n                    // Momentarily switching DEBUG flag to false so we don't throw an\n                    // error trying to upload a small value.\n                    var debugFlag = tf.env().getBool('DEBUG');\n                    tf.env().set('DEBUG', false);\n                    var underflowCheckValue = _this.abs(tf.scalar(1e-8)).dataSync()[0];\n                    tf.env().set('DEBUG', debugFlag);\n                    if (underflowCheckValue > 0) {\n                        return 32;\n                    }\n                }\n                return 16;\n            });\n        }\n        return this.floatPrecisionValue;\n    };\n    /** Returns the smallest representable number.  */\n    MathBackendWebGL.prototype.epsilon = function () {\n        return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    };\n    MathBackendWebGL.prototype.uploadToGPU = function (dataId) {\n        var _a;\n        var texData = this.texData.get(dataId);\n        var shape = texData.shape, dtype = texData.dtype, values = texData.values, texture = texData.texture, usage = texData.usage, isPacked = texData.isPacked;\n        if (texture != null) {\n            // Array is already on GPU. No-op.\n            return;\n        }\n        var shouldTimeProgram = this.activeTimers != null;\n        var start;\n        if (shouldTimeProgram) {\n            start = tf.util.now();\n        }\n        var texShape = texData.texShape;\n        if (texShape == null) {\n            texShape = getTextureShapeFromLogicalShape(shape, isPacked);\n            texData.texShape = texShape;\n        }\n        if (values != null) {\n            var shapeAs3D = getShapeAs3D(shape);\n            var program = void 0;\n            var width = texShape[1], height = texShape[0];\n            var isByteArray = values instanceof Uint8Array;\n            if (isPacked) {\n                _a = getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]), width = _a[0], height = _a[1];\n                program = new EncodeMatrixPackedProgram(shapeAs3D, [height, width], isByteArray);\n            }\n            else {\n                program =\n                    new EncodeMatrixProgram(shapeAs3D, [height, width], isByteArray);\n            }\n            var tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);\n            if (isByteArray) {\n                this.texData.get(tempDenseInputHandle.dataId).usage =\n                    TextureUsage.PIXELS;\n            }\n            else {\n                this.texData.get(tempDenseInputHandle.dataId).usage =\n                    TextureUsage.UPLOAD;\n            }\n            this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);\n            // We want the output to remain packed regardless of the value of\n            // WEBGL_PACK.\n            var preventEagerUnpacking = true;\n            var encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, null, preventEagerUnpacking);\n            // Have the original texture assume the identity of the encoded output.\n            var outputTexData = this.texData.get(encodedOutputTarget.dataId);\n            texData.texture = outputTexData.texture;\n            texData.texShape = outputTexData.texShape;\n            texData.isPacked = outputTexData.isPacked;\n            texData.usage = outputTexData.usage;\n            this.disposeIntermediateTensorInfo(tempDenseInputHandle);\n            this.texData.delete(encodedOutputTarget.dataId);\n            // Once uploaded, don't store the values on cpu.\n            texData.values = null;\n            if (shouldTimeProgram) {\n                this.uploadWaitMs += tf.util.now() - start;\n            }\n        }\n        else {\n            var newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n            texData.texture = newTexture;\n        }\n    };\n    MathBackendWebGL.prototype.convertAndCacheOnCPU = function (dataId, float32Values) {\n        var texData = this.texData.get(dataId);\n        var dtype = texData.dtype;\n        this.releaseGPUData(dataId);\n        if (float32Values != null) {\n            texData.values = float32ToTypedArray(float32Values, dtype);\n        }\n        return texData.values;\n    };\n    MathBackendWebGL.prototype.acquireTexture = function (texShape, texType, dtype, isPacked) {\n        this.numBytesInGPU += this.computeBytes(texShape, dtype);\n        if (!this.warnedAboutMemory &&\n            this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n            var mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n            this.warnedAboutMemory = true;\n            console.warn(\"High memory usage in GPU: \" + mb + \" MB, \" +\n                \"most likely due to a memory leak\");\n        }\n        return this.textureManager.acquireTexture(texShape, texType, isPacked);\n    };\n    MathBackendWebGL.prototype.computeBytes = function (shape, dtype) {\n        return shape[0] * shape[1] * tf.util.bytesPerElement(dtype);\n    };\n    return MathBackendWebGL;\n}(tf.KernelBackend));\nfunction float32ToTypedArray(a, dtype) {\n    if (dtype === 'float32' || dtype === 'complex64') {\n        return a;\n    }\n    else if (dtype === 'int32' || dtype === 'bool') {\n        var result = (dtype === 'int32') ? new Int32Array(a.length) :\n            new Uint8Array(a.length);\n        for (var i = 0; i < result.length; ++i) {\n            result[i] = Math.round(a[i]);\n        }\n        return result;\n    }\n    else {\n        throw new Error(\"Unknown dtype \" + dtype);\n    }\n}\n\n/** @license See the LICENSE file. */\n// This code is auto-generated, do not modify this file!\nvar version = '2.8.6';\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Enforce use of half precision textures if available on the platform.\n *\n * @doc {heading: 'Environment', namespace: 'webgl'}\n */\nfunction forceHalfFloat() {\n    tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);\n}\n\n/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nif (tf.device_util.isBrowser()) {\n    tf.registerBackend('webgl', function () { return new MathBackendWebGL(); }, 2 /* priority */);\n}\nvar webgl = { forceHalfFloat: forceHalfFloat };\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar CHECK_NAN_SNIPPET$1 = \"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\";\nvar BinaryOpProgram = /** @class */ (function () {\n    function BinaryOpProgram(op, aShape, bShape) {\n        this.variableNames = ['A', 'B'];\n        this.outputShape = tf.backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        this.userCode = \"\\n      float binaryOperation(float a, float b) {\\n        \" + op + \"\\n      }\\n\\n      void main() {\\n        float a = getAAtOutCoords();\\n        float b = getBAtOutCoords();\\n        setOutput(binaryOperation(a, b));\\n      }\\n    \";\n    }\n    return BinaryOpProgram;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar CHECK_NAN_SNIPPET$2 = \"\\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\";\nvar BinaryOpPackedProgram = /** @class */ (function () {\n    function BinaryOpPackedProgram(op, aShape, bShape, checkOutOfBounds) {\n        if (checkOutOfBounds === void 0) { checkOutOfBounds = false; }\n        this.variableNames = ['A', 'B'];\n        this.supportsBroadcasting = true;\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = tf.backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        var rank = this.outputShape.length;\n        var checkOutOfBoundsString = '';\n        if (checkOutOfBounds) {\n            if (rank === 0 || tf.util.sizeFromShape(this.outputShape) === 1) {\n                checkOutOfBoundsString = \"\\n          result.y = 0.;\\n          result.z = 0.;\\n          result.w = 0.;\\n        \";\n            }\n            else {\n                var dtype = getCoordsDataType(rank);\n                checkOutOfBoundsString = \"\\n          \" + dtype + \" coords = getOutputCoords();\\n        \";\n                if (rank === 1) {\n                    checkOutOfBoundsString += \"\\n            result.y = (coords + 1) >= \" + this.outputShape[0] + \" ? 0. : result.y;\\n            result.z = 0.;\\n            result.w = 0.;\\n          \";\n                }\n                else {\n                    var channels = getChannels('coords', rank);\n                    checkOutOfBoundsString += \"\\n            bool nextRowOutOfBounds =\\n              (\" + channels[rank - 2] + \" + 1) >= \" + this.outputShape[rank - 2] + \";\\n            bool nextColOutOfBounds =\\n              (\" + channels[rank - 1] + \" + 1) >= \" + this.outputShape[rank - 1] + \";\\n            result.y = nextColOutOfBounds ? 0. : result.y;\\n            result.z = nextRowOutOfBounds ? 0. : result.z;\\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\\n          \";\n                }\n            }\n        }\n        this.userCode = \"\\n      vec4 binaryOperation(vec4 a, vec4 b) {\\n        \" + op + \"\\n      }\\n\\n      void main() {\\n        vec4 a = getAAtOutCoords();\\n        vec4 b = getBAtOutCoords();\\n\\n        vec4 result = binaryOperation(a, b);\\n        \" + checkOutOfBoundsString + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return BinaryOpPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction identity(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    backend.incRef(x.dataId);\n    return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };\n}\nvar identityConfig = {\n    kernelName: tf.Identity,\n    backendName: 'webgl',\n    kernelFunc: identity\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * In WebGL data is stored in GPU textures which can't be efficiently copied, so\n * complex tensors share data with their real and imaginary components. Complex\n * tensors increment the `complexParentRefCount` properties of the underlying\n * data buckets to prevent them from being disposed, as the engine's disposal\n * logic does not account for data sharing by complex tensors.\n *\n * When a complex tensor is disposed, it will explicitly decrease the\n * `complexParentRefCount` properties of its underlying components.\n */\nfunction complex(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var real = inputs.real, imag = inputs.imag;\n    var complexInfo = backend.makeTensorInfo(real.shape, 'complex64');\n    var complex = backend.texData.get(complexInfo.dataId);\n    var realTensorInfo = identity({ inputs: { x: real }, backend: backend });\n    var realData = backend.texData.get(realTensorInfo.dataId);\n    realData.complexParentRefCount++;\n    var imagTensorInfo = identity({ inputs: { x: imag }, backend: backend });\n    var imagData = backend.texData.get(imagTensorInfo.dataId);\n    imagData.complexParentRefCount++;\n    complex.complexTensorInfos = { real: realTensorInfo, imag: imagTensorInfo };\n    return complexInfo;\n}\nvar complexConfig = {\n    kernelName: tf.Complex,\n    backendName: 'webgl',\n    kernelFunc: complex\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LEAKYRELU = \"return (a < 0.) ? b * a : a;\";\nvar LEAKYRELU_PACKED = \"\\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\\n\";\nfunction leakyRelu(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var alpha = attrs.alpha;\n    var $alpha = backend.makeTensorInfo([], 'float32', tf.util.createScalarValue(alpha, 'float32'));\n    var program = tf.env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(LEAKYRELU_PACKED, x.shape, $alpha.shape) :\n        new BinaryOpProgram(LEAKYRELU, x.shape, $alpha.shape);\n    var result = backend.runWebGLProgram(program, [x, $alpha], x.dtype);\n    backend.disposeIntermediateTensorInfo($alpha);\n    return result;\n}\nvar leakyReluConfig = {\n    kernelName: tf.LeakyRelu,\n    backendName: 'webgl',\n    kernelFunc: leakyRelu\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar PRELU = \"return (a < 0.) ? b * a : a;\";\nvar PRELU_PACKED = \"\\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\\n\";\nfunction prelu(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x, alpha = inputs.alpha;\n    var program = tf.env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(PRELU_PACKED, x.shape, alpha.shape) :\n        new BinaryOpProgram(PRELU, x.shape, alpha.shape);\n    return backend.runWebGLProgram(program, [x, alpha], x.dtype);\n}\nvar preluConfig = {\n    kernelName: tf.Prelu,\n    backendName: 'webgl',\n    kernelFunc: prelu\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar CHECK_NAN_SNIPPET_UNARY = \"if (isnan(x)) return x;\";\nvar CHECK_NAN_SNIPPET_BINARY = \"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\";\nvar CHECK_NAN_SNIPPET_BINARY_PACKED = \"\\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\";\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippet Op snippet to create `UnaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `UnaryOpPackedProgram`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nfunction unaryKernelFunc(_a) {\n    var opSnippet = _a.opSnippet, packedOpSnippet = _a.packedOpSnippet, cpuKernelImpl = _a.cpuKernelImpl, dtype = _a.dtype;\n    return function (_a) {\n        var inputs = _a.inputs, backend = _a.backend;\n        var x = inputs.x;\n        var webglBackend = backend;\n        var $dtype = dtype || x.dtype;\n        if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {\n            var xData = webglBackend.texData.get(x.dataId);\n            var outValues = cpuKernelImpl(xData.values, $dtype);\n            return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);\n        }\n        var shouldUsePackedProgram = tf.env().getBool('WEBGL_PACK_UNARY_OPERATIONS') && packedOpSnippet != null;\n        var program;\n        if (shouldUsePackedProgram) {\n            program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);\n        }\n        else {\n            program = new UnaryOpProgram(x.shape, opSnippet);\n        }\n        return webglBackend.runWebGLProgram(program, [x], $dtype);\n    };\n}\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nfunction binaryKernelFunc(_a) {\n    var opSnippet = _a.opSnippet, packedOpSnippet = _a.packedOpSnippet, _b = _a.checkOutOfBounds, checkOutOfBounds = _b === void 0 ? false : _b, _c = _a.supportsComplex, supportsComplex = _c === void 0 ? false : _c, cpuKernelImpl = _a.cpuKernelImpl, dtype = _a.dtype;\n    return function (_a) {\n        var inputs = _a.inputs, backend = _a.backend;\n        var _b = inputs, a = _b.a, b = _b.b;\n        var webglBackend = backend;\n        if (supportsComplex && a.dtype === 'complex64') {\n            var aData = webglBackend.texData.get(a.dataId);\n            var bData = webglBackend.texData.get(b.dataId);\n            var _c = [\n                [aData.complexTensorInfos.real, bData.complexTensorInfos.real],\n                [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]\n            ].map(function (complexParts) {\n                var aPart = complexParts[0], bPart = complexParts[1];\n                var aHandle = {\n                    dataId: aPart.dataId,\n                    dtype: aPart.dtype,\n                    shape: a.shape\n                };\n                var bHandle = {\n                    dataId: bPart.dataId,\n                    dtype: bPart.dtype,\n                    shape: b.shape\n                };\n                var program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n                return webglBackend.runWebGLProgram(program, [aHandle, bHandle], tf.upcastType(aPart.dtype, bPart.dtype));\n            }), real = _c[0], imag = _c[1];\n            var complexOutput = complex({ inputs: { real: real, imag: imag }, backend: webglBackend });\n            webglBackend.disposeIntermediateTensorInfo(real);\n            webglBackend.disposeIntermediateTensorInfo(imag);\n            // TODO(annxingyuan): Implement CPU forwarding for complex inputs.\n            return complexOutput;\n        }\n        var $dtype = dtype || tf.upcastType(a.dtype, b.dtype);\n        if (webglBackend.shouldExecuteOnCPU([a, b]) && cpuKernelImpl != null) {\n            var aData = webglBackend.texData.get(a.dataId);\n            var bData = webglBackend.texData.get(b.dataId);\n            var _d = cpuKernelImpl(a.shape, b.shape, aData.values, bData.values, $dtype), outValues = _d[0], outShape = _d[1];\n            var out = webglBackend.makeTensorInfo(outShape, $dtype);\n            var outData = webglBackend.texData.get(out.dataId);\n            outData.values = outValues;\n            return out;\n        }\n        var shouldUsePackedProgram = tf.env().getBool('WEBGL_PACK_BINARY_OPERATIONS') &&\n            packedOpSnippet != null;\n        var program;\n        if (shouldUsePackedProgram) {\n            program = new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);\n        }\n        else {\n            program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n        }\n        return webglBackend.runWebGLProgram(program, [a, b], $dtype);\n    };\n}\nfunction mapActivationToShaderProgram(activation, packed) {\n    if (packed === void 0) { packed = false; }\n    if (activation === 'linear') {\n        if (packed) {\n            return LINEAR$1;\n        }\n        return LINEAR;\n    }\n    else if (activation === 'relu') {\n        if (packed) {\n            return RELU$1;\n        }\n        return RELU;\n    }\n    else if (activation === 'elu') {\n        if (packed) {\n            return ELU$1;\n        }\n        return ELU;\n    }\n    else if (activation === 'relu6') {\n        if (packed) {\n            return RELU6$1;\n        }\n        return RELU6;\n    }\n    else if (activation === 'prelu') {\n        if (packed) {\n            return PRELU_PACKED;\n        }\n        return PRELU;\n    }\n    else if (activation === 'leakyrelu') {\n        if (packed) {\n            return LEAKYRELU_PACKED;\n        }\n        return LEAKYRELU;\n    }\n    throw new Error(\"Activation \" + activation + \" has not been implemented for the WebGL backend.\");\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar MatMulPackedProgram = /** @class */ (function () {\n    function MatMulPackedProgram(aShape, bShape, outputShape, transposeA, transposeB, addBias, activation, hasPreluActivation, hasLeakyreluActivation) {\n        if (transposeA === void 0) { transposeA = false; }\n        if (transposeB === void 0) { transposeB = false; }\n        if (addBias === void 0) { addBias = false; }\n        if (activation === void 0) { activation = null; }\n        if (hasPreluActivation === void 0) { hasPreluActivation = false; }\n        if (hasLeakyreluActivation === void 0) { hasLeakyreluActivation = false; }\n        this.variableNames = ['matrixA', 'matrixB'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        var sharedDim = transposeA ? aShape[1] : aShape[2];\n        var sharedDimensionPacked = Math.ceil(sharedDim / 2);\n        var aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n        var bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n        var aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n        var bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n        var activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = \"vec4 activation(vec4 a) {\\n          vec4 b = getPreluActivationWeightsAtOutCoords();\\n          \" + activation + \"\\n        }\";\n            }\n            else if (hasLeakyreluActivation) {\n                activationSnippet = \"vec4 activation(vec4 a) {\\n          vec4 b = getLeakyreluAlphaAtOutCoords();\\n          \" + activation + \"\\n        }\";\n            }\n            else {\n                activationSnippet = \"vec4 activation(vec4 x) {\\n          \" + activation + \"\\n        }\";\n            }\n            applyActivationSnippet = \"result = activation(result);\";\n        }\n        var addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyreluActivation) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        var batchASnippet = 'rc.x';\n        var batchBSnippet = 'rc.x';\n        if (aShape[0] < bShape[0]) {\n            batchASnippet = \"int(min(float(rc.x), \" + (aShape[0] - 1) + \".))\";\n        }\n        else if (bShape[0] < aShape[0]) {\n            batchBSnippet = \"int(min(float(rc.x), \" + (bShape[0] - 1) + \".))\";\n        }\n        this.userCode = \"\\n      \" + activationSnippet + \"\\n\\n      const float sharedDimension = \" + sharedDimensionPacked + \".0;\\n\\n      vec4 dot2x2ARowBCol(ivec3 rc) {\\n        vec4 result = vec4(0);\\n        for (int i = 0; i < \" + sharedDimensionPacked + \"; i++) {\\n          int batchA = \" + batchASnippet + \";\\n          int batchB = \" + batchBSnippet + \";\\n          vec4 a = getMatrixA(batchA, \" + aSample + \");\\n          vec4 b = getMatrixB(batchB, \" + bSample + \");\\n\\n          // These swizzled products need to be separately added.\\n          // See: https://github.com/tensorflow/tfjs/issues/1735\\n          result += (\" + aSwizzle[0] + \" * \" + bSwizzle[0] + \");\\n          result += (\" + aSwizzle[1] + \" * \" + bSwizzle[1] + \");\\n        }\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n        vec4 result = dot2x2ARowBCol(rc);\\n\\n        \" + addBiasSnippet + \"\\n\\n        \" + applyActivationSnippet + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return MatMulPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// (Ar + Ai)(Br + Bi) =\n// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr\n// Yr = ArBr - AB\n// Yi = ArBi + AiBr\nvar COMPLEX_MULTIPLY = {\n    REAL: 'return areal * breal - aimag * bimag;',\n    IMAG: 'return areal * bimag + aimag * breal;'\n};\nvar BinaryOpComplexProgram = /** @class */ (function () {\n    function BinaryOpComplexProgram(op, aShape, bShape) {\n        this.variableNames = ['AReal', 'AImag', 'BReal', 'BImag'];\n        this.outputShape = tf.backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        this.userCode = \"\\n      float binaryOpComplex(\\n          float areal, float aimag, float breal, float bimag) {\\n        \" + op + \"\\n      }\\n\\n      void main() {\\n        float areal = getARealAtOutCoords();\\n        float aimag = getAImagAtOutCoords();\\n        float breal = getBRealAtOutCoords();\\n        float bimag = getBImagAtOutCoords();\\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\\n      }\\n    \";\n    }\n    return BinaryOpComplexProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar MUL = 'return a * b;';\nfunction multiply(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var a = inputs.a, b = inputs.b;\n    var dtype = tf.backend_util.upcastType(a.dtype, b.dtype);\n    if (a.dtype === 'complex64') {\n        var aData = backend.texData.get(a.dataId);\n        var bData = backend.texData.get(b.dataId);\n        var realProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL, a.shape, b.shape);\n        var imagProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);\n        var inputs_1 = [\n            {\n                dataId: aData.complexTensorInfos.real.dataId,\n                dtype: aData.complexTensorInfos.real.dtype,\n                shape: a.shape\n            },\n            {\n                dataId: aData.complexTensorInfos.imag.dataId,\n                dtype: aData.complexTensorInfos.imag.dtype,\n                shape: a.shape\n            },\n            {\n                dataId: bData.complexTensorInfos.real.dataId,\n                dtype: bData.complexTensorInfos.real.dtype,\n                shape: b.shape\n            },\n            {\n                dataId: bData.complexTensorInfos.imag.dataId,\n                dtype: bData.complexTensorInfos.imag.dtype,\n                shape: b.shape\n            }\n        ];\n        var realPart = backend.runWebGLProgram(realProgram, inputs_1, 'float32');\n        var imagPart = backend.runWebGLProgram(imagProgram, inputs_1, 'float32');\n        var complexOutput = complex({ inputs: { real: realPart, imag: imagPart }, backend: backend });\n        backend.disposeIntermediateTensorInfo(realPart);\n        backend.disposeIntermediateTensorInfo(imagPart);\n        // TODO(annxingyuan): CPU forwarding for complex inputs.\n        return complexOutput;\n    }\n    if (backend.shouldExecuteOnCPU([a, b])) {\n        var aData = backend.texData.get(a.dataId);\n        var bData = backend.texData.get(b.dataId);\n        var _a = multiplyImplCPU(a.shape, b.shape, aData.values, bData.values, dtype), outValues = _a[0], outShape = _a[1];\n        var out = backend.makeTensorInfo(outShape, dtype);\n        var outData = backend.texData.get(out.dataId);\n        outData.values = outValues;\n        return out;\n    }\n    var program;\n    if (tf.env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n        program = new BinaryOpPackedProgram(MUL, a.shape, b.shape);\n    }\n    else {\n        program = new BinaryOpProgram(MUL, a.shape, b.shape);\n    }\n    return backend.runWebGLProgram(program, [a, b], dtype);\n}\nvar multiplyConfig = {\n    kernelName: tf.Multiply,\n    backendName: 'webgl',\n    kernelFunc: multiply\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction packedReshape(input, afterShape, backend) {\n    var input3DShape = [getBatchDim(input.shape)].concat(getRowsCols(input.shape));\n    var input3D = {\n        dtype: input.dtype,\n        shape: input3DShape,\n        dataId: input.dataId\n    };\n    var afterShapeAs3D = [getBatchDim(afterShape)].concat(getRowsCols(afterShape));\n    var program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n    var preventEagerUnpackingOfOutput = true;\n    var output = backend.runWebGLProgram(program, [input3D], input.dtype, null /* customSetup */, preventEagerUnpackingOfOutput);\n    return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction reshape(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var shape = attrs.shape;\n    var webglBackend = backend;\n    var xSize = tf.util.sizeFromShape(x.shape);\n    var $shape = tf.util.inferFromImplicitShape(shape, xSize);\n    var $xSize = tf.util.sizeFromShape($shape);\n    tf.util.assert(xSize === $xSize, function () { return \"The new shape (\" + $shape + \") has \" + $xSize + \" elements and the old \" +\n        (\"shape (\" + x.shape + \") has \" + xSize + \" elements. The new shape and old \") +\n        \"shape must have the same number of elements.\"; });\n    var xTexData = webglBackend.texData.get(x.dataId);\n    if (xTexData.isPacked && !isReshapeFree(x.shape, $shape) &&\n        !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {\n        return packedReshape(x, $shape, webglBackend);\n    }\n    webglBackend.incRef(x.dataId);\n    return { dataId: x.dataId, shape: $shape, dtype: x.dtype };\n}\nvar reshapeConfig = {\n    kernelName: tf.Reshape,\n    backendName: 'webgl',\n    kernelFunc: reshape\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar MeanProgram = /** @class */ (function () {\n    function MeanProgram(reduceInfo, divisor) {\n        this.variableNames = ['x'];\n        var windowSize = reduceInfo.windowSize, batchSize = reduceInfo.batchSize, inSize = reduceInfo.inSize, outSize = reduceInfo.outSize;\n        this.outputShape = [batchSize, outSize];\n        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        var windowSizeVec4Remainder = windowSize % 4;\n        var updateSnippet = \"sumValue += dot(values, ones);\";\n        if (divisor != null) {\n            var denominator = 1 / divisor;\n            updateSnippet = \"sumValue += dot(values * \" + (tf.util.isInt(denominator) ? denominator.toPrecision(2) :\n                denominator) + \", ones);\";\n        }\n        var checkOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \" + inSize + \") {\\n          return 0.0;\\n        }\\n      \";\n        }\n        this.userCode = \"\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + checkOutOfBounds + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + windowSize + \";\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \" + windowSizeNearestVec4 + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          \" + updateSnippet + \"\\n        }\\n\\n        int inIdx = inOffset + \" + windowSizeNearestVec4 + \";\\n        if (\" + (windowSizeVec4Remainder === 1) + \") {\\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\\n\\n          \" + updateSnippet + \"\\n        } else if (\" + (windowSizeVec4Remainder === 2) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1), 0.0, 0.0);\\n\\n          \" + updateSnippet + \"\\n        } else if (\" + (windowSizeVec4Remainder === 3) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2), 0.0);\\n\\n          \" + updateSnippet + \"\\n        }\\n        setOutput(sumValue);\\n      }\\n    \";\n    }\n    return MeanProgram;\n}());\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ReduceProgram = /** @class */ (function () {\n    function ReduceProgram(reduceInfo, reduceType) {\n        this.variableNames = ['x'];\n        var windowSize = reduceInfo.windowSize, batchSize = reduceInfo.batchSize, inSize = reduceInfo.inSize, outSize = reduceInfo.outSize;\n        this.outputShape = [batchSize, outSize];\n        var initializationValue = '0.0';\n        var compareOp = \"\";\n        if (reduceType === 'prod') {\n            initializationValue = '1.0';\n        }\n        else if (reduceType === 'min') {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '1.0 / 1e-20';\n            compareOp = \"min\";\n        }\n        else if (reduceType === 'max') {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n            compareOp = \"max\";\n        }\n        var returnValue = reduceType + \"(\" + reduceType + \"(\" + reduceType + \"(\" +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (reduceType === 'sum') {\n            returnValue = \"sumValue\";\n        }\n        else if (reduceType === 'prod') {\n            returnValue = \"prodValue\";\n        }\n        else if (reduceType === 'all') {\n            returnValue = \"allValue\";\n        }\n        else if (reduceType === 'any') {\n            returnValue = \"anyValue\";\n        }\n        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        var windowSizeVec4Remainder = windowSize % 4;\n        var updateSnippet = \"\\n      if (\" + (reduceType === 'sum') + \") {\\n        sumValue += dot(values, ones);\\n      } else if (\" + (reduceType === 'prod') + \") {\\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\\n        prodValue *= tmp[0] * tmp[1];\\n      } else {\\n        minMaxValue = \" + compareOp + \"(values, minMaxValue);\\n      }\\n    \";\n        var vecType = \"vec4\";\n        if (reduceType === 'all') {\n            initializationValue = '1.0';\n            updateSnippet = \"\\n        bool reducedAllValue = all(values);\\n        float floatedReducedAllValue = float(reducedAllValue);\\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\\n      \";\n            vecType = \"bvec4\";\n        }\n        else if (reduceType === 'any') {\n            initializationValue = '0.0';\n            updateSnippet = \"\\n        bool reducedAnyValue = any(values);\\n        float floatedReducedAnyValue = float(reducedAnyValue);\\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\\n      \";\n            vecType = \"bvec4\";\n        }\n        var checkOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \" + inSize + \") {\\n          return initializationValue;\\n        }\\n      \";\n        }\n        this.userCode = \"\\n      const float initializationValue = \" + initializationValue + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + checkOutOfBounds + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + windowSize + \";\\n\\n        vec4 minMaxValue = vec4(\" + initializationValue + \");\\n        float prodValue = 1.0;\\n        float sumValue = 0.0;\\n        float allValue = 1.0;\\n        float anyValue = 0.0;\\n\\n        for (int i = 0; i < \" + windowSizeNearestVec4 + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          \" + vecType + \" values = \" + vecType + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          \" + updateSnippet + \"\\n        }\\n\\n        int inIdx = inOffset + \" + windowSizeNearestVec4 + \";\\n        if (\" + (windowSizeVec4Remainder === 1) + \") {\\n          \" + vecType + \" values = \" + vecType + \"(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + updateSnippet + \"\\n        } else if (\" + (windowSizeVec4Remainder === 2) + \") {\\n          \" + vecType + \" values = \" + vecType + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + updateSnippet + \"\\n        } else if (\" + (windowSizeVec4Remainder === 3) + \") {\\n          \" + vecType + \" values = \" + vecType + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          \" + updateSnippet + \"\\n        }\\n        setOutput(\" + returnValue + \");\\n      }\\n    \";\n    }\n    return ReduceProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Returns an array of configuration objects that describe each stage of the\n// reduction.\nfunction getReductionStages(inShape) {\n    var stages = [];\n    while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {\n        var outSize = stages.length ? stages[stages.length - 1].outSize : inShape[1];\n        var windowSize = tf.backend_util.computeOptimalWindowSize(outSize);\n        stages.push({\n            inSize: outSize,\n            windowSize: windowSize,\n            outSize: Math.ceil(outSize / windowSize)\n        });\n    }\n    return stages;\n}\nfunction reduce(x, dtype, reductionType, backend) {\n    var reductionStages = getReductionStages(x.shape);\n    var result = x;\n    for (var i = 0; i < reductionStages.length; i++) {\n        var _a = reductionStages[i], inSize = _a.inSize, windowSize = _a.windowSize, outSize = _a.outSize;\n        var program = void 0;\n        var previousResult = void 0;\n        if (reductionType === 'mean') {\n            program = i === 0 ?\n                new MeanProgram({ windowSize: windowSize, inSize: inSize, batchSize: x.shape[0], outSize: outSize }, inSize) :\n                new MeanProgram({ windowSize: windowSize, inSize: inSize, batchSize: x.shape[0], outSize: outSize });\n        }\n        else {\n            program = new ReduceProgram({ windowSize: windowSize, inSize: inSize, batchSize: x.shape[0], outSize: outSize }, reductionType);\n        }\n        previousResult = result;\n        result = backend.runWebGLProgram(program, [result], dtype);\n        if (previousResult.dataId !== x.dataId) {\n            backend.disposeIntermediateTensorInfo(previousResult);\n        }\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar TransposeProgram = /** @class */ (function () {\n    function TransposeProgram(aShape, newDim) {\n        this.variableNames = ['A'];\n        var outputShape = new Array(aShape.length);\n        for (var i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[newDim[i]];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        var dtype = getCoordsDataType(this.rank);\n        var switched = getSwitchedCoords(newDim);\n        this.userCode = \"\\n    void main() {\\n      \" + dtype + \" resRC = getOutputCoords();\\n      setOutput(getA(\" + switched + \"));\\n    }\\n    \";\n    }\n    return TransposeProgram;\n}());\nfunction getSwitchedCoords(newDim) {\n    var rank = newDim.length;\n    if (rank > 6) {\n        throw Error(\"Transpose for rank \" + rank + \" is not yet supported\");\n    }\n    var originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'];\n    var switchedCoords = new Array(rank);\n    for (var i = 0; i < newDim.length; i++) {\n        switchedCoords[newDim[i]] = originalOrder[i];\n    }\n    return switchedCoords.join();\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar TransposePackedProgram = /** @class */ (function () {\n    function TransposePackedProgram(aShape, newDim) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        var outputShape = new Array(aShape.length);\n        for (var i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[newDim[i]];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        if (this.rank > 6) {\n            throw Error(\"Packed transpose for rank \" + this.rank + \" is not yet supported.\");\n        }\n        var dtype = getCoordsDataType(this.rank);\n        var outputOrder = getVecChannels('rc', this.rank);\n        var switchedOrder = new Array(this.rank);\n        for (var i = 0; i < newDim.length; i++) {\n            switchedOrder[newDim[i]] = outputOrder[i];\n        }\n        var innerDims = \"vec2(\" + switchedOrder.slice(-2).join() + \")\";\n        var nextColumn = \"++\" + outputOrder[this.rank - 1] + \" < \" + outputShape[this.rank - 1];\n        var getc = \"getChannel(getA(\" + switchedOrder.join() + \"), \" + innerDims + \")\";\n        this.userCode = \"\\n    void main() {\\n      \" + dtype + \" rc = getOutputCoords();\\n      vec4 result = vec4(0.);\\n      result[0] = \" + getc + \";\\n      if(\" + nextColumn + \") {\\n        result[1] = \" + getc + \";\\n      }\\n      --\" + outputOrder[this.rank - 1] + \";\\n      if(++\" + outputOrder[this.rank - 2] + \" < \" + outputShape[this.rank - 2] + \") {\\n        result[2] = \" + getc + \";\\n        if(\" + nextColumn + \") {\\n          result[3] = \" + getc + \";\\n        }\\n      }\\n      setOutput(result);\\n    }\\n    \";\n    }\n    return TransposePackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction transposeImpl$1(x, perm, backend) {\n    var program = tf.env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new TransposePackedProgram(x.shape, perm) :\n        new TransposeProgram(x.shape, perm);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction sumImpl(x, axis, keepDims, backend) {\n    var reductionIndices = axis;\n    var xRank = x.shape.length;\n    var origAxes = tf.util.parseAxisParam(reductionIndices, x.shape);\n    var axes = origAxes;\n    var permutedAxes = tf.backend_util.getAxesPermutation(axes, xRank);\n    var sumInputIsTransposed = permutedAxes != null;\n    var sumInput = x;\n    if (sumInputIsTransposed) {\n        sumInput = transposeImpl$1(x, permutedAxes, backend);\n        axes = tf.backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n    tf.backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);\n    var _a = tf.backend_util.computeOutAndReduceShapes(sumInput.shape, axes), sumOutShape = _a[0], reduceShape = _a[1];\n    var outShape = sumOutShape;\n    if (keepDims) {\n        // rather than reshape at the end, set the target shape here.\n        outShape = tf.backend_util.expandShapeToKeepDim(sumOutShape, origAxes);\n    }\n    var inSize = tf.util.sizeFromShape(reduceShape);\n    var xSize = tf.util.sizeFromShape(x.shape);\n    var batchSize = xSize / inSize;\n    var reshapedInput = reshape({ inputs: { x: sumInput }, attrs: { shape: [batchSize, inSize] }, backend: backend });\n    var outType = tf.sumOutType(x.dtype);\n    var reduced = reduce(reshapedInput, outType, 'sum', backend);\n    var out = reshape({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend });\n    backend.disposeIntermediateTensorInfo(reshapedInput);\n    backend.disposeIntermediateTensorInfo(reduced);\n    if (sumInputIsTransposed) {\n        backend.disposeIntermediateTensorInfo(sumInput);\n    }\n    return out;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction sum(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, keepDims = attrs.keepDims;\n    return sumImpl(x, axis, keepDims, backend);\n}\nvar sumConfig = {\n    kernelName: tf.Sum,\n    backendName: 'webgl',\n    kernelFunc: sum\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction transpose(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var perm = attrs.perm;\n    var webglBackend = backend;\n    var xRank = x.shape.length;\n    var newShape = new Array(xRank);\n    for (var i = 0; i < newShape.length; i++) {\n        newShape[i] = x.shape[perm[i]];\n    }\n    var out;\n    if (webglBackend.shouldExecuteOnCPU([x])) {\n        var xTexData = webglBackend.texData.get(x.dataId);\n        var values = xTexData.values;\n        var outValues = transposeImplCPU(values, x.shape, x.dtype, perm, newShape);\n        out = webglBackend.makeTensorInfo(newShape, x.dtype);\n        var outData = webglBackend.texData.get(out.dataId);\n        outData.values = outValues;\n    }\n    else {\n        out = transposeImpl$1(x, perm, webglBackend);\n    }\n    return out;\n}\nvar transposeConfig = {\n    kernelName: tf.Transpose,\n    backendName: 'webgl',\n    kernelFunc: transpose\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Empirically determined minimal shared dimension in matmul before we forward\n// to a.mul(b).sum() in order to take advantage of GPU parallelism. See\n// https://github.com/tensorflow/tfjs-core/pull/1379 for benchmarks.\nvar MATMUL_SHARED_DIM_THRESHOLD = 1000;\nfunction batchMatMulImpl(_a) {\n    var a = _a.a, b = _a.b, transposeA = _a.transposeA, transposeB = _a.transposeB, backend = _a.backend, _b = _a.bias, bias = _b === void 0 ? null : _b, _c = _a.preluActivationWeights, preluActivationWeights = _c === void 0 ? null : _c, _d = _a.leakyreluAlpha, leakyreluAlpha = _d === void 0 ? 0 : _d, _e = _a.activation, activation = _e === void 0 ? null : _e;\n    var aRank = a.shape.length;\n    var bRank = b.shape.length;\n    var innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n    var innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n    var outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n    var outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n    var outerDimsA = a.shape.slice(0, -2);\n    var outerDimsB = b.shape.slice(0, -2);\n    var batchDimA = tf.util.sizeFromShape(outerDimsA);\n    var batchDimB = tf.util.sizeFromShape(outerDimsB);\n    var batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;\n    tf.util.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, function () { return \"Error in matMul: the input batch dimensions must either be the \" +\n        \"same or at least one input batch dimension must be 1. Got input \" +\n        (\"batch dimensions of (\" + outerDimsA + \") and (\" + outerDimsB + \").\"); });\n    var outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);\n    var outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n    tf.util.assert(innerShapeA === innerShapeB, function () { return \"Error in matMul: inner shapes (\" + innerShapeA + \") and (\" +\n        (innerShapeB + \") of Tensors with shapes \" + a.shape + \" and \") +\n        (b.shape + \" and transposeA=\" + transposeA) +\n        (\" and transposeB=\" + transposeB + \" must match.\"); });\n    var a3dShape = transposeA ?\n        [batchDimA, innerShapeA, outerShapeA] :\n        [batchDimA, outerShapeA, innerShapeA];\n    var b3dShape = transposeB ?\n        [batchDimB, outerShapeB, innerShapeB] :\n        [batchDimB, innerShapeB, outerShapeB];\n    // The rest of the implementation is designed to operate on rank-3 tensors\n    var a3d = reshape({ inputs: { x: a }, backend: backend, attrs: { shape: a3dShape } });\n    var b3d = reshape({ inputs: { x: b }, backend: backend, attrs: { shape: b3dShape } });\n    var intermediates = [a3d, b3d];\n    var batchDim = Math.max(batchDimA, batchDimB);\n    var sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n    var hasBias = bias != null;\n    var hasPreluActivationWeights = preluActivationWeights != null;\n    var hasLeakyreluAlpha = activation === 'leakyrelu';\n    var fusedActivation = activation != null ?\n        mapActivationToShaderProgram(activation, true) :\n        null;\n    var containsFusedOps = hasBias || hasPreluActivationWeights ||\n        hasLeakyreluAlpha || fusedActivation != null;\n    var out;\n    // Since the matrices are vectors, it is faster to call mul().sum()\n    // because sum() is O(sqrt(N)) due to divide-and-conquer.\n    if ((outerShapeA === 1 || outerShapeB === 1) &&\n        sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {\n        var aVec = a3d;\n        var bVec = b3d;\n        if (transposeA) {\n            aVec = transpose({ inputs: { x: a3d }, backend: backend, attrs: { perm: [0, 2, 1] } });\n            intermediates.push(aVec);\n        }\n        if (transposeB) {\n            bVec = transpose({ inputs: { x: b3d }, backend: backend, attrs: { perm: [0, 2, 1] } });\n            intermediates.push(bVec);\n        }\n        var shouldReshapeA = outerShapeB !== 1;\n        var shouldReshapeB = outerShapeB === 1;\n        var aVec3d = aVec;\n        if (shouldReshapeA) {\n            aVec3d = reshape({\n                inputs: { x: aVec },\n                backend: backend,\n                attrs: { shape: [batchDim, sharedDim, 1] }\n            });\n            intermediates.push(aVec3d);\n        }\n        var axis = outerShapeB === 1 ? 2 : 1;\n        var bVec3d = bVec;\n        if (shouldReshapeB) {\n            bVec3d = reshape({\n                inputs: { x: bVec },\n                backend: backend,\n                attrs: { shape: [batchDim, 1, sharedDim] }\n            });\n            intermediates.push(bVec3d);\n        }\n        var product = multiply({ inputs: { a: aVec3d, b: bVec3d }, backend: backend });\n        out = sum({ inputs: { x: product }, backend: backend, attrs: { axis: axis, keepDims: true } });\n        intermediates.push(product);\n    }\n    else {\n        var dtype = tf.upcastType(a.dtype, b.dtype);\n        var program = new MatMulPackedProgram(a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);\n        var inputs = [a3d, b3d];\n        if (bias != null) {\n            inputs.push(bias);\n        }\n        if (hasPreluActivationWeights) {\n            inputs.push(preluActivationWeights);\n        }\n        if (hasLeakyreluAlpha) {\n            var $leakyreluAlpha = backend.makeTensorInfo([], 'float32', tf.util.createScalarValue(leakyreluAlpha, 'float32'));\n            inputs.push($leakyreluAlpha);\n            intermediates.push($leakyreluAlpha);\n        }\n        out = backend.runWebGLProgram(program, inputs, dtype);\n    }\n    var outReshaped = reshape({ inputs: { x: out }, backend: backend, attrs: { shape: outShape } });\n    intermediates.push(out);\n    for (var _i = 0, intermediates_1 = intermediates; _i < intermediates_1.length; _i++) {\n        var i = intermediates_1[_i];\n        backend.disposeIntermediateTensorInfo(i);\n    }\n    return outReshaped;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction _fusedMatMul(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var a = inputs.a, b = inputs.b, bias = inputs.bias, preluActivationWeights = inputs.preluActivationWeights;\n    var transposeA = attrs.transposeA, transposeB = attrs.transposeB, activation = attrs.activation, leakyreluAlpha = attrs.leakyreluAlpha;\n    return batchMatMulImpl({\n        a: a,\n        b: b,\n        transposeA: transposeA,\n        transposeB: transposeB,\n        backend: backend,\n        bias: bias,\n        preluActivationWeights: preluActivationWeights,\n        leakyreluAlpha: leakyreluAlpha,\n        activation: activation\n    });\n}\nvar _fusedMatMulConfig = {\n    kernelName: tf._FusedMatMul,\n    backendName: 'webgl',\n    kernelFunc: _fusedMatMul,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ABS$1 = \"return abs(x);\";\nfunction abs(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    // TODO: handle cases when x is complex. Once the cpu implementation\n    // can handle complex values, refactor to use unaryKernelFunc.\n    if (backend.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n        var xData = backend.texData.get(x.dataId);\n        var outValues = simpleAbsImplCPU(xData.values);\n        return backend.makeTensorInfo(x.shape, x.dtype, outValues);\n    }\n    var program;\n    if (tf.env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n        program = new UnaryOpPackedProgram(x.shape, ABS$1);\n    }\n    else {\n        program = new UnaryOpProgram(x.shape, ABS$1);\n    }\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nvar absConfig = {\n    kernelName: tf.Abs,\n    backendName: 'webgl',\n    kernelFunc: abs\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ACOS = CHECK_NAN_SNIPPET + \"\\n  if (abs(x) > 1.) {\\n    return NAN;\\n  }\\n  return acos(x);\\n\";\nvar acos = unaryKernelFunc({ opSnippet: ACOS });\nvar acosConfig = {\n    kernelName: tf.Acos,\n    backendName: 'webgl',\n    kernelFunc: acos,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ACOSH = CHECK_NAN_SNIPPET + \"\\n  if (x < 1.0) return NAN;\\nreturn log(x + sqrt(x * x - 1.0));\";\nvar acosh = unaryKernelFunc({ opSnippet: ACOSH });\nvar acoshConfig = {\n    kernelName: tf.Acosh,\n    backendName: 'webgl',\n    kernelFunc: acosh,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ADD = 'return a + b;';\nvar addKernelFunc = binaryKernelFunc({\n    opSnippet: ADD,\n    packedOpSnippet: ADD,\n    supportsComplex: true,\n    cpuKernelImpl: addImplCPU\n});\nvar addConfig = {\n    kernelName: tf.Add,\n    backendName: 'webgl',\n    kernelFunc: addKernelFunc\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar AddNProgram = /** @class */ (function () {\n    function AddNProgram(outputShape, shapes) {\n        this.outputShape = [];\n        this.outputShape = outputShape;\n        this.variableNames = shapes.map(function (_, i) { return \"T\" + i; });\n        var snippets = [];\n        // Get target elements from every input tensor.\n        this.variableNames.forEach(function (variable) {\n            snippets.push(\"float v\" + variable + \" = get\" + variable + \"AtOutCoords();\");\n        });\n        // Calculate the sum of all elements.\n        var operation = this.variableNames\n            .map(function (variable) {\n            return \"v\" + variable;\n        })\n            .join(' + ');\n        this.userCode = \"\\n      void main() {\\n        \" + snippets.join('\\n        ') + \"\\n\\n        float result = \" + operation + \";\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return AddNProgram;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar AddNPackedProgram = /** @class */ (function () {\n    function AddNPackedProgram(outputShape, shapes) {\n        this.outputShape = [];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        this.variableNames = shapes.map(function (_, i) { return \"T\" + i; });\n        var snippets = [];\n        // Get target elements from every input tensor.\n        this.variableNames.forEach(function (variable) {\n            snippets.push(\"vec4 v\" + variable + \" = get\" + variable + \"AtOutCoords();\");\n        });\n        // Calculate the sum of all elements.\n        var operation = this.variableNames\n            .map(function (variable) {\n            return \"v\" + variable;\n        })\n            .join(' + ');\n        this.userCode = \"\\n      void main() {\\n        \" + snippets.join('\\n        ') + \"\\n\\n        vec4 result = \" + operation + \";\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return AddNPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction addN(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var tensors = inputs;\n    if (tensors.length === 1) {\n        return identity({ inputs: { x: tensors[0] }, backend: backend });\n    }\n    // Limit the number of uploaded textures for optimization.\n    if (tensors.length > tf.env().get('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n        var midIndex = Math.floor(tensors.length / 2);\n        var leftSide = addN({ inputs: tensors.slice(0, midIndex), backend: backend });\n        var rightSide = addN({ inputs: tensors.slice(midIndex), backend: backend });\n        return addN({ inputs: [leftSide, rightSide], backend: backend });\n    }\n    var dtype = tensors.map(function (t) { return t.dtype; }).reduce(function (d1, d2) { return tf.upcastType(d1, d2); });\n    var shapes = tensors.map(function (t) { return t.shape; });\n    // We can make sure shapes are identical in op level.\n    var usePackedOp = tf.env().getBool('WEBGL_PACK');\n    var program = usePackedOp ?\n        new AddNPackedProgram(tensors[0].shape, shapes) :\n        new AddNProgram(tensors[0].shape, shapes);\n    return backend.runWebGLProgram(program, tensors, dtype);\n}\nvar addNConfig = {\n    kernelName: tf.AddN,\n    backendName: 'webgl',\n    kernelFunc: addN\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction all(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, keepDims = attrs.keepDims;\n    var xRank = x.shape.length;\n    var origAxes = tf.util.parseAxisParam(axis, x.shape);\n    var axes = origAxes;\n    var permutedAxes = tf.backend_util.getAxesPermutation(axes, xRank);\n    var permutedX = x;\n    if (permutedAxes != null) {\n        permutedX = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutedAxes } });\n        axes = tf.backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n    tf.backend_util.assertAxesAreInnerMostDims('all', axes, xRank);\n    var _a = tf.backend_util.computeOutAndReduceShapes(permutedX.shape, axes), outShape = _a[0], reduceShape = _a[1];\n    var inSize = tf.util.sizeFromShape(reduceShape);\n    var a2D = reshape({ inputs: { x: permutedX }, backend: backend, attrs: { shape: [-1, inSize] } });\n    var reduced = reduce(a2D, a2D.dtype, 'all', backend);\n    var res;\n    if (keepDims) {\n        var newShape = tf.backend_util.expandShapeToKeepDim(outShape, origAxes);\n        res = reshape({ inputs: { x: reduced }, backend: backend, attrs: { shape: newShape } });\n    }\n    else {\n        res = reshape({ inputs: { x: reduced }, backend: backend, attrs: { shape: outShape } });\n    }\n    backend.disposeIntermediateTensorInfo(a2D);\n    backend.disposeIntermediateTensorInfo(reduced);\n    if (permutedAxes != null) {\n        backend.disposeIntermediateTensorInfo(permutedX);\n    }\n    return res;\n}\nvar allConfig = {\n    kernelName: tf.All,\n    backendName: 'webgl',\n    kernelFunc: all\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction any(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, keepDims = attrs.keepDims;\n    var xRank = x.shape.length;\n    var origAxes = tf.util.parseAxisParam(axis, x.shape);\n    var axes = origAxes;\n    var permutedAxes = tf.backend_util.getAxesPermutation(axes, xRank);\n    var permutedX = x;\n    if (permutedAxes != null) {\n        permutedX = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutedAxes } });\n        axes = tf.backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n    tf.backend_util.assertAxesAreInnerMostDims('any', axes, xRank);\n    var _a = tf.backend_util.computeOutAndReduceShapes(permutedX.shape, axes), outShape = _a[0], reduceShape = _a[1];\n    var inSize = tf.util.sizeFromShape(reduceShape);\n    var a2D = reshape({ inputs: { x: permutedX }, backend: backend, attrs: { shape: [-1, inSize] } });\n    var reduced = reduce(a2D, a2D.dtype, 'any', backend);\n    var res;\n    if (keepDims) {\n        var newShape = tf.backend_util.expandShapeToKeepDim(outShape, origAxes);\n        res = reshape({ inputs: { x: reduced }, backend: backend, attrs: { shape: newShape } });\n    }\n    else {\n        res = reshape({ inputs: { x: reduced }, backend: backend, attrs: { shape: outShape } });\n    }\n    backend.disposeIntermediateTensorInfo(a2D);\n    backend.disposeIntermediateTensorInfo(reduced);\n    if (permutedAxes != null) {\n        backend.disposeIntermediateTensorInfo(permutedX);\n    }\n    return res;\n}\nvar anyConfig = {\n    kernelName: tf.Any,\n    backendName: 'webgl',\n    kernelFunc: any\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ArgMinMaxProgram = /** @class */ (function () {\n    function ArgMinMaxProgram(reduceInfo, op, firstPass) {\n        this.variableNames = ['A'];\n        var windowSize = reduceInfo.windowSize, batchSize = reduceInfo.batchSize, outSize = reduceInfo.outSize;\n        if (!firstPass) {\n            this.variableNames.push('bestIndicesA');\n        }\n        this.outputShape = [batchSize, outSize];\n        var compOp = (op === 'max') ? '>' : '<';\n        var indexSnippet = firstPass ?\n            'inOffset + i;' :\n            'round(getBestIndicesA(batch, inOffset + i));';\n        this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + windowSize + \";\\n\\n        int bestIndex = inOffset;\\n        float bestValue = getA(batch, bestIndex);\\n\\n        for (int i = 0; i < \" + windowSize + \"; i++) {\\n          int inIdx = \" + indexSnippet + \";\\n          float candidate = getA(batch, inIdx);\\n          if (candidate \" + compOp + \" bestValue) {\\n            bestValue = candidate;\\n            bestIndex = inIdx;\\n          }\\n        }\\n        setOutput(float(bestIndex));\\n      }\\n    \";\n    }\n    return ArgMinMaxProgram;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ArgMinMaxPackedProgram = /** @class */ (function () {\n    function ArgMinMaxPackedProgram(shape, windowSize, op, firstPass) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        tf.util.assert(shape.length > 2, function () { return \"Packed arg\" + (op.charAt(0).toUpperCase() +\n            op.slice(1)) + \" supports only inputs with rank above 2.\"; });\n        var inSize = shape[shape.length - 1];\n        var outSize = Math.ceil(inSize / windowSize);\n        this.outputShape = shape.slice(0, -1);\n        if (outSize > 1) {\n            this.outputShape.push(outSize);\n        }\n        if (!firstPass) {\n            this.variableNames.push('bestIndicesA');\n        }\n        var outShape = this.outputShape;\n        var rank = outShape.length;\n        var dtype = getCoordsDataType(rank);\n        var coords = getChannels('coords', rank);\n        var sourceLocSetup;\n        var sourceRank;\n        if (outSize === 1) {\n            sourceRank = rank + 1;\n            var sourceLocDType = getCoordsDataType(sourceRank);\n            sourceLocSetup = \"\\n        \" + sourceLocDType + \" sourceLocR = \" + sourceLocDType + \"(\" + coords.join() + \", 0);\\n        ++\" + coords[rank - 1] + \";\\n        \" + sourceLocDType + \" sourceLocG = \" + sourceLocDType + \"(\" + coords.join() + \", 0);\\n        ++\" + coords[rank - 2] + \";\\n        \" + sourceLocDType + \" sourceLocA = \" + sourceLocDType + \"(\" + coords.join() + \", 0);\\n        --\" + coords[rank - 1] + \";\\n        \" + sourceLocDType + \" sourceLocB = \" + sourceLocDType + \"(\" + coords.join() + \", 0);\\n        --\" + coords[rank - 2] + \";\";\n        }\n        else {\n            sourceRank = rank;\n            sourceLocSetup = \"\\n        \" + dtype + \" sourceLocR = coords;\\n        ++\" + coords[rank - 1] + \";\\n        \" + dtype + \" sourceLocG = coords;\\n        ++\" + coords[rank - 2] + \";\\n        \" + dtype + \" sourceLocA = coords;\\n        --\" + coords[rank - 1] + \";\\n        \" + dtype + \" sourceLocB = coords;\\n        --\" + coords[rank - 2] + \";\";\n        }\n        var channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, sourceRank);\n        var inChannel = '.' + channels[sourceRank - 1]; // e.g. \".b\" for rank 3.\n        var intChannels = channels.map(function (x) { return 'int ' + x; });\n        var srcRCoords = getChannels('sourceLocR', sourceRank - 1).concat('inIdx.r');\n        var srcGCoords = getChannels('sourceLocG', sourceRank - 1).concat('inIdx.g');\n        var srcBCoords = getChannels('sourceLocB', sourceRank - 1).concat('inIdx.b');\n        var srcACoords = getChannels('sourceLocA', sourceRank - 1).concat('inIdx.a');\n        var compOp = (op === 'max') ? 'greaterThan' : 'lessThan';\n        var fetchCandidateIdx = firstPass ? '' : \"\\n          inIdx = round(vec4(getBestIndicesAChannel(\" + srcRCoords.join() + \"),\\n                             getBestIndicesAChannel(\" + srcGCoords.join() + \"),\\n                             getBestIndicesAChannel(\" + srcBCoords.join() + \"),\\n                             getBestIndicesAChannel(\" + srcACoords.join() + \")));\";\n        var fetchValue = \"vec4(\\n            getAChannel(\" + srcRCoords.join() + \"),\\n            hasNextCol ? getAChannel(\" + srcGCoords.join() + \") : 0.,\\n            hasNextRow ? getAChannel(\" + srcBCoords.join() + \") : 0.,\\n            hasNextRow && hasNextCol ? getAChannel(\" + srcACoords.join() + \") : 0.)\";\n        var getBestIndicesAChannelSnippet = firstPass ? '' : \"\\n      float getBestIndicesAChannel(\" + intChannels.join() + \") {\\n        return getChannel(getBestIndicesA(\" + channels.join() + \"),\\n                                          vec2(\" + channels.slice(-2).join() + \"));\\n      }\";\n        this.userCode = \"\\n      float getAChannel(\" + intChannels.join() + \") {\\n        return getChannel(getA(\" + channels.join() + \"),\\n                               vec2(\" + channels.slice(-2).join() + \"));\\n      }\\n      \" + getBestIndicesAChannelSnippet + \"\\n      void main() {\\n        \" + dtype + \" coords = getOutputCoords();\\n        bool hasNextCol = \" + coords[rank - 1] + \" < \" + (outShape[rank - 1] - 1) + \";\\n        bool hasNextRow = \" + coords[rank - 2] + \" < \" + (outShape[rank - 2] - 1) + \";\\n        \" + sourceLocSetup + \"\\n        ivec4 srcIdx = ivec4(sourceLocR\" + inChannel + \", sourceLocG\" + inChannel + \",\\n          sourceLocB\" + inChannel + \", sourceLocA\" + inChannel + \") * \" + windowSize + \";\\n        ivec4 inIdx = srcIdx;\\n        vec4 bestIndex = vec4(inIdx);\\n        vec4 bestValue = \" + fetchValue + \";\\n\\n        for (int i = 0; i < \" + windowSize + \"; i++) {\\n          inIdx = srcIdx;\\n          \" + fetchCandidateIdx + \"\\n          vec4 candidate = \" + fetchValue + \";\\n          bvec4 nan = isnan(candidate);\\n          bvec4 replace = bvec4(\\n            vec4(\" + compOp + \"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\\n\\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\\n                           replace.y  ? candidate.y : bestValue.y,\\n                           replace.z  ? candidate.z : bestValue.z,\\n                           replace.w  ? candidate.w : bestValue.w);\\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\\n          srcIdx++;\\n        }\\n        setOutput(bestIndex);\\n      }\\n    \";\n    }\n    return ArgMinMaxPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction argReduce(backend, x, reduceType, bestIndicesA) {\n    if (bestIndicesA === void 0) { bestIndicesA = null; }\n    var batchSize = x.shape[0];\n    var inSize = x.shape[1];\n    if (bestIndicesA != null) {\n        batchSize = bestIndicesA.shape[0];\n        inSize = bestIndicesA.shape[1];\n    }\n    var windowSize = tf.backend_util.computeOptimalWindowSize(inSize);\n    var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize, outSize: Math.ceil(inSize / windowSize) };\n    var program = new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);\n    var inputs = [x];\n    if (bestIndicesA != null) {\n        inputs.push(bestIndicesA);\n    }\n    var output = backend.runWebGLProgram(program, inputs, 'int32');\n    // No need to run another GPGPU program.\n    if (output.shape[1] === 1) {\n        return output;\n    }\n    var result = argReduce(backend, x, reduceType, output);\n    backend.disposeIntermediateTensorInfo(output);\n    return result;\n}\nfunction argReducePacked(backend, x, reduceType, bestIndicesA) {\n    if (bestIndicesA === void 0) { bestIndicesA = null; }\n    var inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;\n    var inSize = inShape[inShape.length - 1];\n    var windowSize = tf.backend_util.computeOptimalWindowSize(inSize);\n    var program = new ArgMinMaxPackedProgram(inShape, windowSize, reduceType, bestIndicesA == null);\n    var inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];\n    var output = backend.runWebGLProgram(program, inputs, 'int32');\n    if (output.shape.length === x.shape.length) {\n        var result = argReducePacked(backend, x, reduceType, output);\n        backend.disposeIntermediateTensorInfo(output);\n        return result;\n    }\n    return output;\n}\nfunction argMinMaxReduce(backend, x, axis, reduceType) {\n    var axes = [axis];\n    tf.backend_util.assertAxesAreInnerMostDims('arg' + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x.shape.length);\n    if (!tf.env().getBool('WEBGL_PACK_REDUCE') || x.shape.length <= 2) {\n        var intermediateTensorInfos = [];\n        var _a = tf.backend_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];\n        var inSize = tf.util.sizeFromShape(reduceShape);\n        var a2D = reshape({ inputs: { x: x }, backend: backend, attrs: { shape: [-1, inSize] } });\n        intermediateTensorInfos.push(a2D);\n        var reduced = argReduce(backend, a2D, reduceType);\n        intermediateTensorInfos.push(reduced);\n        var reshaped = reshape({ inputs: { x: reduced }, backend: backend, attrs: { shape: outShape } });\n        intermediateTensorInfos.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n        return reshaped;\n    }\n    return argReducePacked(backend, x, reduceType);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction argMax(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis;\n    var axes = tf.util.parseAxisParam(axis, x.shape);\n    var permutedAxes = tf.backend_util.getAxesPermutation(axes, x.shape.length);\n    var $x = x;\n    var intermediateTensorInfos = [];\n    if (permutedAxes != null) {\n        $x = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutedAxes } });\n        intermediateTensorInfos.push($x);\n        axes = tf.backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n    }\n    tf.backend_util.assertAxesAreInnerMostDims('argMax', [axes[0]], $x.shape.length);\n    var out = argMinMaxReduce(backend, $x, axes[0], 'max');\n    intermediateTensorInfos.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return out;\n}\nvar argMaxConfig = {\n    kernelName: tf.ArgMax,\n    backendName: 'webgl',\n    kernelFunc: argMax\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction argMin(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis;\n    var axes = tf.util.parseAxisParam(axis, x.shape);\n    var permutedAxes = tf.backend_util.getAxesPermutation(axes, x.shape.length);\n    var $x = x;\n    var intermediateTensorInfos = [];\n    if (permutedAxes != null) {\n        $x = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutedAxes } });\n        intermediateTensorInfos.push($x);\n        axes = tf.backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n    }\n    tf.backend_util.assertAxesAreInnerMostDims('argMin', [axes[0]], $x.shape.length);\n    var out = argMinMaxReduce(backend, $x, axes[0], 'min');\n    intermediateTensorInfos.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return out;\n}\nvar argMinConfig = {\n    kernelName: tf.ArgMin,\n    backendName: 'webgl',\n    kernelFunc: argMin\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ASIN = CHECK_NAN_SNIPPET + \"\\n  if (abs(x) > 1.) {\\n    return NAN;\\n  }\\n  return asin(x);\\n\";\nvar asin = unaryKernelFunc({ opSnippet: ASIN });\nvar asinConfig = {\n    kernelName: tf.Asin,\n    backendName: 'webgl',\n    kernelFunc: asin,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ASINH = CHECK_NAN_SNIPPET + \"return log(x + sqrt(x * x + 1.0));\";\nvar asinh = unaryKernelFunc({ opSnippet: ASINH });\nvar asinhConfig = {\n    kernelName: tf.Asinh,\n    backendName: 'webgl',\n    kernelFunc: asinh,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ATAN = CHECK_NAN_SNIPPET + \"\\n  return atan(x);\\n\";\nvar atan = unaryKernelFunc({ opSnippet: ATAN });\nvar atanConfig = {\n    kernelName: tf.Atan,\n    backendName: 'webgl',\n    kernelFunc: atan,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ATAN2 = CHECK_NAN_SNIPPET_BINARY + \"\\n  return atan(a, b);\\n\";\nvar ATAN2_PACKED = \"\\n  vec4 result = atan(a, b);\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \" +\n    CHECK_NAN_SNIPPET_BINARY_PACKED + \"\\n  return result;\\n\";\nvar atan2 = binaryKernelFunc({ opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED });\nvar atan2Config = {\n    kernelName: tf.Atan2,\n    backendName: 'webgl',\n    kernelFunc: atan2,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ATANH = CHECK_NAN_SNIPPET + \"\\n  if ((x < -1.0) || (x > 1.0)) return NAN;\\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;\";\nvar atanh = unaryKernelFunc({ opSnippet: ATANH });\nvar atanhConfig = {\n    kernelName: tf.Atanh,\n    backendName: 'webgl',\n    kernelFunc: atanh,\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar Pool2DProgram = /** @class */ (function () {\n    function Pool2DProgram(convInfo, poolType, computePositions, flattenPositions, includeBatchInIndex) {\n        if (flattenPositions === void 0) { flattenPositions = false; }\n        if (includeBatchInIndex === void 0) { includeBatchInIndex = false; }\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        var filterWidth = convInfo.filterWidth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var dilationHeight = convInfo.dilationHeight;\n        var dilationWidth = convInfo.dilationWidth;\n        var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        var isAvgPool = poolType === 'avg';\n        var batchFlattenPositionStr = \"((batch  * \" + convInfo.inHeight + \" + xR) * \" + convInfo.inWidth + \" + xC) * \" + convInfo.inChannels + \" + d\";\n        var flattenPositionStr = \"(xR * \" + convInfo.inWidth + \" + xC) * \" + convInfo.inChannels + \" + d\";\n        var initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            var compareOp_1 = '>=';\n            this.userCode = \"\\n        const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n        const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \" + effectiveFilterHeight + \";\\n              wR += \" + dilationHeight + \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + effectiveFilterWidth + \";\\n                wC += \" + dilationWidth + \") {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value \" + compareOp_1 + \" currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = \" + (flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\n                flattenPositionStr) :\n                \"wR * \" + effectiveFilterWidth + \" + wC\") + \";\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";\n            return;\n        }\n        var compareOp = 'max';\n        var returnValue = poolType + \"(\" + poolType + \"(\" + poolType + \"(\" +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = \"avgValue / count\";\n        }\n        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        var filterWidthVec4Remainder = filterWidth % 4;\n        var updateSnippet = \"\\n      if (\" + isAvgPool + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \" + compareOp + \"(values, minMaxValue);\\n      }\\n    \";\n        this.userCode = \"\\n      const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n      const float initializationValue = \" + initializationValue + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + initializationValue + \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < \" + effectiveFilterHeight + \";\\n            wR += \" + dilationHeight + \") {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + filterWidthNearestVec4 + \"; wC += 4) {\\n            int xC = xCCorner + wC * \" + dilationWidth + \";\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + dilationWidth + \", d),\\n              getValue(batch, xR, xC + 2 * \" + dilationWidth + \", d),\\n              getValue(batch, xR, xC + 3 * \" + dilationWidth + \", d)\\n            );\\n\\n            \" + updateSnippet + \"\\n          }\\n\\n          int xC = xCCorner + \" + filterWidthNearestVec4 + \";\\n          if (\" + (filterWidthVec4Remainder === 1) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          } else if (\" + (filterWidthVec4Remainder === 2) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + dilationWidth + \", d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          } else if (\" + (filterWidthVec4Remainder === 3) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + dilationWidth + \", d),\\n              getValue(batch, xR, xC + 2 * \" + dilationWidth + \", d),\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          }\\n        }\\n        setOutput(\" + returnValue + \");\\n      }\\n    \";\n    }\n    return Pool2DProgram;\n}());\nvar Pool3DProgram = /** @class */ (function () {\n    function Pool3DProgram(convInfo, poolType, computePositions, flattenPositions, includeBatchInIndex) {\n        if (flattenPositions === void 0) { flattenPositions = false; }\n        if (includeBatchInIndex === void 0) { includeBatchInIndex = false; }\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        var filterWidth = convInfo.filterWidth;\n        var strideDepth = convInfo.strideDepth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var dilationDepth = convInfo.dilationDepth;\n        var dilationHeight = convInfo.dilationHeight;\n        var dilationWidth = convInfo.dilationWidth;\n        var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        var padFront = convInfo.padInfo.front;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        var isAvgPool = poolType === 'avg';\n        var initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            var compareOp_2 = '>=';\n            this.userCode = \"\\n        const ivec3 strides =\\n            ivec3(\" + strideDepth + \", \" + strideHeight + \", \" + strideWidth + \");\\n        const ivec3 pads = ivec3(\" + padFront + \", \" + padTop + \", \" + padLeft + \");\\n\\n        void main() {\\n          ivec5 coords = getOutputCoords();\\n          int batch = coords.x;\\n          int ch = coords.u;\\n\\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n          int xDCorner = xCorner.x;\\n          int xRCorner = xCorner.y;\\n          int xCCorner = xCorner.z;\\n\\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n\\n          for (int wD = 0; wD < \" + effectiveFilterDepth + \";\\n              wD += \" + dilationDepth + \") {\\n            int xD = xDCorner + wD;\\n\\n            if (xD < 0 || xD >= \" + convInfo.inDepth + \") {\\n              continue;\\n            }\\n\\n            for (int wR = 0; wR < \" + effectiveFilterHeight + \";\\n                wR += \" + dilationHeight + \") {\\n              int xR = xRCorner + wR;\\n\\n              if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n                continue;\\n              }\\n\\n              for (int wC = 0; wC < \" + effectiveFilterWidth + \";\\n                  wC += \" + dilationWidth + \") {\\n                int xC = xCCorner + wC;\\n\\n                if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n                  continue;\\n                }\\n\\n                float value = getX(batch, xD, xR, xC, ch);\\n\\n                // If a min / max value has already been found, use it. If not,\\n                // use the current value.\\n                float currMinMaxValue = mix(\\n                    value, minMaxValue, minMaxValueFound);\\n                if (value \" + compareOp_2 + \" currMinMaxValue) {\\n                  minMaxValue = value;\\n                  minMaxValueFound = 1.0;\\n                  minMaxPosition = \" + (flattenPositions ?\n                (includeBatchInIndex ?\n                    \"(((batch * \" + convInfo.inDepth + \" + xD) * \" + convInfo.inHeight + \" + xR) * \" + convInfo.inWidth + \" + xC) * \" + convInfo.inChannels + \" + ch\" :\n                    \"((xD * \" + convInfo.inHeight + \" + xR) * \" + convInfo.inWidth + \" + xC) * \" + convInfo.inChannels + \" + ch\") :\n                \"wD * \" + effectiveFilterHeight + \" * \" + effectiveFilterWidth + \" +\\n                      wR * \" + effectiveFilterWidth + \" + wC\") + \";\\n                }\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";\n            return;\n        }\n        var compareOp = 'max';\n        var returnValue = poolType + \"(\" + poolType + \"(\" + poolType + \"(\" +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = \"avgValue / count\";\n        }\n        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        var filterWidthVec4Remainder = filterWidth % 4;\n        var updateSnippet = \"\\n      if (\" + isAvgPool + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \" + compareOp + \"(values, minMaxValue);\\n      }\\n    \";\n        this.userCode = \"\\n      const ivec3 strides =\\n        ivec3(\" + strideDepth + \", \" + strideHeight + \", \" + strideWidth + \");\\n      const ivec3 pads = ivec3(\" + padFront + \", \" + padTop + \", \" + padLeft + \");\\n      const float initializationValue = \" + initializationValue + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\\n        if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xD, xR, xC, ch);\\n      }\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xDCorner = xCorner.x;\\n        int xRCorner = xCorner.y;\\n        int xCCorner = xCorner.z;\\n\\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + initializationValue + \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wD = 0; wD < \" + effectiveFilterDepth + \";\\n            wD += \" + dilationDepth + \") {\\n          int xD = xDCorner + wD;\\n\\n          if (xD < 0 || xD >= \" + convInfo.inDepth + \") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \" + effectiveFilterHeight + \";\\n            wR += \" + dilationHeight + \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + filterWidthNearestVec4 + \"; wC += 4) {\\n              int xC = xCCorner + wC * \" + dilationWidth + \";\\n\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + dilationWidth + \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \" + dilationWidth + \", ch),\\n                getValue(batch, xD, xR, xC + 3 * \" + dilationWidth + \", ch)\\n              );\\n\\n              \" + updateSnippet + \"\\n            }\\n\\n            int xC = xCCorner + \" + filterWidthNearestVec4 + \";\\n            if (\" + (filterWidthVec4Remainder === 1) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                initializationValue,\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \" + updateSnippet + \"\\n            } else if (\" + (filterWidthVec4Remainder === 2) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + dilationWidth + \", ch),\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \" + updateSnippet + \"\\n            } else if (\" + (filterWidthVec4Remainder === 3) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + dilationWidth + \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \" + dilationWidth + \", ch),\\n                initializationValue\\n              );\\n\\n              \" + updateSnippet + \"\\n            }\\n          }\\n          setOutput(\" + returnValue + \");\\n        }\\n      }\\n    \";\n    }\n    return Pool3DProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction avgPool(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    assertNotComplex(x, 'avgPool');\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode;\n    var dilations = 1;\n    tf.util.assert(tf.backend_util.eitherStridesOrDilationsAreOne(strides, dilations), function () { return 'Error in avgPool: Either strides or dilations must be 1. ' +\n        (\"Got strides \" + strides + \" and dilations '\" + dilations + \"'\"); });\n    var convInfo = tf.backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n        tf.util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n        return identity({ inputs: { x: x }, backend: backend });\n    }\n    var avgPoolProgram = new Pool2DProgram(convInfo, 'avg', false);\n    return backend.runWebGLProgram(avgPoolProgram, [x], 'float32');\n}\nvar avgPoolConfig = {\n    kernelName: tf.AvgPool,\n    backendName: 'webgl',\n    kernelFunc: avgPool\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction avgPool3D(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode, dataFormat = attrs.dataFormat;\n    var dilations = [1, 1, 1];\n    var convInfo = tf.backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);\n    var avgPoolProgram = new Pool3DProgram(convInfo, 'avg', false);\n    return backend.runWebGLProgram(avgPoolProgram, [x], 'float32');\n}\nvar avgPool3DConfig = {\n    kernelName: tf.AvgPool3D,\n    backendName: 'webgl',\n    kernelFunc: avgPool3D\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar AvgPool2DBackpropProgram = /** @class */ (function () {\n    function AvgPool2DBackpropProgram(convInfo) {\n        this.variableNames = ['dy'];\n        this.outputShape = convInfo.inShape;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var dilationHeight = convInfo.dilationHeight;\n        var dilationWidth = convInfo.dilationWidth;\n        var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        var avgMultiplier = 1 / (filterHeight * filterWidth);\n        this.userCode = \"\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n      const float avgMultiplier = float(\" + avgMultiplier + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + effectiveFilterHeight + \";\\n            wR += \" + dilationHeight + \") {\\n          float dyR = float(dyRCorner + wR) / \" + strideHeight + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + convInfo.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + effectiveFilterWidth + \";\\n            wC+= \" + dilationWidth + \") {\\n            float dyC = float(dyCCorner + wC) / \" + strideWidth + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + convInfo.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n\\n            dotProd += dyValue * avgMultiplier;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return AvgPool2DBackpropProgram;\n}());\nvar AvgPool3DBackpropProgram = /** @class */ (function () {\n    function AvgPool3DBackpropProgram(convInfo) {\n        this.variableNames = ['dy'];\n        this.outputShape = convInfo.inShape;\n        var filterDepth = convInfo.filterDepth;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var strideDepth = convInfo.strideDepth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var dilationDepth = convInfo.dilationDepth;\n        var dilationHeight = convInfo.dilationHeight;\n        var dilationWidth = convInfo.dilationWidth;\n        var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        var padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        var avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n        this.userCode = \"\\n      const ivec3 pads = ivec3(\" + padFront + \", \" + padTop + \", \" + padLeft + \");\\n      const float avgMultiplier = float(\" + avgMultiplier + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyDCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\\n        // dx(xD, xR, xC, ch).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int wD = 0; wD < \" + effectiveFilterDepth + \";\\n            wD += \" + dilationDepth + \") {\\n          float dyD = float(dyDCorner + wD) / \" + strideDepth + \".0;\\n\\n          if (dyD < 0.0 || dyD >= \" + convInfo.outDepth + \".0 || fract(dyD) > 0.0) {\\n            continue;\\n          }\\n          int idyD = int(dyD);\\n\\n          for (int wR = 0; wR < \" + effectiveFilterHeight + \";\\n              wR += \" + dilationHeight + \") {\\n            float dyR = float(dyRCorner + wR) / \" + strideHeight + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + convInfo.outHeight + \".0 ||\\n                fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            for (int wC = 0; wC < \" + effectiveFilterWidth + \";\\n                wC += \" + dilationWidth + \") {\\n              float dyC = float(dyCCorner + wC) / \" + strideWidth + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + convInfo.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\\n\\n              dotProd += dyValue * avgMultiplier;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return AvgPool3DBackpropProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction avgPool3DGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, input = inputs.input;\n    var x = input;\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode;\n    var dilations = [1, 1, 1];\n    var convInfo = tf.backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    var avgPoolBackpropProgram = new AvgPool3DBackpropProgram(convInfo);\n    return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);\n}\nvar avgPoolGrad3DConfig = {\n    kernelName: tf.AvgPool3DGrad,\n    backendName: 'webgl',\n    kernelFunc: avgPool3DGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction avgPoolGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, input = inputs.input;\n    var x = input;\n    assertNotComplex([dy, input], 'avgPoolGrad');\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad;\n    var convInfo = tf.backend_util.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */, pad);\n    var avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);\n    return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);\n}\nvar avgPoolGradConfig = {\n    kernelName: tf.AvgPoolGrad,\n    backendName: 'webgl',\n    kernelFunc: avgPoolGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction batchMatMul(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var a = inputs.a, b = inputs.b;\n    var transposeA = attrs.transposeA, transposeB = attrs.transposeB;\n    return batchMatMulImpl({ a: a, b: b, transposeA: transposeA, transposeB: transposeB, backend: backend });\n}\nvar batchMatMulConfig = {\n    kernelName: tf.BatchMatMul,\n    backendName: 'webgl',\n    kernelFunc: batchMatMul,\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar BatchNormProgram = /** @class */ (function () {\n    function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {\n        this.outputShape = [];\n        this.variableNames = ['x', 'mean', 'variance'];\n        tf.backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n        tf.backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n        var offsetSnippet = '0.0';\n        if (offsetShape != null) {\n            tf.backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n            this.variableNames.push('offset');\n            offsetSnippet = 'getOffsetAtOutCoords()';\n        }\n        var scaleSnippet = '1.0';\n        if (scaleShape != null) {\n            tf.backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n            this.variableNames.push('scale');\n            scaleSnippet = 'getScaleAtOutCoords()';\n        }\n        this.outputShape = xShape;\n        this.userCode = \"\\n      void main() {\\n        float x = getXAtOutCoords();\\n        float mean = getMeanAtOutCoords();\\n        float variance = getVarianceAtOutCoords();\\n        float offset = \" + offsetSnippet + \";\\n        float scale = \" + scaleSnippet + \";\\n        float inv = scale * inversesqrt(variance + float(\" + varianceEpsilon + \"));\\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\\n      }\\n    \";\n    }\n    return BatchNormProgram;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar BatchNormPackedProgram = /** @class */ (function () {\n    function BatchNormPackedProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.variableNames = ['x', 'mean', 'variance'];\n        tf.backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n        tf.backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n        var offsetSnippet = 'vec4(0.0)';\n        if (offsetShape != null) {\n            tf.backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n            this.variableNames.push('offset');\n            offsetSnippet = 'getOffsetAtOutCoords()';\n        }\n        var scaleSnippet = 'vec4(1.0)';\n        if (scaleShape != null) {\n            tf.backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n            this.variableNames.push('scale');\n            scaleSnippet = 'getScaleAtOutCoords()';\n        }\n        this.outputShape = xShape;\n        this.userCode = \"\\n      void main() {\\n        vec4 offset = \" + offsetSnippet + \";\\n        vec4 scale = \" + scaleSnippet + \";\\n\\n        vec4 x = getXAtOutCoords();\\n        vec4 mean = getMeanAtOutCoords();\\n        vec4 variance = getVarianceAtOutCoords();\\n\\n        vec4 inv = scale * inversesqrt(variance + vec4(\" + varianceEpsilon + \"));\\n\\n        setOutput((x - mean) * inv + offset);\\n      }\\n    \";\n    }\n    return BatchNormPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar batchNorm = function (_a) {\n    var inputs = _a.inputs, backend = _a.backend, attrs = _a.attrs;\n    var x = inputs.x, mean = inputs.mean, variance = inputs.variance, offset = inputs.offset, scale = inputs.scale;\n    tf.util.assert(mean.shape.length === variance.shape.length, function () { return 'Batch normalization gradient requires mean and variance to have ' +\n        'equal ranks.'; });\n    tf.util.assert(offset == null || mean.shape.length === offset.shape.length, function () { return 'Batch normalization gradient requires mean and offset to have ' +\n        'equal ranks.'; });\n    tf.util.assert(scale == null || mean.shape.length === scale.shape.length, function () { return 'Batch normalization gradient requires mean and scale to have ' +\n        'equal ranks.'; });\n    var varianceEpsilon = attrs.varianceEpsilon;\n    if (varianceEpsilon == null) {\n        varianceEpsilon = 0.001;\n    }\n    var finalInputs = [x, mean, variance];\n    var offsetShape = null;\n    if (offset != null) {\n        offsetShape = offset.shape;\n        finalInputs.push(offset);\n    }\n    var scaleShape = null;\n    if (scale != null) {\n        scaleShape = scale.shape;\n        finalInputs.push(scale);\n    }\n    var program = tf.env().getBool('WEBGL_PACK_NORMALIZATION') ?\n        new BatchNormPackedProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon) :\n        new BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);\n    var output = backend.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);\n    return output;\n};\nvar batchNormConfig = {\n    kernelName: tf.FusedBatchNorm,\n    backendName: 'webgl',\n    kernelFunc: batchNorm,\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SliceProgram = /** @class */ (function () {\n    function SliceProgram(destSize) {\n        this.variableNames = ['source'];\n        this.outputShape = destSize;\n        this.rank = destSize.length;\n        var dtype = getCoordsDataType(this.rank);\n        var uniformPart = \"uniform int start[\" + this.rank + \"];\";\n        var sourceCoords = getCoords(this.rank);\n        var body;\n        var coordSum = destSize.map(function (_, i) {\n            return \"sourceLoc.\" + coords[i] + \" = start[\" + i + \"] + coords.\" + coords[i] + \";\";\n        });\n        body = \"\\n        \" + dtype + \" sourceLoc;\\n        \" + dtype + \" coords = getOutputCoords();\\n        \" + coordSum.join('\\n') + \"\\n      \";\n        this.userCode = \"\\n      \" + uniformPart + \"\\n      void main() {\\n        \" + body + \"\\n        setOutput(getSource(\" + sourceCoords + \"));\\n      }\\n    \";\n    }\n    SliceProgram.prototype.getCustomSetupFunc = function (start) {\n        var _this = this;\n        if (start.length !== this.rank) {\n            throw Error(\"The rank (\" + this.rank + \") of the program must match the \" +\n                (\"length of start (\" + start.length + \")\"));\n        }\n        return function (gpgpu, webGLProgram) {\n            if (_this.startLoc == null) {\n                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n                if (_this.startLoc == null) {\n                    // This means the compiler has optimized and realized it doesn't need\n                    // the uniform.\n                    return;\n                }\n            }\n            gpgpu.gl.uniform1iv(_this.startLoc, start);\n        };\n    };\n    return SliceProgram;\n}());\nvar coords = ['x', 'y', 'z', 'w', 'u', 'v'];\nfunction getCoords(rank) {\n    if (rank === 1) {\n        return 'sourceLoc';\n    }\n    else if (rank <= 6) {\n        return coords.slice(0, rank).map(function (x) { return 'sourceLoc.' + x; }).join(',');\n    }\n    else {\n        throw Error(\"Slicing for rank \" + rank + \" is not yet supported\");\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SlicePackedProgram = /** @class */ (function () {\n    function SlicePackedProgram(destSize) {\n        this.variableNames = ['source'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = destSize;\n        this.rank = destSize.length;\n        var dtype = getCoordsDataType(this.rank);\n        var coords = getChannels('coords', this.rank);\n        var sourceLoc = getChannels('sourceLoc', this.rank);\n        var innerDims = this.rank === 1 ? 'sourceLoc' : \"vec2(\" + sourceLoc.slice(-2).join() + \")\";\n        var getChannel = \"getChannel(getSource(\" + sourceLoc.join() + \"), \" + innerDims + \")\";\n        var upperRow = \"\\n      result.x = \" + getChannel + \";\\n      if (++\" + coords[this.rank - 1] + \" < \" + destSize[this.rank - 1] + \") {\\n        ++\" + sourceLoc[this.rank - 1] + \";\\n        result.y = \" + getChannel + \";\\n        --\" + sourceLoc[this.rank - 1] + \";\\n      }\\n    \";\n        var lowerRow = this.rank === 1 ? '' : \"\\n      --\" + coords[this.rank - 1] + \";\\n      if (++\" + coords[this.rank - 2] + \" < \" + destSize[this.rank - 2] + \") {\\n        ++\" + sourceLoc[this.rank - 2] + \";\\n        result.z = \" + getChannel + \";\\n        if (++\" + coords[this.rank - 1] + \" < \" + destSize[this.rank - 1] + \") {\\n          ++\" + sourceLoc[this.rank - 1] + \";\\n          result.w = \" + getChannel + \";\\n        }\\n      }\\n    \";\n        var sourceLocSetup = this.rank <= 4 ?\n            \"sourceLoc = coords +\\n            \" + dtype + \"(\" + destSize.map(function (_, i) { return \"start[\" + i + \"]\"; }).join() + \");\" :\n            destSize.map(function (_, i) { return sourceLoc[i] + \" = \" + coords[i] + \" + start[\" + i + \"];\"; })\n                .join('\\n');\n        this.userCode = \"\\n      uniform int start[\" + this.rank + \"];\\n      void main() {\\n        \" + dtype + \" coords = getOutputCoords();\\n        \" + dtype + \" sourceLoc;\\n        \" + sourceLocSetup + \"\\n        vec4 result = vec4(0.);\\n        \" + upperRow + \"\\n        \" + lowerRow + \"\\n        setOutput(result);\\n      }\\n    \";\n    }\n    SlicePackedProgram.prototype.getCustomSetupFunc = function (start) {\n        var _this = this;\n        if (start.length !== this.rank) {\n            throw Error(\"The rank (\" + this.rank + \") of the program must match the \" +\n                (\"length of start (\" + start.length + \")\"));\n        }\n        return function (gpgpu, webGLProgram) {\n            if (_this.startLoc == null) {\n                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n                if (_this.startLoc == null) {\n                    // This means the compiler has optimized and realized it doesn't need\n                    // the uniform.\n                    return;\n                }\n            }\n            gpgpu.gl.uniform1iv(_this.startLoc, start);\n        };\n    };\n    return SlicePackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction shallowSlice(x, begin, size, backend) {\n    var xTexData = backend.texData.get(x.dataId);\n    var t = backend.makeTensorInfo(size, x.dtype);\n    var newTexData = backend.texData.get(t.dataId);\n    // Copy texture data from the original tensor.\n    Object.assign(newTexData, xTexData);\n    newTexData.complexParentRefCount = 0;\n    newTexData.refCount = 1;\n    newTexData.shape = size;\n    newTexData.dtype = x.dtype;\n    var flatOffset = tf.slice_util.computeFlatOffset(begin, tf.util.computeStrides(x.shape));\n    if (xTexData.slice) {\n        // We are slicing an already sliced tensor, so we have to accumulate\n        // the offset.\n        flatOffset += xTexData.slice.flatOffset;\n    }\n    newTexData.slice = {\n        flatOffset: flatOffset,\n        // Point to the original dataId, which is used to do ref counting.\n        origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId\n    };\n    // Increase the ref count for that data bucket.\n    var refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;\n    backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);\n    return t;\n}\nfunction slice(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var begin = attrs.begin, size = attrs.size;\n    var _a = tf.slice_util.parseSliceParams(x, begin, size), $begin = _a[0], $size = _a[1];\n    tf.slice_util.assertParamsValid(x, $begin, $size);\n    if (tf.util.sizeFromShape($size) === 0) {\n        return backend.makeTensorInfo($size, x.dtype, []);\n    }\n    // Run on cpu if dtype is string. For string, the backend represents it\n    // as Uint8Array[], where each Uint8Array is a character. Given that the\n    // computation is only on the outer array, uploading the whole data onto\n    // gpu is wasteful. Also, currently webgl doesn't have a design to\n    // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n    // just run the kernel on cpu if dtype is string.\n    if (backend.shouldExecuteOnCPU([x]) || x.dtype === 'string') {\n        var xTexData = backend.texData.get(x.dataId);\n        var outValues = sliceImplCPU(xTexData.values, $begin, $size, x.shape, x.dtype);\n        return backend.makeTensorInfo($size, x.dtype, outValues);\n    }\n    var isPacked = backend.texData.get(x.dataId).isPacked;\n    var isContinous = tf.slice_util.isSliceContinous(x.shape, $begin, $size);\n    if (isPacked || !isContinous) {\n        var program = tf.env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n            new SlicePackedProgram($size) :\n            new SliceProgram($size);\n        var customSetup = program.getCustomSetupFunc($begin);\n        return backend.runWebGLProgram(program, [x], x.dtype, customSetup);\n    }\n    backend.uploadToGPU(x.dataId);\n    return shallowSlice(x, $begin, $size, backend);\n}\nvar sliceConfig = {\n    kernelName: tf.Slice,\n    backendName: 'webgl',\n    kernelFunc: slice\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar batchToSpaceND = function (args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var blockShape = attrs.blockShape, crops = attrs.crops;\n    tf.util.assert(x.shape.length <= 4, function () { return 'batchToSpaceND for rank > 4 with a WebGL backend not ' +\n        'implemented yet'; });\n    var prod = blockShape.reduce(function (a, b) { return a * b; });\n    var reshaped = tf.backend_util.getReshaped(x.shape, blockShape, prod);\n    var permuted = tf.backend_util.getPermuted(reshaped.length, blockShape.length);\n    var reshapedPermuted = tf.backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n    var sliceBeginCoords = tf.backend_util.getSliceBeginCoords(crops, blockShape.length);\n    var sliceSize = tf.backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n    var toDispose = [];\n    var reshapedIntermediate = reshape({ inputs: { x: x }, backend: backend, attrs: { shape: reshaped } });\n    var transposedIntermediate = transpose({ inputs: { x: reshapedIntermediate }, backend: backend, attrs: { perm: permuted } });\n    var reshapedIntermediate2 = reshape({\n        inputs: { x: transposedIntermediate },\n        backend: backend,\n        attrs: { shape: reshapedPermuted }\n    });\n    var sliced = slice({\n        inputs: { x: reshapedIntermediate2 },\n        backend: backend,\n        attrs: { begin: sliceBeginCoords, size: sliceSize }\n    });\n    toDispose.push(reshapedIntermediate);\n    toDispose.push(transposedIntermediate);\n    toDispose.push(reshapedIntermediate2);\n    toDispose.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return sliced;\n};\nvar batchToSpaceNDConfig = {\n    kernelName: tf.BatchToSpaceND,\n    backendName: 'webgl',\n    kernelFunc: batchToSpaceND\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction bincount(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, weights = inputs.weights;\n    var size = attrs.size;\n    var xVals = backend.readSync(x.dataId);\n    var weightsVals = backend.readSync(weights.dataId);\n    var outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);\n    return backend.makeTensorInfo([size], weights.dtype, outVals);\n}\nvar bincountConfig = {\n    kernelName: tf.Bincount,\n    backendName: 'webgl',\n    kernelFunc: bincount\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar NOT_EQUAL = \"return float(a != b);\";\nvar notEqual = binaryKernelFunc({ opSnippet: NOT_EQUAL, dtype: 'bool' });\nvar notEqualConfig = {\n    kernelName: tf.NotEqual,\n    backendName: 'webgl',\n    kernelFunc: notEqual,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction real(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var input = inputs.input;\n    var inputData = backend.texData.get(input.dataId);\n    return identity({ inputs: { x: inputData.complexTensorInfos.real }, backend: backend });\n}\nvar realConfig = {\n    kernelName: tf.Real,\n    backendName: 'webgl',\n    kernelFunc: real\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar TO_INT = \"return float(int(x));\";\nfunction int(input, backend) {\n    var program = new UnaryOpProgram(input.shape, TO_INT);\n    var output = backend.runWebGLProgram(program, [input], 'int32');\n    return { dataId: output.dataId, shape: output.shape, dtype: output.dtype };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction cast(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var dtype = attrs.dtype;\n    // Casting to complex64.\n    if (dtype === 'complex64') {\n        if (x.dtype === 'complex64') {\n            return identity({ inputs: { x: x }, backend: backend });\n        }\n        // TODO(annxingyuan): Import kernel function once zeros is modularized.\n        var zerosTensor = tf.zeros(x.shape);\n        var floatX = cast({ inputs: { x: x }, backend: backend, attrs: { dtype: 'float32' } });\n        var result = complex({ inputs: { real: floatX, imag: zerosTensor }, backend: backend });\n        zerosTensor.dispose();\n        backend.disposeIntermediateTensorInfo(floatX);\n        return result;\n    }\n    // Casting from complex64\n    if (x.dtype === 'complex64') {\n        var realPart = real({ inputs: { input: x }, backend: backend });\n        var result = cast({ inputs: { x: realPart }, backend: backend, attrs: { dtype: dtype } });\n        backend.disposeIntermediateTensorInfo(realPart);\n        return result;\n    }\n    if (!tf.util.hasEncodingLoss(x.dtype, dtype)) {\n        // We don't change the underlying data, since we cast to higher\n        // precision.\n        var result = identity({ inputs: { x: x }, backend: backend });\n        return { dataId: result.dataId, shape: result.shape, dtype: dtype };\n    }\n    if (dtype === 'int32') {\n        return int(x, backend);\n    }\n    if (dtype === 'bool') {\n        var zerosTensorInfo = backend.makeTensorInfo([], 'bool', tf.util.getTypedArrayFromDType('bool', 1));\n        var binaryInputs = { a: x, b: zerosTensorInfo };\n        var result = notEqual({ inputs: binaryInputs, backend: backend });\n        backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n        return result;\n    }\n    throw new Error(\"Error in Cast: failed to cast \" + x.dtype + \" to \" + dtype);\n}\nvar castConfig = {\n    kernelName: tf.Cast,\n    backendName: 'webgl',\n    kernelFunc: cast\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar CEIL = \"return ceil(x);\";\nvar ceil = unaryKernelFunc({ opSnippet: CEIL, packedOpSnippet: CEIL, cpuKernelImpl: ceilImplCPU });\nvar ceilConfig = {\n    kernelName: tf.Ceil,\n    backendName: 'webgl',\n    kernelFunc: ceil\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ClipProgram = /** @class */ (function () {\n    function ClipProgram(aShape) {\n        this.variableNames = ['A'];\n        this.outputShape = aShape;\n        this.userCode = \"\\n      uniform float minVal;\\n      uniform float maxVal;\\n\\n      void main() {\\n        float value = getAAtOutCoords();\\n        if (isnan(value)) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, minVal, maxVal));\\n      }\\n    \";\n    }\n    ClipProgram.prototype.getCustomSetupFunc = function (min, max) {\n        var _this = this;\n        return function (gpgpu, webGLProgram) {\n            if (_this.minLoc == null) {\n                _this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n                _this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n            }\n            gpgpu.gl.uniform1f(_this.minLoc, min);\n            gpgpu.gl.uniform1f(_this.maxLoc, max);\n        };\n    };\n    return ClipProgram;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ClipPackedProgram = /** @class */ (function () {\n    function ClipPackedProgram(aShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = aShape;\n        this.userCode = \"\\n      uniform float minVal;\\n      uniform float maxVal;\\n\\n      void main() {\\n        vec4 value = getAAtOutCoords();\\n\\n        if (any(isnan(value))) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\\n      }\\n    \";\n    }\n    ClipPackedProgram.prototype.getCustomSetupFunc = function (min, max) {\n        var _this = this;\n        return function (gpgpu, webGLProgram) {\n            if (_this.minLoc == null) {\n                _this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n                _this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n            }\n            gpgpu.gl.uniform1f(_this.minLoc, min);\n            gpgpu.gl.uniform1f(_this.maxLoc, max);\n        };\n    };\n    return ClipPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction clipByValue(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var clipValueMin = attrs.clipValueMin, clipValueMax = attrs.clipValueMax;\n    var program;\n    if (tf.env().getBool('WEBGL_PACK_CLIP')) {\n        program = new ClipPackedProgram(x.shape);\n    }\n    else {\n        program = new ClipProgram(x.shape);\n    }\n    var customSetup = program.getCustomSetupFunc(clipValueMin, clipValueMax);\n    return backend.runWebGLProgram(program, [x], x.dtype, customSetup);\n}\nvar clipByValueConfig = {\n    kernelName: tf.ClipByValue,\n    backendName: 'webgl',\n    kernelFunc: clipByValue\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ComplexAbsProgram = /** @class */ (function () {\n    function ComplexAbsProgram(shape) {\n        this.variableNames = ['real', 'imag'];\n        this.outputShape = shape;\n        this.userCode = \"\\n      void main() {\\n        float re = abs(getRealAtOutCoords());\\n        float im = abs(getImagAtOutCoords());\\n        float mx = max(re, im);\\n\\n        // sadly the length function in glsl is not underflow-safe\\n        // (at least not on Intel GPUs). So the safe solution is\\n        // to ensure underflow-safety in all cases.\\n        setOutput(\\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\\n        );\\n      }\\n    \";\n    }\n    return ComplexAbsProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Returns a TensorInfo with the complex shape and the dataId of the\n// underlying part. We need to do this because a reshaped complex tensor is\n// not reflected in its parts.\nfunction makeComplexComponentTensorInfo(complexTensor, complexPart) {\n    return {\n        dataId: complexPart.dataId,\n        dtype: complexPart.dtype,\n        shape: complexTensor.shape\n    };\n}\nfunction complexAbs(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    var xData = backend.texData.get(x.dataId);\n    var program = new ComplexAbsProgram(x.shape);\n    var programInputs = [\n        makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),\n        makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag),\n    ];\n    return backend.runWebGLProgram(program, programInputs, programInputs[0].dtype);\n}\nvar complexAbsConfig = {\n    kernelName: tf.ComplexAbs,\n    backendName: 'webgl',\n    kernelFunc: complexAbs\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ConcatProgram = /** @class */ (function () {\n    // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().\n    function ConcatProgram(shapes) {\n        this.outputShape = [];\n        this.outputShape = tf.backend_util.computeOutShape(shapes, 1 /* axis */);\n        this.variableNames = shapes.map(function (_, i) { return \"T\" + i; });\n        var offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][1];\n        for (var i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][1];\n        }\n        var snippets = [\"if (yC < \" + offsets[0] + \") setOutput(getT0(yR, yC));\"];\n        for (var i = 1; i < offsets.length; i++) {\n            var shift = offsets[i - 1];\n            snippets.push(\"else if (yC < \" + offsets[i] + \") \" +\n                (\"setOutput(getT\" + i + \"(yR, yC-\" + shift + \"));\"));\n        }\n        var lastIndex = offsets.length;\n        var lastShift = offsets[offsets.length - 1];\n        snippets.push(\"else setOutput(getT\" + lastIndex + \"(yR, yC-\" + lastShift + \"));\");\n        this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int yR = coords.x;\\n        int yC = coords.y;\\n\\n        \" + snippets.join('\\n        ') + \"\\n      }\\n    \";\n    }\n    return ConcatProgram;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ConcatPackedProgram = /** @class */ (function () {\n    function ConcatPackedProgram(shapes, axis) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        this.outputShape = tf.backend_util.computeOutShape(shapes, axis);\n        var shape = this.outputShape;\n        var rank = shape.length;\n        var dtype = getCoordsDataType(rank);\n        var coords = getChannels('coords', rank);\n        var channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n        this.variableNames = shapes.map(function (_, i) { return \"T\" + i; });\n        var offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][axis];\n        for (var i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][axis];\n        }\n        var channel = channels[axis];\n        var lastChannels = channels.slice(-2);\n        var allChannels = channels.join();\n        var getValueSnippet = \"if (\" + channel + \" < \" + offsets[0] + \") {\\n        return getChannel(\\n            getT0(\" + allChannels + \"), vec2(\" + lastChannels.join() + \"));\\n        }\";\n        for (var i = 1; i < offsets.length; i++) {\n            var shift_1 = offsets[i - 1];\n            // Note: the >= comparison below may seem unnecessary given the check\n            // above but is needed to workaround branch execution issues on some\n            // devices. It makes all the conditions exclusive without relying on\n            // execution order.\n            getValueSnippet += \"\\n        if (\" + channel + \" < \" + offsets[i] + \"  && \" + channel + \" >= \" + offsets[i - 1] + \") {\\n          return getChannel(\\n            getT\" + i + \"(\" + shiftedChannels(channels, channel, shift_1) + \"),\\n            vec2(\" + shiftedChannels(lastChannels, channel, shift_1) + \"));\\n        }\";\n        }\n        var lastIndex = offsets.length;\n        var shift = offsets[offsets.length - 1];\n        getValueSnippet += \"\\n        return getChannel(\\n          getT\" + lastIndex + \"(\" + shiftedChannels(channels, channel, shift) + \"),\\n          vec2(\" + shiftedChannels(lastChannels, channel, shift) + \"));\";\n        this.userCode = \"\\n      float getValue(\" + channels.map(function (x) { return 'int ' + x; }) + \") {\\n        \" + getValueSnippet + \"\\n      }\\n\\n      void main() {\\n        \" + dtype + \" coords = getOutputCoords();\\n        vec4 result = vec4(getValue(\" + coords + \"), 0., 0., 0.);\\n\\n        \" + coords[rank - 1] + \" = \" + coords[rank - 1] + \" + 1;\\n        if (\" + coords[rank - 1] + \" < \" + shape[rank - 1] + \") {\\n          result.g = getValue(\" + coords + \");\\n        }\\n\\n        \" + coords[rank - 2] + \" = \" + coords[rank - 2] + \" + 1;\\n        if (\" + coords[rank - 2] + \" < \" + shape[rank - 2] + \") {\\n          result.a = getValue(\" + coords + \");\\n        }\\n\\n        \" + coords[rank - 1] + \" = \" + coords[rank - 1] + \" - 1;\\n        if (\" + coords[rank - 2] + \" < \" + shape[rank - 2] + \" &&\\n            \" + coords[rank - 1] + \" < \" + shape[rank - 1] + \") {\\n          result.b = getValue(\" + coords + \");\\n        }\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return ConcatPackedProgram;\n}());\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels, channel, shift) {\n    var channelIdx = channels.indexOf(channel);\n    var res = channels.map(function (c, idx) {\n        if (idx === channelIdx) {\n            return c + \" - \" + shift;\n        }\n        else {\n            return c;\n        }\n    });\n    return res.join();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction imag(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var input = inputs.input;\n    var inputData = backend.texData.get(input.dataId);\n    return identity({ inputs: { x: inputData.complexTensorInfos.imag }, backend: backend });\n}\nvar imagConfig = {\n    kernelName: tf.Imag,\n    backendName: 'webgl',\n    kernelFunc: imag\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction concatImpl$1(inputs, axis, backend) {\n    var dtype = inputs[0].dtype;\n    if (dtype === 'complex64') {\n        var reals = inputs.map(function (t) { return real({ inputs: { input: t }, backend: backend }); });\n        var imags = inputs.map(function (t) { return imag({ inputs: { input: t }, backend: backend }); });\n        var realConcated = concatImpl$1(reals, axis, backend);\n        var imagConcated = concatImpl$1(imags, axis, backend);\n        var result_1 = complex({ inputs: { real: realConcated, imag: imagConcated }, backend: backend });\n        reals.forEach(function (r) { return backend.disposeIntermediateTensorInfo(r); });\n        imags.forEach(function (i) { return backend.disposeIntermediateTensorInfo(i); });\n        backend.disposeIntermediateTensorInfo(realConcated);\n        backend.disposeIntermediateTensorInfo(imagConcated);\n        return result_1;\n    }\n    // Run on cpu if dtype is string. For string, the backend represents it\n    // as Uint8Array[], where each Uint8Array is a character. Given that the\n    // computation is only on the outer array, uploading the whole data onto\n    // gpu is wasteful. Also, currently webgl doesn't have a design to\n    // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n    // just run the kernel on cpu if dtype is string.\n    if (dtype === 'string') {\n        var _a = computeTensors2D(inputs, axis, backend), tensors2D_1 = _a.tensors2D, outShape_1 = _a.outShape;\n        var inputsValShapes = tensors2D_1.map(function (t) {\n            return { vals: backend.readSync(t.dataId), shape: t.shape };\n        });\n        var simplyConcat = tensors2D_1[0].shape[0] === 1;\n        var outVals = concatImplCPU(inputsValShapes, outShape_1, dtype, simplyConcat);\n        var finalOutShape = tf.backend_util.computeOutShape(inputs.map(function (t) { return t.shape; }), axis);\n        var outInfo = backend.makeTensorInfo(finalOutShape, dtype, outVals);\n        tensors2D_1.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n        return outInfo;\n    }\n    if (inputs.length > tf.env().getNumber('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n        var midIndex = Math.floor(inputs.length / 2);\n        var leftSide = concatImpl$1(inputs.slice(0, midIndex), axis, backend);\n        var rightSide = concatImpl$1(inputs.slice(midIndex), axis, backend);\n        var result_2 = concatImpl$1([leftSide, rightSide], axis, backend);\n        backend.disposeIntermediateTensorInfo(leftSide);\n        backend.disposeIntermediateTensorInfo(rightSide);\n        return result_2;\n    }\n    if (tf.env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') &&\n        inputs[0].shape.length > 1) {\n        var program_1 = new ConcatPackedProgram(inputs.map(function (t) { return t.shape; }), axis);\n        return backend.runWebGLProgram(program_1, inputs, dtype);\n    }\n    var _b = computeTensors2D(inputs, axis, backend), tensors2D = _b.tensors2D, outShape = _b.outShape;\n    var program = new ConcatProgram(tensors2D.map(function (t) { return t.shape; }));\n    var result = backend.runWebGLProgram(program, tensors2D, dtype);\n    tensors2D.forEach(function (r) { return backend.disposeIntermediateTensorInfo(r); });\n    var reshapedResult = reshape({ inputs: { x: result }, attrs: { shape: outShape }, backend: backend });\n    backend.disposeIntermediateTensorInfo(result);\n    return reshapedResult;\n}\nfunction computeTensors2D(inputs, axis, backend) {\n    // Any concat of n-dimensional tensors across any axis can be reduced to\n    // a concatenation of two-dimensional tensors across the axis 1 by first\n    // partitioning the axes of the original tensors into those less than the\n    // axis to be concatenated and the rest. Then reshape the tensors\n    // into a two-dimensional tensor by collapsing these two sets of axes and\n    // concatenate the resulting matrices across the axis 1, finally reshaping\n    // the result to have the proper shape.\n    var outShape = tf.backend_util.computeOutShape(inputs.map(function (t) { return t.shape; }), axis);\n    var tensors2D = inputs.map(function (x) { return reshape({\n        inputs: { x: x },\n        attrs: { shape: [-1, tf.util.sizeFromShape(x.shape.slice(axis))] },\n        backend: backend\n    }); });\n    return { tensors2D: tensors2D, outShape: outShape };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction concat(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var axis = attrs.axis;\n    var $axis = tf.util.parseAxisParam(axis, inputs[0].shape)[0];\n    var outShape = tf.backend_util.computeOutShape(inputs.map(function (t) { return t.shape; }), $axis);\n    if (tf.util.sizeFromShape(outShape) === 0) {\n        return backend.makeTensorInfo(outShape, inputs[0].dtype, []);\n    }\n    // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n    var $inputs = inputs.filter(function (t) { return tf.util.sizeFromShape(t.shape) > 0; });\n    if ($inputs.length === 1) {\n        return identity({ inputs: { x: $inputs[0] }, backend: backend });\n    }\n    var shapes = $inputs.map(function (t) { return t.shape; });\n    tf.backend_util.assertParamsConsistent(shapes, $axis);\n    return concatImpl$1($inputs, $axis, backend);\n}\nvar concatConfig = {\n    kernelName: tf.Concat,\n    backendName: 'webgl',\n    kernelFunc: concat\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar Conv2DProgram = /** @class */ (function () {\n    function Conv2DProgram(convInfo, addBias, activation, hasPreluActivationWeights, hasLeakyreluAlpha) {\n        if (addBias === void 0) { addBias = false; }\n        if (activation === void 0) { activation = null; }\n        if (hasPreluActivationWeights === void 0) { hasPreluActivationWeights = false; }\n        if (hasLeakyreluAlpha === void 0) { hasLeakyreluAlpha = false; }\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var dilationHeight = convInfo.dilationHeight;\n        var dilationWidth = convInfo.dilationWidth;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        var inputDepthVec4Remainder = convInfo.inChannels % 4;\n        var isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        var rowDim = isChannelsLast ? 1 : 2;\n        var colDim = isChannelsLast ? 2 : 3;\n        var channelDim = isChannelsLast ? 3 : 1;\n        var activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivationWeights) {\n                activationSnippet = \"float activation(float a) {\\n          float b = getPreluActivationWeightsAtOutCoords();\\n          \" + activation + \"\\n        }\";\n            }\n            else if (hasLeakyreluAlpha) {\n                activationSnippet = \"float activation(float a) {\\n          float b = getLeakyreluAlphaAtOutCoords();\\n          \" + activation + \"\\n        }\";\n            }\n            else {\n                activationSnippet = \"\\n          float activation(float x) {\\n            \" + activation + \"\\n          }\\n        \";\n            }\n            applyActivationSnippet = \"result = activation(result);\";\n        }\n        var addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivationWeights) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyreluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = \"\\n      \" + activationSnippet + \"\\n\\n      const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d2 = coords[\" + channelDim + \"];\\n\\n        ivec2 xRCCorner =\\n            ivec2(coords[\" + rowDim + \"], coords[\" + colDim + \"]) * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n          int xR = xRCorner + wR * \" + dilationHeight + \";\\n\\n          if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n            int xC = xCCorner + wC * \" + dilationWidth + \";\\n\\n            if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n              continue;\\n            }\\n\\n            for (int d1 = 0; d1 < \" + inputDepthNearestVec4 + \"; d1 += 4) {\\n              vec4 wValues = vec4(\\n                getW(wR, wC, d1, d2),\\n                getW(wR, wC, d1 + 1, d2),\\n                getW(wR, wC, d1 + 2, d2),\\n                getW(wR, wC, d1 + 3, d2)\\n              );\\n\\n              if (\" + isChannelsLast + \") {\\n                vec4 xValues = vec4(\\n                  getX(batch, xR, xC, d1),\\n                  getX(batch, xR, xC, d1 + 1),\\n                  getX(batch, xR, xC, d1 + 2),\\n                  getX(batch, xR, xC, d1 + 3)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec4 xValues = vec4(\\n                  getX(batch, d1, xR, xC),\\n                  getX(batch, d1 + 1, xR, xC),\\n                  getX(batch, d1 + 2, xR, xC),\\n                  getX(batch, d1 + 3, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n            }\\n\\n            if (\" + (inputDepthVec4Remainder === 1) + \") {\\n\\n              if (\" + isChannelsLast + \") {\\n                dotProd +=\\n                    getX(batch, xR, xC, \" + inputDepthNearestVec4 + \") *\\n                    getW(wR, wC, \" + inputDepthNearestVec4 + \", d2);\\n              } else {\\n                dotProd +=\\n                    getX(batch, \" + inputDepthNearestVec4 + \", xR, xC) *\\n                    getW(wR, wC, \" + inputDepthNearestVec4 + \", d2);\\n              }\\n\\n            } else if (\" + (inputDepthVec4Remainder === 2) + \") {\\n              vec2 wValues = vec2(\\n                getW(wR, wC, \" + inputDepthNearestVec4 + \", d2),\\n                getW(wR, wC, \" + inputDepthNearestVec4 + \" + 1, d2)\\n              );\\n\\n              if (\" + isChannelsLast + \") {\\n                vec2 xValues = vec2(\\n                  getX(batch, xR, xC, \" + inputDepthNearestVec4 + \"),\\n                  getX(batch, xR, xC, \" + inputDepthNearestVec4 + \" + 1)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec2 xValues = vec2(\\n                  getX(batch, \" + inputDepthNearestVec4 + \", xR, xC),\\n                  getX(batch, \" + inputDepthNearestVec4 + \" + 1, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n            } else if (\" + (inputDepthVec4Remainder === 3) + \") {\\n              vec3 wValues = vec3(\\n                getW(wR, wC, \" + inputDepthNearestVec4 + \", d2),\\n                getW(wR, wC, \" + inputDepthNearestVec4 + \" + 1, d2),\\n                getW(wR, wC, \" + inputDepthNearestVec4 + \" + 2, d2)\\n              );\\n\\n              if (\" + isChannelsLast + \") {\\n                vec3 xValues = vec3(\\n                  getX(batch, xR, xC, \" + inputDepthNearestVec4 + \"),\\n                  getX(batch, xR, xC, \" + inputDepthNearestVec4 + \" + 1),\\n                  getX(batch, xR, xC, \" + inputDepthNearestVec4 + \" + 2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec3 xValues = vec3(\\n                  getX(batch, \" + inputDepthNearestVec4 + \", xR, xC),\\n                  getX(batch, \" + inputDepthNearestVec4 + \" + 1, xR, xC),\\n                  getX(batch, \" + inputDepthNearestVec4 + \" + 2, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n            }\\n          }\\n        }\\n\\n        float result = dotProd;\\n        \" + addBiasSnippet + \"\\n        \" + applyActivationSnippet + \"\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return Conv2DProgram;\n}());\nvar Conv3DProgram = /** @class */ (function () {\n    function Conv3DProgram(convInfo) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        var padFront = convInfo.padInfo.front;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        var strideDepth = convInfo.strideDepth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var dilationDepth = convInfo.dilationDepth;\n        var dilationHeight = convInfo.dilationHeight;\n        var dilationWidth = convInfo.dilationWidth;\n        var filterDepth = convInfo.filterDepth;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        var inputDepthVec4Remainder = convInfo.inChannels % 4;\n        this.userCode = \"\\n      const ivec3 strides = ivec3(\" + strideDepth + \", \" + strideHeight + \", \" + strideWidth + \");\\n      const ivec3 pads = ivec3(\" + padFront + \", \" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d2 = coords.u;\\n\\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xFCorner = xFRCCorner.x;\\n        int xRCorner = xFRCCorner.y;\\n        int xCCorner = xFRCCorner.z;\\n\\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\\n        // values in that axis.\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < \" + filterDepth + \"; wF++) {\\n          int xF = xFCorner + wF * \" + dilationDepth + \";\\n\\n          if (xF < 0 || xF >= \" + convInfo.inDepth + \") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n            int xR = xRCorner + wR * \" + dilationHeight + \";\\n\\n            if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n              int xC = xCCorner + wC * \" + dilationWidth + \";\\n\\n              if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n                continue;\\n              }\\n\\n              for (int d1 = 0; d1 < \" + inputDepthNearestVec4 + \"; d1 += 4) {\\n                vec4 xValues = vec4(\\n                  getX(batch, xF, xR, xC, d1),\\n                  getX(batch, xF, xR, xC, d1 + 1),\\n                  getX(batch, xF, xR, xC, d1 + 2),\\n                  getX(batch, xF, xR, xC, d1 + 3)\\n                );\\n                vec4 wValues = vec4(\\n                  getW(wF, wR, wC, d1, d2),\\n                  getW(wF, wR, wC, d1 + 1, d2),\\n                  getW(wF, wR, wC, d1 + 2, d2),\\n                  getW(wF, wR, wC, d1 + 3, d2)\\n                );\\n\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n              if (\" + (inputDepthVec4Remainder === 1) + \") {\\n                dotProd +=\\n                  getX(batch, xF, xR, xC, \" + inputDepthNearestVec4 + \") *\\n                  getW(wF, wR, wC, \" + inputDepthNearestVec4 + \", d2);\\n              } else if (\" + (inputDepthVec4Remainder === 2) + \") {\\n                vec2 xValues = vec2(\\n                  getX(batch, xF, xR, xC, \" + inputDepthNearestVec4 + \"),\\n                  getX(batch, xF, xR, xC, \" + inputDepthNearestVec4 + \" + 1)\\n                );\\n                vec2 wValues = vec2(\\n                  getW(wF, wR, wC, \" + inputDepthNearestVec4 + \", d2),\\n                  getW(wF, wR, wC, \" + inputDepthNearestVec4 + \" + 1, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else if (\" + (inputDepthVec4Remainder === 3) + \") {\\n                vec3 xValues = vec3(\\n                  getX(batch, xF, xR, xC, \" + inputDepthNearestVec4 + \"),\\n                  getX(batch, xF, xR, xC, \" + inputDepthNearestVec4 + \" + 1),\\n                  getX(batch, xF, xR, xC, \" + inputDepthNearestVec4 + \" + 2)\\n                );\\n                vec3 wValues = vec3(\\n                  getW(wF, wR, wC, \" + inputDepthNearestVec4 + \", d2),\\n                  getW(wF, wR, wC, \" + inputDepthNearestVec4 + \" + 1, d2),\\n                  getW(wF, wR, wC, \" + inputDepthNearestVec4 + \" + 2, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return Conv3DProgram;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar Im2ColPackedProgram = /** @class */ (function () {\n    function Im2ColPackedProgram(outputShape, inputShape, convInfo) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        var filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels, strideWidth = convInfo.strideWidth, strideHeight = convInfo.strideHeight, padInfo = convInfo.padInfo, outWidth = convInfo.outWidth, dilationWidth = convInfo.dilationWidth, dilationHeight = convInfo.dilationHeight, dataFormat = convInfo.dataFormat;\n        var left = padInfo.left, top = padInfo.top;\n        var itemsPerBlockRow = inChannels * filterWidth;\n        var glsl = getGlslDifferences();\n        var isChannelsLast = dataFormat === 'channelsLast';\n        var rowDim = isChannelsLast ? 0 : 1;\n        var colDim = isChannelsLast ? 1 : 2;\n        var unrolled = \"\";\n        for (var row = 0; row <= 1; row++) {\n            for (var col = 0; col <= 1; col++) {\n                unrolled += \"\\n          blockIndex = rc.y + \" + col + \";\\n          pos = rc.x + \" + row + \";\\n\\n          if(blockIndex < \" + outputShape[1] + \" && pos < \" + outputShape[0] + \") {\\n            offsetY = int(blockIndex / (\" + outWidth + \")) * \" + strideHeight + \" - \" + top + \";\\n            d0 = offsetY + \" + dilationHeight + \" * (pos / \" + itemsPerBlockRow + \");\\n\\n            if(d0 < \" + inputShape[rowDim] + \" && d0 >= 0) {\\n\\n              offsetX = int(mod(float(blockIndex), \" + outWidth + \".) * \" + strideWidth + \". - \" + left + \".);\\n              d1 = offsetX + \" + dilationWidth + \" * (int(mod(float(pos), \" + itemsPerBlockRow + \".) / \" + inChannels + \".));\\n\\n              if(d1 < \" + inputShape[colDim] + \" && d1 >= 0) {\\n\\n                ch = int(mod(float(pos), \" + inChannels + \".));\\n\\n                if (\" + isChannelsLast + \") {\\n                  innerDims = vec2(d1, ch);\\n                  result[\" + (row * 2 + col) + \"] = getChannel(\\n                    getA(d0, int(innerDims.x),\\n                    int(innerDims.y)), innerDims);\\n                } else {\\n                  innerDims = vec2(d0, d1);\\n                  result[\" + (row * 2 + col) + \"] = getChannel(\\n                    getA(ch, int(innerDims.x),\\n                    int(innerDims.y)), innerDims);\\n                }\\n              }\\n            }\\n          }\\n        \";\n            }\n        }\n        this.userCode = \"\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0);\\n\\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\\n        vec2 innerDims;\\n\\n        \" + unrolled + \"\\n\\n        \" + glsl.output + \" = result;\\n      }\\n    \";\n    }\n    return Im2ColPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// For 1x1 kernels that iterate through every point in the input, convolution\n// can be expressed as matrix multiplication (without need for memory\n// remapping).\nfunction conv2dByMatMul(_a) {\n    var x = _a.x, filter = _a.filter, convInfo = _a.convInfo, backend = _a.backend, _b = _a.bias, bias = _b === void 0 ? null : _b, _c = _a.preluActivationWeights, preluActivationWeights = _c === void 0 ? null : _c, _d = _a.leakyreluAlpha, leakyreluAlpha = _d === void 0 ? 0 : _d, _e = _a.activation, activation = _e === void 0 ? null : _e;\n    // Reshapes conv2D input to 2D tensors, uses matMul and then reshape the\n    // result from 2D to 4D.\n    var xShape = x.shape;\n    var xTexData = backend.texData.get(x.dataId);\n    var sharedMatMulDim = convInfo.inChannels;\n    var outerShapeX = xShape[0] * xShape[1] * xShape[2];\n    var outerShapeFilter = convInfo.outChannels;\n    var isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    var transposeA = false;\n    var transposeB = false;\n    var out;\n    var intermediates = [];\n    // TODO: Once reduction ops are packed, batchMatMul will always be packed\n    // and we can remove this condition.\n    var batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) &&\n        sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;\n    var reshapeWillBeExpensive = xShape[2] % 2 !== 0 && !!xTexData.isPacked;\n    if (batchMatMulWillBeUnpacked || !tf.env().getBool('WEBGL_LAZILY_UNPACK') ||\n        !tf.env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ||\n        !reshapeWillBeExpensive) {\n        var targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] :\n            xShape[0] * xShape[2] * xShape[3];\n        var xReshaped = reshape({\n            inputs: { x: x },\n            backend: backend,\n            attrs: { shape: [1, targetShape, convInfo.inChannels] }\n        });\n        var filterReshaped = reshape({\n            inputs: { x: filter },\n            backend: backend,\n            attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }\n        });\n        var result = batchMatMulImpl({\n            a: xReshaped,\n            b: filterReshaped,\n            transposeA: transposeA,\n            transposeB: transposeB,\n            backend: backend,\n            bias: bias,\n            activation: activation,\n            preluActivationWeights: preluActivationWeights,\n            leakyreluAlpha: leakyreluAlpha\n        });\n        out = reshape({ inputs: { x: result }, backend: backend, attrs: { shape: convInfo.outShape } });\n        intermediates.push(xReshaped);\n        intermediates.push(filterReshaped);\n        intermediates.push(result);\n    }\n    else {\n        // Following optimization is specific to packed |x| with odd row count\n        // (For example, in channelLast mode, 'row count' refers to x.shape[2]):\n        // we avoid expensive packed 2x2 reshape by padding row count to next,\n        // even number. When x.shape[2] is odd, the result of packed batchMatMul is\n        // the same (has the same texture layout and and values in the texture) as\n        // it is for even x.shape[2] + 1. We make the odd-rows tensor to look like\n        // even-rows tensor before the operation and, after the batchMatMul,\n        // fix the even-rows result to have odd number of rows.\n        var targetShape = isChannelsLast ?\n            xShape[0] * xShape[1] * (xShape[2] + 1) :\n            xShape[0] * xShape[2] * (xShape[3] + 1);\n        var xReshaped_1 = {\n            dataId: x.dataId,\n            shape: [1, targetShape, convInfo.inChannels],\n            dtype: x.dtype\n        };\n        // xTexData.shape gets referenced from GPGPUBinary.inShapeInfos.\n        // Decrementing row count, after batchMatMul->...->compileProgram leads to\n        // invalid row count within the reference in GPGPUBinary.inShapeInfos.\n        // Alternative fix would be to provide a copy to GPGPUBinary.inShapeInfos\n        // in compileProgram method, but that would affect compilation of all\n        // programs - instead, provide a copy here, with even row count, before\n        // calling batchMatMul->...->compileProgram and after that, the original\n        // xTexData.shape is restored.\n        var originalXTexDataShape = xTexData.shape;\n        xTexData.shape = xTexData.shape.slice();\n        xTexData.shape[xTexData.shape.length - 2]++;\n        tf.util.assert(isReshapeFree(xTexData.shape, xReshaped_1.shape), function () { return \"packed reshape \" + xTexData.shape + \" to \" + xReshaped_1.shape + \" isn't free\"; });\n        var filterReshaped = reshape({\n            inputs: { x: filter },\n            backend: backend,\n            attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }\n        });\n        intermediates.push(filterReshaped);\n        var pointwiseConv = batchMatMulImpl({\n            a: xReshaped_1,\n            b: filterReshaped,\n            backend: backend,\n            transposeA: transposeA,\n            transposeB: transposeB,\n            bias: bias,\n            activation: activation,\n            preluActivationWeights: preluActivationWeights,\n            leakyreluAlpha: leakyreluAlpha\n        });\n        var pointwiseConvTexData = backend.texData.get(pointwiseConv.dataId);\n        tf.util.assert(pointwiseConvTexData.isPacked, function () { return 'batchMatMul result is expected to be packed'; });\n        // Restore the input shape to original.\n        xTexData.shape = originalXTexDataShape;\n        // Set the output shape - there is no need for expensive reshape as data\n        // layout is already correct.\n        pointwiseConvTexData.shape = convInfo.outShape;\n        out = identity({ inputs: { x: pointwiseConv }, backend: backend });\n        out.shape = convInfo.outShape;\n        intermediates.push(pointwiseConv);\n    }\n    for (var _i = 0, intermediates_1 = intermediates; _i < intermediates_1.length; _i++) {\n        var i = intermediates_1[_i];\n        backend.disposeIntermediateTensorInfo(i);\n    }\n    return out;\n}\n// Implements the im2row algorithm as outlined in \"High Performance\n// Convolutional Neural Networks for Document Processing\" (Suvisoft, 2006)\nfunction conv2dWithIm2Row(_a) {\n    var x = _a.x, filter = _a.filter, convInfo = _a.convInfo, backend = _a.backend, _b = _a.bias, bias = _b === void 0 ? null : _b, _c = _a.preluActivationWeights, preluActivationWeights = _c === void 0 ? null : _c, _d = _a.leakyreluAlpha, leakyreluAlpha = _d === void 0 ? 0 : _d, _e = _a.activation, activation = _e === void 0 ? null : _e;\n    // Rearranges conv2d input so each block to be convolved over forms the\n    // column of a new matrix with shape [filterWidth * filterHeight *\n    // inChannels, outHeight * outWidth]. The filter is also rearranged so each\n    // output channel forms a row of a new matrix with shape [outChannels,\n    // filterWidth * filterHeight * inChannels]. The convolution is then\n    // computed by multiplying these matrices and reshaping the result.\n    var filterWidth = convInfo.filterWidth, filterHeight = convInfo.filterHeight, inChannels = convInfo.inChannels, outWidth = convInfo.outWidth, outHeight = convInfo.outHeight, dataFormat = convInfo.dataFormat;\n    var isChannelsLast = dataFormat === 'channelsLast';\n    var sharedDim = filterWidth * filterHeight * inChannels;\n    var numCols = outHeight * outWidth;\n    var x2ColShape = [sharedDim, numCols];\n    var transposeA = true;\n    var transposeB = false;\n    var intermediates = [];\n    var xSqueezed = reshape({ inputs: { x: x }, backend: backend, attrs: { shape: x.shape.slice(1) } });\n    var w2Row = reshape({\n        inputs: { x: filter },\n        backend: backend,\n        attrs: { shape: [1, sharedDim, tf.util.sizeFromShape(filter.shape) / sharedDim] }\n    });\n    intermediates.push(xSqueezed);\n    intermediates.push(w2Row);\n    var im2ColProgram = new Im2ColPackedProgram(x2ColShape, xSqueezed.shape, convInfo);\n    var im2Col = backend.runWebGLProgram(im2ColProgram, [xSqueezed], 'float32');\n    var im2ColReshaped = reshape({\n        inputs: { x: im2Col },\n        backend: backend,\n        attrs: { shape: [1, x2ColShape[0], x2ColShape[1]] }\n    });\n    intermediates.push(im2Col);\n    intermediates.push(im2ColReshaped);\n    var hasBias = bias != null;\n    var hasPreluActivationWeights = preluActivationWeights != null;\n    var hasLeakyreluAlpha = activation === 'leakyrelu';\n    var fusedActivation = activation ? mapActivationToShaderProgram(activation, true) : null;\n    var matmulProgram = new MatMulPackedProgram(im2ColReshaped.shape, w2Row.shape, [1, numCols, convInfo.outChannels], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);\n    var inputs = [im2ColReshaped, w2Row];\n    if (bias) {\n        inputs.push(bias);\n    }\n    if (hasPreluActivationWeights) {\n        inputs.push(preluActivationWeights);\n    }\n    if (hasLeakyreluAlpha) {\n        var $leakyreluAlpha = backend.makeTensorInfo([], 'float32', tf.util.createScalarValue(leakyreluAlpha, 'float32'));\n        inputs.push($leakyreluAlpha);\n        intermediates.push($leakyreluAlpha);\n    }\n    var product = backend.runWebGLProgram(matmulProgram, inputs, 'float32');\n    var outShape = isChannelsLast ?\n        [1, outHeight, outWidth, convInfo.outChannels] :\n        [1, convInfo.outChannels, outHeight, outWidth];\n    var out = reshape({ inputs: { x: product }, backend: backend, attrs: { shape: outShape } });\n    intermediates.push(product);\n    for (var _i = 0, intermediates_2 = intermediates; _i < intermediates_2.length; _i++) {\n        var i = intermediates_2[_i];\n        backend.disposeIntermediateTensorInfo(i);\n    }\n    return out;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv2d(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, filter = inputs.filter;\n    var strides = attrs.strides, pad = attrs.pad, dataFormat = attrs.dataFormat, dilations = attrs.dilations, dimRoundingMode = attrs.dimRoundingMode;\n    var $dataFormat = tf.backend_util.convertConv2DDataFormat(dataFormat);\n    var convInfo = tf.backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false /* depthwise */, $dataFormat);\n    var out;\n    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n        convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n        convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n        (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {\n        out = conv2dByMatMul({ x: x, filter: filter, convInfo: convInfo, backend: backend });\n    }\n    else if (tf.env().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {\n        out = conv2dWithIm2Row({ x: x, filter: filter, convInfo: convInfo, backend: backend });\n    }\n    else {\n        var program = new Conv2DProgram(convInfo);\n        out = backend.runWebGLProgram(program, [x, filter], 'float32');\n    }\n    var outReshaped = reshape({ inputs: { x: out }, backend: backend, attrs: { shape: convInfo.outShape } });\n    backend.disposeIntermediateTensorInfo(out);\n    return outReshaped;\n}\nvar conv2DConfig = {\n    kernelName: tf.Conv2D,\n    backendName: 'webgl',\n    kernelFunc: conv2d,\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar Conv2DDerFilterProgram = /** @class */ (function () {\n    function Conv2DDerFilterProgram(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        var isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int d2 = coords.w;\\n\\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \" + convInfo.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + convInfo.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + strideHeight + \" - \" + padTop + \";\\n\\n            if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + convInfo.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + strideWidth + \" - \" + padLeft + \";\\n\\n              if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n                continue;\\n              }\\n\\n              if (\" + isChannelsLast + \") {\\n                float dyValue = getDy(b, yR, yC, d2);\\n                float xValue = getX(b, xR, xC, d1);\\n                dotProd += (xValue * dyValue);\\n              } else {\\n                float dyValue = getDy(b, d2, yR, yC);\\n                float xValue = getX(b, d1, xR, xC);\\n                dotProd += (xValue * dyValue);\\n              }\\n\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return Conv2DDerFilterProgram;\n}());\nvar Conv2DDerInputProgram = /** @class */ (function () {\n    function Conv2DDerInputProgram(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        var padTop = filterHeight - 1 - convInfo.padInfo.top;\n        var padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        var rowDim = isChannelsLast ? 1 : 2;\n        var colDim = isChannelsLast ? 2 : 3;\n        var channelDim = isChannelsLast ? 3 : 1;\n        this.userCode = \"\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[\" + channelDim + \"];\\n\\n        ivec2 dyCorner = ivec2(coords[\" + rowDim + \"], coords[\" + colDim + \"]) - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + strideHeight + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + convInfo.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + filterHeight + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + strideWidth + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + convInfo.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + filterWidth + \" - 1 - wC;\\n\\n            for (int d2 = 0; d2 < \" + convInfo.outChannels + \"; d2++) {\\n\\n              if (\" + isChannelsLast + \") {\\n                float xValue = getDy(batch, idyR, idyC, d2);\\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              } else {\\n                float xValue = getDy(batch, d2, idyR, idyC);\\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              }\\n\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return Conv2DDerInputProgram;\n}());\nvar Conv3DDerFilterProgram = /** @class */ (function () {\n    function Conv3DDerFilterProgram(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        var strideDepth = convInfo.strideDepth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var padFront = convInfo.padInfo.front;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        this.userCode = \"\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int wF = coords.x;\\n        int wR = coords.y;\\n        int wC = coords.z;\\n        int d1 = coords.w;\\n        int d2 = coords.u;\\n\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \" + convInfo.batchSize + \"; b++) {\\n          for (int yF = 0; yF < \" + convInfo.outDepth + \"; yF++) {\\n            int xF = wF + yF * \" + strideDepth + \" - \" + padFront + \";\\n\\n            if (xF < 0 || xF >= \" + convInfo.inDepth + \") {\\n              continue;\\n            }\\n\\n            for (int yR = 0; yR < \" + convInfo.outHeight + \"; yR++) {\\n              int xR = wR + yR * \" + strideHeight + \" - \" + padTop + \";\\n\\n              if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n                continue;\\n              }\\n\\n              for (int yC = 0; yC < \" + convInfo.outWidth + \"; yC++) {\\n                int xC = wC + yC * \" + strideWidth + \" - \" + padLeft + \";\\n\\n                if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n                  continue;\\n                }\\n\\n                float dyValue = getDy(b, yF, yR, yC, d2);\\n                float xValue = getX(b, xF, xR, xC, d1);\\n                dotProd += (xValue * dyValue);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return Conv3DDerFilterProgram;\n}());\nvar Conv3DDerInputProgram = /** @class */ (function () {\n    function Conv3DDerInputProgram(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        var filterDepth = convInfo.filterDepth;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var strideDepth = convInfo.strideDepth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var padFront = filterDepth - 1 - convInfo.padInfo.front;\n        var padTop = filterHeight - 1 - convInfo.padInfo.top;\n        var padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        this.userCode = \"\\n      const ivec3 pads = ivec3(\" + padFront + \", \" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d1 = coords.u;\\n\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyFCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < \" + filterDepth + \"; wF++) {\\n          float dyF = float(dyFCorner + wF) / \" + strideDepth + \".0;\\n\\n          if (dyF < 0.0 || dyF >= \" + convInfo.outDepth + \".0 || fract(dyF) > 0.0) {\\n            continue;\\n          }\\n          int idyF = int(dyF);\\n\\n          int wFPerm = \" + filterDepth + \" - 1 - wF;\\n\\n          for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n            float dyR = float(dyRCorner + wR) / \" + strideHeight + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + convInfo.outHeight + \".0 ||\\n              fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            int wRPerm = \" + filterHeight + \" - 1 - wR;\\n\\n            for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n              float dyC = float(dyCCorner + wC) / \" + strideWidth + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + convInfo.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              int wCPerm = \" + filterWidth + \" - 1 - wC;\\n\\n              for (int d2 = 0; d2 < \" + convInfo.outChannels + \"; d2++) {\\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return Conv3DDerInputProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv2DBackpropFilter(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, dy = inputs.dy;\n    var strides = attrs.strides, pad = attrs.pad, dataFormat = attrs.dataFormat, dimRoundingMode = attrs.dimRoundingMode, filterShape = attrs.filterShape;\n    var $dataFormat = tf.backend_util.convertConv2DDataFormat(dataFormat);\n    var convInfo = tf.backend_util.computeConv2DInfo(x.shape, filterShape, strides, 1 /* dilations */, pad, dimRoundingMode, false /* depthwise */, $dataFormat);\n    var program = new Conv2DDerFilterProgram(convInfo);\n    return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\nvar conv2DBackpropFilterConfig = {\n    kernelName: tf.Conv2DBackpropFilter,\n    backendName: 'webgl',\n    kernelFunc: conv2DBackpropFilter,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv2DBackpropInput(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, filter = inputs.filter;\n    var inputShape = attrs.inputShape, strides = attrs.strides, pad = attrs.pad, dataFormat = attrs.dataFormat, dimRoundingMode = attrs.dimRoundingMode;\n    var $dataFormat = tf.backend_util.convertConv2DDataFormat(dataFormat);\n    var convInfo = tf.backend_util.computeConv2DInfo(inputShape, filter.shape, strides, 1 /* dilations */, pad, dimRoundingMode, false, $dataFormat);\n    var program = new Conv2DDerInputProgram(convInfo);\n    return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\nvar conv2DBackpropInputConfig = {\n    kernelName: tf.Conv2DBackpropInput,\n    backendName: 'webgl',\n    kernelFunc: conv2DBackpropInput,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv3D(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, filter = inputs.filter;\n    var strides = attrs.strides, pad = attrs.pad, dilations = attrs.dilations;\n    var convInfo = tf.backend_util.computeConv3DInfo(x.shape, filter.shape, strides, dilations, pad);\n    var program = new Conv3DProgram(convInfo);\n    return backend.runWebGLProgram(program, [x, filter], 'float32');\n}\nvar conv3DConfig = {\n    kernelName: tf.Conv3D,\n    backendName: 'webgl',\n    kernelFunc: conv3D,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv3DBackpropFilterV2(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, dy = inputs.dy;\n    var strides = attrs.strides, pad = attrs.pad, filterShape = attrs.filterShape;\n    var convInfo = tf.backend_util.computeConv3DInfo(x.shape, filterShape, strides, 1 /* dilations */, pad);\n    var program = new Conv3DDerFilterProgram(convInfo);\n    return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\nvar conv3DBackpropFilterV2Config = {\n    kernelName: tf.Conv3DBackpropFilterV2,\n    backendName: 'webgl',\n    kernelFunc: conv3DBackpropFilterV2\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction conv3DBackpropInput(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, filter = inputs.filter;\n    var pad = attrs.pad, strides = attrs.strides, inputShape = attrs.inputShape;\n    var convInfo = tf.backend_util.computeConv3DInfo(inputShape, filter.shape, strides, 1 /* dilations */, pad);\n    var program = new Conv3DDerInputProgram(convInfo);\n    return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\nvar conv3DBackpropInputConfig = {\n    kernelName: tf.Conv3DBackpropInputV2,\n    backendName: 'webgl',\n    kernelFunc: conv3DBackpropInput,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar COS = CHECK_NAN_SNIPPET_UNARY + \"\\n  return cos(x);\\n\";\nvar cos = unaryKernelFunc({ opSnippet: COS });\nvar cosConfig = {\n    kernelName: tf.Cos,\n    backendName: 'webgl',\n    kernelFunc: cos,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar COSH = \"\\n  float e2x = exp(-x);\\n  return (e2x + 1.0 / e2x) / 2.0;\\n\";\nvar cosh = unaryKernelFunc({ opSnippet: COSH });\nvar coshConfig = {\n    kernelName: tf.Cosh,\n    backendName: 'webgl',\n    kernelFunc: cosh,\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar CropAndResizeProgram = /** @class */ (function () {\n    function CropAndResizeProgram(imageShape, boxShape, cropSize, method, extrapolationValue) {\n        this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n        this.outputShape = [];\n        var batch = imageShape[0], imageHeight = imageShape[1], imageWidth = imageShape[2], depth = imageShape[3];\n        var numBoxes = boxShape[0];\n        var cropHeight = cropSize[0], cropWidth = cropSize[1];\n        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n        var methodId = method === 'bilinear' ? 1 : 0;\n        var _a = [imageHeight - 1 + \".0\", imageWidth - 1 + \".0\"], inputHeightFloat = _a[0], inputWidthFloat = _a[1];\n        var _b = cropHeight > 1 ?\n            [\n                \"\" + (imageHeight - 1) / (cropHeight - 1),\n                '(y2-y1) * height_ratio',\n                \"y1*\" + inputHeightFloat + \" + float(y)*(height_scale)\",\n            ] :\n            [\n                '0.0',\n                '0.0',\n                \"0.5 * (y1+y2) * \" + inputHeightFloat,\n            ], heightRatio = _b[0], heightScale = _b[1], inY = _b[2];\n        var _c = cropWidth > 1 ?\n            [\n                \"\" + (imageWidth - 1) / (cropWidth - 1),\n                '(x2-x1) * width_ratio',\n                \"x1*\" + inputWidthFloat + \" + float(x)*(width_scale)\",\n            ] :\n            [\n                '0.0',\n                '0.0',\n                \"0.5 * (x1+x2) * \" + inputWidthFloat,\n            ], widthRatio = _c[0], widthScale = _c[1], inX = _c[2];\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n        this.userCode = \"\\n      const float height_ratio = float(\" + heightRatio + \");\\n      const float width_ratio = float(\" + widthRatio + \");\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= \" + batch + \") {\\n          return;\\n        }\\n\\n        float height_scale = \" + heightScale + \";\\n        float width_scale = \" + widthScale + \";\\n\\n        float in_y = \" + inY + \";\\n        if( in_y < 0.0 || in_y > \" + inputHeightFloat + \" ) {\\n          setOutput(float(\" + extrapolationValue + \"));\\n          return;\\n        }\\n        float in_x = \" + inX + \";\\n        if( in_x < 0.0 || in_x > \" + inputWidthFloat + \" ) {\\n          setOutput(float(\" + extrapolationValue + \"));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\\n        if(\" + methodId + \" == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\\n\\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\\n\\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\\n\\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\\n          float newValue = top + (bottom - top) * fracCR.y;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestCR = ivec2(floor(\\n            sourceFracIndexCR + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    \";\n    }\n    return CropAndResizeProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar cropAndResize = function (args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var image = inputs.image, boxes = inputs.boxes, boxInd = inputs.boxInd;\n    var cropSize = attrs.cropSize, method = attrs.method, extrapolationValue = attrs.extrapolationValue;\n    var program = new CropAndResizeProgram(image.shape, boxes.shape, cropSize, method, extrapolationValue);\n    return backend.runWebGLProgram(program, [image, boxes, boxInd], 'float32');\n};\nvar cropAndResizeConfig = {\n    kernelName: tf.CropAndResize,\n    backendName: 'webgl',\n    kernelFunc: cropAndResize\n};\n\nvar CumSumProgram = /** @class */ (function () {\n    function CumSumProgram(shape, exclusive, reverse) {\n        this.variableNames = ['x'];\n        this.outputShape = shape;\n        var rank = shape.length;\n        var val = exclusive ? '0.0' : \"getX(\" + getCoords$1(rank, 'coords') + \")\";\n        var length = shape[shape.length - 1];\n        var condition = '';\n        var idxString = '';\n        // When exclusive is set, the cumsum op becomes roll op that copies the\n        // value from the previous index based on the direction specified by the\n        // reverse flag.\n        if (exclusive) {\n            condition = reverse ? \"end != \" + (length - 1) : 'end != 0';\n            idxString = reverse ? 'end + 1' : 'end - 1';\n        }\n        else {\n            condition = reverse ? \"end + pow2 < \" + length : 'end >= pow2';\n            idxString = (reverse ? 'end + pow2' : 'end - pow2');\n        }\n        this.userCode = \"\\n      uniform float index;\\n      void main() {\\n        \" + getCoordsDataType(rank) + \" coords = getOutputCoords();\\n        int end = \" + getFinalCoord(rank, 'coords') + \";\\n        float val = \" + val + \";\\n        int pow2 = int(pow(2.0, index));\\n        if (\" + condition + \") {\\n          int idx = \" + idxString + \";\\n          \" + getFinalCoord(rank, 'coords') + \" = idx;\\n          val += getX(\" + getCoords$1(rank, 'coords') + \");\\n        }\\n        setOutput(val);\\n      }\\n    \";\n    }\n    CumSumProgram.prototype.getCustomSetupFunc = function (index) {\n        var _this = this;\n        return function (gpgpu, webGLProgram) {\n            if (_this.index == null) {\n                _this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n            }\n            gpgpu.gl.uniform1f(_this.index, index);\n        };\n    };\n    return CumSumProgram;\n}());\nfunction getCoords$1(rank, name) {\n    if (rank === 1) {\n        return \"\" + name;\n    }\n    else if (rank === 2) {\n        return name + \".x, \" + name + \".y\";\n    }\n    else if (rank === 3) {\n        return name + \".x, \" + name + \".y, \" + name + \".z\";\n    }\n    else if (rank === 4) {\n        return name + \".x, \" + name + \".y, \" + name + \".z, \" + name + \".w\";\n    }\n    else {\n        throw Error(\"Cumulative sum for rank \" + rank + \" is not yet supported\");\n    }\n}\nfunction getFinalCoord(rank, name) {\n    if (rank === 1) {\n        return \"\" + name;\n    }\n    else if (rank === 2) {\n        return name + \".y\";\n    }\n    else if (rank === 3) {\n        return name + \".z\";\n    }\n    else if (rank === 4) {\n        return name + \".w\";\n    }\n    else {\n        throw Error(\"Cumulative sum for rank \" + rank + \" is not yet supported\");\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction cumsum(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, exclusive = attrs.exclusive, reverse = attrs.reverse;\n    var xRank = x.shape.length;\n    var permutation = tf.backend_util.getAxesPermutation([axis], xRank);\n    var permutedX = x;\n    if (permutation != null) {\n        permutedX = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutation } });\n    }\n    var permutedAxis = tf.backend_util.getInnerMostAxes(1, xRank)[0];\n    if (permutedAxis !== xRank - 1) {\n        throw new Error(\"WebGL cumsum shader expects an inner-most axis=\" + (x.shape.length - 1) + \" \" +\n            (\"but got axis=\" + axis));\n    }\n    var size = permutedX.shape[permutedAxis];\n    var result = identity({ inputs: { x: permutedX }, backend: backend });\n    // Use cumsum parallel algorithm, ref:\n    // https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda\n    for (var i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++) {\n        var program = new CumSumProgram(permutedX.shape, false, reverse);\n        var customSetup = program.getCustomSetupFunc(i);\n        var prevResult = result;\n        result =\n            backend.runWebGLProgram(program, [result], result.dtype, customSetup);\n        backend.disposeIntermediateTensorInfo(prevResult);\n    }\n    // For exclusive cumsum, shift the end result in the direction of sum\n    // and add 0 to the front index.\n    if (exclusive) {\n        var program = new CumSumProgram(permutedX.shape, exclusive, reverse);\n        var prevResult = result;\n        result = backend.runWebGLProgram(program, [result], result.dtype);\n        backend.disposeIntermediateTensorInfo(prevResult);\n    }\n    if (permutation != null) {\n        var reversePermutation = tf.backend_util.getUndoAxesPermutation(permutation);\n        var reverseTransposedResult = transpose({ inputs: { x: result }, backend: backend, attrs: { perm: reversePermutation } });\n        backend.disposeIntermediateTensorInfo(result);\n        backend.disposeIntermediateTensorInfo(permutedX);\n        return reverseTransposedResult;\n    }\n    return result;\n}\nvar cumsumConfig = {\n    kernelName: tf.Cumsum,\n    backendName: 'webgl',\n    kernelFunc: cumsum\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction denseBincount(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, weights = inputs.weights;\n    var size = attrs.size, binaryOutput = attrs.binaryOutput;\n    if (x.shape.length === 1) {\n        var xVals = backend.readSync(x.dataId);\n        var weightsVals = backend.readSync(weights.dataId);\n        var outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);\n        return backend.makeTensorInfo([size], weights.dtype, outVals);\n    }\n    else if (x.shape.length === 2) {\n        var xBuf = backend.bufferSync(x);\n        var weightsBuf = backend.bufferSync(weights);\n        var outBuf = bincountReduceImplCPU(xBuf, weightsBuf, size, binaryOutput);\n        return backend.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);\n    }\n    throw new Error(\"Error in denseBincount: input must be at most rank 2, but got rank\" +\n        (x.shape.length + \".\"));\n}\nvar denseBincountConfig = {\n    kernelName: tf.DenseBincount,\n    backendName: 'webgl',\n    kernelFunc: denseBincount\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar DepthToSpaceProgram = /** @class */ (function () {\n    function DepthToSpaceProgram(outputShape, blockSize, dataFormat) {\n        this.variableNames = ['x'];\n        this.outputShape = [];\n        this.outputShape = outputShape;\n        this.blockSize = blockSize;\n        this.dataFormat = dataFormat;\n        this.userCode = \"\\n    void main() {\\n      ivec4 coords = getOutputCoords();\\n      int b = coords[0];\\n      int h = \" + this.getHeightCoordString() + \";\\n      int w = \" + this.getWidthCoordString() + \";\\n      int d = \" + this.getDepthCoordString() + \";\\n\\n      int in_h = h / \" + blockSize + \";\\n      int offset_h = imod(h, \" + blockSize + \");\\n      int in_w = w / \" + blockSize + \";\\n      int offset_w = imod(w, \" + blockSize + \");\\n      int offset_d = (offset_h * \" + blockSize + \" + offset_w) *\\n        \" + this.getOutputDepthSize() + \";\\n      int in_d = d + offset_d;\\n\\n      float result = \" + this.getInputSamplingString() + \";\\n      setOutput(result);\\n    }\\n  \";\n    }\n    DepthToSpaceProgram.prototype.getHeightCoordString = function () {\n        if (this.dataFormat === 'NHWC') {\n            return \"coords[1]\";\n        }\n        else {\n            return \"coords[2]\";\n        }\n    };\n    DepthToSpaceProgram.prototype.getWidthCoordString = function () {\n        if (this.dataFormat === 'NHWC') {\n            return \"coords[2]\";\n        }\n        else {\n            return \"coords[3]\";\n        }\n    };\n    DepthToSpaceProgram.prototype.getDepthCoordString = function () {\n        if (this.dataFormat === 'NHWC') {\n            return \"coords[3]\";\n        }\n        else {\n            return \"coords[1]\";\n        }\n    };\n    DepthToSpaceProgram.prototype.getOutputDepthSize = function () {\n        if (this.dataFormat === 'NHWC') {\n            return this.outputShape[3];\n        }\n        else {\n            return this.outputShape[1];\n        }\n    };\n    DepthToSpaceProgram.prototype.getInputSamplingString = function () {\n        if (this.dataFormat === 'NHWC') {\n            return \"getX(b, in_h, in_w, in_d)\";\n        }\n        else {\n            return \"getX(b, in_d, in_h, in_w)\";\n        }\n    };\n    return DepthToSpaceProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction depthToSpace(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var blockSize = attrs.blockSize, dataFormat = attrs.dataFormat;\n    tf.util.assert(blockSize > 1, function () { return \"blockSize should be > 1 for depthToSpace, but was: \" + blockSize; });\n    var batchSize = x.shape[0];\n    var inputHeight = (dataFormat === 'NHWC') ? x.shape[1] : x.shape[2];\n    var inputWidth = (dataFormat === 'NHWC') ? x.shape[2] : x.shape[3];\n    var inputDepth = (dataFormat === 'NHWC') ? x.shape[3] : x.shape[1];\n    var outputHeight = inputHeight * blockSize;\n    var outputWidth = inputWidth * blockSize;\n    var outputDepth = inputDepth / (blockSize * blockSize);\n    var outputShape = (dataFormat === 'NHWC') ?\n        [batchSize, outputHeight, outputWidth, outputDepth] :\n        [batchSize, outputDepth, outputHeight, outputWidth];\n    var program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nvar depthToSpaceConfig = {\n    kernelName: tf.DepthToSpace,\n    backendName: 'webgl',\n    kernelFunc: depthToSpace\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar DepthwiseConv2DProgram = /** @class */ (function () {\n    function DepthwiseConv2DProgram(convInfo, addBias, activation, hasPreluActivation, hasLeakyReluAlpha) {\n        if (addBias === void 0) { addBias = false; }\n        if (activation === void 0) { activation = null; }\n        if (hasPreluActivation === void 0) { hasPreluActivation = false; }\n        if (hasLeakyReluAlpha === void 0) { hasLeakyReluAlpha = false; }\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        var xNumRows = convInfo.inHeight;\n        var xNumCols = convInfo.inWidth;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var dilationHeight = convInfo.dilationHeight;\n        var dilationWidth = convInfo.dilationWidth;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var channelMul = convInfo.outChannels / convInfo.inChannels;\n        var activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = \"float activation(float a) {\\n          float b = getPreluActivationWeightsAtOutCoords();\\n          \" + activation + \"\\n        }\";\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = \"float activation(float a) {\\n          float b = getLeakyreluAlphaAtOutCoords();\\n          \" + activation + \"\\n        }\";\n            }\n            else {\n                activationSnippet = \"\\n          float activation(float x) {\\n            \" + activation + \"\\n          }\\n        \";\n            }\n            applyActivationSnippet = \"result = activation(result);\";\n        }\n        var addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = \"\\n      \" + activationSnippet + \"\\n\\n      const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2 / \" + channelMul + \";\\n        int q = d2 - d1 * \" + channelMul + \";\\n\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\\n        for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n          int xR = xRCorner + wR * \" + dilationHeight + \";\\n\\n          if (xR < 0 || xR >= \" + xNumRows + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n            int xC = xCCorner + wC * \" + dilationWidth + \";\\n\\n            if (xC < 0 || xC >= \" + xNumCols + \") {\\n              continue;\\n            }\\n\\n            float xVal = getX(batch, xR, xC, d1);\\n            float wVal = getW(wR, wC, d1, q);\\n            dotProd += xVal * wVal;\\n          }\\n        }\\n\\n        float result = dotProd;\\n        \" + addBiasSnippet + \"\\n        \" + applyActivationSnippet + \"\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return DepthwiseConv2DProgram;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar DepthwiseConvPacked2DProgram = /** @class */ (function () {\n    function DepthwiseConvPacked2DProgram(convInfo, addBias, activation, hasPreluActivation, hasLeakyReluAlpha) {\n        if (addBias === void 0) { addBias = false; }\n        if (activation === void 0) { activation = null; }\n        if (hasPreluActivation === void 0) { hasPreluActivation = false; }\n        if (hasLeakyReluAlpha === void 0) { hasLeakyReluAlpha = false; }\n        this.variableNames = ['x', 'W'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = convInfo.outShape;\n        var xNumRows = convInfo.inHeight;\n        var xNumCols = convInfo.inWidth;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var dilationHeight = convInfo.dilationHeight;\n        var dilationWidth = convInfo.dilationWidth;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var texelsAcross = filterWidth;\n        var mainLoop = \"int xR; int xC; int xCOffset;\";\n        for (var r = 0; r < filterHeight; r++) {\n            for (var c = 0; c < filterWidth; c++) {\n                mainLoop += \"\\n          vec4 xTexelR\" + r + \"C\" + c * 2 + \" = vec4(0.);\\n          vec4 wR\" + r + \"C\" + c + \" = vec4(0.);\\n          vec4 xR\" + r + \"C\" + c + \" = vec4(0.);\";\n            }\n        }\n        /**\n         * This vectorized implementation works by gathering the values needed for\n         * each output channel's dot product into vec4's and then multiplying them\n         * all together (this happens in the final double for-loop below). Most of\n         * the main loop consists of constructing these vec4's with the minimum\n         * number of texture2D calls, which means making use of all four returned\n         * values from a texture2D call at once.\n         */\n        for (var r = 0; r < filterHeight; r++) {\n            for (var texelC = 0; texelC < texelsAcross; texelC++) {\n                var c = texelC * 2;\n                mainLoop += \"\\n          xR = xRCorner + \" + r * dilationHeight + \";\\n          xC = xCCorner + \" + c * dilationWidth + \";\\n        \";\n                if (strideWidth === 1) {\n                    if (c < filterWidth) {\n                        // If padding is odd, the outer texels have to be composed.\n                        if (padLeft % 2 === 1) {\n                            // TODO: Ensure vec4 previous does not result in redundant sample,\n                            // and avoid setting xTexelRC's that exceed the boundary in the\n                            // first place rather than resetting them to vec4(0)).\n                            // To compute xCOffset:\n                            // - If padding is odd, we must add 1 to ensure we ask for an\n                            // even-numbered row.\n                            // - We subtract 2 to access the previous texel.\n                            mainLoop += \"\\n                xCOffset = xC + 1;\\n                if(xR >= 0 && xR < \" + xNumRows + \" && xCOffset >= 0 && xCOffset < \" + xNumCols + \") {\\n                  xTexelR\" + r + \"C\" + c + \" = getX(batch, xR, xCOffset, d1);\\n\\n                  // Need to manually clear unused channels in case\\n                  // we're reading from recycled texture.\\n                  if(xCOffset + 1 >= \" + xNumCols + \") {\\n                    xTexelR\" + r + \"C\" + c + \".zw = vec2(0.);\\n                  }\\n                } else {\\n                  xTexelR\" + r + \"C\" + c + \" = vec4(0.);\\n                }\\n\\n                xCOffset = xC + 1 - 2;\\n                if(xR >= 0 && xR < \" + xNumRows + \" && xCOffset >= 0 && xCOffset < \" + xNumCols + \") {\\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\\n\\n                  // Need to manually clear unused channels in case\\n                  // we're reading from recycled texture.\\n                  if(xCOffset + 1 >= \" + xNumCols + \") {\\n                    previous.zw = vec2(0.);\\n                  }\\n\\n                  xR\" + r + \"C\" + c + \" = vec4(previous.zw, xTexelR\" + r + \"C\" + c + \".xy);\\n                } else {\\n                  xR\" + r + \"C\" + c + \" = vec4(0, 0, xTexelR\" + r + \"C\" + c + \".xy);\\n                }\\n              \";\n                        }\n                        else {\n                            // Padding is even, so xRC corresponds to a single texel.\n                            mainLoop += \"\\n                if(xR >= 0 && xR < \" + xNumRows + \" && xC >= 0 && xC < \" + xNumCols + \") {\\n                  xTexelR\" + r + \"C\" + c + \" = getX(batch, xR, xC, d1);\\n                } else {\\n                  xTexelR\" + r + \"C\" + c + \" = vec4(0.);\\n                }\\n\\n                xR\" + r + \"C\" + c + \" = xTexelR\" + r + \"C\" + c + \";\\n              \";\n                        }\n                        if (c + 1 < filterWidth) {\n                            // If dilation is even, the second entry should match the first\n                            // (either both are composed or both are single samples). But if\n                            // dilation is odd, then the second entry should be the opposite\n                            // of the first (if the first is composed, the second is a single\n                            // sample, and vice versa.)\n                            var nextTexelOffset = padLeft % 2 === 0 ?\n                                tf.util.nearestLargerEven(dilationWidth) :\n                                dilationWidth;\n                            if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                                (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                                mainLoop += \"\\n                  xCOffset = xC + \" + padLeft % 2 + \" + \" + nextTexelOffset + \";\\n\\n                  if(xR >= 0 && xR < \" + xNumRows + \" &&\\n                    xCOffset >= 0 && xCOffset < \" + xNumCols + \") {\\n                    xTexelR\" + r + \"C\" + (c + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                  }\\n                \";\n                                // If dilation > 1 then the xRC's will not be able to share any\n                                // values, so each xRC will require two unique calls to getX.\n                                if (dilationWidth > 1) {\n                                    mainLoop += \"\\n                    xCOffset -= 2;\\n                    if(xR >= 0 && xR < \" + xNumRows + \" &&\\n                      xCOffset >= 0 && xCOffset < \" + xNumCols + \") {\\n                      xTexelR\" + r + \"C\" + c + \" = getX(batch, xR, xCOffset, d1);\\n                    } else {\\n                      xTexelR\" + r + \"C\" + c + \" = vec4(0.);\\n                    }\\n                  \";\n                                }\n                                mainLoop += \"\\n                  xR\" + r + \"C\" + (c + 1) + \" = vec4(\\n                    xTexelR\" + r + \"C\" + c + \".zw, xTexelR\" + r + \"C\" + (c + 2) + \".xy);\\n                \";\n                            }\n                            else {\n                                mainLoop += \"\\n                  xCOffset = xC + \" + nextTexelOffset + \";\\n\\n                  if(xR >= 0 && xR < \" + xNumRows + \" &&\\n                    xCOffset >= 0 && xCOffset < \" + xNumCols + \") {\\n                    xTexelR\" + r + \"C\" + (c + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                  }\\n\\n                  xR\" + r + \"C\" + (c + 1) + \" = xTexelR\" + r + \"C\" + (c + 2) + \";\\n                \";\n                            }\n                        }\n                    }\n                }\n                else { // stride > 1\n                    if (c < filterWidth) {\n                        mainLoop += \"\\n              if(xR >= 0 && xR < \" + xNumRows + \") {\\n            \";\n                        // Depending on whether padLeft is even or odd, we want either the\n                        // xy or zw channels from X texels for xR${r}C${c}. If padLeft is\n                        // even, xR${r}C${c + 1} is simply the zw channels of texels we've\n                        // already sampled. But if padLeft is odd, xR${r}C{$c + 1}.zw will\n                        // need to come from the xy channels of a new texel, hence the `vec4\n                        // final` initialized below.\n                        if (padLeft % 2 === 1) {\n                            mainLoop += \"\\n                xCOffset = xC + 1 - \" + strideWidth + \";\\n                if(xCOffset >= 0 && xCOffset < \" + xNumCols + \") {\\n                  xTexelR\" + r + \"C\" + c + \" = getX(batch, xR, xCOffset, d1);\\n                } else {\\n                  xTexelR\" + r + \"C\" + c + \" = vec4(0.);\\n                }\\n\\n                if(xC + 1 >= 0 && xC + 1 < \" + xNumCols + \") {\\n                  xTexelR\" + r + \"C\" + (c + 2) + \" = getX(batch, xR, xC + 1, d1);\\n                } else {\\n                  xTexelR\" + r + \"C\" + (c + 2) + \" = vec4(0.);\\n                }\\n\\n                xR\" + r + \"C\" + c + \" = vec4(\\n                  xTexelR\" + r + \"C\" + c + \".zw, xTexelR\" + r + \"C\" + (c + 2) + \".zw);\\n              \";\n                            if (c + 1 < filterWidth) {\n                                mainLoop += \"\\n                  vec4 final = vec4(0.);\\n                  xCOffset = xC + 1 + \" + strideWidth + \";\\n                  if(xCOffset >= 0 && xCOffset < \" + xNumCols + \") {\\n                    final = getX(batch, xR, xCOffset, d1);\\n                  }\\n                  xR\" + r + \"C\" + (c + 1) + \" = vec4(xTexelR\" + r + \"C\" + (c + 2) + \".xy, final.xy);\\n                \";\n                            }\n                        }\n                        else {\n                            mainLoop += \"\\n                if(xC >= 0 && xC < \" + xNumCols + \") {\\n                  xTexelR\" + r + \"C\" + c + \" = getX(batch, xR, xC, d1);\\n                } else {\\n                  xTexelR\" + r + \"C\" + c + \" = vec4(0.);\\n                }\\n\\n                xCOffset = xC + \" + strideWidth + \";\\n                if(xCOffset >= 0 && xCOffset < \" + xNumCols + \") {\\n                  xTexelR\" + r + \"C\" + (c + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                } else {\\n                  xTexelR\" + r + \"C\" + (c + 2) + \" = vec4(0.);\\n                }\\n\\n                xR\" + r + \"C\" + c + \" = vec4(\\n                  xTexelR\" + r + \"C\" + c + \".xy, xTexelR\" + r + \"C\" + (c + 2) + \".xy);\\n              \";\n                            if (c + 1 < filterWidth) {\n                                mainLoop += \"\\n                  xR\" + r + \"C\" + (c + 1) + \" = vec4(\\n                    xTexelR\" + r + \"C\" + c + \".zw, xTexelR\" + r + \"C\" + (c + 2) + \".zw);\\n                \";\n                            }\n                        }\n                        mainLoop += \"}\";\n                    }\n                }\n                if (c < filterWidth) {\n                    mainLoop += \"\\n            vec4 wTexelR\" + r + \"C\" + c + \" = getW(\" + r + \", \" + c + \", d1, q);\\n            wR\" + r + \"C\" + c + \" = vec4(wTexelR\" + r + \"C\" + c + \".xz, wTexelR\" + r + \"C\" + c + \".xz);\\n          \";\n                    if (c + 1 < filterWidth) {\n                        mainLoop += \"\\n              vec4 wTexelR\" + r + \"C\" + (c + 1) + \" = getW(\" + r + \", \" + (c + 1) + \", d1, q);\\n              wR\" + r + \"C\" + (c + 1) + \" =\\n                vec4(wTexelR\" + r + \"C\" + (c + 1) + \".xz, wTexelR\" + r + \"C\" + (c + 1) + \".xz);\";\n                    }\n                }\n            }\n        }\n        for (var r = 0; r < filterHeight; r++) {\n            for (var c = 0; c < filterWidth; c++) {\n                mainLoop += \"dotProd += xR\" + r + \"C\" + c + \" * wR\" + r + \"C\" + c + \";\";\n            }\n        }\n        var activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = \"vec4 activation(vec4 a) {\\n          vec4 b = getPreluActivationWeightsAtOutCoords();\\n          \" + activation + \"\\n        }\";\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = \"vec4 activation(vec4 a) {\\n          vec4 b = getLeakyreluAlphaAtOutCoords();\\n          \" + activation + \"\\n        }\";\n            }\n            else {\n                activationSnippet = \"vec4 activation(vec4 x) {\\n          \" + activation + \"\\n        }\";\n            }\n            applyActivationSnippet = \"result = activation(result);\";\n        }\n        var addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = \"\\n      \" + activationSnippet + \"\\n\\n      const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2;\\n        int q = 0;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        vec4 dotProd = vec4(0.);\\n\\n        \" + mainLoop + \"\\n\\n        vec4 result = dotProd;\\n        \" + addBiasSnippet + \"\\n        \" + applyActivationSnippet + \"\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return DepthwiseConvPacked2DProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction depthwiseConv2dNative(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, filter = inputs.filter;\n    var strides = attrs.strides, pad = attrs.pad, dilations = attrs.dilations, dimRoundingMode = attrs.dimRoundingMode;\n    var $dilations = dilations;\n    if ($dilations == null) {\n        $dilations = [1, 1];\n    }\n    tf.util.assert(tf.backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), function () { return 'Error in depthwiseConv2d: Either strides or dilations must be ' +\n        (\"1. Got strides \" + strides + \" and dilations '\" + $dilations + \"'\"); });\n    var convInfo = tf.backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true /* depthwise */);\n    var program;\n    if (tf.env().getBool('WEBGL_PACK_DEPTHWISECONV') && convInfo.strideWidth <= 2 &&\n        convInfo.outChannels / convInfo.inChannels === 1) {\n        program = new DepthwiseConvPacked2DProgram(convInfo);\n    }\n    else {\n        program = new DepthwiseConv2DProgram(convInfo);\n    }\n    return backend.runWebGLProgram(program, [x, filter], 'float32');\n}\nvar depthwiseConv2dNativeConfig = {\n    kernelName: tf.DepthwiseConv2dNative,\n    backendName: 'webgl',\n    kernelFunc: depthwiseConv2dNative,\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar DepthwiseConv2DDerFilterProgram = /** @class */ (function () {\n    function DepthwiseConv2DDerFilterProgram(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        var channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int dm = coords.w;\\n        int d2 = d1 * \" + channelMul + \" + dm;\\n\\n        float dotProd = 0.0;\\n\\n        // TO DO: Vec4 over the batch size\\n        for (int b = 0; b < \" + convInfo.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + convInfo.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + strideHeight + \" - \" + padTop + \";\\n\\n            if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + convInfo.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + strideWidth + \" - \" + padLeft + \";\\n\\n              if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n                continue;\\n              }\\n\\n              float dyValue = getDy(b, yR, yC, d2);\\n              float xValue = getX(b, xR, xC, d1);\\n              dotProd += (xValue * dyValue);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return DepthwiseConv2DDerFilterProgram;\n}());\nvar DepthwiseConv2DDerInputProgram = /** @class */ (function () {\n    function DepthwiseConv2DDerInputProgram(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var padTop = filterHeight - 1 - convInfo.padInfo.top;\n        var padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        var channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = \"\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[3];\\n        ivec2 dyCorner = coords.yz - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        float dotProd = 0.0;\\n\\n        for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + strideHeight + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + convInfo.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + filterHeight + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + strideWidth + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + convInfo.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + filterWidth + \" - 1 - wC;\\n\\n            // TO DO: Vec4 over the channelMul\\n            for (int dm = 0; dm < \" + channelMul + \"; dm++) {\\n              int d2 = d1 * \" + channelMul + \" + dm;\\n              float xValue = getDy(batch, idyR, idyC, d2);\\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\\n              dotProd += xValue * wValue;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return DepthwiseConv2DDerInputProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction depthwiseConv2dNativeBackpropFilter(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, dy = inputs.dy;\n    var strides = attrs.strides, dilations = attrs.dilations, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode, filterShape = attrs.filterShape;\n    var convInfo = tf.backend_util.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);\n    var program = new DepthwiseConv2DDerFilterProgram(convInfo);\n    return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\nvar depthwiseConv2dNativeBackpropFilterConfig = {\n    kernelName: tf.DepthwiseConv2dNativeBackpropFilter,\n    backendName: 'webgl',\n    kernelFunc: depthwiseConv2dNativeBackpropFilter\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction depthwiseConv2dNativeBackpropInput(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, filter = inputs.filter;\n    var strides = attrs.strides, dilations = attrs.dilations, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode, inputShape = attrs.inputShape;\n    var convInfo = tf.backend_util.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);\n    var program = new DepthwiseConv2DDerInputProgram(convInfo);\n    return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\nvar depthwiseConv2dNativeBackpropInputConfig = {\n    kernelName: tf.DepthwiseConv2dNativeBackpropInput,\n    backendName: 'webgl',\n    kernelFunc: depthwiseConv2dNativeBackpropInput\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar DiagProgram = /** @class */ (function () {\n    function DiagProgram(size) {\n        this.variableNames = ['X'];\n        this.outputShape = [size, size];\n        this.userCode = \"\\n      void main() {\\n          ivec2 coords = getOutputCoords();\\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\\n          setOutput(val);\\n      }\\n    \";\n    }\n    return DiagProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction diag(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    var outShape = x.shape.concat(x.shape);\n    var xSize = tf.util.sizeFromShape(x.shape);\n    var flat = reshape({ inputs: { x: x }, backend: backend, attrs: { shape: [xSize] } });\n    var program = new DiagProgram(xSize);\n    var res = backend.runWebGLProgram(program, [flat], flat.dtype);\n    var out = reshape({ inputs: { x: res }, backend: backend, attrs: { shape: outShape } });\n    backend.disposeIntermediateTensorInfo(flat);\n    backend.disposeIntermediateTensorInfo(res);\n    return out;\n}\nvar diagConfig = {\n    kernelName: tf.Diag,\n    backendName: 'webgl',\n    kernelFunc: diag\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar Dilation2DProgram = /** @class */ (function () {\n    function Dilation2DProgram(convInfo) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        var inHeight = convInfo.inHeight, inWidth = convInfo.inWidth, padInfo = convInfo.padInfo, strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, dilationHeight = convInfo.dilationHeight, dilationWidth = convInfo.dilationWidth;\n        var padTop = padInfo.top, padLeft = padInfo.left;\n        this.userCode = \"\\n      const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n      const float neg_infinity = -3.4e38;\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d1 = coords.w;\\n        ivec2 outTopLeftCorner =\\n            coords.yz * strides - pads;\\n        int hBeg = outTopLeftCorner.x;\\n        int wBeg = outTopLeftCorner.y;\\n\\n        float curVal = neg_infinity;\\n        for (int h = 0; h < \" + filterHeight + \"; h++) {\\n          int hIn = hBeg + h * \" + dilationHeight + \";\\n\\n          if (hIn >= 0 && hIn < \" + inHeight + \") {\\n            for (int w = 0; w < \" + filterWidth + \"; w++) {\\n              int wIn = wBeg + w * \" + dilationWidth + \";\\n\\n              if (wIn >= 0 && wIn < \" + inWidth + \") {\\n                float xVal = getX(batch, hIn, wIn, d1);\\n                float wVal = getW(h, w, d1);\\n\\n                float val = xVal + wVal;\\n                if (val > curVal) {\\n                  curVal = val;\\n                }\\n              }\\n            }\\n          }\\n        }\\n\\n        float result = curVal;\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return Dilation2DProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction dilation2D(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, filter = inputs.filter;\n    var strides = attrs.strides, pad = attrs.pad, dilations = attrs.dilations;\n    var convInfo = tf.backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */, dilations);\n    var out;\n    var program = new Dilation2DProgram(convInfo);\n    out = backend.runWebGLProgram(program, [x, filter], 'float32');\n    var outReshaped = reshape({ inputs: { x: out }, backend: backend, attrs: { shape: convInfo.outShape } });\n    backend.disposeIntermediateTensorInfo(out);\n    return outReshaped;\n}\nvar dilation2DConfig = {\n    kernelName: tf.Dilation2D,\n    backendName: 'webgl',\n    kernelFunc: dilation2D,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ELU$2 = \"return (x >= 0.0) ? x : (exp(x) - 1.0);\";\nvar ELU_PACKED = \"\\n  vec4 result;\\n\\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\\n\\n  return result;\\n\";\nvar elu = unaryKernelFunc({ opSnippet: ELU$2, packedOpSnippet: ELU_PACKED });\nvar eluConfig = {\n    kernelName: tf.Elu,\n    backendName: 'webgl',\n    kernelFunc: elu\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ELU_DER = \"return (b >= 1.0) ? a : a * (b + 1.0);\";\nvar ELU_DER_PACKED = \"\\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\\n\";\nvar eluGrad = function (args) {\n    var inputs = args.inputs, backend = args.backend;\n    var dy = inputs.dy, y = inputs.y;\n    var program = tf.env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(ELU_DER_PACKED, dy.shape, y.shape) :\n        new BinaryOpProgram(ELU_DER, dy.shape, y.shape);\n    return backend.runWebGLProgram(program, [dy, y], dy.dtype);\n};\nvar eluGradConfig = {\n    kernelName: tf.EluGrad,\n    backendName: 'webgl',\n    kernelFunc: eluGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar PACKED_EQUAL = \"\\n  return vec4(equal(a, b));\\n\";\nvar EQUAL = \"return float(a == b);\";\nvar equal = binaryKernelFunc({ opSnippet: EQUAL, packedOpSnippet: PACKED_EQUAL, dtype: 'bool' });\nvar equalConfig = {\n    kernelName: tf.Equal,\n    backendName: 'webgl',\n    kernelFunc: equal\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ERF = \"\\n  // Error function is calculated approximately with elementary function.\\n  // See \\\"Handbook of Mathematical Functions with Formulas,\\n  // Graphs, and Mathematical Tables\\\", Abramowitz and Stegun.\\n  float p = \" + tf.backend_util.ERF_P + \";\\n  float a1 = \" + tf.backend_util.ERF_A1 + \";\\n  float a2 = \" + tf.backend_util.ERF_A2 + \";\\n  float a3 = \" + tf.backend_util.ERF_A3 + \";\\n  float a4 = \" + tf.backend_util.ERF_A4 + \";\\n  float a5 = \" + tf.backend_util.ERF_A5 + \";\\n\\n  float sign = sign(x);\\n  x = abs(x);\\n  float t = 1.0 / (1.0 + p * x);\\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\\n\";\nvar erf = unaryKernelFunc({ opSnippet: ERF });\nvar erfConfig = {\n    kernelName: tf.Erf,\n    backendName: 'webgl',\n    kernelFunc: erf,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar EXP = \"return exp(x);\";\nvar exp = unaryKernelFunc({ opSnippet: EXP, packedOpSnippet: EXP, cpuKernelImpl: expImplCPU });\nvar expConfig = {\n    kernelName: tf.Exp,\n    backendName: 'webgl',\n    kernelFunc: exp\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction expandDims(args) {\n    var inputs = args.inputs, attrs = args.attrs, backend = args.backend;\n    var dim = attrs.dim;\n    var input = inputs.input;\n    var inputRank = input.shape.length;\n    var newShape = input.shape.slice();\n    var $dim = dim;\n    if (dim < 0) {\n        // Negative value is counted from the tail of rank.\n        tf.util.assert(-(inputRank + 1) <= dim, function () { return \"Axis must be in the interval [\" + -(inputRank + 1) + \", \" + inputRank + \"]\"; });\n        $dim = inputRank + dim + 1;\n    }\n    newShape.splice($dim, 0, 1);\n    return reshape({ inputs: { x: input }, backend: backend, attrs: { shape: newShape } });\n}\nvar expandDimsConfig = {\n    kernelName: tf.ExpandDims,\n    backendName: 'webgl',\n    kernelFunc: expandDims,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar EXPM1 = \"return exp(x) - 1.0;\";\nvar expm1 = unaryKernelFunc({ opSnippet: EXPM1, packedOpSnippet: EXPM1, cpuKernelImpl: expm1ImplCPU });\nvar expm1Config = {\n    kernelName: tf.Expm1,\n    backendName: 'webgl',\n    kernelFunc: expm1\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar FFTProgram = /** @class */ (function () {\n    function FFTProgram(component, inputShape, inverse) {\n        this.variableNames = ['real', 'imag'];\n        var innerDim = inputShape[1];\n        this.outputShape = inputShape;\n        var exponentMultiplierSnippet = inverse ? \"2.0 * \" + Math.PI : \"-2.0 * \" + Math.PI;\n        var resultDenominator = inverse ? innerDim + \".0\" : '1.0';\n        var opString;\n        if (component === 'real') {\n            opString = 'return real * expR - imag * expI;';\n        }\n        else if (component === 'imag') {\n            opString = 'return real * expI + imag * expR;';\n        }\n        else {\n            throw new Error(\"FFT component must be either \\\"real\\\" or \\\"imag\\\", got \" + component + \".\");\n        }\n        this.userCode = \"\\n      const float exponentMultiplier = \" + exponentMultiplierSnippet + \";\\n\\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\\n        \" + opString + \"\\n      }\\n\\n      float mulMatDFT(int batch, int index) {\\n        float indexRatio = float(index) / float(\" + innerDim + \");\\n        float exponentMultiplierTimesIndexRatio =\\n            exponentMultiplier * indexRatio;\\n\\n        float result = 0.0;\\n\\n        for (int i = 0; i < \" + innerDim + \"; i++) {\\n          // x = (-2|2 * PI / N) * index * i;\\n          float x = exponentMultiplierTimesIndexRatio * float(i);\\n          float expR = cos(x);\\n          float expI = sin(x);\\n          float real = getReal(batch, i);\\n          float imag = getImag(batch, i);\\n\\n          result +=\\n              unaryOpComplex(real, expR, imag, expI) / \" + resultDenominator + \";\\n        }\\n\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        setOutput(mulMatDFT(coords[0], coords[1]));\\n      }\\n    \";\n    }\n    return FFTProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction fftImpl(x, inverse, backend) {\n    var xData = backend.texData.get(x.dataId);\n    var inputSize = tf.util.sizeFromShape(x.shape);\n    // Collapse all outer dimensions to a single batch dimension.\n    var innerDimensionSize = x.shape[x.shape.length - 1];\n    var batch = inputSize / innerDimensionSize;\n    var input2D = reshape({ inputs: { x: x }, backend: backend, attrs: { shape: [batch, innerDimensionSize] } });\n    var xShape = input2D.shape;\n    var realProgram = new FFTProgram('real', xShape, inverse);\n    var imagProgram = new FFTProgram('imag', xShape, inverse);\n    var inputs = [\n        {\n            dataId: xData.complexTensorInfos.real.dataId,\n            dtype: xData.complexTensorInfos.real.dtype,\n            shape: xShape\n        },\n        {\n            dataId: xData.complexTensorInfos.imag.dataId,\n            dtype: xData.complexTensorInfos.imag.dtype,\n            shape: xShape\n        }\n    ];\n    var realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');\n    var imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');\n    var complexOutput = complex({ inputs: { real: realPart, imag: imagPart }, backend: backend });\n    backend.disposeIntermediateTensorInfo(realPart);\n    backend.disposeIntermediateTensorInfo(imagPart);\n    var complexOutputReshaped = reshape({ inputs: { x: complexOutput }, backend: backend, attrs: { shape: x.shape } });\n    backend.disposeIntermediateTensorInfo(input2D);\n    backend.disposeIntermediateTensorInfo(complexOutput);\n    return complexOutputReshaped;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction fft(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var input = inputs.input;\n    return fftImpl(input, false /* inverse */, backend);\n}\nvar fftConfig = {\n    kernelName: tf.FFT,\n    backendName: 'webgl',\n    kernelFunc: fft\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar FillProgram = /** @class */ (function () {\n    function FillProgram(shape, value) {\n        this.outputShape = [];\n        this.variableNames = ['x'];\n        this.outputShape = shape;\n        this.userCode = \"\\n      uniform float value;\\n      void main() {\\n        // Input can be obtained from uniform value.\\n        setOutput(value);\\n      }\\n    \";\n    }\n    FillProgram.prototype.getCustomSetupFunc = function (value) {\n        var _this = this;\n        return function (gpgpu, webGLProgram) {\n            if (_this.valueLoc == null) {\n                _this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');\n            }\n            gpgpu.gl.uniform1f(_this.valueLoc, value);\n        };\n    };\n    return FillProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction fill(args) {\n    var backend = args.backend, attrs = args.attrs;\n    var shape = attrs.shape, value = attrs.value;\n    var dtype = attrs.dtype;\n    dtype = dtype || tf.util.inferDtype(value);\n    if (dtype === 'string') {\n        // String type should be handled in CPU memory.\n        var values = tf.util.getArrayFromDType(dtype, tf.util.sizeFromShape(shape));\n        values.fill(value);\n        return backend.makeTensorInfo(shape, dtype, values);\n    }\n    else {\n        var program = new FillProgram(shape, value);\n        var customSetup = program.getCustomSetupFunc(value);\n        return backend.runWebGLProgram(program, [], dtype, customSetup);\n    }\n}\nvar fillConfig = {\n    kernelName: tf.Fill,\n    backendName: 'webgl',\n    kernelFunc: fill\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar FlipLeftRightProgram = /** @class */ (function () {\n    function FlipLeftRightProgram(imageShape) {\n        this.variableNames = ['Image'];\n        this.outputShape = [];\n        var imageWidth = imageShape[2];\n        this.outputShape = imageShape;\n        this.userCode = \"\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int x = coords[2];\\n\\n          int coordX = \" + imageWidth + \" - x;\\n          float outputValue;\\n          if(coordX >= 0 && coordX < \" + imageWidth + \") {\\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\\n          } else {\\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\\n          }\\n          setOutput(outputValue);\\n        }\\n    \";\n    }\n    return FlipLeftRightProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar flipLeftRightConfig = {\n    kernelName: tf.FlipLeftRight,\n    backendName: 'webgl',\n    kernelFunc: function (_a) {\n        var inputs = _a.inputs, backend = _a.backend;\n        var image = inputs.image;\n        var webglBackend = backend;\n        var program = new FlipLeftRightProgram(image.shape);\n        var output = webglBackend.runWebGLProgram(program, [image], image.dtype);\n        return output;\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar FLOOR = \"return floor(x);\";\nvar floor = unaryKernelFunc({ opSnippet: FLOOR, packedOpSnippet: FLOOR, cpuKernelImpl: floorImplCPU });\nvar floorConfig = {\n    kernelName: tf.Floor,\n    backendName: 'webgl',\n    kernelFunc: floor,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// We use native integer division to deal with floating point imprecision. Since\n// we implement floor division and glsl implements truncated division, we\n// correct for this by subtracting 1 from result when the result is negative and\n// there is a remainder.\nvar INT_DIV = \"\\n  float s = sign(a) * sign(b);\\n  int ia = round(a);\\n  int ib = round(b);\\n  if (ib != 0) {\\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\\n    return float(idiv(ia, ib, s));\\n  } else {\\n    return NAN;\\n  }\\n\";\nvar INT_DIV_PACKED = \"\\n  ivec4 ia = round(a);\\n  ivec4 ib = round(b);\\n  bvec4 cond = notEqual(ib, ivec4(0));\\n  ivec4 result = ivec4(0);\\n  vec4 s = sign(a) * sign(b);\\n\\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\\n  if (cond[0]) {\\n    result[0] = idiv(ia[0], ib[0], s[0]);\\n  }\\n  if (cond[1]) {\\n    result[1] = idiv(ia[1], ib[1], s[1]);\\n  }\\n  if (cond[2]) {\\n    result[2] = idiv(ia[2], ib[2], s[2]);\\n  }\\n  if (cond[3]) {\\n    result[3] = idiv(ia[3], ib[3], s[3]);\\n  }\\n  return vec4(result);\\n\";\nvar floorDiv = binaryKernelFunc({ opSnippet: INT_DIV, packedOpSnippet: INT_DIV_PACKED, dtype: 'int32' });\nvar floorDivConfig = {\n    kernelName: tf.FloorDiv,\n    backendName: 'webgl',\n    kernelFunc: floorDiv\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar FromPixelsProgram = /** @class */ (function () {\n    function FromPixelsProgram(outputShape) {\n        this.variableNames = ['A'];\n        var glsl = getGlslDifferences();\n        var height = outputShape[0], width = outputShape[1];\n        this.outputShape = outputShape;\n        this.userCode = \"\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int texR = coords[0];\\n        int texC = coords[1];\\n        int depth = coords[2];\\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + width + \".0, \" + height + \".0);\\n\\n        vec4 values = \" + glsl.texture2D + \"(A, uv);\\n        float value;\\n        if (depth == 0) {\\n          value = values.r;\\n        } else if (depth == 1) {\\n          value = values.g;\\n        } else if (depth == 2) {\\n          value = values.b;\\n        } else if (depth == 3) {\\n          value = values.a;\\n        }\\n\\n        setOutput(floor(value * 255.0 + 0.5));\\n      }\\n    \";\n    }\n    return FromPixelsProgram;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar FromPixelsPackedProgram = /** @class */ (function () {\n    function FromPixelsPackedProgram(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        var glsl = getGlslDifferences();\n        var height = outputShape[0], width = outputShape[1];\n        this.outputShape = outputShape;\n        this.userCode = \"\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int texR = coords[0];\\n        int texC = coords[1];\\n        int depth = coords[2];\\n\\n        vec4 result = vec4(0.);\\n\\n        for(int row=0; row<=1; row++) {\\n          for(int col=0; col<=1; col++) {\\n            texC = coords[1] + row;\\n            depth = coords[2] + col;\\n\\n            vec2 uv = (vec2(texC, texR) + halfCR) /\\n                       vec2(\" + width + \".0, \" + height + \".0);\\n            vec4 values = \" + glsl.texture2D + \"(A, uv);\\n            float value;\\n            if (depth == 0) {\\n              value = values.r;\\n            } else if (depth == 1) {\\n              value = values.g;\\n            } else if (depth == 2) {\\n              value = values.b;\\n            } else if (depth == 3) {\\n              value = values.a;\\n            }\\n\\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\\n          }\\n        }\\n\\n        \" + glsl.output + \" = result;\\n      }\\n    \";\n    }\n    return FromPixelsPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar fromPixelsConfig = {\n    kernelName: tf.FromPixels,\n    backendName: 'webgl',\n    kernelFunc: fromPixels,\n};\nvar fromPixels2DContext;\nfunction fromPixels(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var pixels = inputs.pixels;\n    var numChannels = attrs.numChannels;\n    var isVideo = typeof (HTMLVideoElement) !== 'undefined' &&\n        pixels instanceof HTMLVideoElement;\n    var isImage = typeof (HTMLImageElement) !== 'undefined' &&\n        pixels instanceof HTMLImageElement;\n    var isImageBitmap = typeof (ImageBitmap) !== 'undefined' &&\n        pixels instanceof ImageBitmap;\n    var _a = isVideo ?\n        [\n            pixels.videoWidth,\n            pixels.videoHeight\n        ] :\n        [pixels.width, pixels.height], width = _a[0], height = _a[1];\n    var texShape = [height, width];\n    var outShape = [height, width, numChannels];\n    if (isImage || isVideo || isImageBitmap) {\n        if (fromPixels2DContext == null) {\n            fromPixels2DContext = document.createElement('canvas').getContext('2d');\n        }\n        fromPixels2DContext.canvas.width = width;\n        fromPixels2DContext.canvas.height = height;\n        fromPixels2DContext.drawImage(pixels, 0, 0, width, height);\n        pixels = fromPixels2DContext.canvas;\n    }\n    var tempPixelHandle = backend.makeTensorInfo(texShape, 'int32');\n    // This is a byte texture with pixels.\n    backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;\n    backend.gpgpu.uploadPixelDataToTexture(backend.getTexture(tempPixelHandle.dataId), pixels);\n    var program = tf.env().getBool('WEBGL_PACK') ?\n        new FromPixelsPackedProgram(outShape) :\n        new FromPixelsProgram(outShape);\n    var res = backend.runWebGLProgram(program, [tempPixelHandle], 'int32');\n    backend.disposeData(tempPixelHandle.dataId);\n    return res;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction fusedConv2d(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, filter = inputs.filter, bias = inputs.bias, preluActivationWeights = inputs.preluActivationWeights;\n    var strides = attrs.strides, pad = attrs.pad, dataFormat = attrs.dataFormat, dilations = attrs.dilations, dimRoundingMode = attrs.dimRoundingMode, activation = attrs.activation, leakyreluAlpha = attrs.leakyreluAlpha;\n    var $dataFormat = tf.backend_util.convertConv2DDataFormat(dataFormat);\n    var convInfo = tf.backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false /* depthwise */, $dataFormat);\n    var out;\n    var intermediates = [];\n    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n        convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n        convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n        (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {\n        out = conv2dByMatMul({\n            x: x,\n            filter: filter,\n            convInfo: convInfo,\n            backend: backend,\n            bias: bias,\n            activation: activation,\n            preluActivationWeights: preluActivationWeights,\n            leakyreluAlpha: leakyreluAlpha\n        });\n    }\n    else if (tf.env().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {\n        out = conv2dWithIm2Row({\n            x: x,\n            filter: filter,\n            convInfo: convInfo,\n            backend: backend,\n            bias: bias,\n            activation: activation,\n            preluActivationWeights: preluActivationWeights,\n            leakyreluAlpha: leakyreluAlpha\n        });\n    }\n    else {\n        var hasBias = bias != null;\n        var hasPreluActivationWeights = preluActivationWeights != null;\n        var hasLeakyreluAlpha = activation === 'leakyrelu';\n        var fusedActivation = activation ? mapActivationToShaderProgram(activation, false) : null;\n        var program = new Conv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);\n        var inputs_1 = [x, filter];\n        if (bias) {\n            inputs_1.push(bias);\n        }\n        if (preluActivationWeights) {\n            inputs_1.push(preluActivationWeights);\n        }\n        if (hasLeakyreluAlpha) {\n            var $leakyreluAlpha = backend.makeTensorInfo([], 'float32', tf.util.createScalarValue(leakyreluAlpha, 'float32'));\n            inputs_1.push($leakyreluAlpha);\n            intermediates.push($leakyreluAlpha);\n        }\n        out = backend.runWebGLProgram(program, inputs_1, 'float32');\n    }\n    var outReshaped = reshape({ inputs: { x: out }, backend: backend, attrs: { shape: convInfo.outShape } });\n    intermediates.push(out);\n    intermediates.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return outReshaped;\n}\nvar fusedConv2DConfig = {\n    kernelName: tf.FusedConv2D,\n    backendName: 'webgl',\n    kernelFunc: fusedConv2d,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction fusedDepthwiseConv2D(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, filter = inputs.filter, bias = inputs.bias, preluActivationWeights = inputs.preluActivationWeights;\n    var strides = attrs.strides, pad = attrs.pad, dilations = attrs.dilations, dimRoundingMode = attrs.dimRoundingMode, activation = attrs.activation, leakyreluAlpha = attrs.leakyreluAlpha;\n    var intermediates = [];\n    var $dilations = dilations;\n    if ($dilations == null) {\n        $dilations = [1, 1];\n    }\n    tf.util.assert(tf.backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), function () { return 'Error in depthwiseConv2d: Either strides or dilations must be ' +\n        (\"1. Got strides \" + strides + \" and dilations '\" + $dilations + \"'\"); });\n    var convInfo = tf.backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true /* depthwise */);\n    var shouldPackDepthwiseConv = tf.env().getBool('WEBGL_PACK_DEPTHWISECONV') &&\n        convInfo.strideWidth <= 2 &&\n        convInfo.outChannels / convInfo.inChannels === 1;\n    var fusedActivation = activation ?\n        mapActivationToShaderProgram(activation, shouldPackDepthwiseConv) :\n        null;\n    var programInputs = [x, filter];\n    var hasBias = bias != null;\n    var hasPreluActivationWeights = preluActivationWeights != null;\n    var hasLeakyreluAlpha = activation === 'leakyrelu';\n    if (hasBias) {\n        programInputs.push(bias);\n    }\n    if (hasPreluActivationWeights) {\n        programInputs.push(preluActivationWeights);\n    }\n    if (hasLeakyreluAlpha) {\n        var $leakyreluAlpha = backend.makeTensorInfo([], 'float32', tf.util.createScalarValue(leakyreluAlpha, 'float32'));\n        programInputs.push($leakyreluAlpha);\n        intermediates.push($leakyreluAlpha);\n    }\n    var program;\n    if (shouldPackDepthwiseConv) {\n        program = new DepthwiseConvPacked2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);\n    }\n    else {\n        program = new DepthwiseConv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);\n    }\n    var result = backend.runWebGLProgram(program, programInputs, 'float32');\n    intermediates.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return result;\n}\nvar fusedDepthwiseConv2DConfig = {\n    kernelName: tf.FusedDepthwiseConv2D,\n    backendName: 'webgl',\n    kernelFunc: fusedDepthwiseConv2D,\n};\n\nvar GatherNDProgram = /** @class */ (function () {\n    function GatherNDProgram(sliceDim, strides, shape) {\n        this.sliceDim = sliceDim;\n        this.strides = strides;\n        this.variableNames = ['x', 'indices'];\n        this.outputShape = shape;\n        var stridesType = getCoordsDataType(strides.length);\n        var dtype = getCoordsDataType(shape.length);\n        var strideString = this.sliceDim > 1 ? 'strides[j]' : 'strides';\n        this.userCode = \"\\n        \" + stridesType + \" strides = \" + stridesType + \"(\" + this.strides + \");\\n         void main() {\\n          \" + dtype + \" coords = getOutputCoords();\\n          int flattenIndex = 0;\\n          for (int j = 0; j < \" + this.sliceDim + \"; j++) {\\n            int index = round(getIndices(coords[0], j));\\n            flattenIndex += index * \" + strideString + \";\\n          }\\n          setOutput(getX(flattenIndex, coords[1]));\\n        }\\n      \";\n    }\n    return GatherNDProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction gatherNd(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var params = inputs.params, indices = inputs.indices;\n    var indicesShape = indices.shape;\n    var sliceRank = indicesShape[indicesShape.length - 1];\n    var _a = tf.backend_util.prepareAndValidate(params, indices), resultShape = _a[0], numSlices = _a[1], sliceSize = _a[2], strides = _a[3];\n    var flattenIndices = reshape({ inputs: { x: indices }, backend: backend, attrs: { shape: [numSlices, sliceRank] } });\n    var flattenX = reshape({\n        inputs: { x: params },\n        backend: backend,\n        attrs: { shape: [(tf.util.sizeFromShape(params.shape) / sliceSize), sliceSize] }\n    });\n    var program = new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);\n    var res = backend.runWebGLProgram(program, [flattenX, flattenIndices], flattenX.dtype);\n    var reshaped = reshape({ inputs: { x: res }, backend: backend, attrs: { shape: resultShape } });\n    backend.disposeIntermediateTensorInfo(flattenIndices);\n    backend.disposeIntermediateTensorInfo(flattenX);\n    backend.disposeIntermediateTensorInfo(res);\n    return reshaped;\n}\nvar gatherNdConfig = {\n    kernelName: tf.GatherNd,\n    backendName: 'webgl',\n    kernelFunc: gatherNd\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar GatherProgram = /** @class */ (function () {\n    function GatherProgram(aShape, outputShape) {\n        this.variableNames = ['A', 'indices'];\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        var dtype = getCoordsDataType(this.rank);\n        var sourceCoords = getSourceCoords$1(aShape);\n        this.userCode = \"\\n      void main() {\\n        \" + dtype + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + sourceCoords + \"));\\n      }\\n    \";\n    }\n    return GatherProgram;\n}());\n// The input and output are always flattened into rank 4 tensors.\nfunction getSourceCoords$1(aShape, axis) {\n    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n    var sourceCoords = [];\n    for (var i = 0; i < aShape.length; i++) {\n        if (i === 2) {\n            sourceCoords.push('int(getIndices(resRC.x, resRC.z))');\n        }\n        else {\n            sourceCoords.push(\"\" + currentCoords[i]);\n        }\n    }\n    return sourceCoords.join();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction gatherV2(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, indices = inputs.indices;\n    var axis = attrs.axis, batchDims = attrs.batchDims;\n    var parsedAxis = tf.util.parseAxisParam(axis, x.shape)[0];\n    var shapeInfo = tf.backend_util.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);\n    var indicesSize = tf.util.sizeFromShape(indices.shape);\n    var toDispose = [];\n    var flattenX = reshape({\n        inputs: { x: x },\n        backend: backend,\n        attrs: {\n            shape: [\n                shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize,\n                shapeInfo.sliceSize\n            ]\n        }\n    });\n    var flattenIndex = reshape({\n        inputs: { x: indices },\n        backend: backend,\n        attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }\n    });\n    toDispose.push(flattenX);\n    toDispose.push(flattenIndex);\n    var flattenOutputShape = [\n        shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize,\n        shapeInfo.sliceSize\n    ];\n    if (backend.shouldExecuteOnCPU([x, indices]) || x.dtype === 'string') {\n        var indicesBuf = backend.bufferSync(flattenIndex);\n        var xBuf = backend.bufferSync(flattenX);\n        var outBuf = gatherV2ImplCPU(xBuf, indicesBuf, flattenOutputShape);\n        toDispose.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n        return backend.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);\n    }\n    var program = new GatherProgram(flattenX.shape, flattenOutputShape);\n    var res = backend.runWebGLProgram(program, [flattenX, flattenIndex], flattenX.dtype);\n    toDispose.push(res);\n    var reshaped = reshape({ inputs: { x: res }, backend: backend, attrs: { shape: shapeInfo.outputShape } });\n    toDispose.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return reshaped;\n}\nvar gatherV2Config = {\n    kernelName: tf.GatherV2,\n    backendName: 'webgl',\n    kernelFunc: gatherV2\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar GREATER = \"return float(a > b);\";\nvar GREATER_PACKED = \"\\n  return vec4(greaterThan(a, b));\\n\";\nvar greater = binaryKernelFunc({\n    opSnippet: GREATER,\n    packedOpSnippet: GREATER_PACKED,\n    cpuKernelImpl: greaterImplCPU,\n    dtype: 'bool'\n});\nvar greaterConfig = {\n    kernelName: tf.Greater,\n    backendName: 'webgl',\n    kernelFunc: greater\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar GREATER_EQUAL = \"return float(a >= b);\";\nvar GREATER_EQUAL_PACKED = \"\\n  return vec4(greaterThanEqual(a, b));\\n\";\nvar greaterEqual = binaryKernelFunc({\n    opSnippet: GREATER_EQUAL,\n    packedOpSnippet: GREATER_EQUAL_PACKED,\n    dtype: 'bool'\n});\nvar greaterEqualConfig = {\n    kernelName: tf.GreaterEqual,\n    backendName: 'webgl',\n    kernelFunc: greaterEqual\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction ifft(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var input = inputs.input;\n    return fftImpl(input, true /* inverse */, backend);\n}\nvar ifftConfig = {\n    kernelName: tf.IFFT,\n    backendName: 'webgl',\n    kernelFunc: ifft\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar IS_FINITE = \"return float(!isnan(x) && !isinf(x));\";\nvar isFinite = unaryKernelFunc({ opSnippet: IS_FINITE, dtype: 'bool' });\nvar isFiniteConfig = {\n    kernelName: tf.IsFinite,\n    backendName: 'webgl',\n    kernelFunc: isFinite,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar IS_INF = \"return float(isinf(x));\";\nvar isInf = unaryKernelFunc({ opSnippet: IS_INF, dtype: 'bool' });\nvar isInfConfig = {\n    kernelName: tf.IsInf,\n    backendName: 'webgl',\n    kernelFunc: isInf,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar IS_NAN = \"return float(isnan(x));\";\nvar isNaN = unaryKernelFunc({ opSnippet: IS_NAN, dtype: 'bool' });\nvar isNaNConfig = {\n    kernelName: tf.IsNan,\n    backendName: 'webgl',\n    kernelFunc: isNaN,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LESS = \"return float(a < b);\";\nvar LESS_PACKED = \"\\n  return vec4(lessThan(a, b));\\n\";\nvar less = binaryKernelFunc({\n    opSnippet: LESS,\n    packedOpSnippet: LESS_PACKED,\n    cpuKernelImpl: lessImplCPU,\n    dtype: 'bool'\n});\nvar lessConfig = {\n    kernelName: tf.Less,\n    backendName: 'webgl',\n    kernelFunc: less\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LESS_EQUAL = \"return float(a <= b);\";\nvar LESS_EQUAL_PACKED = \"\\n  return vec4(lessThanEqual(a, b));\\n\";\nvar lessEqual = binaryKernelFunc({ opSnippet: LESS_EQUAL, packedOpSnippet: LESS_EQUAL_PACKED, dtype: 'bool' });\nvar lessEqualConfig = {\n    kernelName: tf.LessEqual,\n    backendName: 'webgl',\n    kernelFunc: lessEqual\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction linSpace(args) {\n    var backend = args.backend, attrs = args.attrs;\n    var start = attrs.start, stop = attrs.stop, num = attrs.num;\n    // TODO: Use CPU implementation due to the precision problem in Safari.\n    var outVals = linSpaceImplCPU(start, stop, num);\n    return backend.makeTensorInfo([outVals.length], 'float32', outVals);\n}\nvar linSpaceConfig = {\n    kernelName: tf.LinSpace,\n    backendName: 'webgl',\n    kernelFunc: linSpace\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LOG = \"if (x < 0.0) return NAN;\\n  return log(x);\";\nvar LOG_PACKED = \"\\n  vec4 result = log(x);\\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\\n\\n  return result;\\n\";\nvar log = unaryKernelFunc({ opSnippet: LOG, packedOpSnippet: LOG_PACKED, cpuKernelImpl: logImplCPU });\nvar logConfig = {\n    kernelName: tf.Log,\n    backendName: 'webgl',\n    kernelFunc: log\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LOG1P = \"return log(1.0 + x);\";\nvar log1p = unaryKernelFunc({ opSnippet: LOG1P });\nvar log1pConfig = {\n    kernelName: tf.Log1p,\n    backendName: 'webgl',\n    kernelFunc: log1p,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LOGICAL_AND = \"return float(a >= 1.0 && b >= 1.0);\";\nvar LOGICAL_AND_PACKED = \"\\n  return vec4(\\n    vec4(greaterThanEqual(a, vec4(1.0))) *\\n    vec4(greaterThanEqual(b, vec4(1.0))));\\n\";\nvar logicalAnd = binaryKernelFunc({\n    opSnippet: LOGICAL_AND,\n    packedOpSnippet: LOGICAL_AND_PACKED,\n    dtype: 'bool'\n});\nvar logicalAndConfig = {\n    kernelName: tf.LogicalAnd,\n    backendName: 'webgl',\n    kernelFunc: logicalAnd\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LOGICAL_NOT = \"return float(!(x >= 1.0));\";\nvar logicalNot = unaryKernelFunc({ opSnippet: LOGICAL_NOT });\nvar logicalNotConfig = {\n    kernelName: tf.LogicalNot,\n    backendName: 'webgl',\n    kernelFunc: logicalNot,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LOGICAL_OR = \"return float(a >= 1.0 || b >= 1.0);\";\nvar LOGICAL_OR_PACKED = \"\\n  return min(\\n    vec4(greaterThanEqual(a, vec4(1.0))) +\\n    vec4(greaterThanEqual(b, vec4(1.0))),\\n    vec4(1.0));\\n\";\nvar logicalOr = binaryKernelFunc({ opSnippet: LOGICAL_OR, packedOpSnippet: LOGICAL_OR_PACKED, dtype: 'bool' });\nvar logicalOrConfig = {\n    kernelName: tf.LogicalOr,\n    backendName: 'webgl',\n    kernelFunc: logicalOr\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LRNProgram = /** @class */ (function () {\n    function LRNProgram(xShape, radius, bias, alpha, beta) {\n        this.variableNames = ['x'];\n        this.outputShape = [];\n        var rad = radius;\n        var maxD = xShape[3] - 1;\n        this.outputShape = xShape;\n        // optimize pow(bias + alpha * sum, -beta)\n        // src: https://github.com/tensorflow/tensorflow/..\n        // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n        // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n        var powOperator;\n        var basis = \"float(\" + bias + \") + float(\" + alpha + \") * sum\";\n        if (beta === 0.5) {\n            powOperator = \"inversesqrt(\" + basis + \")\";\n        }\n        else if (beta === 1.0) {\n            powOperator = \"1.0/(\" + basis + \")\";\n        }\n        else {\n            powOperator = \"exp(log(\" + basis + \") * float(-\" + beta + \"));\";\n        }\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n        int d = coords[3];\\n        float x = getX(b, r, c, d);\\n        float sum = 0.0;\\n        for (int j = -\" + rad + \"; j <= \" + rad + \"; j++) {\\n          int idx = d + j;\\n          if (idx >= 0 && idx <=  \" + maxD + \") {\\n            float z = getX(b, r, c, idx);\\n            sum += z * z;\\n          }\\n        }\\n        float val = x * \" + powOperator + \";\\n        setOutput(val);\\n      }\\n    \";\n    }\n    return LRNProgram;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LRNPackedProgram = /** @class */ (function () {\n    function LRNPackedProgram(xShape, radius, bias, alpha, beta) {\n        this.variableNames = ['x'];\n        this.outputShape = [];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        var rad = radius;\n        var maxD = xShape[3] - 1;\n        this.outputShape = xShape;\n        // optimize pow(bias + alpha * sum, -beta)\n        // src: https://github.com/tensorflow/tensorflow/..\n        // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n        // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n        var powOperator;\n        var basis = \"float(\" + bias + \") + float(\" + alpha + \") * sum\";\n        if (beta === 0.5) {\n            powOperator = \"inversesqrt(\" + basis + \")\";\n        }\n        else if (beta === 1.0) {\n            powOperator = \"1.0/(\" + basis + \")\";\n        }\n        else {\n            powOperator = \"exp(log(\" + basis + \") * float(-\" + beta + \"));\";\n        }\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords.x;\\n        int r = coords.y;\\n        int c = coords.z;\\n        int d = coords.w;\\n\\n        bool hasNextCol = d < \" + this.outputShape[3] + \";\\n        bool hasNextRow = c < \" + this.outputShape[2] + \";\\n\\n        vec4 sum = vec4(0.);\\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\\n\\n        vec4 xAtOutputCoords = vec4(\\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\\n          hasNextCol ?\\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\\n          hasNextRow ?\\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\\n        );\\n\\n        int firstChannel = d - \" + rad + \";\\n        vec2 cache = vec2(0.);\\n        if(firstChannel >= 0){\\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\\n            if(hasNextRow){\\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\\n            }\\n        }\\n\\n        ivec2 depth = ivec2(d, d + 1);\\n        for (int j = - \" + rad + \"; j <= \" + rad + \"; j++) {\\n          ivec2 idx = depth + j;\\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(\" + maxD + \"));\\n\\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\\n\\n          if(depthInRange || depthPlusOneInRange){\\n            vec4 z = vec4(0.);\\n            vec4 xFragAtCurrentDepth;\\n            z.xz = cache.xy;\\n            if(depthPlusOneInRange && hasNextCol){\\n              xFragAtCurrentDepth = idx.y != d ?\\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\\n              if(hasNextRow){\\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\\n              }\\n            }\\n            cache.xy = z.yw;\\n            sum += z * z;\\n          }\\n        }\\n        vec4 result = xAtOutputCoords * \" + powOperator + \";\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return LRNPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar lrn = function (args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var depthRadius = attrs.depthRadius, bias = attrs.bias, alpha = attrs.alpha, beta = attrs.beta;\n    var program = tf.env().getBool('WEBGL_PACK_NORMALIZATION') ?\n        new LRNPackedProgram(x.shape, depthRadius, bias, alpha, beta) :\n        new LRNProgram(x.shape, depthRadius, bias, alpha, beta);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n};\n// tslint:disable-next-line: variable-name\nvar LRNConfig = {\n    kernelName: tf.LRN,\n    backendName: 'webgl',\n    kernelFunc: lrn\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar LRNGradProgram = /** @class */ (function () {\n    function LRNGradProgram(inputShape, depthRadius, bias, alpha, beta) {\n        this.variableNames = ['inputImage', 'outputImage', 'dy'];\n        this.outputShape = [];\n        this.outputShape = inputShape;\n        this.depth = inputShape[3];\n        this.depthRadius = depthRadius;\n        this.bias = bias;\n        this.alpha = alpha;\n        this.beta = beta;\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float result = 0.0;\\n        for (int d = 0; d < \" + this.depth + \"; ++d) {\\n          int depthBegin = int(max(0.0, float(d - \" + depthRadius + \")));\\n          int depthEnd = int(min(float(\" + this.depth + \"),\\n              float(d + \" + depthRadius + \" + 1)));\\n\\n          const int MIN_DEPTH_BEGIN = 0;\\n          const int MAX_DEPTH_END = \" + this.depth + \";\\n\\n          float norm = 0.0;\\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd) {\\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n\\n          norm = float(\" + alpha + \") * norm + float(\" + bias + \");\\n\\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd){\\n              float dyi = -2.0 * float(\" + alpha + \")\\n                * float(\" + beta + \")\\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\\n                / norm;\\n              if (k == d) {\\n                dyi += pow(norm, -1.0 * \" + beta + \");\\n              }\\n              if (k == coords[3]) {\\n                dyi *= getDy(b, r, c, d);\\n                result += dyi;\\n              }\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n      }\\n      setOutput(result);\\n      }\\n    \";\n    }\n    return LRNGradProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar lrnGrad = function (args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, y = inputs.y, dy = inputs.dy;\n    var depthRadius = attrs.depthRadius, bias = attrs.bias, alpha = attrs.alpha, beta = attrs.beta;\n    var program = new LRNGradProgram(x.shape, depthRadius, bias, alpha, beta);\n    return backend.runWebGLProgram(program, [x, y, dy], x.dtype);\n};\n// tslint:disable-next-line: variable-name\nvar LRNGradConfig = {\n    kernelName: tf.LRNGrad,\n    backendName: 'webgl',\n    kernelFunc: lrnGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxImpl$1(x, reduceShape, outShape, backend) {\n    var inSize = tf.util.sizeFromShape(reduceShape);\n    var xSize = tf.util.sizeFromShape(x.shape);\n    var batchSize = xSize / inSize;\n    var reshapedInput = reshape({ inputs: { x: x }, attrs: { shape: [batchSize, inSize] }, backend: backend });\n    var reduced = reduce(reshapedInput, x.dtype, 'max', backend);\n    var reshapedOutput = reshape({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend });\n    backend.disposeIntermediateTensorInfo(reshapedInput);\n    backend.disposeIntermediateTensorInfo(reduced);\n    return reshapedOutput;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction max(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var reductionIndices = attrs.reductionIndices, keepDims = attrs.keepDims;\n    var xRank = x.shape.length;\n    var origAxes = tf.util.parseAxisParam(reductionIndices, x.shape);\n    var axes = origAxes;\n    var permutedAxes = tf.backend_util.getAxesPermutation(axes, xRank);\n    var maxInputIsTransposed = permutedAxes != null;\n    var shouldExecuteOnCPU = backend.shouldExecuteOnCPU([x]);\n    var maxInput = x;\n    if (maxInputIsTransposed) {\n        if (shouldExecuteOnCPU) {\n            var xTexData = backend.texData.get(maxInput.dataId);\n            var values = xTexData.values;\n            var newShape = new Array(xRank);\n            for (var i = 0; i < newShape.length; i++) {\n                newShape[i] = x.shape[permutedAxes[i]];\n            }\n            var maxInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n            maxInput = backend.makeTensorInfo(newShape, x.dtype);\n            var maxInputData = backend.texData.get(maxInput.dataId);\n            maxInputData.values = maxInputValues;\n        }\n        else {\n            maxInput = transposeImpl$1(x, permutedAxes, backend);\n        }\n        axes = tf.backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n    tf.backend_util.assertAxesAreInnerMostDims('max', axes, xRank);\n    var _a = tf.backend_util.computeOutAndReduceShapes(maxInput.shape, axes), maxOutShape = _a[0], reduceShape = _a[1];\n    var outShape = maxOutShape;\n    if (keepDims) {\n        // rather than reshape at the end, set the target shape here.\n        outShape = tf.backend_util.expandShapeToKeepDim(maxOutShape, origAxes);\n    }\n    var out;\n    if (shouldExecuteOnCPU) {\n        var xTexData = backend.texData.get(maxInput.dataId);\n        var values = xTexData.values;\n        var outValues = maxImplCPU(values, tf.util.sizeFromShape(reduceShape), outShape, x.dtype);\n        out = backend.makeTensorInfo(outShape, x.dtype);\n        var outData = backend.texData.get(out.dataId);\n        outData.values = outValues;\n    }\n    else {\n        out = maxImpl$1(maxInput, reduceShape, outShape, backend);\n    }\n    if (maxInputIsTransposed) {\n        backend.disposeIntermediateTensorInfo(maxInput);\n    }\n    return out;\n}\nvar maxConfig = {\n    kernelName: tf.Max,\n    backendName: 'webgl',\n    kernelFunc: max\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar MAXIMUM = CHECK_NAN_SNIPPET$1 + \"\\n  return max(a, b);\\n\";\nvar MAXIMUM_PACKED = \"\\n  vec4 result = vec4(max(a, b));\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \" +\n    CHECK_NAN_SNIPPET$2 + \"\\n  return result;\\n\";\nvar maximum = binaryKernelFunc({\n    opSnippet: MAXIMUM,\n    packedOpSnippet: MAXIMUM_PACKED,\n    cpuKernelImpl: maximumImplCPU\n});\nvar maximumConfig = {\n    kernelName: tf.Maximum,\n    backendName: 'webgl',\n    kernelFunc: maximum\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxPool(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    assertNotComplex(x, 'maxPool');\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode;\n    var dilations = 1;\n    tf.util.assert(tf.backend_util.eitherStridesOrDilationsAreOne(strides, dilations), function () { return 'Error in maxPool: Either strides or dilations must be 1. ' +\n        (\"Got strides \" + strides + \" and dilations '\" + dilations + \"'\"); });\n    var convInfo = tf.backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n        tf.util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n        return identity({ inputs: { x: x }, backend: backend });\n    }\n    var maxPoolProgram = new Pool2DProgram(convInfo, 'max', false);\n    return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);\n}\nvar maxPoolConfig = {\n    kernelName: tf.MaxPool,\n    backendName: 'webgl',\n    kernelFunc: maxPool\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxPool3d(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dataFormat = attrs.dataFormat, dimRoundingMode = attrs.dimRoundingMode;\n    var dilations = [1, 1, 1];\n    var convInfo = tf.backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);\n    var maxPoolProgram = new Pool3DProgram(convInfo, 'max', false);\n    return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);\n}\nvar maxPool3DConfig = {\n    kernelName: tf.MaxPool3D,\n    backendName: 'webgl',\n    kernelFunc: maxPool3d\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar MaxPool2DBackpropProgram = /** @class */ (function () {\n    function MaxPool2DBackpropProgram(convInfo) {\n        this.variableNames = ['dy', 'maxPos'];\n        this.outputShape = convInfo.inShape;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var dilationHeight = convInfo.dilationHeight;\n        var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        var lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;\n        this.userCode = \"\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + effectiveFilterHeight + \";\\n          wR += \" + dilationHeight + \") {\\n          float dyR = float(dyRCorner + wR) / \" + strideHeight + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + convInfo.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + effectiveFilterWidth + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + strideWidth + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + convInfo.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n            int maxPosValue = \" + lastIndex + \" - int(getMaxPos(b, idyR, idyC, d));\\n\\n            // Get the current value, check it against the value from the\\n            // position matrix.\\n            int curPosValue = wR * \" + effectiveFilterWidth + \" + wC;\\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n            dotProd += dyValue * mask;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return MaxPool2DBackpropProgram;\n}());\nvar MaxPool3DBackpropProgram = /** @class */ (function () {\n    function MaxPool3DBackpropProgram(convInfo) {\n        this.variableNames = ['dy', 'maxPos'];\n        this.outputShape = convInfo.inShape;\n        var strideDepth = convInfo.strideDepth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var dilationDepth = convInfo.dilationDepth;\n        var dilationHeight = convInfo.dilationHeight;\n        var dilationWidth = convInfo.dilationWidth;\n        var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        var padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        var lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;\n        this.userCode = \"\\n      const ivec3 pads = ivec3(\" + padFront + \", \" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyDCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\\n        // dx(xD, xR, xC, ch).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int wD = 0; wD < \" + effectiveFilterDepth + \";\\n           wD += \" + dilationDepth + \") {\\n          float dyD = float(dyDCorner + wD) / \" + strideDepth + \".0;\\n\\n          if (dyD < 0.0 || dyD >= \" + convInfo.outDepth + \".0 || fract(dyD) > 0.0) {\\n            continue;\\n          }\\n          int idyD = int(dyD);\\n\\n          for (int wR = 0; wR < \" + effectiveFilterHeight + \";\\n              wR += \" + dilationHeight + \") {\\n            float dyR = float(dyRCorner + wR) / \" + strideHeight + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + convInfo.outHeight + \".0 ||\\n                fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            for (int wC = 0; wC < \" + effectiveFilterWidth + \";\\n                wC += \" + dilationWidth + \") {\\n              float dyC = float(dyCCorner + wC) / \" + strideWidth + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + convInfo.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\\n              int maxPosValue = \" + lastIndex + \" -\\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\\n\\n              // Get the current value, check it against the value from the\\n              // position matrix.\\n              int curPosValue =\\n                  wD * \" + effectiveFilterHeight + \" * \" + effectiveFilterWidth + \" +\\n                  wR * \" + effectiveFilterWidth + \" + wC;\\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n              dotProd += dyValue * mask;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return MaxPool3DBackpropProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxPool3DGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, input = inputs.input;\n    var x = input;\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode;\n    var dilations = [1, 1, 1];\n    var convInfo = tf.backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);\n    var maxPool3dPositionsProgram = new Pool3DProgram(convInfo, 'max', true /* get positions */);\n    var maxPool3dPositions = backend.runWebGLProgram(maxPool3dPositionsProgram, [x], x.dtype);\n    var maxPoolBackpropProgram = new MaxPool3DBackpropProgram(convInfo);\n    var result = backend.runWebGLProgram(maxPoolBackpropProgram, [dy, maxPool3dPositions], x.dtype);\n    backend.disposeIntermediateTensorInfo(maxPool3dPositions);\n    return result;\n}\nvar maxPoolGrad3DConfig = {\n    kernelName: tf.MaxPool3DGrad,\n    backendName: 'webgl',\n    kernelFunc: maxPool3DGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxPoolGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var dy = inputs.dy, input = inputs.input, output = inputs.output;\n    var x = input;\n    assertNotComplex([input, output], 'maxPoolGrad');\n    var filterSize = attrs.filterSize, strides = attrs.strides, pad = attrs.pad, dimRoundingMode = attrs.dimRoundingMode;\n    var convInfo = tf.backend_util.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */, pad, dimRoundingMode);\n    var getPositions = true;\n    var maxPoolPositionsProgram = new Pool2DProgram(convInfo, 'max', getPositions);\n    var maxPoolPositions = backend.runWebGLProgram(maxPoolPositionsProgram, [x], x.dtype);\n    var maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);\n    var result = backend.runWebGLProgram(maxPoolBackPropProgram, [dy, maxPoolPositions], x.dtype);\n    backend.disposeIntermediateTensorInfo(maxPoolPositions);\n    return result;\n}\nvar maxPoolGradConfig = {\n    kernelName: tf.MaxPoolGrad,\n    backendName: 'webgl',\n    kernelFunc: maxPoolGrad\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, backend) {\n    var program = new Pool2DProgram(convInfo, 'max', false);\n    var poolOutput = backend.runWebGLProgram(program, [x], 'float32');\n    program = new Pool2DProgram(convInfo, 'max', true, true, includeBatchInIndex);\n    var indexOutput = backend.runWebGLProgram(program, [x], 'float32');\n    return [poolOutput, indexOutput];\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar maxPoolWithArgmaxConfig = {\n    kernelName: tf.MaxPoolWithArgmax,\n    backendName: 'webgl',\n    kernelFunc: function (_a) {\n        var inputs = _a.inputs, attrs = _a.attrs, backend = _a.backend;\n        var x = inputs.x;\n        var _b = attrs, filterSize = _b.filterSize, strides = _b.strides, pad = _b.pad, includeBatchInIndex = _b.includeBatchInIndex;\n        var webglBackend = backend;\n        tf.util.assert(x.shape.length === 4, function () { return \"Error in maxPool: input must be rank 4 but got rank \" + x.shape.length + \".\"; });\n        var dilations = [1, 1];\n        tf.util.assert(tf.backend_util.eitherStridesOrDilationsAreOne(strides, dilations), function () { return 'Error in maxPool: Either strides or dilations must be 1. ' +\n            (\"Got strides \" + strides + \" and dilations '\" + dilations + \"'\"); });\n        var convInfo = tf.backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad);\n        var _c = maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, webglBackend), result = _c[0], indexes = _c[1];\n        return [result, indexes];\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction meanImpl(x, reduceShape, outShape, backend) {\n    var inSize = tf.util.sizeFromShape(reduceShape);\n    var xSize = tf.util.sizeFromShape(x.shape);\n    var batchSize = xSize / inSize;\n    var reshapedInput = reshape({ inputs: { x: x }, attrs: { shape: [batchSize, inSize] }, backend: backend });\n    var reduced = reduce(reshapedInput, 'float32', 'mean', backend);\n    var reshapedOutput = reshape({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend });\n    backend.disposeIntermediateTensorInfo(reshapedInput);\n    backend.disposeIntermediateTensorInfo(reduced);\n    return reshapedOutput;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar meanConfig = {\n    kernelName: tf.Mean,\n    backendName: 'webgl',\n    kernelFunc: function (_a) {\n        var inputs = _a.inputs, attrs = _a.attrs, backend = _a.backend;\n        var x = inputs.x;\n        var _b = attrs, keepDims = _b.keepDims, axis = _b.axis;\n        var webglBackend = backend;\n        var xRank = x.shape.length;\n        var origAxes = tf.util.parseAxisParam(axis, x.shape);\n        var axes = origAxes;\n        var permutedAxes = tf.backend_util.getAxesPermutation(axes, xRank);\n        var meanInputIsTransposed = permutedAxes != null;\n        var shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);\n        var intermediates = [];\n        var meanInput = x;\n        if (meanInputIsTransposed) {\n            if (shouldExecuteOnCPU) {\n                var xTexData = webglBackend.texData.get(meanInput.dataId);\n                var values = xTexData.values;\n                var newShape = new Array(xRank);\n                for (var i = 0; i < newShape.length; i++) {\n                    newShape[i] = x.shape[permutedAxes[i]];\n                }\n                var meanInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n                meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);\n                var meanInputData = webglBackend.texData.get(meanInput.dataId);\n                meanInputData.values = meanInputValues;\n            }\n            else {\n                meanInput = transposeImpl$1(x, permutedAxes, webglBackend);\n            }\n            intermediates.push(meanInput);\n            axes = tf.backend_util.getInnerMostAxes(axes.length, xRank);\n        }\n        tf.backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);\n        var _c = tf.backend_util.computeOutAndReduceShapes(meanInput.shape, axes), meanOutShape = _c[0], reduceShape = _c[1];\n        var outShape = meanOutShape;\n        if (keepDims) {\n            // rather than reshape at the end, set the target shape here.\n            outShape = tf.backend_util.expandShapeToKeepDim(meanOutShape, origAxes);\n        }\n        var out = meanImpl(meanInput, reduceShape, outShape, webglBackend);\n        for (var _i = 0, intermediates_1 = intermediates; _i < intermediates_1.length; _i++) {\n            var i = intermediates_1[_i];\n            webglBackend.disposeIntermediateTensorInfo(i);\n        }\n        return out;\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction min(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, keepDims = attrs.keepDims;\n    var xRank = x.shape.length;\n    var origAxes = tf.util.parseAxisParam(axis, x.shape);\n    var axes = origAxes;\n    var permutedAxes = tf.backend_util.getAxesPermutation(axes, xRank);\n    var permutedX = x;\n    if (permutedAxes != null) {\n        permutedX = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutedAxes } });\n        axes = tf.backend_util.getInnerMostAxes(axes.length, x.shape.length);\n    }\n    tf.backend_util.assertAxesAreInnerMostDims('min', axes, xRank);\n    var _a = tf.backend_util.computeOutAndReduceShapes(permutedX.shape, axes), outShape = _a[0], reduceShape = _a[1];\n    var inSize = tf.util.sizeFromShape(reduceShape);\n    var a2D = reshape({ inputs: { x: permutedX }, backend: backend, attrs: { shape: [-1, inSize] } });\n    var reduced = reduce(a2D, a2D.dtype, 'min', backend);\n    var res;\n    if (keepDims) {\n        var newShape = tf.backend_util.expandShapeToKeepDim(outShape, origAxes);\n        res = reshape({ inputs: { x: reduced }, backend: backend, attrs: { shape: newShape } });\n    }\n    else {\n        res = reshape({ inputs: { x: reduced }, backend: backend, attrs: { shape: outShape } });\n    }\n    backend.disposeIntermediateTensorInfo(a2D);\n    backend.disposeIntermediateTensorInfo(reduced);\n    if (permutedAxes != null) {\n        backend.disposeIntermediateTensorInfo(permutedX);\n    }\n    return res;\n}\nvar minConfig = {\n    kernelName: tf.Min,\n    backendName: 'webgl',\n    kernelFunc: min\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar MINIMUM = CHECK_NAN_SNIPPET$1 + \"\\n  return min(a, b);\\n\";\nvar MINIMUM_PACKED = \"\\n  vec4 result = vec4(min(a, b));\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \" +\n    CHECK_NAN_SNIPPET$2 + \"\\n  return result;\\n\";\nvar minimum = binaryKernelFunc({\n    opSnippet: MINIMUM,\n    packedOpSnippet: MINIMUM_PACKED,\n    cpuKernelImpl: minimumImplCPU\n});\nvar minimumConfig = {\n    kernelName: tf.Minimum,\n    backendName: 'webgl',\n    kernelFunc: minimum\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar MirrorPadProgram = /** @class */ (function () {\n    function MirrorPadProgram(xShape, paddings, mode) {\n        this.variableNames = ['x'];\n        this.outputShape = paddings.map(function (p, i) { return p[0] /* beforePad */ + xShape[i] + p[1]; } /* afterPad */);\n        var rank = xShape.length;\n        var dtype = getCoordsDataType(rank);\n        var start = paddings.map(function (p) { return p[0]; }).join(',');\n        var end = paddings.map(function (p, i) { return p[0] + xShape[i]; }).join(',');\n        var unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n        var offset = mode === 'reflect' ? 0 : 1;\n        if (rank === 1) {\n            this.userCode = \"\\n        int start = \" + start + \";\\n        int end = \" + end + \";\\n\\n        void main() {\\n          int outC = getOutputCoords();\\n          if (outC < start) {\\n            outC = start * 2 - outC - \" + offset + \";\\n          } else if(outC >= end) {\\n            outC = (end - 1) * 2 - outC + \" + offset + \";\\n          }\\n          setOutput(getX(outC - start));\\n        }\\n      \";\n            return;\n        }\n        this.userCode = \"\\n      \" + dtype + \" start = \" + dtype + \"(\" + start + \");\\n      \" + dtype + \" end = \" + dtype + \"(\" + end + \");\\n\\n      void main() {\\n        \" + dtype + \" outC = getOutputCoords();\\n        for (int i = 0; i < \" + rank + \"; i++) {\\n          if (outC[i] < start[i]) {\\n            outC[i] = start[i] * 2 - outC[i] - \" + offset + \";\\n          } else if(outC[i] >= end[i]) {\\n            outC[i] = (end[i] - 1) * 2 - outC[i] + \" + offset + \";\\n          }\\n        }\\n        \" + dtype + \" coords = outC - start;\\n        setOutput(getX(\" + unpackedCoords + \"));\\n      }\\n    \";\n    }\n    return MirrorPadProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Example shader code for\n * `mirrorPad(tf.tensor1d([1, 2, 3], 'int32'), [[2, 2]], 'reflect')`\n * ```\n *    const int start = int(2);\n *    const int end = int(5);\n *\n *    void main() {\n *       int outputLoc = getOutputCoords();\n *       vec4 result = vec4(0.);\n *\n *       int rc = outputLoc;\n *\n *       int source = rc;\n *       if (source < start) {\n *         source = start * 2 - source - 0;\n *       } else if (source >= end) {\n *         source = (end - 1) * 2 - source + 0;\n *       }\n *       source -= start;\n *\n *       result[0] = getChannel(getX(source), source);\n *       rc += 1;\n *       if(rc < 6) {\n *          int source = rc;\n *          if (source < start) {\n *            source = start * 2 - source - 0;\n *          } else if (source >= end) {\n *            source = (end - 1) * 2 - source + 0;\n *          }\n *          source -= start;\n *\n *         result[1] = getChannel(getX(source), source);\n *       }\n *\n *       setOutput(result);\n *     }\n * ```\n */\nvar MirrorPadPackedProgram = /** @class */ (function () {\n    function MirrorPadPackedProgram(xShape, paddings, mode) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = paddings.map(function (p, i) { return p[0] /* beforePad */ + xShape[i] + p[1]; } /* afterPad */);\n        var rank = xShape.length;\n        var dtype = getCoordsDataType(rank);\n        var start = paddings.map(function (p) { return p[0]; }).join(',');\n        var end = paddings.map(function (p, i) { return p[0] + xShape[i]; }).join(',');\n        var coords = getChannels('rc', rank);\n        var source = getChannels('source', rank);\n        var cLimit = coords[rank - 1] + \" < \" + this.outputShape[rank - 1];\n        var innerDims = rank === 1 ? 'source' : \"vec2(\" + source.slice(-2).join() + \")\";\n        var offset = mode === 'reflect' ? 0 : 1;\n        var mainLoop = '';\n        if (rank === 1) {\n            var padSetup = \"\\n        \" + dtype + \" source = rc;\\n        if (source < start) {\\n          source = start * 2 - source - \" + offset + \";\\n        } else if (source >= end) {\\n          source = (end - 1) * 2 - source + \" + offset + \";\\n        }\\n        source -= start;\\n      \";\n            mainLoop = \"\\n        \" + dtype + \" rc = outputLoc;\\n        \" + padSetup + \"\\n        result[0] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n        \" + coords[rank - 1] + \" += 1;\\n        if(\" + cLimit + \") {\\n          \" + padSetup + \"\\n          result[1] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n        }\\n      \";\n        }\n        else {\n            var padSetup = \"\\n        \" + dtype + \" source = rc;\\n        \" + dtype + \" lt = \" + dtype + \"(lessThan(source, start));\\n        \" + dtype + \" gte = \" + dtype + \"(greaterThanEqual(source, end));\\n        \" + dtype + \" orig = 1 - (lt + gte);\\n        source = orig * source +\\n                lt * (start * 2 - source - \" + offset + \") +\\n                gte * ((end - 1) * 2 - source + \" + offset + \");\\n        source -= start;\\n      \";\n            mainLoop = \"\\n        \" + dtype + \" rc = outputLoc;\\n        \" + padSetup + \"\\n        result[0] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n        \" + coords[rank - 1] + \" += 1;\\n        if(\" + cLimit + \") {\\n          \" + padSetup + \"\\n          result[1] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n        }\\n        rc = outputLoc;\\n        \" + coords[rank - 2] + \" += 1;\\n        if(\" + coords[rank - 2] + \" < \" + this.outputShape[rank - 2] + \") {\\n          \" + padSetup + \"\\n          result[2] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n          \" + coords[rank - 1] + \" += 1;\\n          if(\" + cLimit + \") {\\n            \" + padSetup + \"\\n            result[3] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n          }\\n        }\\n      \";\n        }\n        this.userCode = \"\\n      const \" + dtype + \" start = \" + dtype + \"(\" + start + \");\\n      const \" + dtype + \" end = \" + dtype + \"(\" + end + \");\\n\\n      void main() {\\n        \" + dtype + \" outputLoc = getOutputCoords();\\n        vec4 result = vec4(0.);\\n        \" + mainLoop + \"\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return MirrorPadPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar mirrorPadKernelFunc = function (_a) {\n    var inputs = _a.inputs, backend = _a.backend, attrs = _a.attrs;\n    var x = inputs.x;\n    var paddings = attrs.paddings, mode = attrs.mode;\n    var program = tf.env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new MirrorPadPackedProgram(x.shape, paddings, mode) :\n        new MirrorPadProgram(x.shape, paddings, mode);\n    var output = backend.runWebGLProgram(program, [x], x.dtype);\n    return output;\n};\nvar mirrorPadConfig = {\n    kernelName: tf.MirrorPad,\n    backendName: 'webgl',\n    kernelFunc: mirrorPadKernelFunc,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar MOD = \"if (b == 0.0) return NAN;\\n  return mod(a, b);\";\nvar MOD_PACKED = \"\\n  vec4 result = mod(a, b);\\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\\n  \" +\n    CHECK_NAN_SNIPPET$2 + \"\\n  return result;\\n\";\nvar mod = binaryKernelFunc({\n    opSnippet: MOD,\n    packedOpSnippet: MOD_PACKED,\n});\nvar modConfig = {\n    kernelName: tf.Mod,\n    backendName: 'webgl',\n    kernelFunc: mod\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar MultinomialProgram = /** @class */ (function () {\n    function MultinomialProgram(batchSize, numOutcomes, numSamples) {\n        this.variableNames = ['probs'];\n        this.outputShape = [batchSize, numSamples];\n        this.userCode = \"\\n      uniform float seed;\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n\\n        float r = random(seed);\\n        float cdf = 0.0;\\n\\n        for (int i = 0; i < \" + (numOutcomes - 1) + \"; i++) {\\n          cdf += getProbs(batch, i);\\n\\n          if (r < cdf) {\\n            setOutput(float(i));\\n            return;\\n          }\\n        }\\n\\n        // If no other event happened, last event happened.\\n        setOutput(float(\" + (numOutcomes - 1) + \"));\\n      }\\n    \";\n    }\n    MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {\n        var _this = this;\n        return function (gpgpu, webGLProgram) {\n            if (_this.seedLoc == null) {\n                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');\n            }\n            gpgpu.gl.uniform1f(_this.seedLoc, seed);\n        };\n    };\n    return MultinomialProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Without the equality check div produces 0.9999 for a = b, which when\n// floored can cause errors.\nvar DIV = \"\\nif (a == b) {\\n  return 1.0;\\n};\\nreturn a / b;\";\n// We do the same as in ./binaryop_gpu, with vec4 and ivec4.\n// On Linux, the vectorized implementation produces NaNs when a and b are 0.\nvar DIV_PACKED = \"\\n  // vec4 one = vec4(equal(a, b));\\n  // return one + (vec4(1.0) - one) * a / b;\\n  vec4 result = a / b;\\n  if(a.x == b.x) {\\n    result.x = 1.;\\n  }\\n  if(a.y == b.y) {\\n    result.y = 1.;\\n  }\\n  if(a.z == b.z) {\\n    result.z = 1.;\\n  }\\n  if(a.w == b.w) {\\n    result.w = 1.;\\n  }\\n\\n  return result;\\n\";\nvar realDiv = binaryKernelFunc({ opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true });\nvar realDivConfig = {\n    kernelName: tf.RealDiv,\n    backendName: 'webgl',\n    kernelFunc: realDiv,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SUB = 'return a - b;';\nvar sub = binaryKernelFunc({\n    opSnippet: SUB,\n    packedOpSnippet: SUB,\n    supportsComplex: true,\n    cpuKernelImpl: subImplCPU\n});\nvar subConfig = {\n    kernelName: tf.Sub,\n    backendName: 'webgl',\n    kernelFunc: sub\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction softmax(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var logits = inputs.logits;\n    var dim = attrs.dim;\n    var axes = tf.util.parseAxisParam([dim], logits.shape);\n    var maxLogit = max({\n        inputs: { x: logits },\n        backend: backend,\n        attrs: { reductionIndices: axes, keepDims: false }\n    });\n    var expandedShape = tf.backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n    var maxLogitsReshaped = reshape({ inputs: { x: maxLogit }, backend: backend, attrs: { shape: expandedShape } });\n    var a = sub({ inputs: { a: logits, b: maxLogitsReshaped }, backend: backend });\n    var b = exp({ inputs: { x: a }, backend: backend });\n    var sumExp = sum({ inputs: { x: b }, backend: backend, attrs: { axis: axes, keepDims: false } });\n    var sumExpReshaped = reshape({ inputs: { x: sumExp }, backend: backend, attrs: { shape: expandedShape } });\n    var res = realDiv({ inputs: { a: b, b: sumExpReshaped }, backend: backend });\n    backend.disposeIntermediateTensorInfo(maxLogit);\n    backend.disposeIntermediateTensorInfo(maxLogitsReshaped);\n    backend.disposeIntermediateTensorInfo(a);\n    backend.disposeIntermediateTensorInfo(b);\n    backend.disposeIntermediateTensorInfo(sumExp);\n    backend.disposeIntermediateTensorInfo(sumExpReshaped);\n    return res;\n}\nvar softmaxConfig = {\n    kernelName: tf.Softmax,\n    backendName: 'webgl',\n    kernelFunc: softmax\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction multinomial(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var logits = inputs.logits;\n    var numSamples = attrs.numSamples, seed = attrs.seed, normalized = attrs.normalized;\n    var probs = normalized ?\n        logits :\n        softmax({ inputs: { logits: logits }, backend: backend, attrs: { dim: logits.shape.length - 1 } });\n    var batchSize = probs.shape[0];\n    var numOutcomes = probs.shape[1];\n    var program = new MultinomialProgram(batchSize, numOutcomes, numSamples);\n    var customSetup = program.getCustomSetupFunc(seed);\n    var res = backend.runWebGLProgram(program, [probs], 'int32', customSetup);\n    if (!normalized) {\n        backend.disposeIntermediateTensorInfo(probs);\n    }\n    return res;\n}\nvar multinomialConfig = {\n    kernelName: tf.Multinomial,\n    backendName: 'webgl',\n    kernelFunc: multinomial\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar NEG = \"return -x;\";\n// This doesn't use unaryKernelFunc because negImplCPU is not of type\n// SimpleUnaryKernelImplCPU.\nfunction neg(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    if (backend.shouldExecuteOnCPU([x])) {\n        var xData = backend.texData.get(x.dataId);\n        var _a = negImplCPU(xData.values, x.shape, x.dtype), outValues = _a[0], newShape = _a[1];\n        return backend.makeTensorInfo(newShape, x.dtype, outValues);\n    }\n    var program;\n    if (tf.env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n        program = new UnaryOpPackedProgram(x.shape, NEG);\n    }\n    else {\n        program = new UnaryOpProgram(x.shape, NEG);\n    }\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nvar negConfig = {\n    kernelName: tf.Neg,\n    backendName: 'webgl',\n    kernelFunc: neg\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar nonMaxSuppressionV3Impl = tf.kernel_impls.nonMaxSuppressionV3Impl;\nfunction nonMaxSuppressionV3(args) {\n    tf.backend_util.warn('tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n        'Call tf.nonMaxSuppressionAsync() instead');\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var boxes = inputs.boxes, scores = inputs.scores;\n    var maxOutputSize = attrs.maxOutputSize, iouThreshold = attrs.iouThreshold, scoreThreshold = attrs.scoreThreshold;\n    var boxesVals = backend.readSync(boxes.dataId);\n    var scoresVals = backend.readSync(scores.dataId);\n    var selectedIndices = nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold).selectedIndices;\n    return backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices));\n}\nvar nonMaxSuppressionV3Config = {\n    kernelName: tf.NonMaxSuppressionV3,\n    backendName: 'webgl',\n    kernelFunc: nonMaxSuppressionV3\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar nonMaxSuppressionV4Impl = tf.kernel_impls.nonMaxSuppressionV4Impl;\nfunction nonMaxSuppressionV4(args) {\n    tf.backend_util.warn('tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n        'Call tf.nonMaxSuppressionAsync() instead');\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var boxes = inputs.boxes, scores = inputs.scores;\n    var maxOutputSize = attrs.maxOutputSize, iouThreshold = attrs.iouThreshold, scoreThreshold = attrs.scoreThreshold, padToMaxOutputSize = attrs.padToMaxOutputSize;\n    var boxesVals = backend.readSync(boxes.dataId);\n    var scoresVals = backend.readSync(scores.dataId);\n    var _a = nonMaxSuppressionV4Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize), selectedIndices = _a.selectedIndices, validOutputs = _a.validOutputs;\n    return [\n        backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices)),\n        backend.makeTensorInfo([], 'int32', new Int32Array([validOutputs]))\n    ];\n}\nvar nonMaxSuppressionV4Config = {\n    kernelName: tf.NonMaxSuppressionV4,\n    backendName: 'webgl',\n    kernelFunc: nonMaxSuppressionV4\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar nonMaxSuppressionV5Impl = tf.kernel_impls.nonMaxSuppressionV5Impl;\nfunction nonMaxSuppressionV5(args) {\n    tf.backend_util.warn('tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n        'Call tf.nonMaxSuppressionAsync() instead');\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var boxes = inputs.boxes, scores = inputs.scores;\n    var maxOutputSize = attrs.maxOutputSize, iouThreshold = attrs.iouThreshold, scoreThreshold = attrs.scoreThreshold, softNmsSigma = attrs.softNmsSigma;\n    var boxesVals = backend.readSync(boxes.dataId);\n    var scoresVals = backend.readSync(scores.dataId);\n    var maxOutputSizeVal = maxOutputSize;\n    var iouThresholdVal = iouThreshold;\n    var scoreThresholdVal = scoreThreshold;\n    var softNmsSigmaVal = softNmsSigma;\n    var _a = nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal), selectedIndices = _a.selectedIndices, selectedScores = _a.selectedScores;\n    return [\n        backend.makeTensorInfo([selectedIndices.length], 'int32', new Int32Array(selectedIndices)),\n        backend.makeTensorInfo([selectedScores.length], 'float32', new Float32Array(selectedScores))\n    ];\n}\nvar nonMaxSuppressionV5Config = {\n    kernelName: tf.NonMaxSuppressionV5,\n    backendName: 'webgl',\n    kernelFunc: nonMaxSuppressionV5\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar OneHotProgram = /** @class */ (function () {\n    function OneHotProgram(numIndices, depth, onValue, offValue) {\n        this.variableNames = ['indices'];\n        this.outputShape = [numIndices, depth];\n        this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int index = round(getIndices(coords.x));\\n        setOutput(mix(float(\" + offValue + \"), float(\" + onValue + \"),\\n                      float(index == coords.y)));\\n      }\\n    \";\n    }\n    return OneHotProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar oneHot = function (args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var indices = inputs.indices;\n    var depth = attrs.depth, onValue = attrs.onValue, offValue = attrs.offValue;\n    var indicesSize = tf.util.sizeFromShape(indices.shape);\n    var program = new OneHotProgram(indicesSize, depth, onValue, offValue);\n    var reshaped = reshape({ inputs: { x: indices }, backend: backend, attrs: { shape: [indicesSize] } });\n    var result = backend.runWebGLProgram(program, [reshaped], indices.dtype);\n    backend.disposeIntermediateTensorInfo(reshaped);\n    var outShape = indices.shape.concat([depth]);\n    var out = reshape({ inputs: { x: result }, backend: backend, attrs: { shape: outShape } });\n    backend.disposeIntermediateTensorInfo(result);\n    return out;\n};\nvar oneHotConfig = {\n    kernelName: tf.OneHot,\n    backendName: 'webgl',\n    kernelFunc: oneHot\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction zerosLike(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    if (x.dtype === 'complex64') {\n        var realPart = real({ inputs: { input: x }, backend: backend });\n        var r = zerosLike({ inputs: { x: realPart }, backend: backend });\n        var imagPart = imag({ inputs: { input: x }, backend: backend });\n        var i = zerosLike({ inputs: { x: imagPart }, backend: backend });\n        var result = complex({ inputs: { real: r, imag: i }, backend: backend });\n        backend.disposeIntermediateTensorInfo(realPart);\n        backend.disposeIntermediateTensorInfo(r);\n        backend.disposeIntermediateTensorInfo(imagPart);\n        backend.disposeIntermediateTensorInfo(i);\n        return result;\n    }\n    else {\n        return fill({\n            attrs: {\n                shape: x.shape,\n                dtype: x.dtype,\n                value: x.dtype === 'string' ? '' : 0\n            },\n            backend: backend\n        });\n    }\n}\nvar zerosLikeConfig = {\n    kernelName: tf.ZerosLike,\n    backendName: 'webgl',\n    kernelFunc: zerosLike\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction onesLike(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var x = inputs.x;\n    if (x.dtype === 'string') {\n        throw new Error('onesLike is not supported under string dtype');\n    }\n    else if (x.dtype === 'complex64') {\n        var realPart = real({ inputs: { input: x }, backend: backend });\n        var r = onesLike({ inputs: { x: realPart }, backend: backend });\n        var imagPart = imag({ inputs: { input: x }, backend: backend });\n        var i = zerosLike({ inputs: { x: imagPart }, backend: backend });\n        var result = complex({ inputs: { real: r, imag: i }, backend: backend });\n        backend.disposeIntermediateTensorInfo(realPart);\n        backend.disposeIntermediateTensorInfo(r);\n        backend.disposeIntermediateTensorInfo(imagPart);\n        backend.disposeIntermediateTensorInfo(i);\n        return result;\n    }\n    else {\n        // TODO(cais, smilkov): Add WebGL shader for onesLike:\n        //   https://github.com/tensorflow/tfjs/issues/1293\n        return fill({ attrs: { shape: x.shape, dtype: x.dtype, value: 1 }, backend: backend });\n    }\n}\nvar onesLikeConfig = {\n    kernelName: tf.OnesLike,\n    backendName: 'webgl',\n    kernelFunc: onesLike\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction pack(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var axis = attrs.axis;\n    if (inputs.length === 1) {\n        return expandDims({ inputs: { input: inputs[0] }, backend: backend, attrs: { dim: axis } });\n    }\n    var shape = inputs[0].shape;\n    var dtype = inputs[0].dtype;\n    inputs.forEach(function (t) {\n        tf.util.assertShapesMatch(shape, t.shape, 'All tensors passed to stack must have matching shapes');\n        tf.util.assert(dtype === t.dtype, function () { return 'All tensors passed to stack must have matching dtypes'; });\n    });\n    var intermediateTensorInfos = [];\n    var expandedTensors = inputs.map(function (t) {\n        var expandedT = expandDims({ inputs: { input: t }, backend: backend, attrs: { dim: axis } });\n        intermediateTensorInfos.push(expandedT);\n        return expandedT;\n    });\n    var result = concat({ inputs: expandedTensors, backend: backend, attrs: { axis: axis } });\n    intermediateTensorInfos.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return result;\n}\nvar packConfig = {\n    kernelName: tf.Pack,\n    backendName: 'webgl',\n    kernelFunc: pack\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar PadProgram = /** @class */ (function () {\n    function PadProgram(xShape, paddings, constantValue) {\n        this.variableNames = ['x'];\n        this.outputShape = paddings.map(function (p, i) { return p[0] /* beforePad */ + xShape[i] + p[1]; } /* afterPad */);\n        var rank = xShape.length;\n        var type = getCoordsDataType(rank);\n        var start = paddings.map(function (p) { return p[0]; }).join(',');\n        var end = paddings.map(function (p, i) { return p[0] + xShape[i]; }).join(',');\n        var unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n        if (rank === 1) {\n            this.userCode = \"\\n        int start = \" + start + \";\\n        int end = \" + end + \";\\n\\n        void main() {\\n          int outC = getOutputCoords();\\n          if (outC < start || outC >= end) {\\n            setOutput(float(\" + constantValue + \"));\\n          } else {\\n            setOutput(getX(outC - start));\\n          }\\n        }\\n      \";\n            return;\n        }\n        this.userCode = \"\\n      \" + type + \" start = \" + type + \"(\" + start + \");\\n      \" + type + \" end = \" + type + \"(\" + end + \");\\n\\n      void main() {\\n        \" + type + \" outC = getOutputCoords();\\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\\n          setOutput(float(\" + constantValue + \"));\\n        } else {\\n          \" + type + \" coords = outC - start;\\n          setOutput(getX(\" + unpackedCoords + \"));\\n        }\\n      }\\n    \";\n    }\n    return PadProgram;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar PadPackedProgram = /** @class */ (function () {\n    function PadPackedProgram(xShape, paddings, constantValue) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = paddings.map(function (p, i) { return p[0] /* beforePad */ + xShape[i] + p[1]; } /* afterPad */);\n        var rank = xShape.length;\n        var dtype = getCoordsDataType(rank);\n        var start = paddings.map(function (p) { return p[0]; }).join(',');\n        var end = paddings.map(function (p, i) { return p[0] + xShape[i]; }).join(',');\n        var coords = getChannels('rc', rank);\n        var source = getChannels('source', rank);\n        var cLimit = coords[rank - 1] + \" < \" + this.outputShape[rank - 1];\n        var innerDims = rank === 1 ? 'source' : \"vec2(\" + source.slice(-2).join() + \")\";\n        var componentSetup = [\n            dtype + \" rc = outputLoc;\", coords[rank - 1] + \" += 1;\\n       if(\" + cLimit + \") {\\n      \",\n            rank === 1 ? '' : \"}\\n       rc = outputLoc;\\n       \" + coords[rank - 2] + \" += 1;\\n       if(\" + coords[rank - 2] + \" < \" + this.outputShape[rank - 2] + \") {\",\n            rank === 1 ? '' : \"  \" + coords[rank - 1] + \" += 1;\\n         if(\" + cLimit + \") {\"\n        ];\n        var paddingArea = rank === 1 ?\n            'rc < start || rc >= end' :\n            'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))';\n        var mainLoop = '';\n        for (var i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {\n            mainLoop += \"\\n        \" + componentSetup[i] + \"\\n        if (\" + paddingArea + \") {\\n          result[\" + i + \"] = float(\" + constantValue + \");\\n        } else {\\n          \" + dtype + \" source = rc - start;\\n          result[\" + i + \"] = getChannel(getX(\" + source.join() + \"), \" + innerDims + \");\\n        }\\n      \";\n        }\n        mainLoop += (rank === 1 ? \"} \" : \"}}\");\n        this.userCode = \"\\n      const \" + dtype + \" start = \" + dtype + \"(\" + start + \");\\n      const \" + dtype + \" end = \" + dtype + \"(\" + end + \");\\n\\n      void main() {\\n        \" + dtype + \" outputLoc = getOutputCoords();\\n        vec4 result = vec4(0.);\\n        \" + mainLoop + \"\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return PadPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar padV2 = function (args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var paddings = attrs.paddings, constantValue = attrs.constantValue;\n    var program = tf.env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new PadPackedProgram(x.shape, paddings, constantValue) :\n        new PadProgram(x.shape, paddings, constantValue);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n};\nvar padV2Config = {\n    kernelName: tf.PadV2,\n    backendName: 'webgl',\n    kernelFunc: padV2\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar POW = \"\\n  if(a < 0.0 && floor(b) < b){\\n    return NAN;\\n  }\\n  if (b == 0.0) {\\n    return 1.0;\\n  }\\n  return (round(mod(b, 2.0)) != 1) ?\\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\\n\";\nvar POW_PACKED = \"\\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\\n  vec4 result = multiplier * pow(abs(a), b);\\n\\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\\n  bvec4 isExpZero = equal(b, vec4(0.0));\\n  result.r = isExpZero.r ? 1.0 : result.r;\\n  result.g = isExpZero.g ? 1.0 : result.g;\\n  result.b = isExpZero.b ? 1.0 : result.b;\\n  result.a = isExpZero.a ? 1.0 : result.a;\\n\\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\\n  \" +\n    CHECK_NAN_SNIPPET$2 + \"\\n  return result;\\n\";\nvar pow = binaryKernelFunc({ opSnippet: POW, packedOpSnippet: POW_PACKED });\nvar powConfig = {\n    kernelName: tf.Pow,\n    backendName: 'webgl',\n    kernelFunc: pow\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction prod(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var axis = attrs.axis, keepDims = attrs.keepDims;\n    var xRank = x.shape.length;\n    var toDispose = [];\n    var origAxes = tf.util.parseAxisParam(axis, x.shape);\n    var axes = origAxes;\n    var permutedAxes = tf.backend_util.getAxesPermutation(axes, xRank);\n    var permutedX = x;\n    if (permutedAxes != null) {\n        permutedX = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutedAxes } });\n        axes = tf.backend_util.getInnerMostAxes(axes.length, xRank);\n        toDispose.push(permutedX);\n    }\n    tf.backend_util.assertAxesAreInnerMostDims('prod', axes, xRank);\n    var res;\n    if (backend.shouldExecuteOnCPU([permutedX])) {\n        var xVals = backend.texData.get(permutedX.dataId).values;\n        var _a = prodImplCPU(permutedX.shape, permutedX.dtype, xVals, axes), outVals = _a.outVals, outShape = _a.outShape, outDtype = _a.outDtype;\n        res = backend.makeTensorInfo(outShape, outDtype, outVals);\n    }\n    else {\n        var _b = tf.backend_util.computeOutAndReduceShapes(permutedX.shape, axes), outShape = _b[0], reduceShape = _b[1];\n        var inSize = tf.util.sizeFromShape(reduceShape);\n        var a2D = reshape({ inputs: { x: permutedX }, backend: backend, attrs: { shape: [-1, inSize] } });\n        var outputDType = tf.sumOutType(x.dtype);\n        var reduced = reduce(a2D, outputDType, 'prod', backend);\n        res = reshape({ inputs: { x: reduced }, backend: backend, attrs: { shape: outShape } });\n        toDispose.push(a2D);\n        toDispose.push(reduced);\n    }\n    if (keepDims) {\n        toDispose.push(res);\n        var newShape = tf.backend_util.expandShapeToKeepDim(res.shape, origAxes);\n        res = reshape({ inputs: { x: res }, backend: backend, attrs: { shape: newShape } });\n    }\n    toDispose.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return res;\n}\nvar prodConfig = {\n    kernelName: tf.Prod,\n    backendName: 'webgl',\n    kernelFunc: prod\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar range = function (args) {\n    var backend = args.backend, attrs = args.attrs;\n    var start = attrs.start, stop = attrs.stop, step = attrs.step, dtype = attrs.dtype;\n    var values = rangeImplCPU(start, stop, step, dtype);\n    return backend.makeTensorInfo([values.length], dtype, values);\n};\nvar rangeConfig = {\n    kernelName: tf.Range,\n    backendName: 'webgl',\n    kernelFunc: range\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar RECIPROCAL = \"return 1.0 / x;\";\nvar reciprocal = unaryKernelFunc({ opSnippet: RECIPROCAL });\nvar reciprocalConfig = {\n    kernelName: tf.Reciprocal,\n    backendName: 'webgl',\n    kernelFunc: reciprocal,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar RELU$2 = CHECK_NAN_SNIPPET + \"\\n  return (x < 0.0) ? 0.0 : x;\\n\";\nvar RELU_PACKED = \"\\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\\n  bvec4 isNaN = isnan(x);\\n\\n  result.r = isNaN.r ? x.r : result.r;\\n  result.g = isNaN.g ? x.g : result.g;\\n  result.b = isNaN.b ? x.b : result.b;\\n  result.a = isNaN.a ? x.a : result.a;\\n\\n  return result;\\n\";\nvar relu = unaryKernelFunc({ opSnippet: RELU$2, packedOpSnippet: RELU_PACKED });\nvar reluConfig = {\n    kernelName: tf.Relu,\n    backendName: 'webgl',\n    kernelFunc: relu\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar RELU6$2 = CHECK_NAN_SNIPPET + \"\\n  return (x < 0.0) ? 0.0 : min(6.0, x);\\n\";\nvar RELU6_PACKED = \"\\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\\n  bvec4 isNaN = isnan(x);\\n\\n  result.r = isNaN.r ? x.r : result.r;\\n  result.g = isNaN.g ? x.g : result.g;\\n  result.b = isNaN.b ? x.b : result.b;\\n  result.a = isNaN.a ? x.a : result.a;\\n\\n  return result;\\n\";\nvar relu6 = unaryKernelFunc({ opSnippet: RELU6$2, packedOpSnippet: RELU6_PACKED });\nvar relu6Config = {\n    kernelName: tf.Relu6,\n    backendName: 'webgl',\n    kernelFunc: relu6\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ResizeBilinearProgram = /** @class */ (function () {\n    function ResizeBilinearProgram(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {\n        this.variableNames = ['A'];\n        this.outputShape = [];\n        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        var effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        var effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        var sourceFracIndexRC;\n        if (halfPixelCenters) {\n            sourceFracIndexRC =\n                \"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC\" +\n                    \" - vec2(0.5)\";\n        }\n        else {\n            sourceFracIndexRC = \"vec2(yRC) * effectiveInputOverOutputRatioRC\";\n        }\n        this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + effectiveInSize[0] / effectiveOutSize[0] + \",\\n          \" + effectiveInSize[1] / effectiveOutSize[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + oldHeight + \".0, \" + oldWidth + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = \" + sourceFracIndexRC + \";\\n\\n        // Compute the four integer indices.\\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\\n        ivec2 sourceCeilRC = ivec2(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n        float newValue = top + (bottom - top) * fracRC.x;\\n\\n        setOutput(newValue);\\n      }\\n    \";\n    }\n    return ResizeBilinearProgram;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ResizeBilinearPackedProgram = /** @class */ (function () {\n    function ResizeBilinearPackedProgram(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        var effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        var effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        var sourceFracIndexRC;\n        if (halfPixelCenters) {\n            sourceFracIndexRC = \"(vec3(yRC) + vec3(0.5)) * \" +\n                \"effectiveInputOverOutputRatioRC - vec3(0.5)\";\n        }\n        else {\n            sourceFracIndexRC = \"vec3(yRC) * effectiveInputOverOutputRatioRC\";\n        }\n        this.userCode = \"\\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\\n          \" + effectiveInSize[0] / effectiveOutSize[0] + \",\\n          \" + effectiveInSize[1] / effectiveOutSize[1] + \",\\n          \" + effectiveInSize[1] / effectiveOutSize[1] + \");\\n      const vec3 inputShapeRC = vec3(\" + oldHeight + \".0, \" + oldWidth + \".0,\\n                                     \" + oldWidth + \".0);\\n\\n      float getAValue(int b, int r, int c, int d) {\\n        return getChannel(getA(b, r, c, d), vec2(c, d));\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        // Calculate values for next column in yRC.z.\\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\\n\\n        // Fractional source index.\\n        vec3 sourceFracIndexRC = \" + sourceFracIndexRC + \";\\n\\n        // Compute the four integer indices.\\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\\n        ivec3 sourceCeilRC = ivec3(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        // Should we calculate next column and row elements in 2x2 packed cell.\\n        bool hasNextCol = d < \" + (depth - 1) + \";\\n        bool hasNextRow = coords.z < \" + (newWidth - 1) + \";\\n\\n        // In parallel, construct four corners for all four components in\\n        // packed 2x2 cell.\\n        vec4 topLeft = vec4(\\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\\n\\n        vec4 bottomLeft = vec4(\\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\\n\\n        vec4 topRight = vec4(\\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\\n\\n        vec4 bottomRight = vec4(\\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\\n\\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\\n\\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\\n        vec4 newValue = mix(top, bottom, fracRC.x);\\n\\n        setOutput(newValue);\\n      }\\n    \";\n    }\n    return ResizeBilinearPackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction resizeBilinear(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var images = inputs.images;\n    var alignCorners = attrs.alignCorners, halfPixelCenters = attrs.halfPixelCenters, size = attrs.size;\n    var newHeight = size[0], newWidth = size[1];\n    var program = tf.env().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ?\n        new ResizeBilinearPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) :\n        new ResizeBilinearProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);\n    return backend.runWebGLProgram(program, [images], 'float32');\n}\nvar resizeBilinearConfig = {\n    kernelName: tf.ResizeBilinear,\n    backendName: 'webgl',\n    kernelFunc: resizeBilinear\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ResizeBilinearBackpropProgram = /** @class */ (function () {\n    function ResizeBilinearBackpropProgram(dyShape, inputShape, alignCorners) {\n        this.variableNames = ['dy'];\n        this.outputShape = [];\n        this.outputShape = inputShape;\n        var xHeight = inputShape[1], xWidth = inputShape[2];\n        var yHeight = dyShape[1], yWidth = dyShape[2];\n        // In the backwards pass, we want to find the pixels that were generated for\n        // each pixel in the input image the forward pass and add the corresponding\n        // coefficient from dy to the gradient (with some interpolation).\n        var effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        var effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        var heightScale = effectiveXSize[0] / effectiveYSize[0];\n        var widthScale = effectiveXSize[1] / effectiveYSize[1];\n        var invHeightScale = 1 / heightScale;\n        var invWidthScale = 1 / widthScale;\n        // This defines the size of the window of values around a particular\n        // index in dy that we want to search for contributions to dx.\n        var winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n        var winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + heightScale + \");\\n        const float widthScale = float(\" + widthScale + \");\\n\\n        const float invHeightScale = float(\" + invHeightScale + \");\\n        const float invWidthScale = float(\" + invWidthScale + \");\\n\\n        const int winHeight = int(\" + winHeight + \");\\n        const int winWidth = int(\" + winWidth + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(startRLerp - float(winHeight / 2));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(startCLerp - float(winWidth / 2));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + yHeight + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + yWidth + \") {\\n              continue;\\n            }\\n\\n            float dxR = float(dyR) * heightScale;\\n            int topDxRIndex = int(floor(dxR));\\n            int bottomDxRIndex = int(min(ceil(dxR), \" + (xHeight - 1) + \".0));\\n            float dxRLerp = dxR - float(topDxRIndex);\\n            float inverseDxRLerp = 1.0 - dxRLerp;\\n\\n            float dxC = float(dyC) * widthScale;\\n            int leftDxCIndex = int(floor(dxC));\\n            int rightDxCIndex = int(min(ceil(dxC), \" + (xWidth - 1) + \".0));\\n            float dxCLerp = dxC - float(leftDxCIndex);\\n            float inverseDxCLerp = 1.0 - dxCLerp;\\n\\n            if (r == topDxRIndex && c == leftDxCIndex) {\\n              // topLeft\\n              accumulator +=\\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == topDxRIndex && c == rightDxCIndex) {\\n              // topRight\\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\\n              // bottomLeft\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\\n              // bottomRight\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n    }\n    return ResizeBilinearBackpropProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction resizeBilinearGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var images = inputs.images, dy = inputs.dy;\n    var alignCorners = attrs.alignCorners;\n    var program = new ResizeBilinearBackpropProgram(dy.shape, images.shape, alignCorners);\n    return backend.runWebGLProgram(program, [dy], dy.dtype);\n}\nvar resizeBilinearGradConfig = {\n    kernelName: tf.ResizeBilinearGrad,\n    backendName: 'webgl',\n    kernelFunc: resizeBilinearGrad\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ResizeNearestNeighborProgram = /** @class */ (function () {\n    function ResizeNearestNeighborProgram(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {\n        this.variableNames = ['A'];\n        this.outputShape = [];\n        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        var effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        var effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        // When align corners is false, we rounds the value with floor.\n        var roundBase = alignCorners ? '0.5' : '0.0';\n        var sourceFracIndexRC;\n        if (halfPixelCenters) {\n            sourceFracIndexRC =\n                \"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC\" +\n                    \", vec2(0.0))\";\n        }\n        else {\n            sourceFracIndexRC = \"vec2(yRC) * effectiveInputOverOutputRatioRC\";\n        }\n        this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + effectiveInSize[0] / effectiveOutSize[0] + \",\\n          \" + effectiveInSize[1] / effectiveOutSize[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + oldHeight + \".0, \" + oldWidth + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = \" + sourceFracIndexRC + \";\\n\\n        // Compute the coordinators of nearest neighbor point.\\n        ivec2 sourceNearestRC = ivec2(\\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + \" + roundBase + \")));\\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\\n\\n        setOutput(newValue);\\n      }\\n    \";\n    }\n    return ResizeNearestNeighborProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction resizeNearestNeighbor(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var images = inputs.images;\n    var alignCorners = attrs.alignCorners, halfPixelCenters = attrs.halfPixelCenters, size = attrs.size;\n    var newHeight = size[0], newWidth = size[1];\n    var program = new ResizeNearestNeighborProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);\n    return backend.runWebGLProgram(program, [images], images.dtype);\n}\nvar resizeNearestNeighborConfig = {\n    kernelName: tf.ResizeNearestNeighbor,\n    backendName: 'webgl',\n    kernelFunc: resizeNearestNeighbor\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ResizeNearestNeigborBackpropProgram = /** @class */ (function () {\n    function ResizeNearestNeigborBackpropProgram(dyShape, inputShape, alignCorners) {\n        this.variableNames = ['dy'];\n        this.outputShape = [];\n        this.outputShape = inputShape;\n        var xHeight = inputShape[1], xWidth = inputShape[2];\n        var yHeight = dyShape[1], yWidth = dyShape[2];\n        // In the backwards pass, we want to find the pixels that were generated for\n        // each pixel in the input image the forward pass and add the corresponding\n        // coefficient from dy to the gradient (with some interpolation).\n        var effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        var effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        var heightScale = effectiveXSize[0] / effectiveYSize[0];\n        var widthScale = effectiveXSize[1] / effectiveYSize[1];\n        var invHeightScale = 1 / heightScale;\n        var invWidthScale = 1 / widthScale;\n        // This defines the size of the window of values around a particular\n        // index in dy that we want to search for contributions to dx.\n        var winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n        var winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + heightScale + \");\\n        const float widthScale = float(\" + widthScale + \");\\n\\n        const float invHeightScale = float(\" + invHeightScale + \");\\n        const float invWidthScale = float(\" + invWidthScale + \");\\n\\n        const int winHeight = int(\" + winHeight + \");\\n        const int winWidth = int(\" + winWidth + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + yHeight + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + yWidth + \") {\\n              continue;\\n            }\\n\\n            float sourceFracRow =\\n              float(\" + effectiveXSize[0] + \") *\\n                (float(dyR) / float(\" + effectiveYSize[0] + \"));\\n\\n            float sourceFracCol =\\n                float(\" + effectiveXSize[1] + \") *\\n                  (float(dyC) / float(\" + effectiveYSize[1] + \"));\\n\\n            int sourceNearestRow = int(min(\\n                float(int(\" + xHeight + \") - 1),\\n                \" + alignCorners + \" ? float(round(sourceFracRow)) :\\n                                  float(floor(sourceFracRow))));\\n\\n            int sourceNearestCol = int(min(\\n                float(int(\" + xWidth + \") - 1),\\n                \" + alignCorners + \" ? float(round(sourceFracCol)) :\\n                                  float(floor(sourceFracCol))));\\n\\n            if (r == sourceNearestRow && c == sourceNearestCol) {\\n              accumulator += getDy(b, dyR, dyC, d);\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n    }\n    return ResizeNearestNeigborBackpropProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction resizeNearestNeighborGrad(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var images = inputs.images, dy = inputs.dy;\n    var alignCorners = attrs.alignCorners;\n    var program = new ResizeNearestNeigborBackpropProgram(dy.shape, images.shape, alignCorners);\n    return backend.runWebGLProgram(program, [dy], dy.dtype);\n}\nvar resizeNearestNeighborGradConfig = {\n    kernelName: tf.ResizeNearestNeighborGrad,\n    backendName: 'webgl',\n    kernelFunc: resizeNearestNeighborGrad\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ReverseProgram = /** @class */ (function () {\n    function ReverseProgram(xShape, axis) {\n        this.variableNames = ['x'];\n        var rank = xShape.length;\n        if (rank > 4) {\n            throw new Error(\"WebGL backend: Reverse of rank-\" + rank + \" tensor is not yet supported\");\n        }\n        this.outputShape = xShape;\n        if (rank === 1) {\n            this.userCode = \"\\n        void main() {\\n          int coord = getOutputCoords();\\n          setOutput(getX(\" + xShape[0] + \" - coord - 1));\\n        }\\n      \";\n            return;\n        }\n        var getInCoord = function (i) {\n            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n                return xShape[i] + \" - coords[\" + i + \"] - 1\";\n            }\n            return \"coords[\" + i + \"]\";\n        };\n        var inCoords = xShape.map(function (_, i) { return getInCoord(i); }).join(',');\n        var type = getCoordsDataType(rank);\n        this.userCode = \"\\n      void main() {\\n        \" + type + \" coords = getOutputCoords();\\n        setOutput(getX(\" + inCoords + \"));\\n      }\\n    \";\n    }\n    return ReverseProgram;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ReversePackedProgram = /** @class */ (function () {\n    function ReversePackedProgram(xShape, axis) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        var rank = xShape.length;\n        if (rank > 4) {\n            throw new Error(\"WebGL backend: Reverse of rank-\" + rank + \" tensor is not yet supported\");\n        }\n        this.outputShape = xShape;\n        var channels = getChannels('rc', rank);\n        var nextColumn = channels[rank - 1] + \" + 1 < \" + this.outputShape[rank - 1];\n        var nextRow = channels[rank - 2] + \" + 1 < \" + this.outputShape[rank - 2];\n        var type = getCoordsDataType(rank);\n        if (rank === 1) {\n            this.userCode = \"\\n        void main(){\\n          int rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = getChannel(getX(\" + xShape[0] + \" - rc - 1),\\n            \" + xShape[0] + \" - rc - 1);\\n          if(\" + nextColumn + \"){\\n              result.g = getChannel(getX(\" + xShape[0] + \" - (rc  + 1) - 1),\\n                \" + xShape[0] + \" - (rc  + 1) - 1);\\n          }\\n          setOutput(result);\\n        }\\n      \";\n        }\n        else {\n            this.userCode = \"\\n        void main() {\\n          \" + type + \" rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = \" + getR(channels.slice()) + \";\\n          if(\" + nextColumn + \"){\\n            result.g = \" + getG(channels.slice()) + \";\\n          }\\n          if(\" + nextRow + \") {\\n            result.b = \" + getB(channels.slice()) + \";\\n            if(\" + nextColumn + \") {\\n              result.a = \" + getA(channels.slice()) + \";\\n            }\\n          }\\n          setOutput(result);\\n        }\\n    \";\n        }\n        function getR(channels) {\n            return getChannel(channels);\n        }\n        function getG(channels) {\n            channels[rank - 1] = '(' + channels[rank - 1] + \" + 1)\";\n            return getChannel(channels);\n        }\n        function getB(channels) {\n            channels[rank - 2] = '(' + channels[rank - 2] + \" + 1)\";\n            return getChannel(channels);\n        }\n        function getA(channels) {\n            channels[rank - 1] = '(' + channels[rank - 1] + \" + 1)\";\n            channels[rank - 2] = '(' + channels[rank - 2] + \" + 1)\";\n            return getChannel(channels);\n        }\n        function getChannel(channels) {\n            var inCoordsArray = xShape.map(function (_, i) { return getInCoord(i, channels); });\n            var inCoords = inCoordsArray.join(',');\n            var innerDims = inCoordsArray.slice(-2).join(',');\n            return \"getChannel(getX(\" + inCoords + \"), vec2(\" + innerDims + \"))\";\n        }\n        function getInCoord(i, channels1) {\n            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n                return xShape[i] + \" - \" + channels1[i] + \" - 1\";\n            }\n            else {\n                return \"\" + channels1[i];\n            }\n        }\n    }\n    return ReversePackedProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction reverse(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var dims = attrs.dims;\n    var xRank = x.shape.length;\n    var $dims = tf.util.parseAxisParam(dims, x.shape);\n    if (xRank === 0) {\n        return identity({ inputs: { x: x }, backend: backend });\n    }\n    var program = tf.env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new ReversePackedProgram(x.shape, $dims) :\n        new ReverseProgram(x.shape, $dims);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nvar reverseConfig = {\n    kernelName: tf.Reverse,\n    backendName: 'webgl',\n    kernelFunc: reverse\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar RotateProgram = /** @class */ (function () {\n    function RotateProgram(imageShape, radians, fillValue, center) {\n        this.variableNames = ['Image'];\n        this.outputShape = [];\n        var imageHeight = imageShape[1];\n        var imageWidth = imageShape[2];\n        var sinFactor = Math.sin(radians).toFixed(3);\n        var cosFactor = Math.cos(radians).toFixed(3);\n        this.outputShape = imageShape;\n        var _a = tf.backend_util.getImageCenter(center, imageHeight, imageWidth), centerX = _a[0], centerY = _a[1];\n        var centerXString = centerX.toFixed(3);\n        var centerYString = centerY.toFixed(3);\n        var fillSnippet = '';\n        if (typeof fillValue === 'number') {\n            fillSnippet = \"float outputValue = \" + fillValue.toFixed(2) + \";\";\n        }\n        else {\n            fillSnippet = \"\\n        vec3 fill = vec3(\" + fillValue.join(',') + \");\\n        float outputValue = fill[coords[3]];\";\n        }\n        this.userCode = \"\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int x = coords[2];\\n          int y = coords[1];\\n          float coordXFloat = (float(x) - \" + centerXString + \") * \" + cosFactor + \" - (float(y) - \" + centerYString + \") * \" + sinFactor + \";\\n          float coordYFloat = (float(x) - \" + centerXString + \") * \" + sinFactor + \" + (float(y) - \" + centerYString + \") * \" + cosFactor + \";\\n          int coordX = int(round(coordXFloat + \" + centerXString + \"));\\n          int coordY = int(round(coordYFloat + \" + centerYString + \"));\\n          \" + fillSnippet + \"\\n          if(coordX >= 0 && coordX < \" + imageWidth + \" && coordY >= 0 && coordY < \" + imageHeight + \") {\\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\\n          }\\n          setOutput(outputValue);\\n        }\\n    \";\n    }\n    return RotateProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar rotateWithOffsetConfig = {\n    kernelName: tf.RotateWithOffset,\n    backendName: 'webgl',\n    kernelFunc: function (_a) {\n        var inputs = _a.inputs, attrs = _a.attrs, backend = _a.backend;\n        var image = inputs.image;\n        var _b = attrs, radians = _b.radians, fillValue = _b.fillValue, center = _b.center;\n        var webglBackend = backend;\n        var program = new RotateProgram(image.shape, radians, fillValue, center);\n        var output = webglBackend.runWebGLProgram(program, [image], image.dtype);\n        return output;\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ROUND = \"\\n  // OpenGL ES does not support round function.\\n  // The algorithm is based on banker's rounding.\\n  float base = floor(x);\\n  if ((x - base) < 0.5) {\\n    return floor(x);\\n  } else if ((x - base) > 0.5) {\\n    return ceil(x);\\n  } else {\\n    if (mod(base, 2.0) == 0.0) {\\n      return base;\\n    } else {\\n      return base + 1.0;\\n    }\\n  }\\n\";\nvar round = unaryKernelFunc({ opSnippet: ROUND });\nvar roundConfig = {\n    kernelName: tf.Round,\n    backendName: 'webgl',\n    kernelFunc: round,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar RSQRT = \"return inversesqrt(x);\";\nvar rsqrt = unaryKernelFunc({ opSnippet: RSQRT, cpuKernelImpl: rsqrtImplCPU });\nvar rsqrtConfig = {\n    kernelName: tf.Rsqrt,\n    backendName: 'webgl',\n    kernelFunc: rsqrt\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar ScatterProgram = /** @class */ (function () {\n    function ScatterProgram(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex) {\n        this.variableNames = ['updates', 'indices', 'defaultValue'];\n        this.outputShape = shape;\n        var stridesType = getCoordsDataType(strides.length);\n        var dtype = getCoordsDataType(shape.length);\n        var indicesString = '';\n        if (indicesRank === 1) {\n            indicesString = 'i';\n        }\n        else if (indicesRank === 2) {\n            indicesString = 'i, j';\n        }\n        var indicesSnippet = \"getIndices(\" + indicesString + \")\";\n        var updatesString = '';\n        if (updatesRank === 1) {\n            updatesString = 'i';\n        }\n        else if (updatesRank === 2) {\n            updatesString = 'i, coords[1]';\n        }\n        var updatesSnippet = \"getUpdates(\" + updatesString + \")\";\n        var strideString = sliceDim > 1 ? 'strides[j]' : 'strides';\n        this.userCode = \"\\n        \" + stridesType + \" strides = \" + stridesType + \"(\" + strides + \");\\n\\n        void main() {\\n          \" + dtype + \" coords = getOutputCoords();\\n          float sum = 0.0;\\n          bool found = false;\\n          for (int i = 0; i < \" + updateSize + \"; i++) {\\n            int flattenedIndex = 0;\\n            for (int j = 0; j < \" + sliceDim + \"; j++) {\\n              int index = round(\" + indicesSnippet + \");\\n              flattenedIndex += index * \" + strideString + \";\\n            }\\n            if (flattenedIndex == coords[0]) {\\n              sum += \" + updatesSnippet + \";\\n              found = true;\\n            }\\n          }\\n          setOutput(mix(getDefaultValue(), sum, float(found)));\\n        }\\n      \";\n    }\n    return ScatterProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction scatterNd(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var indices = inputs.indices, updates = inputs.updates;\n    var shape = attrs.shape;\n    var _a = tf.backend_util.calculateShapes(updates, indices, shape), sliceRank = _a.sliceRank, numUpdates = _a.numUpdates, sliceSize = _a.sliceSize, strides = _a.strides, outputSize = _a.outputSize;\n    var flattenShape = [outputSize / sliceSize, sliceSize];\n    if (outputSize === 0) {\n        return backend.makeTensorInfo(shape, indices.dtype);\n    }\n    var flattenIndices = reshape({ inputs: { x: indices }, backend: backend, attrs: { shape: [numUpdates, sliceRank] } });\n    var flattenX = reshape({ inputs: { x: updates }, backend: backend, attrs: { shape: [numUpdates, sliceSize] } });\n    var defaultValue = backend.makeTensorInfo([], 'float32', new Float32Array([0])); // scalar(0)\n    var program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);\n    var res = backend.runWebGLProgram(program, [flattenX, flattenIndices, defaultValue], flattenX.dtype);\n    var reshaped = reshape({ inputs: { x: res }, backend: backend, attrs: { shape: shape } });\n    backend.disposeIntermediateTensorInfo(flattenIndices);\n    backend.disposeIntermediateTensorInfo(flattenX);\n    backend.disposeIntermediateTensorInfo(res);\n    backend.disposeIntermediateTensorInfo(defaultValue);\n    return reshaped;\n}\nvar scatterNdConfig = {\n    kernelName: tf.ScatterNd,\n    backendName: 'webgl',\n    kernelFunc: scatterNd\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SelectProgram = /** @class */ (function () {\n    function SelectProgram(cRank, shape, rank) {\n        this.variableNames = ['c', 'a', 'b'];\n        this.outputShape = shape;\n        var cCoords;\n        var abCoords;\n        if (rank > 4) {\n            throw Error(\"Where for rank \" + rank + \" is not yet supported\");\n        }\n        if (rank === 1) {\n            abCoords = \"resRC\";\n            cCoords = \"resRC\";\n        }\n        else {\n            var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n            var cCoordVars = [];\n            var abCoordVars = [];\n            for (var i = 0; i < shape.length; i++) {\n                abCoordVars.push(\"\" + currentCoords[i]);\n                if (i < cRank) {\n                    cCoordVars.push(\"\" + currentCoords[i]);\n                }\n            }\n            cCoords = cCoordVars.join();\n            abCoords = abCoordVars.join();\n        }\n        var dtype = getCoordsDataType(rank);\n        this.userCode = \"\\n      void main() {\\n        \" + dtype + \" resRC = getOutputCoords();\\n        float cVal = getC(\" + cCoords + \");\\n        if (cVal >= 1.0) {\\n          setOutput(getA(\" + abCoords + \"));\\n        } else {\\n          setOutput(getB(\" + abCoords + \"));\\n        }\\n      }\\n    \";\n    }\n    return SelectProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction select(args) {\n    var inputs = args.inputs, backend = args.backend;\n    var condition = inputs.condition, t = inputs.t, e = inputs.e;\n    var program = new SelectProgram(condition.shape.length, t.shape, t.shape.length);\n    return backend.runWebGLProgram(program, [condition, t, e], tf.upcastType(t.dtype, e.dtype));\n}\nvar selectConfig = {\n    kernelName: tf.Select,\n    backendName: 'webgl',\n    kernelFunc: select\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SELU = \"\\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\\n  // see: https://arxiv.org/abs/1706.02515\\n  float scaleAlpha = \" + tf.backend_util.SELU_SCALEALPHA + \";\\n  float scale = \" + tf.backend_util.SELU_SCALE + \";\\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\\n\";\nvar selu = unaryKernelFunc({ opSnippet: SELU });\nvar seluConfig = {\n    kernelName: tf.Selu,\n    backendName: 'webgl',\n    kernelFunc: selu,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SIGMOID = \"return 1.0 / (1.0 + exp(-1.0 * x));\";\nvar sigmoid = unaryKernelFunc({ opSnippet: SIGMOID });\nvar sigmoidConfig = {\n    kernelName: tf.Sigmoid,\n    backendName: 'webgl',\n    kernelFunc: sigmoid,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Sign does not propagate NANs.\nvar SIGN = \"\\n  if (isnan(x)) { return 0.0; }\\n  return sign(x);\\n\";\nvar sign = unaryKernelFunc({ opSnippet: SIGN });\nvar signConfig = {\n    kernelName: tf.Sign,\n    backendName: 'webgl',\n    kernelFunc: sign,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SIN = CHECK_NAN_SNIPPET_UNARY + \"\\n  return sin(x);\\n\";\nvar sin = unaryKernelFunc({ opSnippet: SIN });\nvar sinConfig = {\n    kernelName: tf.Sin,\n    backendName: 'webgl',\n    kernelFunc: sin,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SINH = \"\\n  float e2x = exp(x);\\n  return (e2x - 1.0 / e2x) / 2.0;\\n\";\nvar sinh = unaryKernelFunc({ opSnippet: SINH });\nvar sinhConfig = {\n    kernelName: tf.Sinh,\n    backendName: 'webgl',\n    kernelFunc: sinh,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SOFTPLUS = \"\\n  float epsilon = 1.1920928955078125e-7;\\n  float threshold = log(epsilon) + 2.0;\\n\\n  bool too_large = x > -threshold;\\n  bool too_small = x < threshold;\\n\\n  float result;\\n  float exp_x = exp(x);\\n\\n  if (too_large){\\n    result = x;\\n  }\\n  else if (too_small){\\n    result = exp_x;\\n  }\\n  else{\\n    result = log(exp_x + 1.0);\\n  }\\n  return result;\\n\";\nvar softplus = unaryKernelFunc({ opSnippet: SOFTPLUS });\nvar softplusConfig = {\n    kernelName: tf.Softplus,\n    backendName: 'webgl',\n    kernelFunc: softplus,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar spaceToBatchND = function (args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var blockShape = attrs.blockShape, paddings = attrs.paddings;\n    tf.util.assert(x.shape.length <= 4, function () { return 'spaceToBatchND for rank > 4 with a WebGL backend not ' +\n        'implemented yet'; });\n    var prod = blockShape.reduce(function (a, b) { return a * b; });\n    var completePaddings = [[0, 0]];\n    completePaddings.push.apply(completePaddings, paddings);\n    for (var i = 1 + blockShape.length; i < x.shape.length; ++i) {\n        completePaddings.push([0, 0]);\n    }\n    var toDispose = [];\n    var paddedX = padV2({\n        inputs: { x: x },\n        backend: backend,\n        attrs: { paddings: completePaddings, constantValue: 0 }\n    });\n    var reshapedPaddedShape = tf.backend_util.getReshaped(paddedX.shape, blockShape, prod, false);\n    var permutedReshapedPaddedPermutation = tf.backend_util.getPermuted(reshapedPaddedShape.length, blockShape.length, false);\n    var flattenShape = tf.backend_util.getReshapedPermuted(paddedX.shape, blockShape, prod, false);\n    var reshapedPaddedX = reshape({ inputs: { x: paddedX }, backend: backend, attrs: { shape: reshapedPaddedShape } });\n    var paddedXT = transpose({\n        inputs: { x: reshapedPaddedX },\n        backend: backend,\n        attrs: { perm: permutedReshapedPaddedPermutation }\n    });\n    var result = reshape({ inputs: { x: paddedXT }, backend: backend, attrs: { shape: flattenShape } });\n    toDispose.push(paddedX);\n    toDispose.push(reshapedPaddedX);\n    toDispose.push(paddedXT);\n    toDispose.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return result;\n};\nvar spaceToBatchNDConfig = {\n    kernelName: tf.SpaceToBatchND,\n    backendName: 'webgl',\n    kernelFunc: spaceToBatchND\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction sparseToDense(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var sparseIndices = inputs.sparseIndices, sparseValues = inputs.sparseValues, defaultValue = inputs.defaultValue;\n    var outputShape = attrs.outputShape;\n    var _a = tf.backend_util.calculateShapes(sparseValues, sparseIndices, outputShape), sliceRank = _a.sliceRank, numUpdates = _a.numUpdates, strides = _a.strides, outputSize = _a.outputSize;\n    var sumDupeIndices = false;\n    var program = new ScatterProgram(numUpdates, sliceRank, sparseIndices.shape.length, sparseValues.shape.length, strides, [outputSize, 1], sumDupeIndices);\n    var res = backend.runWebGLProgram(program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype);\n    var reshaped = reshape({ inputs: { x: res }, backend: backend, attrs: { shape: outputShape } });\n    backend.disposeIntermediateTensorInfo(res);\n    return reshaped;\n}\nvar sparseToDenseConfig = {\n    kernelName: tf.SparseToDense,\n    backendName: 'webgl',\n    kernelFunc: sparseToDense\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction splitV(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var numOrSizeSplits = attrs.numOrSizeSplits, axis = attrs.axis;\n    var $axis = tf.util.parseAxisParam(axis, x.shape)[0];\n    var splitSizes = tf.backend_util.prepareSplitSize(x, numOrSizeSplits, $axis);\n    var xRank = x.shape.length;\n    var begin = new Array(xRank).fill(0);\n    var size = x.shape.slice();\n    return splitSizes.map(function (s) {\n        var sliceSize = size.slice();\n        sliceSize[$axis] = s;\n        var sliceT = slice({ inputs: { x: x }, backend: backend, attrs: { begin: begin, size: sliceSize } });\n        begin[$axis] += s;\n        return sliceT;\n    });\n}\nvar splitVConfig = {\n    kernelName: tf.SplitV,\n    backendName: 'webgl',\n    kernelFunc: splitV\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SQRT = \"return sqrt(x);\";\nvar sqrt = unaryKernelFunc({ opSnippet: SQRT });\nvar sqrtConfig = {\n    kernelName: tf.Sqrt,\n    backendName: 'webgl',\n    kernelFunc: sqrt\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SQUARE = \"return x * x;\";\nvar square = unaryKernelFunc({ opSnippet: SQUARE });\nvar squareConfig = {\n    kernelName: tf.Square,\n    backendName: 'webgl',\n    kernelFunc: square,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\nvar squaredDifference = binaryKernelFunc({ opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE });\nvar squaredDifferenceConfig = {\n    kernelName: tf.SquaredDifference,\n    backendName: 'webgl',\n    kernelFunc: squaredDifference,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction step(_a) {\n    var inputs = _a.inputs, attrs = _a.attrs, backend = _a.backend;\n    var x = inputs.x;\n    var opSnippet = CHECK_NAN_SNIPPET + (\"\\n    return x > 0.0 ? 1.0 : float(\" + attrs.alpha + \");\\n  \");\n    var program = new UnaryOpProgram(x.shape, opSnippet);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nvar stepConfig = {\n    kernelName: tf.Step,\n    backendName: 'webgl',\n    kernelFunc: step,\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar StridedSliceProgram = /** @class */ (function () {\n    function StridedSliceProgram(begin, strides, size) {\n        this.variableNames = ['x'];\n        this.outputShape = size;\n        var rank = size.length;\n        var inputDtype = getCoordsDataType(size.length);\n        var dtype = getCoordsDataType(size.length);\n        var newCoords = '';\n        if (rank === 1) {\n            newCoords = 'coords * strides + begin';\n        }\n        else {\n            var outputAxis_1 = 0;\n            newCoords =\n                size.map(function (_, i) {\n                    outputAxis_1++;\n                    return size.length === 1 ?\n                        \"coords * strides[\" + i + \"] + begin[\" + i + \"]\" :\n                        \"coords[\" + (outputAxis_1 - 1) + \"] * strides[\" + i + \"] + begin[\" + i + \"]\";\n                })\n                    .join(',');\n        }\n        this.userCode = \"\\n      \" + inputDtype + \" begin = \" + inputDtype + \"(\" + begin + \");\\n      \" + inputDtype + \" strides = \" + inputDtype + \"(\" + strides + \");\\n\\n      void main() {\\n        \" + dtype + \" coords = getOutputCoords();\\n        setOutput(getX(\" + newCoords + \"));\\n      }\\n    \";\n    }\n    return StridedSliceProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction stridedSlice(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var begin = attrs.begin, end = attrs.end, strides = attrs.strides, beginMask = attrs.beginMask, endMask = attrs.endMask, ellipsisMask = attrs.ellipsisMask, newAxisMask = attrs.newAxisMask, shrinkAxisMask = attrs.shrinkAxisMask;\n    var _a = tf.slice_util.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask), nonStrided = _a.nonStrided, $begin = _a.$begin, $strides = _a.$strides, size = _a.size, newShape = _a.newShape, outShape = _a.outShape;\n    var $x = reshape({ inputs: { x: x }, backend: backend, attrs: { shape: newShape } });\n    var result;\n    if (nonStrided) {\n        var sliced = slice({ inputs: { x: $x }, backend: backend, attrs: { begin: $begin, size: size } });\n        result = reshape({ inputs: { x: sliced }, backend: backend, attrs: { shape: outShape } });\n        backend.disposeIntermediateTensorInfo(sliced);\n    }\n    else if (outShape.some(function (axis) { return axis === 0; })) {\n        result = backend.makeTensorInfo(outShape, x.dtype, []);\n    }\n    else {\n        var shouldExecuteOnCPU = backend.shouldExecuteOnCPU([$x]);\n        if (shouldExecuteOnCPU) {\n            var xTexData = backend.texData.get($x.dataId);\n            var values = xTexData.values;\n            var xBuf = tf.buffer($x.shape, $x.dtype, values);\n            var resultValues = stridedSliceImplCPU(outShape, xBuf, $strides, $begin);\n            result = backend.makeTensorInfo(outShape, $x.dtype, resultValues.values);\n        }\n        else {\n            var program = new StridedSliceProgram($begin, $strides, outShape);\n            result = backend.runWebGLProgram(program, [$x], $x.dtype);\n        }\n    }\n    var resultReshaped = reshape({ inputs: { x: result }, backend: backend, attrs: { shape: outShape } });\n    backend.disposeIntermediateTensorInfo($x);\n    backend.disposeIntermediateTensorInfo(result);\n    return resultReshaped;\n}\nvar stridedSliceConfig = {\n    kernelName: tf.StridedSlice,\n    backendName: 'webgl',\n    kernelFunc: stridedSlice\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar TAN = \"return tan(x);\";\nvar tan = unaryKernelFunc({ opSnippet: TAN });\nvar tanConfig = {\n    kernelName: tf.Tan,\n    backendName: 'webgl',\n    kernelFunc: tan,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar TANH = \"\\n  float e2x = exp(-2.0 * abs(x));\\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\\n\";\nvar tanh = unaryKernelFunc({ opSnippet: TANH });\nvar tanhConfig = {\n    kernelName: tf.Tanh,\n    backendName: 'webgl',\n    kernelFunc: tanh,\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar TileProgram = /** @class */ (function () {\n    function TileProgram(aShape, reps) {\n        this.variableNames = ['A'];\n        var outputShape = new Array(aShape.length);\n        for (var i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[i] * reps[i];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        var dtype = getCoordsDataType(this.rank);\n        var sourceCoords = getSourceCoords$2(aShape);\n        this.userCode = \"\\n      void main() {\\n        \" + dtype + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + sourceCoords + \"));\\n      }\\n    \";\n    }\n    return TileProgram;\n}());\nfunction getSourceCoords$2(aShape) {\n    var rank = aShape.length;\n    if (rank > 5) {\n        throw Error(\"Tile for rank \" + rank + \" is not yet supported\");\n    }\n    if (rank === 1) {\n        return \"imod(resRC, \" + aShape[0] + \")\";\n    }\n    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];\n    var sourceCoords = [];\n    for (var i = 0; i < aShape.length; i++) {\n        sourceCoords.push(\"imod(\" + currentCoords[i] + \", \" + aShape[i] + \")\");\n    }\n    return sourceCoords.join();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction tile(params) {\n    var inputs = params.inputs, backend = params.backend, attrs = params.attrs;\n    var x = inputs.x;\n    var reps = attrs.reps;\n    if (x.dtype === 'string') {\n        // Even thought string tensor is always on CPU, just to be consistent on how\n        // to access tensor data.\n        var data = backend.readSync(x.dataId);\n        var decodedData = data.map(function (d) { return tf.util.decodeString(d); });\n        var buf = tf.buffer(x.shape, x.dtype, decodedData);\n        var outBuf = tileImplCPU(buf, reps);\n        return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);\n    }\n    var program = new TileProgram(x.shape, reps);\n    var output = backend.runWebGLProgram(program, [x], x.dtype);\n    return output;\n}\nvar tileConfig = {\n    kernelName: tf.Tile,\n    backendName: 'webgl',\n    kernelFunc: tile,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction topK(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x;\n    var k = attrs.k, sorted = attrs.sorted;\n    var xVals = backend.readSync(x.dataId);\n    var _a = topKImplCPU(xVals, x.shape, x.dtype, k), allTopKVals = _a[0], allTopKIndices = _a[1];\n    return [\n        backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),\n        backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)\n    ];\n}\nvar topKConfig = {\n    kernelName: tf.TopK,\n    backendName: 'webgl',\n    kernelFunc: topK\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction unique(args) {\n    var inputs = args.inputs, attrs = args.attrs, backend = args.backend;\n    var axis = attrs.axis;\n    var x = inputs.x;\n    assertNotComplex(x, 'unique');\n    // For now, always forward calculation to the CPU backend.\n    console.warn('WARNING: ', 'UI might be locked temporarily as data is being downloaded');\n    var values = backend.readSync(x.dataId);\n    var _a = uniqueImplCPU(values, axis, x.shape, x.dtype), outputValues = _a.outputValues, outputShape = _a.outputShape, indices = _a.indices;\n    return [\n        backend.makeTensorInfo(outputShape, x.dtype, outputValues),\n        backend.makeTensorInfo([indices.length], 'int32', indices),\n    ];\n}\nvar uniqueConfig = {\n    kernelName: tf.Unique,\n    backendName: 'webgl',\n    kernelFunc: unique,\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction unpack(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var value = inputs.value;\n    var axis = attrs.axis;\n    if (axis < 0) {\n        axis += value.shape.length;\n    }\n    var x = value;\n    var xRank = x.shape.length;\n    var num = value.shape[axis];\n    var outShape = new Array(xRank - 1);\n    var outIndex = 0;\n    for (var i = 0; i < xRank; i++) {\n        if (i !== axis) {\n            outShape[outIndex++] = x.shape[i];\n        }\n    }\n    var toDispose = [];\n    var begin = new Array(xRank).fill(0);\n    var size = x.shape.slice();\n    size[axis] = 1;\n    var res = new Array(num);\n    for (var i = 0; i < res.length; i++) {\n        begin[axis] = i;\n        var sliced = slice({ inputs: { x: x }, backend: backend, attrs: { begin: begin, size: size } });\n        var reshaped = reshape({ inputs: { x: sliced }, backend: backend, attrs: { shape: outShape } });\n        res[i] = reshaped;\n        toDispose.push(sliced);\n    }\n    toDispose.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return res;\n}\nvar unpackConfig = {\n    kernelName: tf.Unpack,\n    backendName: 'webgl',\n    kernelFunc: unpack\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar SegmentOpProgram = /** @class */ (function () {\n    function SegmentOpProgram(segOpInfo, segOpType) {\n        this.variableNames = ['x', 'segmentIds'];\n        var windowSize = segOpInfo.windowSize;\n        var batchSize = segOpInfo.batchSize;\n        var inSize = segOpInfo.inSize;\n        var numSegments = segOpInfo.numSegments;\n        var outSize = numSegments * Math.ceil(inSize / windowSize);\n        this.outputShape = [batchSize, outSize];\n        var initializationValue = '0.0';\n        var returnValue = \"sumValue\";\n        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        var windowSizeVec4Remainder = windowSize % 4;\n        var updateSnippet = \"\\n        sumValue += dot(values, segFilter);\\n    \";\n        var checkValueOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkValueOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \" + inSize + \") {\\n          return initializationValue;\\n        }\\n      \";\n        }\n        var checkSegmentIdOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkSegmentIdOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \" + inSize + \") {\\n          return -1.0;\\n        }\\n      \";\n        }\n        this.userCode = \"\\n      const float initializationValue = \" + initializationValue + \";\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + checkValueOutOfBounds + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      float getSegmentIdAtIndex(int inIdx) {\\n        \" + checkSegmentIdOutOfBounds + \"\\n        return getSegmentIds(inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = int(floor(float(outIdx) / float(\\n          \" + numSegments + \")) * float(\" + windowSize + \"));\\n        int currentSeg = int(mod(float(outIdx), float(\" + numSegments + \")));\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \" + windowSizeNearestVec4 + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\\n          );\\n\\n          \" + updateSnippet + \"\\n        }\\n\\n        int inIdx = inOffset + \" + windowSizeNearestVec4 + \";\\n        if (\" + (windowSizeVec4Remainder === 1) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            0,\\n            0,\\n            0\\n          );\\n\\n          \" + updateSnippet + \"\\n        } else if (\" + (windowSizeVec4Remainder === 2) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n              0,\\n              0\\n          );\\n\\n          \" + updateSnippet + \"\\n        } else if (\" + (windowSizeVec4Remainder === 3) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            0\\n          );\\n\\n          \" + updateSnippet + \"\\n        }\\n        setOutput(\" + returnValue + \");\\n      }\\n    \";\n    }\n    return SegmentOpProgram;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction unsortedSegmentSum(args) {\n    var inputs = args.inputs, backend = args.backend, attrs = args.attrs;\n    var x = inputs.x, segmentIds = inputs.segmentIds;\n    var numSegments = attrs.numSegments;\n    var xRank = x.shape.length;\n    var toDispose = [];\n    var axis = 0;\n    var permutation = tf.backend_util.getAxesPermutation([axis], xRank);\n    var permutedX = x;\n    if (permutation != null) {\n        permutedX = transpose({ inputs: { x: x }, backend: backend, attrs: { perm: permutation } });\n        toDispose.push(permutedX);\n        axis = tf.backend_util.getInnerMostAxes(1, xRank)[0];\n    }\n    var outShape = tf.backend_util.segment_util.computeOutShape(permutedX.shape, axis, numSegments);\n    var inSize = tf.util.sizeFromShape([permutedX.shape[axis]]);\n    var a2D = reshape({ inputs: { x: permutedX }, backend: backend, attrs: { shape: [-1, inSize] } });\n    toDispose.push(a2D);\n    var outputDType = tf.sumOutType(x.dtype);\n    var segOpCompute = function (x, segOpType, segmentIds, dtype, numSegments) {\n        var batchSize = x.shape[0];\n        var inSize = x.shape[1];\n        var windowSize = tf.backend_util.segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);\n        var segOpInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize, numSegments: numSegments };\n        var program = new SegmentOpProgram(segOpInfo, segOpType);\n        var output = backend.compileAndRun(program, [x, segmentIds], dtype);\n        toDispose.push(output);\n        // No need to run another GPGPU program.\n        if (output.shape[1] === numSegments) {\n            return output;\n        }\n        var rangeInfo = range({\n            backend: backend,\n            attrs: { start: 0, stop: numSegments, step: 1, dtype: 'float32' }\n        });\n        var tileInfo = tile({\n            inputs: { x: rangeInfo },\n            backend: backend,\n            attrs: { reps: [inSize / windowSize] }\n        });\n        toDispose.push(rangeInfo);\n        toDispose.push(tileInfo);\n        var result = segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n        return result;\n    };\n    var segOpResult = segOpCompute(a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n    var reshaped = reshape({ inputs: { x: segOpResult }, backend: backend, attrs: { shape: outShape } });\n    var result = reshaped;\n    if (permutation != null) {\n        toDispose.push(reshaped);\n        var perm = tf.backend_util.getUndoAxesPermutation(permutation);\n        result = transpose({ inputs: { x: result }, backend: backend, attrs: { perm: perm } });\n    }\n    toDispose.forEach(function (t) { return backend.disposeIntermediateTensorInfo(t); });\n    return result;\n}\nvar unsortedSegmentSumConfig = {\n    kernelName: tf.UnsortedSegmentSum,\n    backendName: 'webgl',\n    kernelFunc: unsortedSegmentSum\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// List all kernel configs here\nvar kernelConfigs = [\n    LRNConfig,\n    LRNGradConfig,\n    _fusedMatMulConfig,\n    absConfig,\n    acosConfig,\n    acoshConfig,\n    addConfig,\n    addNConfig,\n    allConfig,\n    anyConfig,\n    argMaxConfig,\n    argMinConfig,\n    asinConfig,\n    asinhConfig,\n    atan2Config,\n    atanConfig,\n    atanhConfig,\n    avgPool3DConfig,\n    avgPoolConfig,\n    avgPoolGrad3DConfig,\n    avgPoolGradConfig,\n    batchMatMulConfig,\n    batchNormConfig,\n    batchToSpaceNDConfig,\n    bincountConfig,\n    castConfig,\n    ceilConfig,\n    clipByValueConfig,\n    complexAbsConfig,\n    complexConfig,\n    concatConfig,\n    conv2DBackpropFilterConfig,\n    conv2DBackpropInputConfig,\n    conv2DConfig,\n    conv3DBackpropFilterV2Config,\n    conv3DBackpropInputConfig,\n    conv3DConfig,\n    cosConfig,\n    coshConfig,\n    cropAndResizeConfig,\n    cumsumConfig,\n    denseBincountConfig,\n    depthToSpaceConfig,\n    depthwiseConv2dNativeBackpropFilterConfig,\n    depthwiseConv2dNativeBackpropInputConfig,\n    depthwiseConv2dNativeConfig,\n    diagConfig,\n    dilation2DConfig,\n    eluConfig,\n    eluGradConfig,\n    equalConfig,\n    erfConfig,\n    expConfig,\n    expandDimsConfig,\n    expm1Config,\n    fftConfig,\n    fillConfig,\n    flipLeftRightConfig,\n    floorConfig,\n    floorDivConfig,\n    fromPixelsConfig,\n    fusedConv2DConfig,\n    fusedDepthwiseConv2DConfig,\n    gatherNdConfig,\n    gatherV2Config,\n    greaterConfig,\n    greaterEqualConfig,\n    identityConfig,\n    ifftConfig,\n    imagConfig,\n    isFiniteConfig,\n    isInfConfig,\n    isNaNConfig,\n    leakyReluConfig,\n    lessConfig,\n    lessEqualConfig,\n    linSpaceConfig,\n    log1pConfig,\n    logConfig,\n    logicalAndConfig,\n    logicalNotConfig,\n    logicalOrConfig,\n    maxConfig,\n    maxPool3DConfig,\n    maxPoolConfig,\n    maxPoolGrad3DConfig,\n    maxPoolGradConfig,\n    maxPoolWithArgmaxConfig,\n    maximumConfig,\n    meanConfig,\n    minConfig,\n    minimumConfig,\n    mirrorPadConfig,\n    modConfig,\n    multinomialConfig,\n    multiplyConfig,\n    negConfig,\n    nonMaxSuppressionV3Config,\n    nonMaxSuppressionV4Config,\n    nonMaxSuppressionV5Config,\n    notEqualConfig,\n    oneHotConfig,\n    onesLikeConfig,\n    packConfig,\n    padV2Config,\n    powConfig,\n    preluConfig,\n    prodConfig,\n    rangeConfig,\n    realConfig,\n    realDivConfig,\n    reciprocalConfig,\n    relu6Config,\n    reluConfig,\n    reshapeConfig,\n    resizeBilinearConfig,\n    resizeBilinearGradConfig,\n    resizeNearestNeighborConfig,\n    resizeNearestNeighborGradConfig,\n    reverseConfig,\n    rotateWithOffsetConfig,\n    roundConfig,\n    rsqrtConfig,\n    scatterNdConfig,\n    selectConfig,\n    seluConfig,\n    sigmoidConfig,\n    signConfig,\n    sinConfig,\n    sinhConfig,\n    sliceConfig,\n    softmaxConfig,\n    softplusConfig,\n    spaceToBatchNDConfig,\n    sparseToDenseConfig,\n    splitVConfig,\n    sqrtConfig,\n    squareConfig,\n    squaredDifferenceConfig,\n    stepConfig,\n    stridedSliceConfig,\n    subConfig,\n    sumConfig,\n    tanConfig,\n    tanhConfig,\n    tileConfig,\n    topKConfig,\n    transposeConfig,\n    uniqueConfig,\n    unpackConfig,\n    unsortedSegmentSumConfig,\n    zerosLikeConfig\n];\nfor (var _i = 0, kernelConfigs_1 = kernelConfigs; _i < kernelConfigs_1.length; _i++) {\n    var kernelConfig = kernelConfigs_1[_i];\n    tf.registerKernel(kernelConfig);\n}\n\nexports.GPGPUContext = GPGPUContext;\nexports.MathBackendWebGL = MathBackendWebGL;\nexports.forceHalfFloat = forceHalfFloat;\nexports.gpgpu_util = gpgpu_util;\nexports.setWebGLContext = setWebGLContext;\nexports.version_webgl = version;\nexports.webgl = webgl;\nexports.webgl_util = webgl_util;\n//# sourceMappingURL=tf-backend-webgl.node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRlbnNvcmZsb3crdGZqcy1iYWNrZW5kLXdlYmdsQDIuOC42X0B0ZW5zb3JmbG93K3RmanMtY29yZUAyLjguNi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1iYWNrZW5kLXdlYmdsL2Rpc3QvdGYtYmFja2VuZC13ZWJnbC5ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxTQUFTLG1CQUFPLENBQUMsNklBQXVCOztBQUV4QztBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1CQUFtQjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMLHFEQUFxRCxxQkFBcUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakMsd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDRDQUE0QztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHFDQUFxQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDRDQUE0QztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDRCQUE0QjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUNBQWlDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtEQUFrRDtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyxpQkFBaUI7QUFDNUgsbURBQW1ELG1CQUFtQjtBQUN0RSx5R0FBeUcsZ0JBQWdCO0FBQ3pILG1EQUFtRCxtQkFBbUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsVUFBVSwyQ0FBMkMsSUFBSTtBQUM3SCxvREFBb0QsOEJBQThCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlDQUFpQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnREFBZ0Q7QUFDbkcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGVBQWU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxtREFBbUQ7QUFDbkc7QUFDQTtBQUNBLHFDQUFxQyxpRUFBaUU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QTZCLFNBQVM7QUFDMzNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsNkJBQTZCO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9tb25nYWguZ2l0aHViLmlvLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW5zb3JmbG93K3RmanMtYmFja2VuZC13ZWJnbEAyLjguNl9AdGVuc29yZmxvdyt0ZmpzLWNvcmVAMi44LjYvbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtYmFja2VuZC13ZWJnbC9kaXN0L3RmLWJhY2tlbmQtd2ViZ2wubm9kZS5qcz9jYTJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHRmID0gcmVxdWlyZSgnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJyk7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBjb250ZXh0cyA9IHt9O1xudmFyIFdFQkdMX0FUVFJJQlVURVMgPSB7XG4gICAgYWxwaGE6IGZhbHNlLFxuICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICAgIGRlcHRoOiBmYWxzZSxcbiAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiB0cnVlXG59O1xuZnVuY3Rpb24gc2V0V2ViR0xDb250ZXh0KHdlYkdMVmVyc2lvbiwgZ2wpIHtcbiAgICBjb250ZXh0c1t3ZWJHTFZlcnNpb25dID0gZ2w7XG59XG5mdW5jdGlvbiBnZXRXZWJHTENvbnRleHQod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKCEod2ViR0xWZXJzaW9uIGluIGNvbnRleHRzKSkge1xuICAgICAgICB2YXIgbmV3Q3R4ID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgICAgIGlmIChuZXdDdHggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRleHRzW3dlYkdMVmVyc2lvbl0gPSBuZXdDdHg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ291bGQgbm90IGdldCBjb250ZXh0IGZvciBXZWJHTCB2ZXJzaW9uJywgd2ViR0xWZXJzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBnbCA9IGNvbnRleHRzW3dlYkdMVmVyc2lvbl07XG4gICAgaWYgKGdsLmlzQ29udGV4dExvc3QoKSkge1xuICAgICAgICBkZWxldGUgY29udGV4dHNbd2ViR0xWZXJzaW9uXTtcbiAgICAgICAgcmV0dXJuIGdldFdlYkdMQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgIH1cbiAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5kaXNhYmxlKGdsLkRJVEhFUik7XG4gICAgZ2wuZGlzYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTtcbiAgICBnbC5kaXNhYmxlKGdsLlNBTVBMRV9DT1ZFUkFHRSk7XG4gICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7XG4gICAgcmV0dXJuIGNvbnRleHRzW3dlYkdMVmVyc2lvbl07XG59XG5mdW5jdGlvbiBjcmVhdGVDYW52YXMod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIHdlYkdMVmVyc2lvbiA9PT0gMikge1xuICAgICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygzMDAsIDE1MCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIGEgY2FudmFzIGluIHRoaXMgY29udGV4dCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCh3ZWJHTFZlcnNpb24pIHtcbiAgICBpZiAod2ViR0xWZXJzaW9uICE9PSAxICYmIHdlYkdMVmVyc2lvbiAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZXQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQsIFdlYkdMIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgICB2YXIgY2FudmFzID0gY3JlYXRlQ2FudmFzKHdlYkdMVmVyc2lvbik7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGVsZXRlIGNvbnRleHRzW3dlYkdMVmVyc2lvbl07XG4gICAgfSwgZmFsc2UpO1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIChjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBXRUJHTF9BVFRSSUJVVEVTKSB8fFxuICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIFdFQkdMX0FUVFJJQlVURVMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBXRUJHTF9BVFRSSUJVVEVTKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFBhY2tpbmdTY2hlbWU7XG4oZnVuY3Rpb24gKFBhY2tpbmdTY2hlbWUpIHtcbiAgICAvKipcbiAgICAgKiBBbGwgdmFsdWVzIGluIGEgc2luZ2xlIHRleGVsIGFyZSBkZW5zZWx5IHBhY2tlZCB3aXRob3V0IGFueSBjb25zdHJhaW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgaG93IHRoZSBzaGFkZXIgZW5jb2RlcyBhIHRlbnNvciB3aXRoIHNoYXBlID0gWzIsIDMsIDRdXG4gICAgICogKGluZGljZXMgYXJlIFtiYXRjaCwgcm93LCBjb2xdKS5cbiAgICAgKlxuICAgICAqIDAwMHwwMDEgICAwMTB8MDExICAgMDIwfDAyMVxuICAgICAqIC0tLS0tLS0gICAtLS0tLS0tICAgLS0tLS0tLVxuICAgICAqIDAwMnwwMDMgICAwMTJ8MDEzICAgMDIyfDAyM1xuICAgICAqXG4gICAgICogMTAwfDEwMSAgIDExMHwxMTEgICAxMjB8MTIxXG4gICAgICogLS0tLS0tLSAgIC0tLS0tLS0gICAtLS0tLS0tXG4gICAgICogMTAyfDEwMyAgIDExMnwxMTMgICAxMjJ8MTIzXG4gICAgICpcbiAgICAgKi9cbiAgICBQYWNraW5nU2NoZW1lW1BhY2tpbmdTY2hlbWVbXCJERU5TRVwiXSA9IDBdID0gXCJERU5TRVwiO1xuICAgIC8qKlxuICAgICAqIFNpbmdsZSB0ZXhlbHMgY29udGFpbiBvbmx5IHZhbHVlcyBmcm9tIHRoZSBzYW1lIGJhdGNoLCBhbmQgZnJvbSBhZGphY2VudFxuICAgICAqIHJvd3MgYW5kIGNvbHVtbnMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGhvdyB0aGUgc2hhZGVyIGVuY29kZXMgYSB0ZW5zb3Igd2l0aCBzaGFwZSA9IFsyLCAzLCA1XVxuICAgICAqIChpbmRpY2VzIGFyZSBbYmF0Y2gsIHJvdywgY29sXSkuXG4gICAgICpcbiAgICAgKiAwMDB8MDAxICAgMDAyfDAwMyAgIDAwNHx4eHggICAwMjB8MDIxICAgMDIyfDAyMyAgIDAyNHx4eHhcbiAgICAgKiAtLS0tLS0tICAgLS0tLS0tLSAgIC0tLS0tLS0gICAtLS0tLS0tICAgLS0tLS0tLSAgIC0tLS0tLS1cbiAgICAgKiAwMTB8MDExICAgMDEyfDAxMyAgIDAxNHx4eHggICB4eHh8eHh4ICAgeHh4fHh4eCAgIHh4eHx4eHhcbiAgICAgKlxuICAgICAqIDEwMHwxMDEgICAxMDJ8MTAzICAgMTA0fHh4eCAgIDEyMHwxMjEgICAxMjJ8MTIzICAgMTI0fHh4eFxuICAgICAqIC0tLS0tLS0gICAtLS0tLS0tICAgLS0tLS0tLSAgIC0tLS0tLS0gICAtLS0tLS0tICAgLS0tLS0tLVxuICAgICAqIDExMHwxMTEgICAxMTJ8MTEzICAgMTE0fHh4eCAgIHh4eHx4eHggICB4eHh8eHh4ICAgeHh4fHh4eFxuICAgICAqXG4gICAgICovXG4gICAgUGFja2luZ1NjaGVtZVtQYWNraW5nU2NoZW1lW1wiU0hBUkVEX0JBVENIXCJdID0gMV0gPSBcIlNIQVJFRF9CQVRDSFwiO1xufSkoUGFja2luZ1NjaGVtZSB8fCAoUGFja2luZ1NjaGVtZSA9IHt9KSk7XG52YXIgVGV4dHVyZVVzYWdlO1xuKGZ1bmN0aW9uIChUZXh0dXJlVXNhZ2UpIHtcbiAgICBUZXh0dXJlVXNhZ2VbVGV4dHVyZVVzYWdlW1wiUkVOREVSXCJdID0gMF0gPSBcIlJFTkRFUlwiO1xuICAgIFRleHR1cmVVc2FnZVtUZXh0dXJlVXNhZ2VbXCJVUExPQURcIl0gPSAxXSA9IFwiVVBMT0FEXCI7XG4gICAgVGV4dHVyZVVzYWdlW1RleHR1cmVVc2FnZVtcIlBJWEVMU1wiXSA9IDJdID0gXCJQSVhFTFNcIjtcbiAgICBUZXh0dXJlVXNhZ2VbVGV4dHVyZVVzYWdlW1wiRE9XTkxPQURcIl0gPSAzXSA9IFwiRE9XTkxPQURcIjtcbn0pKFRleHR1cmVVc2FnZSB8fCAoVGV4dHVyZVVzYWdlID0ge30pKTtcbnZhciBQaHlzaWNhbFRleHR1cmVUeXBlO1xuKGZ1bmN0aW9uIChQaHlzaWNhbFRleHR1cmVUeXBlKSB7XG4gICAgUGh5c2ljYWxUZXh0dXJlVHlwZVtQaHlzaWNhbFRleHR1cmVUeXBlW1wiVU5QQUNLRURfRkxPQVQxNlwiXSA9IDBdID0gXCJVTlBBQ0tFRF9GTE9BVDE2XCI7XG4gICAgUGh5c2ljYWxUZXh0dXJlVHlwZVtQaHlzaWNhbFRleHR1cmVUeXBlW1wiVU5QQUNLRURfRkxPQVQzMlwiXSA9IDFdID0gXCJVTlBBQ0tFRF9GTE9BVDMyXCI7XG4gICAgUGh5c2ljYWxUZXh0dXJlVHlwZVtQaHlzaWNhbFRleHR1cmVUeXBlW1wiUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFXCJdID0gMl0gPSBcIlBBQ0tFRF80WDFfVU5TSUdORURfQllURVwiO1xuICAgIFBoeXNpY2FsVGV4dHVyZVR5cGVbUGh5c2ljYWxUZXh0dXJlVHlwZVtcIlBBQ0tFRF8yWDJfRkxPQVQzMlwiXSA9IDNdID0gXCJQQUNLRURfMlgyX0ZMT0FUMzJcIjtcbiAgICBQaHlzaWNhbFRleHR1cmVUeXBlW1BoeXNpY2FsVGV4dHVyZVR5cGVbXCJQQUNLRURfMlgyX0ZMT0FUMTZcIl0gPSA0XSA9IFwiUEFDS0VEXzJYMl9GTE9BVDE2XCI7XG59KShQaHlzaWNhbFRleHR1cmVUeXBlIHx8IChQaHlzaWNhbFRleHR1cmVUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBbY29sdW1ucywgcm93c107XG59XG5mdW5jdGlvbiBnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKG1hdHJpeFNpemUsIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIHJldHVybiBtYXRyaXhTaXplICogY2hhbm5lbHNQZXJUZXh0dXJlO1xufVxuLyoqXG4gKiBHZXQgc2hhcGUgZm9yIGRlbnNlbHkgcGFja2VkIFJHQkEgdGV4dHVyZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVuc2VUZXhTaGFwZShzaGFwZSkge1xuICAgIHZhciBzaXplID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgICB2YXIgdGV4ZWxzTmVlZGVkID0gTWF0aC5jZWlsKHNpemUgLyA0KTtcbiAgICByZXR1cm4gdGYudXRpbC5zaXplVG9TcXVhcmlzaFNoYXBlKHRleGVsc05lZWRlZCk7XG59XG5mdW5jdGlvbiBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5tYXgoMSwgTWF0aC5jZWlsKGNvbHVtbnMgLyAyKSksIE1hdGgubWF4KDEsIE1hdGguY2VpbChyb3dzIC8gMikpXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUocm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICByZXR1cm4gdyAqIGggKiA0O1xufVxuZnVuY3Rpb24gZ2V0VGV4dHVyZUNvbmZpZyhcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbmdsLCB0ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHZhciBnbGFueSA9IGdsO1xuICAgIHZhciBpbnRlcm5hbEZvcm1hdEZsb2F0O1xuICAgIHZhciBpbnRlcm5hbEZvcm1hdEhhbGZGbG9hdDtcbiAgICB2YXIgaW50ZXJuYWxGb3JtYXRQYWNrZWRIYWxmRmxvYXQ7XG4gICAgdmFyIGludGVybmFsRm9ybWF0UGFja2VkRmxvYXQ7XG4gICAgdmFyIHRleHR1cmVGb3JtYXRGbG9hdDtcbiAgICB2YXIgZG93bmxvYWRUZXh0dXJlRm9ybWF0O1xuICAgIHZhciBkb3dubG9hZFVucGFja051bUNoYW5uZWxzO1xuICAgIHZhciBkZWZhdWx0TnVtQ2hhbm5lbHM7XG4gICAgdmFyIHRleHR1cmVUeXBlSGFsZkZsb2F0O1xuICAgIHZhciB0ZXh0dXJlVHlwZUZsb2F0O1xuICAgIGlmICh0Zi5lbnYoKS5nZXROdW1iZXIoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICBpbnRlcm5hbEZvcm1hdEZsb2F0ID0gZ2xhbnkuUjMyRjtcbiAgICAgICAgaW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQgPSBnbGFueS5SMTZGO1xuICAgICAgICBpbnRlcm5hbEZvcm1hdFBhY2tlZEhhbGZGbG9hdCA9IGdsYW55LlJHQkExNkY7XG4gICAgICAgIGludGVybmFsRm9ybWF0UGFja2VkRmxvYXQgPSBnbGFueS5SR0JBMzJGO1xuICAgICAgICB0ZXh0dXJlRm9ybWF0RmxvYXQgPSBnbGFueS5SRUQ7XG4gICAgICAgIGRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHMgPSA0O1xuICAgICAgICBkZWZhdWx0TnVtQ2hhbm5lbHMgPSAxO1xuICAgICAgICB0ZXh0dXJlVHlwZUhhbGZGbG9hdCA9IGdsYW55LkhBTEZfRkxPQVQ7XG4gICAgICAgIHRleHR1cmVUeXBlRmxvYXQgPSBnbGFueS5GTE9BVDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGludGVybmFsRm9ybWF0RmxvYXQgPSBnbC5SR0JBO1xuICAgICAgICBpbnRlcm5hbEZvcm1hdEhhbGZGbG9hdCA9IGdsLlJHQkE7XG4gICAgICAgIGludGVybmFsRm9ybWF0UGFja2VkSGFsZkZsb2F0ID0gZ2wuUkdCQTtcbiAgICAgICAgaW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdCA9IGdsYW55LlJHQkE7XG4gICAgICAgIHRleHR1cmVGb3JtYXRGbG9hdCA9IGdsLlJHQkE7XG4gICAgICAgIGRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHMgPSA0O1xuICAgICAgICBkZWZhdWx0TnVtQ2hhbm5lbHMgPSA0O1xuICAgICAgICB0ZXh0dXJlVHlwZUhhbGZGbG9hdCA9IHRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24gIT0gbnVsbCA/XG4gICAgICAgICAgICB0ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgICAgIHRleHR1cmVUeXBlRmxvYXQgPSBnbC5GTE9BVDtcbiAgICB9XG4gICAgZG93bmxvYWRUZXh0dXJlRm9ybWF0ID0gZ2wuUkdCQTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcm5hbEZvcm1hdEZsb2F0OiBpbnRlcm5hbEZvcm1hdEZsb2F0LFxuICAgICAgICBpbnRlcm5hbEZvcm1hdEhhbGZGbG9hdDogaW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQsXG4gICAgICAgIGludGVybmFsRm9ybWF0UGFja2VkSGFsZkZsb2F0OiBpbnRlcm5hbEZvcm1hdFBhY2tlZEhhbGZGbG9hdCxcbiAgICAgICAgaW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdDogaW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdCxcbiAgICAgICAgdGV4dHVyZUZvcm1hdEZsb2F0OiB0ZXh0dXJlRm9ybWF0RmxvYXQsXG4gICAgICAgIGRvd25sb2FkVGV4dHVyZUZvcm1hdDogZG93bmxvYWRUZXh0dXJlRm9ybWF0LFxuICAgICAgICBkb3dubG9hZFVucGFja051bUNoYW5uZWxzOiBkb3dubG9hZFVucGFja051bUNoYW5uZWxzLFxuICAgICAgICBkZWZhdWx0TnVtQ2hhbm5lbHM6IGRlZmF1bHROdW1DaGFubmVscyxcbiAgICAgICAgdGV4dHVyZVR5cGVIYWxmRmxvYXQ6IHRleHR1cmVUeXBlSGFsZkZsb2F0LFxuICAgICAgICB0ZXh0dXJlVHlwZUZsb2F0OiB0ZXh0dXJlVHlwZUZsb2F0XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY2FsbEFuZENoZWNrKGdsLCBmdW5jKSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gZnVuYygpO1xuICAgIGlmICh0Zi5lbnYoKS5nZXRCb29sKCdERUJVRycpKSB7XG4gICAgICAgIGNoZWNrV2ViR0xFcnJvcihnbCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrV2ViR0xFcnJvcihnbCkge1xuICAgIHZhciBlcnJvciA9IGdsLmdldEVycm9yKCk7XG4gICAgaWYgKGVycm9yICE9PSBnbC5OT19FUlJPUikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIEVycm9yOiAnICsgZ2V0V2ViR0xFcnJvck1lc3NhZ2UoZ2wsIGVycm9yKSk7XG4gICAgfVxufVxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFsZi1wcmVjaXNpb25fZmxvYXRpbmctcG9pbnRfZm9ybWF0XG52YXIgTUlOX0ZMT0FUMTYgPSA1Ljk2ZS04O1xudmFyIE1BWF9GTE9BVDE2ID0gNjU1MDQ7XG5mdW5jdGlvbiBjYW5CZVJlcHJlc2VudGVkKG51bSkge1xuICAgIGlmICh0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEJykgfHwgbnVtID09PSAwIHx8XG4gICAgICAgIChNSU5fRkxPQVQxNiA8IE1hdGguYWJzKG51bSkgJiYgTWF0aC5hYnMobnVtKSA8IE1BWF9GTE9BVDE2KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0V2ViR0xFcnJvck1lc3NhZ2UoZ2wsIHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgZ2wuTk9fRVJST1I6XG4gICAgICAgICAgICByZXR1cm4gJ05PX0VSUk9SJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX0VOVU06XG4gICAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfRU5VTSc7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9WQUxVRTpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9WQUxVRSc7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9PUEVSQVRJT046XG4gICAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfT1BFUkFUSU9OJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTjpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nO1xuICAgICAgICBjYXNlIGdsLk9VVF9PRl9NRU1PUlk6XG4gICAgICAgICAgICByZXR1cm4gJ09VVF9PRl9NRU1PUlknO1xuICAgICAgICBjYXNlIGdsLkNPTlRFWFRfTE9TVF9XRUJHTDpcbiAgICAgICAgICAgIHJldHVybiAnQ09OVEVYVF9MT1NUX1dFQkdMJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVua25vd24gZXJyb3IgY29kZSBcIiArIHN0YXR1cztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFeHRlbnNpb25PclRocm93KGdsLCBleHRlbnNpb25OYW1lKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSk7IH0sICdFeHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleFNoYWRlcihnbCwgdmVydGV4U2hhZGVyU291cmNlKSB7XG4gICAgdmFyIHZlcnRleFNoYWRlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7IH0sICdVbmFibGUgdG8gY3JlYXRlIHZlcnRleCBXZWJHTFNoYWRlci4nKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZSk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpOyB9KTtcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcikpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudFNoYWRlcihnbCwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7IH0sICdVbmFibGUgdG8gY3JlYXRlIGZyYWdtZW50IFdlYkdMU2hhZGVyLicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7IH0pO1xuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbG9nU2hhZGVyU291cmNlQW5kSW5mb0xvZyhmcmFnbWVudFNoYWRlclNvdXJjZSwgZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnbWVudFNoYWRlcikpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xufVxudmFyIGxpbmVOdW1iZXJSZWdleCA9IC9FUlJPUjogWzAtOV0rOihbMC05XSspOi9nO1xuZnVuY3Rpb24gbG9nU2hhZGVyU291cmNlQW5kSW5mb0xvZyhzaGFkZXJTb3VyY2UsIHNoYWRlckluZm9Mb2cpIHtcbiAgICB2YXIgbGluZU51bWJlclJlZ2V4UmVzdWx0ID0gbGluZU51bWJlclJlZ2V4LmV4ZWMoc2hhZGVySW5mb0xvZyk7XG4gICAgaWYgKGxpbmVOdW1iZXJSZWdleFJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGRuJ3QgcGFyc2UgbGluZSBudW1iZXIgaW4gZXJyb3I6IFwiICsgc2hhZGVySW5mb0xvZyk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNoYWRlclNvdXJjZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxpbmVOdW1iZXIgPSArbGluZU51bWJlclJlZ2V4UmVzdWx0WzFdO1xuICAgIHZhciBzaGFkZXJMaW5lcyA9IHNoYWRlclNvdXJjZS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIHBhZCA9IHNoYWRlckxpbmVzLmxlbmd0aC50b1N0cmluZygpLmxlbmd0aCArIDI7XG4gICAgdmFyIGxpbmVzV2l0aExpbmVOdW1iZXJzID0gc2hhZGVyTGluZXMubWFwKGZ1bmN0aW9uIChsaW5lLCBsaW5lTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0Zi51dGlsLnJpZ2h0UGFkKChsaW5lTnVtYmVyICsgMSkudG9TdHJpbmcoKSwgcGFkKSArIGxpbmU7XG4gICAgfSk7XG4gICAgdmFyIG1heExpbmVMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXNXaXRoTGluZU51bWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF4TGluZUxlbmd0aCA9IE1hdGgubWF4KGxpbmVzV2l0aExpbmVOdW1iZXJzW2ldLmxlbmd0aCwgbWF4TGluZUxlbmd0aCk7XG4gICAgfVxuICAgIHZhciBiZWZvcmVFcnJvckxpbmVzID0gbGluZXNXaXRoTGluZU51bWJlcnMuc2xpY2UoMCwgbGluZU51bWJlciAtIDEpO1xuICAgIHZhciBlcnJvckxpbmUgPSBsaW5lc1dpdGhMaW5lTnVtYmVycy5zbGljZShsaW5lTnVtYmVyIC0gMSwgbGluZU51bWJlcik7XG4gICAgdmFyIGFmdGVyRXJyb3JMaW5lcyA9IGxpbmVzV2l0aExpbmVOdW1iZXJzLnNsaWNlKGxpbmVOdW1iZXIpO1xuICAgIGNvbnNvbGUubG9nKGJlZm9yZUVycm9yTGluZXMuam9pbignXFxuJykpO1xuICAgIGNvbnNvbGUubG9nKHNoYWRlckluZm9Mb2cuc3BsaXQoJ1xcbicpWzBdKTtcbiAgICBjb25zb2xlLmxvZyhcIiVjIFwiICsgdGYudXRpbC5yaWdodFBhZChlcnJvckxpbmVbMF0sIG1heExpbmVMZW5ndGgpLCAnYm9yZGVyOjFweCBzb2xpZCByZWQ7IGJhY2tncm91bmQtY29sb3I6I2UzZDJkMjsgY29sb3I6I2E2MTcxNycpO1xuICAgIGNvbnNvbGUubG9nKGFmdGVyRXJyb3JMaW5lcy5qb2luKCdcXG4nKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGdsKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVQcm9ncmFtKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMUHJvZ3JhbS4nKTtcbn1cbmZ1bmN0aW9uIGxpbmtQcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxpbmsgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmFsaWRhdGVQcm9ncmFtKHByb2dyYW0pOyB9KTtcbiAgICBpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhZGVyIHByb2dyYW0gdmFsaWRhdGlvbiBmYWlsZWQuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyKGdsLCBkYXRhKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVCdWZmZXIoKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXInKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7IH0pO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcihnbCwgZGF0YSkge1xuICAgIHZhciBidWZmZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlQnVmZmVyKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyJyk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTsgfSk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGdldE51bUNoYW5uZWxzKCkge1xuICAgIGlmICh0Zi5lbnYoKS5nZXROdW1iZXIoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlKGdsKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVUZXh0dXJlKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMVGV4dHVyZS4nKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVGV4dHVyZVNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBtYXhUZXh0dXJlU2l6ZSA9IHRmLmVudigpLmdldE51bWJlcignV0VCR0xfTUFYX1RFWFRVUkVfU0laRScpO1xuICAgIGlmICgod2lkdGggPD0gMCkgfHwgKGhlaWdodCA8PSAwKSkge1xuICAgICAgICB2YXIgcmVxdWVzdGVkID0gXCJbXCIgKyB3aWR0aCArIFwieFwiICsgaGVpZ2h0ICsgXCJdXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSAnICsgcmVxdWVzdGVkICsgJyBpcyBpbnZhbGlkLicpO1xuICAgIH1cbiAgICBpZiAoKHdpZHRoID4gbWF4VGV4dHVyZVNpemUpIHx8IChoZWlnaHQgPiBtYXhUZXh0dXJlU2l6ZSkpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RlZCA9IFwiW1wiICsgd2lkdGggKyBcInhcIiArIGhlaWdodCArIFwiXVwiO1xuICAgICAgICB2YXIgbWF4ID0gXCJbXCIgKyBtYXhUZXh0dXJlU2l6ZSArIFwieFwiICsgbWF4VGV4dHVyZVNpemUgKyBcIl1cIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplICcgKyByZXF1ZXN0ZWQgK1xuICAgICAgICAgICAgJyBncmVhdGVyIHRoYW4gV2ViR0wgbWF4aW11bSBvbiB0aGlzIGJyb3dzZXIgLyBHUFUgJyArIG1heCArICcuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRnJhbWVidWZmZXIoZ2wpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMRnJhbWVidWZmZXIuJyk7XG59XG5mdW5jdGlvbiBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKGdsLCBwcm9ncmFtLCBhdHRyaWJ1dGUsIGJ1ZmZlciwgYXJyYXlFbnRyaWVzUGVySXRlbSwgaXRlbVN0cmlkZUluQnl0ZXMsIGl0ZW1PZmZzZXRJbkJ5dGVzKSB7XG4gICAgdmFyIGxvYyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZSk7XG4gICAgaWYgKGxvYyA9PT0gLTEpIHtcbiAgICAgICAgLy8gVGhlIEdQVSBjb21waWxlciBkZWNpZGVkIHRvIHN0cmlwIG91dCB0aGlzIGF0dHJpYnV0ZSBiZWNhdXNlIGl0J3MgdW51c2VkLFxuICAgICAgICAvLyB0aHVzIG5vIG5lZWQgdG8gYmluZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jLCBhcnJheUVudHJpZXNQZXJJdGVtLCBnbC5GTE9BVCwgZmFsc2UsIGl0ZW1TdHJpZGVJbkJ5dGVzLCBpdGVtT2Zmc2V0SW5CeXRlcyk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jKTsgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBiaW5kVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmUsIHRleHR1cmVVbml0KSB7XG4gICAgdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTsgfSk7XG59XG5mdW5jdGlvbiB1bmJpbmRUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICB2YWxpZGF0ZVRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpOyB9KTtcbn1cbmZ1bmN0aW9uIGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KGdsLCBwcm9ncmFtLCB1bmlmb3JtTmFtZSkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTsgfSwgJ3VuaWZvcm0gXCInICsgdW5pZm9ybU5hbWUgKyAnXCIgbm90IHByZXNlbnQgaW4gcHJvZ3JhbS4nKTtcbn1cbmZ1bmN0aW9uIGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb24oZ2wsIHByb2dyYW0sIHVuaWZvcm1OYW1lKSB7XG4gICAgcmV0dXJuIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG59XG5mdW5jdGlvbiBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyKGdsLCB0ZXh0dXJlLCB1bmlmb3JtU2FtcGxlckxvY2F0aW9uLCB0ZXh0dXJlVW5pdCkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYmluZFRleHR1cmVVbml0KGdsLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudW5pZm9ybTFpKHVuaWZvcm1TYW1wbGVyTG9jYXRpb24sIHRleHR1cmVVbml0KTsgfSk7XG59XG5mdW5jdGlvbiBiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcihnbCkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNjaXNzb3IoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTsgfSk7XG59XG5mdW5jdGlvbiBiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcihnbCwgdGV4dHVyZSwgZnJhbWVidWZmZXIpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7IH0pO1xufVxuZnVuY3Rpb24gdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKGdsLCBmcmFtZWJ1ZmZlcikge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBudWxsLCAwKTsgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUZyYW1lYnVmZmVyKGdsKSB7XG4gICAgdmFyIHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuICAgIGlmIChzdGF0dXMgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYmluZGluZyBmcmFtZWJ1ZmZlcjogJyArIGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlKGdsLCBzdGF0dXMpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZShnbCwgc3RhdHVzKSB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVCc7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UJztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUyc7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcInVua25vd24gZXJyb3IgXCIgKyBzdGF0dXM7XG4gICAgfVxufVxuZnVuY3Rpb24gdGhyb3dJZk51bGwoZ2wsIHJldHVyblRPck51bGwsIGZhaWx1cmVNZXNzYWdlKSB7XG4gICAgdmFyIHRPck51bGwgPSBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHVyblRPck51bGwoKTsgfSk7XG4gICAgaWYgKHRPck51bGwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFpbHVyZU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdE9yTnVsbDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmVVbml0KSB7XG4gICAgdmFyIG1heFRleHR1cmVVbml0ID0gZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgLSAxO1xuICAgIHZhciBnbFRleHR1cmVVbml0ID0gdGV4dHVyZVVuaXQgKyBnbC5URVhUVVJFMDtcbiAgICBpZiAoZ2xUZXh0dXJlVW5pdCA8IGdsLlRFWFRVUkUwIHx8IGdsVGV4dHVyZVVuaXQgPiBtYXhUZXh0dXJlVW5pdCkge1xuICAgICAgICB2YXIgdGV4dHVyZVVuaXRSYW5nZSA9IFwiW2dsLlRFWFRVUkUwLCBnbC5URVhUVVJFXCIgKyBtYXhUZXh0dXJlVW5pdCArIFwiXVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0ZXh0dXJlVW5pdCBtdXN0IGJlIGluIFwiICsgdGV4dHVyZVVuaXRSYW5nZSArIFwiLlwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRCYXRjaERpbShzaGFwZSwgZGltc1RvU2tpcCkge1xuICAgIGlmIChkaW1zVG9Ta2lwID09PSB2b2lkIDApIHsgZGltc1RvU2tpcCA9IDI7IH1cbiAgICByZXR1cm4gdGYudXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlLnNsaWNlKDAsIHNoYXBlLmxlbmd0aCAtIGRpbXNUb1NraXApKTtcbn1cbmZ1bmN0aW9uIGdldFJvd3NDb2xzKHNoYXBlKSB7XG4gICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGdldCByb3dzIGFuZCBjb2x1bW5zIG9mIGFuIGVtcHR5IHNoYXBlIGFycmF5LicpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBzaGFwZS5sZW5ndGggPiAxID8gc2hhcGVbc2hhcGUubGVuZ3RoIC0gMl0gOiAxLCBzaGFwZVtzaGFwZS5sZW5ndGggLSAxXVxuICAgIF07XG59XG5mdW5jdGlvbiBnZXRTaGFwZUFzM0Qoc2hhcGUpIHtcbiAgICB2YXIgc2hhcGVBczNEID0gWzEsIDEsIDFdO1xuICAgIHZhciBpc1NjYWxhciA9IHNoYXBlLmxlbmd0aCA9PT0gMCB8fCAoc2hhcGUubGVuZ3RoID09PSAxICYmIHNoYXBlWzBdID09PSAxKTtcbiAgICBpZiAoIWlzU2NhbGFyKSB7XG4gICAgICAgIHNoYXBlQXMzRCA9XG4gICAgICAgICAgICBbZ2V0QmF0Y2hEaW0oc2hhcGUpXS5jb25jYXQoZ2V0Um93c0NvbHMoc2hhcGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlQXMzRDtcbn1cbmZ1bmN0aW9uIGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUobG9nU2hhcGUsIGlzUGFja2VkKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChpc1BhY2tlZCA9PT0gdm9pZCAwKSB7IGlzUGFja2VkID0gZmFsc2U7IH1cbiAgICB2YXIgbWF4VGV4U2l6ZSA9IHRmLmVudigpLmdldE51bWJlcignV0VCR0xfTUFYX1RFWFRVUkVfU0laRScpO1xuICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICBtYXhUZXhTaXplID0gbWF4VGV4U2l6ZSAqIDI7XG4gICAgICAgIC8vIFRoaXMgbG9naWMgZW5zdXJlcyB3ZSBhY2N1cmF0ZWx5IGNvdW50IHRoZSBudW1iZXIgb2YgcGFja2VkIHRleGVscyBuZWVkZWRcbiAgICAgICAgLy8gdG8gYWNjb21tb2RhdGUgdGhlIHRlbnNvci4gV2UgY2FuIG9ubHkgcGFjayB2YWx1ZXMgaW4gdGhlIHNhbWUgdGV4ZWwgaWZcbiAgICAgICAgLy8gdGhleSBhcmUgZnJvbSBhZGphY2VudCBwYWlycyBvZiByb3dzL2NvbHMgd2l0aGluIHRoZSBzYW1lIGJhdGNoLiBTbyBpZiBhXG4gICAgICAgIC8vIHRlbnNvciBoYXMgMyByb3dzLCB3ZSBwcmV0ZW5kIGl0IGhhcyA0IHJvd3MgaW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhlXG4gICAgICAgIC8vIGZhY3QgdGhhdCB0aGUgdGV4ZWxzIGNvbnRhaW5pbmcgdGhlIHRoaXJkIHJvdyBhcmUgaGFsZiBlbXB0eS5cbiAgICAgICAgbG9nU2hhcGUgPSBsb2dTaGFwZS5tYXAoZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIGkgPj0gbG9nU2hhcGUubGVuZ3RoIC0gMiA/XG4gICAgICAgICAgICB0Zi51dGlsLm5lYXJlc3RMYXJnZXJFdmVuKGxvZ1NoYXBlW2ldKSA6XG4gICAgICAgICAgICBsb2dTaGFwZVtpXTsgfSk7XG4gICAgICAgIC8vIFBhY2tlZCB0ZXh0dXJlIGhlaWdodCBpcyBhdCBsZWFzdCAyICh0aGUgY2hhbm5lbCBoZWlnaHQgb2YgYSBzaW5nbGVcbiAgICAgICAgLy8gdGV4ZWwpLlxuICAgICAgICBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBsb2dTaGFwZSA9IFsyLCBsb2dTaGFwZVswXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgbG9naWNhbCBzaGFwZSBpcyAyLCB3ZSBkb24ndCBzcXVlZXplLCBzaW5jZSB3ZSB3YW50IHRvIG1hdGNoIHBoeXNpY2FsLlxuICAgIGlmIChsb2dTaGFwZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdmFyIHNxdWVlemVSZXN1bHQgPSB0Zi51dGlsLnNxdWVlemVTaGFwZShsb2dTaGFwZSk7XG4gICAgICAgIGxvZ1NoYXBlID0gc3F1ZWV6ZVJlc3VsdC5uZXdTaGFwZTtcbiAgICB9XG4gICAgdmFyIHNpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUobG9nU2hhcGUpO1xuICAgIGlmIChsb2dTaGFwZS5sZW5ndGggPD0gMSAmJiBzaXplIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIFsxLCBzaXplXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAyICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleFNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbMV0gPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gbG9nU2hhcGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMyAmJiBsb2dTaGFwZVswXSAqIGxvZ1NoYXBlWzFdIDw9IG1heFRleFNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbMl0gPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0sIGxvZ1NoYXBlWzJdXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAzICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleFNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl1dO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDQgJiZcbiAgICAgICAgbG9nU2hhcGVbMF0gKiBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdIDw9IG1heFRleFNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbM10gPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSwgbG9nU2hhcGVbM11dO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDQgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4U2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdICogbG9nU2hhcGVbM10gPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdLCBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdICogbG9nU2hhcGVbM11dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgICAgICAvLyBGb3IgcGFja2VkIHRleHR1cmVzIHNpemUgZXF1YWxzIHRoZSBudW1iZXIgb2YgY2hhbm5lbHMgcmVxdWlyZWQgdG9cbiAgICAgICAgICAgIC8vIGFjY29tbW9kYXRlIHRoZSB0ZXh0dXJlIGRhdGEuIEhvd2V2ZXIgaW4gb3JkZXIgdG8gc3F1YXJpZnkgc3VjaCB0aGF0XG4gICAgICAgICAgICAvLyBpbm5lciBkaW1lbnNpb25zIHN0YXkgZXZlbiwgd2UgcmV3cml0ZSBzaXplIHRvIGVxdWFsIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIHRleGVscy4gVGhlbiBpbiB0aGUgcmV0dXJuIHN0YXRlbWVudCB3ZSByZWh5ZHJhdGUgdGhlIHNxdWFyaWZpZWRcbiAgICAgICAgICAgIC8vIGRpbWVuc2lvbnMgdG8gY2hhbm5lbCB1bml0cy5cbiAgICAgICAgICAgIHZhciBiYXRjaERpbSA9IGdldEJhdGNoRGltKGxvZ1NoYXBlKTtcbiAgICAgICAgICAgIHZhciByb3dzID0gMiwgY29scyA9IDI7XG4gICAgICAgICAgICBpZiAobG9nU2hhcGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgX2EgPSBnZXRSb3dzQ29scyhsb2dTaGFwZSksIHJvd3MgPSBfYVswXSwgY29scyA9IF9hWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSA9IGJhdGNoRGltICogKHJvd3MgLyAyKSAqIChjb2xzIC8gMik7XG4gICAgICAgICAgICByZXR1cm4gdGYudXRpbC5zaXplVG9TcXVhcmlzaFNoYXBlKHNpemUpLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCAqIDI7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0Zi51dGlsLnNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICByZXR1cm4gbiAlIDIgPT09IDA7XG59XG4vKipcbiAqIFRoaXMgZGV0ZXJtaW5lcyB3aGV0aGVyIHJlc2hhcGluZyBhIHBhY2tlZCB0ZXh0dXJlIHJlcXVpcmVzIHJlYXJyYW5naW5nXG4gKiB0aGUgZGF0YSB3aXRoaW4gdGhlIHRleHR1cmUsIGFzc3VtaW5nIDJ4MiBwYWNraW5nLlxuICovXG5mdW5jdGlvbiBpc1Jlc2hhcGVGcmVlKHNoYXBlMSwgc2hhcGUyKSB7XG4gICAgc2hhcGUxID0gc2hhcGUxLnNsaWNlKC0yKTtcbiAgICBzaGFwZTIgPSBzaGFwZTIuc2xpY2UoLTIpO1xuICAgIGlmICh0Zi51dGlsLmFycmF5c0VxdWFsKHNoYXBlMSwgc2hhcGUyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFzaGFwZTEubGVuZ3RoIHx8ICFzaGFwZTIubGVuZ3RoKSB7IC8vIE9uZSBvZiB0aGUgc2hhcGVzIGlzIGEgc2NhbGFyLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNoYXBlMVswXSA9PT0gMCB8fCBzaGFwZTFbMV0gPT09IDAgfHwgc2hhcGUyWzBdID09PSAwIHx8XG4gICAgICAgIHNoYXBlMlsxXSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNoYXBlMS5sZW5ndGggIT09IHNoYXBlMi5sZW5ndGgpIHsgLy8gT25lIG9mIHRoZSBzaGFwZXMgaXMgYSB2ZWN0b3IuXG4gICAgICAgIHZhciBzaGFwZTFDb2xzID0gc2hhcGUxLnNsaWNlKC0xKVswXTtcbiAgICAgICAgdmFyIHNoYXBlMkNvbHMgPSBzaGFwZTIuc2xpY2UoLTEpWzBdO1xuICAgICAgICBpZiAoc2hhcGUxQ29scyA9PT0gc2hhcGUyQ29scykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRXZlbihzaGFwZTFDb2xzKSAmJiBpc0V2ZW4oc2hhcGUyQ29scykgJiZcbiAgICAgICAgICAgIChzaGFwZTFbMF0gPT09IDEgfHwgc2hhcGUyWzBdID09PSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlMVsxXSA9PT0gc2hhcGUyWzFdICYmIGlzRXZlbihzaGFwZTFbMF0pICYmIGlzRXZlbihzaGFwZTJbMF0pO1xufVxuLy8gV2UgY2FjaGUgd2ViZ2wgcGFyYW1zIGJlY2F1c2UgdGhlIGVudmlyb25tZW50IGdldHMgcmVzZXQgYmV0d2VlblxuLy8gdW5pdCB0ZXN0cyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBjb25zdGFudGx5IHF1ZXJ5IHRoZSBXZWJHTENvbnRleHQgZm9yXG4vLyBNQVhfVEVYVFVSRV9TSVpFLlxudmFyIE1BWF9URVhUVVJFX1NJWkU7XG52YXIgTUFYX1RFWFRVUkVTX0lOX1NIQURFUjtcbmZ1bmN0aW9uIGdldFdlYkdMTWF4VGV4dHVyZVNpemUod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKE1BWF9URVhUVVJFX1NJWkUgPT0gbnVsbCkge1xuICAgICAgICB2YXIgZ2wgPSBnZXRXZWJHTENvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICAgICAgTUFYX1RFWFRVUkVfU0laRSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgICB9XG4gICAgcmV0dXJuIE1BWF9URVhUVVJFX1NJWkU7XG59XG5mdW5jdGlvbiByZXNldE1heFRleHR1cmVTaXplKCkge1xuICAgIE1BWF9URVhUVVJFX1NJWkUgPSBudWxsO1xufVxuZnVuY3Rpb24gcmVzZXRNYXhUZXh0dXJlc0luU2hhZGVyKCkge1xuICAgIE1BWF9URVhUVVJFU19JTl9TSEFERVIgPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0TWF4VGV4dHVyZXNJblNoYWRlcih3ZWJHTFZlcnNpb24pIHtcbiAgICBpZiAoTUFYX1RFWFRVUkVTX0lOX1NIQURFUiA9PSBudWxsKSB7XG4gICAgICAgIHZhciBnbCA9IGdldFdlYkdMQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgICAgICBNQVhfVEVYVFVSRVNfSU5fU0hBREVSID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcbiAgICB9XG4gICAgLy8gV2UgY2FwIGF0IDE2IHRvIGF2b2lkIHNwdXJpb3VzIHJ1bnRpbWUgXCJtZW1vcnkgZXhoYXVzdGVkXCIgZXJyb3IuXG4gICAgcmV0dXJuIE1hdGgubWluKDE2LCBNQVhfVEVYVFVSRVNfSU5fU0hBREVSKTtcbn1cbmZ1bmN0aW9uIGdldFdlYkdMRGlzam9pbnRRdWVyeVRpbWVyVmVyc2lvbih3ZWJHTFZlcnNpb24pIHtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgcXVlcnlUaW1lclZlcnNpb247XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgaWYgKGhhc0V4dGVuc2lvbihnbCwgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInKSAmJlxuICAgICAgICB3ZWJHTFZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgcXVlcnlUaW1lclZlcnNpb24gPSAyO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYXNFeHRlbnNpb24oZ2wsICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnknKSkge1xuICAgICAgICBxdWVyeVRpbWVyVmVyc2lvbiA9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBxdWVyeVRpbWVyVmVyc2lvbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVRpbWVyVmVyc2lvbjtcbn1cbmZ1bmN0aW9uIGhhc0V4dGVuc2lvbihnbCwgZXh0ZW5zaW9uTmFtZSkge1xuICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSk7XG4gICAgcmV0dXJuIGV4dCAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNXZWJHTFZlcnNpb25FbmFibGVkKHdlYkdMVmVyc2lvbikge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBnbCA9IGdldFdlYkdMQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgICAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIHdoZW4gZ2V0dGluZyBXZWJHTCBjb250ZXh0OiAnLCBlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0NhcGFibGVPZlJlbmRlcmluZ1RvRmxvYXRUZXh0dXJlKHdlYkdMVmVyc2lvbikge1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZ2wgPSBnZXRXZWJHTENvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGlmICghaGFzRXh0ZW5zaW9uKGdsLCAnT0VTX3RleHR1cmVfZmxvYXQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWhhc0V4dGVuc2lvbihnbCwgJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBpc0ZyYW1lQnVmZmVyQ29tcGxldGUgPSBjcmVhdGVGbG9hdFRleHR1cmVBbmRCaW5kVG9GcmFtZWJ1ZmZlcihnbCk7XG4gICAgcmV0dXJuIGlzRnJhbWVCdWZmZXJDb21wbGV0ZTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgd2UgY2FuIGRvd25sb2FkIHZhbHVlcyBmcm9tIGEgZmxvYXQvaGFsZi1mbG9hdCB0ZXh0dXJlLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyB3ZSB1c2UgYmluZGluZyBhIHRleHR1cmUgdG8gYSBmcmFtZWJ1ZmZlclxuICogYXMgYSBwcm94eSBmb3IgYWJpbGl0eSB0byBkb3dubG9hZCBmbG9hdCB2YWx1ZXMgbGF0ZXIgdXNpbmcgcmVhZFBpeGVscy4gVGhlXG4gKiB0ZXh0dXJlIHBhcmFtcyBvZiB0aGlzIHRleHR1cmUgd2lsbCBub3QgbWF0Y2ggdGhvc2UgaW4gcmVhZFBpeGVscyBleGFjdGx5XG4gKiBidXQgaWYgd2UgYXJlIHVuYWJsZSB0byBiaW5kIHNvbWUga2luZCBvZiBmbG9hdCB0ZXh0dXJlIHRvIHRoZSBmcmFtZUJ1ZmZlclxuICogdGhlbiB3ZSBkZWZpbml0ZWx5IHdpbGwgbm90IGJlIGFibGUgdG8gcmVhZCBmbG9hdCB2YWx1ZXMgZnJvbSBpdC5cbiAqL1xuZnVuY3Rpb24gaXNEb3dubG9hZEZsb2F0VGV4dHVyZUVuYWJsZWQod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBnbCA9IGdldFdlYkdMQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgaWYgKCFoYXNFeHRlbnNpb24oZ2wsICdPRVNfdGV4dHVyZV9mbG9hdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNFeHRlbnNpb24oZ2wsICdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaGFzRXh0ZW5zaW9uKGdsLCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRmxvYXRUZXh0dXJlQW5kQmluZFRvRnJhbWVidWZmZXIoZ2wpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBDT0xPUl9CVUZGRVJfSEFMRl9GTE9BVCA9ICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnO1xuICAgICAgICBpZiAoaGFzRXh0ZW5zaW9uKGdsLCBDT0xPUl9CVUZGRVJfSEFMRl9GTE9BVCkpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKENPTE9SX0JVRkZFUl9IQUxGX0ZMT0FUKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVIYWxmRmxvYXRUZXh0dXJlQW5kQmluZFRvRnJhbWVidWZmZXIoZ2wsIHRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGlzRnJhbWVCdWZmZXJDb21wbGV0ZSA9IGNyZWF0ZUZsb2F0VGV4dHVyZUFuZEJpbmRUb0ZyYW1lYnVmZmVyKGdsKTtcbiAgICByZXR1cm4gaXNGcmFtZUJ1ZmZlckNvbXBsZXRlO1xufVxuZnVuY3Rpb24gY3JlYXRlRmxvYXRUZXh0dXJlQW5kQmluZFRvRnJhbWVidWZmZXIoZ2wpIHtcbiAgICB2YXIgdGV4Q29uZmlnID0gZ2V0VGV4dHVyZUNvbmZpZyhnbCk7XG4gICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdmFyIHdpZHRoID0gMTtcbiAgICB2YXIgaGVpZ2h0ID0gMTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRleENvbmZpZy5pbnRlcm5hbEZvcm1hdEZsb2F0LCB3aWR0aCwgaGVpZ2h0LCAwLCB0ZXhDb25maWcudGV4dHVyZUZvcm1hdEZsb2F0LCB0ZXhDb25maWcudGV4dHVyZVR5cGVGbG9hdCwgbnVsbCk7XG4gICAgdmFyIGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIHZhciBpc0ZyYW1lQnVmZmVyQ29tcGxldGUgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSA9PT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEU7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyKTtcbiAgICByZXR1cm4gaXNGcmFtZUJ1ZmZlckNvbXBsZXRlO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFsZkZsb2F0VGV4dHVyZUFuZEJpbmRUb0ZyYW1lYnVmZmVyKFxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuZ2wsIHRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24pIHtcbiAgICB2YXIgdGV4Q29uZmlnID0gZ2V0VGV4dHVyZUNvbmZpZyhnbCwgdGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbik7XG4gICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdmFyIHdpZHRoID0gMTtcbiAgICB2YXIgaGVpZ2h0ID0gMTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRleENvbmZpZy5pbnRlcm5hbEZvcm1hdEhhbGZGbG9hdCwgd2lkdGgsIGhlaWdodCwgMCwgdGV4Q29uZmlnLnRleHR1cmVGb3JtYXRGbG9hdCwgdGV4Q29uZmlnLnRleHR1cmVUeXBlSGFsZkZsb2F0LCBudWxsKTtcbiAgICB2YXIgZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgdmFyIGlzRnJhbWVCdWZmZXJDb21wbGV0ZSA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVCdWZmZXIpO1xuICAgIHJldHVybiBpc0ZyYW1lQnVmZmVyQ29tcGxldGU7XG59XG5mdW5jdGlvbiBpc1dlYkdMRmVuY2VFbmFibGVkKHdlYkdMVmVyc2lvbikge1xuICAgIGlmICh3ZWJHTFZlcnNpb24gIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZ2wgPSBnZXRXZWJHTENvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgdmFyIGlzRW5hYmxlZCA9IGdsLmZlbmNlU3luYyAhPSBudWxsO1xuICAgIHJldHVybiBpc0VuYWJsZWQ7XG59XG5mdW5jdGlvbiBhc3NlcnROb3RDb21wbGV4KHRlbnNvciwgb3BOYW1lKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRlbnNvcikpIHtcbiAgICAgICAgdGVuc29yID0gW3RlbnNvcl07XG4gICAgfVxuICAgIHRlbnNvci5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRmLnV0aWwuYXNzZXJ0KHQuZHR5cGUgIT09ICdjb21wbGV4NjQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvcE5hbWUgKyBcIiBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXg2NCB0ZW5zb3JzIFwiICtcbiAgICAgICAgICAgICAgICAnaW4gdGhlIFdlYkdMIGJhY2tlbmQuJzsgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxudmFyIHdlYmdsX3V0aWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNhbGxBbmRDaGVjazogY2FsbEFuZENoZWNrLFxuICAgIGNhbkJlUmVwcmVzZW50ZWQ6IGNhbkJlUmVwcmVzZW50ZWQsXG4gICAgZ2V0V2ViR0xFcnJvck1lc3NhZ2U6IGdldFdlYkdMRXJyb3JNZXNzYWdlLFxuICAgIGdldEV4dGVuc2lvbk9yVGhyb3c6IGdldEV4dGVuc2lvbk9yVGhyb3csXG4gICAgY3JlYXRlVmVydGV4U2hhZGVyOiBjcmVhdGVWZXJ0ZXhTaGFkZXIsXG4gICAgY3JlYXRlRnJhZ21lbnRTaGFkZXI6IGNyZWF0ZUZyYWdtZW50U2hhZGVyLFxuICAgIGNyZWF0ZVByb2dyYW06IGNyZWF0ZVByb2dyYW0sXG4gICAgbGlua1Byb2dyYW06IGxpbmtQcm9ncmFtLFxuICAgIHZhbGlkYXRlUHJvZ3JhbTogdmFsaWRhdGVQcm9ncmFtLFxuICAgIGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcjogY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyLFxuICAgIGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyOiBjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcixcbiAgICBnZXROdW1DaGFubmVsczogZ2V0TnVtQ2hhbm5lbHMsXG4gICAgY3JlYXRlVGV4dHVyZTogY3JlYXRlVGV4dHVyZSxcbiAgICB2YWxpZGF0ZVRleHR1cmVTaXplOiB2YWxpZGF0ZVRleHR1cmVTaXplLFxuICAgIGNyZWF0ZUZyYW1lYnVmZmVyOiBjcmVhdGVGcmFtZWJ1ZmZlcixcbiAgICBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlOiBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlLFxuICAgIGJpbmRUZXh0dXJlVW5pdDogYmluZFRleHR1cmVVbml0LFxuICAgIHVuYmluZFRleHR1cmVVbml0OiB1bmJpbmRUZXh0dXJlVW5pdCxcbiAgICBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdzogZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3csXG4gICAgZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbjogZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbixcbiAgICBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyOiBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyLFxuICAgIGJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyOiBiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcixcbiAgICBiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcjogYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIsXG4gICAgdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyOiB1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIsXG4gICAgdmFsaWRhdGVGcmFtZWJ1ZmZlcjogdmFsaWRhdGVGcmFtZWJ1ZmZlcixcbiAgICBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZTogZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2UsXG4gICAgZ2V0QmF0Y2hEaW06IGdldEJhdGNoRGltLFxuICAgIGdldFJvd3NDb2xzOiBnZXRSb3dzQ29scyxcbiAgICBnZXRTaGFwZUFzM0Q6IGdldFNoYXBlQXMzRCxcbiAgICBnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlOiBnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlLFxuICAgIGlzUmVzaGFwZUZyZWU6IGlzUmVzaGFwZUZyZWUsXG4gICAgZ2V0V2ViR0xNYXhUZXh0dXJlU2l6ZTogZ2V0V2ViR0xNYXhUZXh0dXJlU2l6ZSxcbiAgICByZXNldE1heFRleHR1cmVTaXplOiByZXNldE1heFRleHR1cmVTaXplLFxuICAgIHJlc2V0TWF4VGV4dHVyZXNJblNoYWRlcjogcmVzZXRNYXhUZXh0dXJlc0luU2hhZGVyLFxuICAgIGdldE1heFRleHR1cmVzSW5TaGFkZXI6IGdldE1heFRleHR1cmVzSW5TaGFkZXIsXG4gICAgZ2V0V2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJWZXJzaW9uOiBnZXRXZWJHTERpc2pvaW50UXVlcnlUaW1lclZlcnNpb24sXG4gICAgaGFzRXh0ZW5zaW9uOiBoYXNFeHRlbnNpb24sXG4gICAgaXNXZWJHTFZlcnNpb25FbmFibGVkOiBpc1dlYkdMVmVyc2lvbkVuYWJsZWQsXG4gICAgaXNDYXBhYmxlT2ZSZW5kZXJpbmdUb0Zsb2F0VGV4dHVyZTogaXNDYXBhYmxlT2ZSZW5kZXJpbmdUb0Zsb2F0VGV4dHVyZSxcbiAgICBpc0Rvd25sb2FkRmxvYXRUZXh0dXJlRW5hYmxlZDogaXNEb3dubG9hZEZsb2F0VGV4dHVyZUVuYWJsZWQsXG4gICAgaXNXZWJHTEZlbmNlRW5hYmxlZDogaXNXZWJHTEZlbmNlRW5hYmxlZCxcbiAgICBhc3NlcnROb3RDb21wbGV4OiBhc3NlcnROb3RDb21wbGV4XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRU5WID0gdGYuZW52KCk7XG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBXZWJHTC1zcGVjaWZpYyBmbGFnIHJlZ2lzdHJhdGlvbnMuXG4gKi9cbi8qKlxuICogVHJ1ZSBpZiBXZWJHTCBpcyBzdXBwb3J0ZWQuXG4gKi9cbkVOVi5yZWdpc3RlckZsYWcoJ0hBU19XRUJHTCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIEVOVi5nZXROdW1iZXIoJ1dFQkdMX1ZFUlNJT04nKSA+IDA7IH0pO1xuLyoqIDA6IE5vIFdlYkdMLCAxOiBXZWJHTCAxLjAsIDI6IFdlYkdMIDIuMC4gKi9cbkVOVi5yZWdpc3RlckZsYWcoJ1dFQkdMX1ZFUlNJT04nLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzV2ViR0xWZXJzaW9uRW5hYmxlZCgyKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNXZWJHTFZlcnNpb25FbmFibGVkKDEpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn0pO1xuLyoqIFdoZXRoZXIgdG8gY2hlY2sgZm9yIG51bWVyaWNhbCByZXByZXNlbnRhdGlvbiBwcm9ibGVtcy4gKi9cbkVOVi5yZWdpc3RlckZsYWcoJ1dFQkdMX0NIRUNLX05VTUVSSUNBTF9QUk9CTEVNUycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9KTtcbkVOVi5yZWdpc3RlckZsYWcoJ1dFQkdMX0JVRkZFUl9TVVBQT1JURUQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBFTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDI7IH0pO1xuLyoqIFdoZXRoZXIgdGhlIFdlYkdMIGJhY2tlbmQgd2lsbCBzb21ldGltZXMgZm9yd2FyZCBvcHMgdG8gdGhlIENQVS4gKi9cbkVOVi5yZWdpc3RlckZsYWcoJ1dFQkdMX0NQVV9GT1JXQVJEJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4vKiogV2hldGhlciB0aGUgV2ViR0wgYmFja2VuZCB3aWxsIGFsd2F5cyB1c2UgZjE2IHRleHR1cmVzIGZvciByZW5kZXJpbmcuICovXG5FTlYucmVnaXN0ZXJGbGFnKCdXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSk7XG4vKiogV2hldGhlciB0byB0dXJuIGFsbCBwYWNraW5nIHJlbGF0ZWQgZmxhZ3Mgb24uICovXG5FTlYucmVnaXN0ZXJGbGFnKCdXRUJHTF9QQUNLJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gRU5WLmdldEJvb2woJ0hBU19XRUJHTCcpOyB9KTtcbi8qKiBXaGV0aGVyIHdlIHdpbGwgcGFjayB0aGUgYmF0Y2hub3JtYWxpemF0aW9uIG9wLiAqL1xuRU5WLnJlZ2lzdGVyRmxhZygnV0VCR0xfUEFDS19OT1JNQUxJWkFUSU9OJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gRU5WLmdldEJvb2woJ1dFQkdMX1BBQ0snKTsgfSk7XG4vKiogV2hldGhlciB3ZSB3aWxsIHBhY2sgdGhlIGNsaXAgb3AuICovXG5FTlYucmVnaXN0ZXJGbGFnKCdXRUJHTF9QQUNLX0NMSVAnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBFTlYuZ2V0Qm9vbCgnV0VCR0xfUEFDSycpOyB9KTtcbi8qKiBXaGV0aGVyIHdlIHdpbGwgcGFjayB0aGUgZGVwdGh3aXNlIGNvbnYgb3AuICovXG4vLyBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2lzc3Vlcy8xNjc5XG5FTlYucmVnaXN0ZXJGbGFnKCdXRUJHTF9QQUNLX0RFUFRIV0lTRUNPTlYnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSk7XG4vKiogV2hldGhlciB3ZSB3aWxsIHBhY2sgYmluYXJ5IG9wcy4gKi9cbkVOVi5yZWdpc3RlckZsYWcoJ1dFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBFTlYuZ2V0Qm9vbCgnV0VCR0xfUEFDSycpOyB9KTtcbi8qKiBXaGV0aGVyIHdlIHdpbGwgcGFjayB1bmFyeSBvcHMuICovXG5FTlYucmVnaXN0ZXJGbGFnKCdXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBFTlYuZ2V0Qm9vbCgnV0VCR0xfUEFDSycpOyB9KTtcbi8qKiBXaGV0aGVyIHdlIHdpbGwgcGFjayBhcnJheSBvcHMuICovXG5FTlYucmVnaXN0ZXJGbGFnKCdXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBFTlYuZ2V0Qm9vbCgnV0VCR0xfUEFDSycpOyB9KTtcbi8qKiBXaGV0aGVyIHdlIHdpbGwgcGFjayBpbWFnZSBvcHMuICovXG5FTlYucmVnaXN0ZXJGbGFnKCdXRUJHTF9QQUNLX0lNQUdFX09QRVJBVElPTlMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBFTlYuZ2V0Qm9vbCgnV0VCR0xfUEFDSycpOyB9KTtcbi8qKiBXaGV0aGVyIHdlIHdpbGwgcGFjayByZWR1Y2Ugb3BzLiAqL1xuRU5WLnJlZ2lzdGVyRmxhZygnV0VCR0xfUEFDS19SRURVQ0UnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBFTlYuZ2V0Qm9vbCgnV0VCR0xfUEFDSycpOyB9KTtcbi8qKiBXaGV0aGVyIHBhY2tlZCBXZWJHTCBrZXJuZWxzIGxhemlseSB1bnBhY2sgdGhlaXIgb3V0cHV0cy4gKi9cbkVOVi5yZWdpc3RlckZsYWcoJ1dFQkdMX0xBWklMWV9VTlBBQ0snLCBmdW5jdGlvbiAoKSB7IHJldHVybiBFTlYuZ2V0Qm9vbCgnV0VCR0xfUEFDSycpOyB9KTtcbi8qKiBXaGV0aGVyIHdlIHdpbGwgdXNlIHRoZSBpbTJjb2wgYWxnb3JpdGhtIHRvIHNwZWVkIHVwIGNvbnZvbHV0aW9ucy4gKi9cbkVOVi5yZWdpc3RlckZsYWcoJ1dFQkdMX0NPTlZfSU0yQ09MJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gRU5WLmdldEJvb2woJ1dFQkdMX1BBQ0snKTsgfSk7XG4vKiogVGhlIG1heGltdW0gdGV4dHVyZSBkaW1lbnNpb24uICovXG5FTlYucmVnaXN0ZXJGbGFnKCdXRUJHTF9NQVhfVEVYVFVSRV9TSVpFJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0V2ViR0xNYXhUZXh0dXJlU2l6ZShFTlYuZ2V0TnVtYmVyKCdXRUJHTF9WRVJTSU9OJykpOyB9KTtcbi8qKiBUaGUgbWF4aW11bSB0ZXh0dXJlIGRpbWVuc2lvbi4gKi9cbkVOVi5yZWdpc3RlckZsYWcoJ1dFQkdMX01BWF9URVhUVVJFU19JTl9TSEFERVInLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRNYXhUZXh0dXJlc0luU2hhZGVyKEVOVi5nZXROdW1iZXIoJ1dFQkdMX1ZFUlNJT04nKSk7IH0pO1xuLyoqXG4gKiBUaGUgZGlzam9pbnRfcXVlcnlfdGltZXIgZXh0ZW5zaW9uIHZlcnNpb24uXG4gKiAwOiBkaXNhYmxlZCwgMTogRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LCAyOlxuICogRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMi5cbiAqIEluIEZpcmVmb3ggd2l0aCBXZWJHTCAyLjAsXG4gKiBFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyIGlzIG5vdCBhdmFpbGFibGUsIHNvIHdlIG11c3QgdXNlIHRoZVxuICogV2ViR0wgMS4wIGV4dGVuc2lvbi5cbiAqL1xuRU5WLnJlZ2lzdGVyRmxhZygnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdlYkdMVmVyc2lvbiA9IEVOVi5nZXROdW1iZXIoJ1dFQkdMX1ZFUlNJT04nKTtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0V2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJWZXJzaW9uKHdlYkdMVmVyc2lvbik7XG59KTtcbi8qKlxuICogV2hldGhlciB0aGUgdGltZXIgb2JqZWN0IGZyb20gdGhlIGRpc2pvaW50X3F1ZXJ5X3RpbWVyIGV4dGVuc2lvbiBnaXZlc1xuICogdGltaW5nIGluZm9ybWF0aW9uIHRoYXQgaXMgcmVsaWFibGUuXG4gKi9cbkVOVi5yZWdpc3RlckZsYWcoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIEVOVi5nZXROdW1iZXIoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OJykgPiAwICYmXG4gICAgIXRmLmRldmljZV91dGlsLmlzTW9iaWxlKCk7IH0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBkZXZpY2UgaXMgcGh5c2ljYWxseSBjYXBhYmxlIG9mIHJlbmRlcmluZyB0byBmbG9hdDMyIHRleHR1cmVzLlxuICovXG5FTlYucmVnaXN0ZXJGbGFnKCdXRUJHTF9SRU5ERVJfRkxPQVQzMl9DQVBBQkxFJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNDYXBhYmxlT2ZSZW5kZXJpbmdUb0Zsb2F0VGV4dHVyZShFTlYuZ2V0TnVtYmVyKCdXRUJHTF9WRVJTSU9OJykpOyB9KTtcbi8qKlxuICogV2hldGhlciByZW5kZXJpbmcgdG8gZmxvYXQzMiB0ZXh0dXJlcyBpcyBlbmFibGVkLiBJZiBkaXNhYmxlZCwgcmVuZGVycyB0b1xuICogZmxvYXQxNiB0ZXh0dXJlcy5cbiAqL1xuRU5WLnJlZ2lzdGVyRmxhZygnV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRCcsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRU5WLmdldEJvb2woJ1dFQkdMX0ZPUkNFX0YxNl9URVhUVVJFUycpID9cbiAgICAgICAgZmFsc2UgOlxuICAgICAgICBFTlYuZ2V0Qm9vbCgnV0VCR0xfUkVOREVSX0ZMT0FUMzJfQ0FQQUJMRScpO1xufSk7XG4vKipcbiAqIFdoZXRoZXIgZG93bmxvYWRpbmcgZmxvYXQgdGV4dHVyZXMgaXMgZW5hYmxlZCAoMTYgb3IgMzIgYml0KS4gSWYgZGlzYWJsZWQsXG4gKiB1c2VzIElFRUUgNzU0IGVuY29kaW5nIG9mIHRoZSBmbG9hdDMyIHZhbHVlcyB0byA0IHVpbnQ4IHdoZW4gZG93bmxvYWRpbmcuXG4gKi9cbkVOVi5yZWdpc3RlckZsYWcoJ1dFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRUQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpc0Rvd25sb2FkRmxvYXRUZXh0dXJlRW5hYmxlZChFTlYuZ2V0TnVtYmVyKCdXRUJHTF9WRVJTSU9OJykpOyB9KTtcbi8qKiBXaGV0aGVyIHRoZSBmZW5jZSBBUEkgaXMgYXZhaWxhYmxlLiAqL1xuRU5WLnJlZ2lzdGVyRmxhZygnV0VCR0xfRkVOQ0VfQVBJX0VOQUJMRUQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1dlYkdMRmVuY2VFbmFibGVkKEVOVi5nZXROdW1iZXIoJ1dFQkdMX1ZFUlNJT04nKSk7IH0pO1xuLyoqXG4gKiBUZW5zb3JzIHdpdGggc2l6ZSA8PSB0aGFuIHRoaXMgd2lsbCBiZSB1cGxvYWRlZCBhcyB1bmlmb3Jtcywgbm90IHRleHR1cmVzLlxuICovXG5FTlYucmVnaXN0ZXJGbGFnKCdXRUJHTF9TSVpFX1VQTE9BRF9VTklGT1JNJywgZnVuY3Rpb24gKCkge1xuICAgIC8vIFVzZSB1bmlmb3JtIHVwbG9hZHMgb25seSB3aGVuIDMyYml0IGZsb2F0cyBhcmUgc3VwcG9ydGVkLiBJblxuICAgIC8vIDE2Yml0XG4gICAgLy8gZW52aXJvbm1lbnRzIHRoZXJlIGFyZSBwcm9ibGVtcyB3aXRoIGNvbXBhcmluZyBhIDE2Yml0IHRleHR1cmUgdmFsdWVcbiAgICAvLyB3aXRoIGEgMzJiaXQgdW5pZm9ybSB2YWx1ZS5cbiAgICB2YXIgdXNlVW5pZm9ybXMgPSBFTlYuZ2V0Qm9vbCgnV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRCcpO1xuICAgIHJldHVybiB1c2VVbmlmb3JtcyA/IDQgOiAwO1xufSk7XG4vKipcbiAqIElmIHRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgYWxsb2NhdGVkIG9uIHRoZSBHUFUgaXMgZ3JlYXRlciB0aGFuIHRoaXNcbiAqIG51bWJlciwgd2Ugd2lsbCBhZ2dyZXNzaXZlbHkgZGVsZXRlIHRleHR1cmVzIHVwb24gZGlzcG9zYWwgd2l0aFxuICogZ2wuZGVsZXRlTWF0cml4VGV4dHVyZSwgcmF0aGVyIHRoYW4gbWFraW5nIHRoZW0gYXZhaWxhYmxlIGZvciByZXVzZS5cbiAqXG4gKiBEZWZhdWx0IHZhbHVlIC0xIGluZGljYXRlcyB0aGF0IHdlIHdpbGwgbmV2ZXIgYWdncmVzc2l2ZWx5IGRlbGV0ZSB0ZXh0dXJlcy5cbiAqL1xuRU5WLnJlZ2lzdGVyRmxhZygnV0VCR0xfREVMRVRFX1RFWFRVUkVfVEhSRVNIT0xEJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAtMTtcbn0sIGZ1bmN0aW9uICh0aHJlc2hvbGQpIHtcbiAgICBpZiAodGhyZXNob2xkIDwgMCAmJiB0aHJlc2hvbGQgIT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldFQkdMX0RFTEVURV9URVhUVVJFX1RIUkVTSE9MRCBtdXN0IGJlIC0xIChpbmRpY2F0aW5nIG5ldmVyIFwiICtcbiAgICAgICAgICAgIChcImRlbGV0ZSkgb3IgYXQgbGVhc3QgMCwgYnV0IGdvdCBcIiArIHRocmVzaG9sZCArIFwiLlwiKSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGdldEdsc2xEaWZmZXJlbmNlcygpIHtcbiAgICB2YXIgdmVyc2lvbjtcbiAgICB2YXIgYXR0cmlidXRlO1xuICAgIHZhciB2YXJ5aW5nVnM7XG4gICAgdmFyIHZhcnlpbmdGcztcbiAgICB2YXIgdGV4dHVyZTJEO1xuICAgIHZhciBvdXRwdXQ7XG4gICAgdmFyIGRlZmluZU91dHB1dDtcbiAgICB2YXIgZGVmaW5lU3BlY2lhbE5hTjtcbiAgICB2YXIgZGVmaW5lU3BlY2lhbEluZjtcbiAgICB2YXIgZGVmaW5lUm91bmQ7XG4gICAgaWYgKHRmLmVudigpLmdldE51bWJlcignV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgIHZlcnNpb24gPSAnI3ZlcnNpb24gMzAwIGVzJztcbiAgICAgICAgYXR0cmlidXRlID0gJ2luJztcbiAgICAgICAgdmFyeWluZ1ZzID0gJ291dCc7XG4gICAgICAgIHZhcnlpbmdGcyA9ICdpbic7XG4gICAgICAgIHRleHR1cmUyRCA9ICd0ZXh0dXJlJztcbiAgICAgICAgb3V0cHV0ID0gJ291dHB1dENvbG9yJztcbiAgICAgICAgZGVmaW5lT3V0cHV0ID0gJ291dCB2ZWM0IG91dHB1dENvbG9yOyc7XG4gICAgICAgIC8vIFVzZSBjdXN0b20gaXNuYW4gZGVmaW5pdGlvbiB0byB3b3JrIGFjcm9zcyBkaWZmZXJlbmNlcyBiZXR3ZWVuXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9ucyBvbiB2YXJpb3VzIHBsYXRmb3Jtcy4gV2hpbGUgdGhpcyBzaG91bGQgaGFwcGVuIGluIEFOR0xFXG4gICAgICAgIC8vIHdlIHN0aWxsIHNlZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGFuZHJvaWQgYW5kIHdpbmRvd3MgKG9uIGNocm9tZSkgd2hlblxuICAgICAgICAvLyB1c2luZyBpc25hbiBkaXJlY3RseS5cbiAgICAgICAgZGVmaW5lU3BlY2lhbE5hTiA9IFwiXFxuICAgICAgYm9vbCBpc25hbl9jdXN0b20oZmxvYXQgdmFsKSB7XFxuICAgICAgICByZXR1cm4gKHZhbCA+IDAuMCB8fCB2YWwgPCAwLjApID8gZmFsc2UgOiB2YWwgIT0gMC4wO1xcbiAgICAgIH1cXG5cXG4gICAgICBidmVjNCBpc25hbl9jdXN0b20odmVjNCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBidmVjNChpc25hbl9jdXN0b20odmFsLngpLFxcbiAgICAgICAgICBpc25hbl9jdXN0b20odmFsLnkpLCBpc25hbl9jdXN0b20odmFsLnopLCBpc25hbl9jdXN0b20odmFsLncpKTtcXG4gICAgICB9XFxuXFxuICAgICAgI2RlZmluZSBpc25hbih2YWx1ZSkgaXNuYW5fY3VzdG9tKHZhbHVlKVxcbiAgICBcIjtcbiAgICAgICAgLy8gSW4gd2ViZ2wgMiB3ZSBkbyBub3QgbmVlZCB0byBzcGVjaWZ5IGEgY3VzdG9tIGlzaW5mIHNvIHRoZXJlIGlzIG5vXG4gICAgICAgIC8vIG5lZWQgZm9yIGEgc3BlY2lhbCBJTkZJTklUWSBjb25zdGFudC5cbiAgICAgICAgZGVmaW5lU3BlY2lhbEluZiA9IFwiXCI7XG4gICAgICAgIGRlZmluZVJvdW5kID0gXCJcXG4gICAgICAjZGVmaW5lIHJvdW5kKHZhbHVlKSBuZXdSb3VuZCh2YWx1ZSlcXG4gICAgICBpbnQgbmV3Um91bmQoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBpbnQoZmxvb3IodmFsdWUgKyAwLjUpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaXZlYzQgbmV3Um91bmQodmVjNCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWM0KGZsb29yKHZhbHVlICsgdmVjNCgwLjUpKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSAnJztcbiAgICAgICAgYXR0cmlidXRlID0gJ2F0dHJpYnV0ZSc7XG4gICAgICAgIHZhcnlpbmdWcyA9ICd2YXJ5aW5nJztcbiAgICAgICAgdmFyeWluZ0ZzID0gJ3ZhcnlpbmcnO1xuICAgICAgICB0ZXh0dXJlMkQgPSAndGV4dHVyZTJEJztcbiAgICAgICAgb3V0cHV0ID0gJ2dsX0ZyYWdDb2xvcic7XG4gICAgICAgIGRlZmluZU91dHB1dCA9ICcnO1xuICAgICAgICAvLyBXZWJHTDEgaGFzIG5vIGJ1aWx0IGluIGlzbmFuIHNvIHdlIGRlZmluZSBvbmUgaGVyZS5cbiAgICAgICAgZGVmaW5lU3BlY2lhbE5hTiA9IFwiXFxuICAgICAgI2RlZmluZSBpc25hbih2YWx1ZSkgaXNuYW5fY3VzdG9tKHZhbHVlKVxcbiAgICAgIGJvb2wgaXNuYW5fY3VzdG9tKGZsb2F0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuICh2YWwgPiAwLiB8fCB2YWwgPCAxLiB8fCB2YWwgPT0gMC4pID8gZmFsc2UgOiB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBidmVjNCBpc25hbl9jdXN0b20odmVjNCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBidmVjNChpc25hbih2YWwueCksIGlzbmFuKHZhbC55KSwgaXNuYW4odmFsLnopLCBpc25hbih2YWwudykpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgICAgIGRlZmluZVNwZWNpYWxJbmYgPSBcIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgSU5GSU5JVFk7XFxuXFxuICAgICAgYm9vbCBpc2luZihmbG9hdCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBhYnModmFsKSA9PSBJTkZJTklUWTtcXG4gICAgICB9XFxuICAgICAgYnZlYzQgaXNpbmYodmVjNCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBlcXVhbChhYnModmFsKSwgdmVjNChJTkZJTklUWSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgICAgIGRlZmluZVJvdW5kID0gXCJcXG4gICAgICBpbnQgcm91bmQoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBpbnQoZmxvb3IodmFsdWUgKyAwLjUpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaXZlYzQgcm91bmQodmVjNCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWM0KGZsb29yKHZhbHVlICsgdmVjNCgwLjUpKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gICAgICAgIHZhcnlpbmdWczogdmFyeWluZ1ZzLFxuICAgICAgICB2YXJ5aW5nRnM6IHZhcnlpbmdGcyxcbiAgICAgICAgdGV4dHVyZTJEOiB0ZXh0dXJlMkQsXG4gICAgICAgIG91dHB1dDogb3V0cHV0LFxuICAgICAgICBkZWZpbmVPdXRwdXQ6IGRlZmluZU91dHB1dCxcbiAgICAgICAgZGVmaW5lU3BlY2lhbE5hTjogZGVmaW5lU3BlY2lhbE5hTixcbiAgICAgICAgZGVmaW5lU3BlY2lhbEluZjogZGVmaW5lU3BlY2lhbEluZixcbiAgICAgICAgZGVmaW5lUm91bmQ6IGRlZmluZVJvdW5kXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBQcm9kdWNlcyBHTFNMIGNvZGUgdGhhdCBkZXJpdmVzIGxvZ2ljYWwgY29vcmRpbmF0ZXMgZnJvbSBhIGZsYXRcbiAqIGluZGV4LiBUaGUgY29kZSBwZXJmb3JtcyBpbnRlZ2VyIGRpdmlzaW9uIHdpdGggZWFjaCBzdHJpZGUgYW5kIGRlY3JlbWVudHNcbiAqIHRoZSBpbmRleCB1bnRpbCB0aGUgaW5kZXggZXF1YWxzIHRoZSBmaW5hbCBkaW1lbnNpb24gY29vcmRpbmF0ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9naWNhbENvb3JkaW5hdGVzRnJvbUZsYXRJbmRleChjb29yZHMsIHNoYXBlLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gJ2luZGV4JzsgfVxuICAgIHZhciBzdHJpZGVzID0gdGYudXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZSk7XG4gICAgcmV0dXJuIHN0cmlkZXNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoc3RyaWRlLCBpKSB7XG4gICAgICAgIHZhciBsaW5lMSA9IFwiaW50IFwiICsgY29vcmRzW2ldICsgXCIgPSBcIiArIGluZGV4ICsgXCIgLyBcIiArIHN0cmlkZTtcbiAgICAgICAgdmFyIGxpbmUyID0gaSA9PT0gc3RyaWRlcy5sZW5ndGggLSAxID9cbiAgICAgICAgICAgIFwiaW50IFwiICsgY29vcmRzW2kgKyAxXSArIFwiID0gXCIgKyBpbmRleCArIFwiIC0gXCIgKyBjb29yZHNbaV0gKyBcIiAqIFwiICsgc3RyaWRlIDpcbiAgICAgICAgICAgIFwiaW5kZXggLT0gXCIgKyBjb29yZHNbaV0gKyBcIiAqIFwiICsgc3RyaWRlO1xuICAgICAgICByZXR1cm4gbGluZTEgKyBcIjsgXCIgKyBsaW5lMiArIFwiO1wiO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgR0xTTCB0aGF0IGNvbXB1dGVzIHRoZSBmbGF0IGluZGV4IGZyb20gM0QgY29vcmRpbmF0ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEZsYXRJbmRleEZyb20zRChzaGFwZSkge1xuICAgIHZhciBzdHJpZGVzID0gdGYudXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZSkubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnRvU3RyaW5nKCk7IH0pO1xuICAgIHJldHVybiBcIlxcbiAgaW50IGdldEZsYXRJbmRleChpdmVjMyBjb29yZHMpIHtcXG4gICAgcmV0dXJuIGNvb3Jkcy54ICogXCIgKyBzdHJpZGVzWzBdICsgXCIgKyBjb29yZHMueSAqIFwiICsgc3RyaWRlc1sxXSArIFwiICsgY29vcmRzLno7XFxuICB9XFxuXCI7XG59XG52YXIgRU5DT0RFX0ZMT0FUX1NOSVBQRVQgPSBcIlxcbiAgY29uc3QgZmxvYXQgRkxPQVRfTUFYID0gMS43MDE0MTE4NGUzODtcXG4gIGNvbnN0IGZsb2F0IEZMT0FUX01JTiA9IDEuMTc1NDk0MzVlLTM4O1xcblxcbiAgbG93cCB2ZWM0IGVuY29kZV9mbG9hdChoaWdocCBmbG9hdCB2KSB7XFxuICAgIGlmIChpc25hbih2KSkge1xcbiAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxuICAgIH1cXG5cXG4gICAgaGlnaHAgZmxvYXQgYXYgPSBhYnModik7XFxuXFxuICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XFxuICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgfSBlbHNlIGlmKHYgPiBGTE9BVF9NQVgpIHtcXG4gICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xcbiAgICB9IGVsc2UgaWYodiA8IC1GTE9BVF9NQVgpIHtcXG4gICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgIDEyOC4wLCAyNTUuMCkgLyAyNTUuMDtcXG4gICAgfVxcblxcbiAgICBoaWdocCB2ZWM0IGMgPSB2ZWM0KDAsMCwwLDApO1xcblxcbiAgICBoaWdocCBmbG9hdCBlID0gZmxvb3IobG9nMihhdikpO1xcbiAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xcblxcbiAgICBjWzJdID0gZmxvb3IoMTI4LjAgKiBtKTtcXG4gICAgbSAtPSBjWzJdIC8gMTI4LjA7XFxuICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XFxuICAgIG0gLT0gY1sxXSAvIDMyNzY4LjA7XFxuICAgIGNbMF0gPSBmbG9vcig4Mzg4NjA4LjAgKiBtKTtcXG5cXG4gICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XFxuICAgIGNbM10gPSBmbG9vcihlYmlhcyAvIDIuMCk7XFxuICAgIGViaWFzIC09IGNbM10gKiAyLjA7XFxuICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XFxuXFxuICAgIGNbM10gKz0gMTI4LjAgKiBzdGVwKDAuMCwgLXYpO1xcblxcbiAgICByZXR1cm4gYyAvIDI1NS4wO1xcbiAgfVxcblwiO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRGVjb2RlTWF0cml4UHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWNvZGVNYXRyaXhQcm9ncmFtKG91dHB1dFNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLnBhY2tlZElucHV0cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhY2tlZE91dHB1dCA9IHRydWU7XG4gICAgICAgIHRoaXMub3V0UGFja2luZ1NjaGVtZSA9IFBhY2tpbmdTY2hlbWUuREVOU0U7XG4gICAgICAgIHZhciB0ZXhTaGFwZSA9IGdldERlbnNlVGV4U2hhcGUob3V0cHV0U2hhcGUpO1xuICAgICAgICB2YXIgZ2xzbCA9IGdldEdsc2xEaWZmZXJlbmNlcygpO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGl2ZWMzIG91dENvb3Jkc0Zyb21GbGF0SW5kZXgoaW50IGluZGV4KSB7XFxuICAgICAgICBcIiArIGdldExvZ2ljYWxDb29yZGluYXRlc0Zyb21GbGF0SW5kZXgoWydyJywgJ2MnLCAnZCddLCBvdXRwdXRTaGFwZSkgKyBcIlxcbiAgICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gNCAqIChyZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueSk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcblxcbiAgICAgICAgZm9yIChpbnQgaT0wOyBpPDQ7IGkrKykge1xcbiAgICAgICAgICBpbnQgZmxhdEluZGV4ID0gaW5kZXggKyBpO1xcbiAgICAgICAgICBpdmVjMyByYyA9IG91dENvb3Jkc0Zyb21GbGF0SW5kZXgoZmxhdEluZGV4KTtcXG4gICAgICAgICAgcmVzdWx0W2ldID0gZ2V0QShyYy54LCByYy55LCByYy56KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiICsgZ2xzbC5vdXRwdXQgKyBcIiA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gRGVjb2RlTWF0cml4UHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBEZWNvZGVNYXRyaXhQYWNrZWRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlY29kZU1hdHJpeFBhY2tlZFByb2dyYW0ob3V0cHV0U2hhcGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMucGFja2VkSW5wdXRzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWNrZWRPdXRwdXQgPSB0cnVlO1xuICAgICAgICB0aGlzLm91dFBhY2tpbmdTY2hlbWUgPSBQYWNraW5nU2NoZW1lLkRFTlNFO1xuICAgICAgICB2YXIgdGV4U2hhcGUgPSBnZXREZW5zZVRleFNoYXBlKG91dHB1dFNoYXBlKTtcbiAgICAgICAgdmFyIGdsc2wgPSBnZXRHbHNsRGlmZmVyZW5jZXMoKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBpdmVjMyBvdXRDb29yZHNGcm9tRmxhdEluZGV4KGludCBpbmRleCkge1xcbiAgICAgICAgXCIgKyBnZXRMb2dpY2FsQ29vcmRpbmF0ZXNGcm9tRmxhdEluZGV4KFsncicsICdjJywgJ2QnXSwgb3V0cHV0U2hhcGUpICsgXCJcXG4gICAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IDQgKiAocmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnkpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG5cXG4gICAgICAgIGZvciAoaW50IGk9MDsgaTw0OyBpKyspIHtcXG4gICAgICAgICAgaW50IGZsYXRJbmRleCA9IGluZGV4ICsgaTtcXG4gICAgICAgICAgaXZlYzMgcmMgPSBvdXRDb29yZHNGcm9tRmxhdEluZGV4KGZsYXRJbmRleCk7XFxuICAgICAgICAgIHJlc3VsdFtpXSA9IGdldENoYW5uZWwoZ2V0QShyYy54LCByYy55LCByYy56KSwgdmVjMihyYy55LCByYy56KSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIiArIGdsc2wub3V0cHV0ICsgXCIgPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIERlY29kZU1hdHJpeFBhY2tlZFByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRW5jb2RlRmxvYXRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVuY29kZUZsb2F0UHJvZ3JhbShvdXRwdXRTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5vdXRUZXhVc2FnZSA9IFRleHR1cmVVc2FnZS5ET1dOTE9BRDtcbiAgICAgICAgdmFyIGdsc2wgPSBnZXRHbHNsRGlmZmVyZW5jZXMoKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBcIiArIEVOQ09ERV9GTE9BVF9TTklQUEVUICsgXCJcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBcIiArIGdsc2wub3V0cHV0ICsgXCIgPSBlbmNvZGVfZmxvYXQoeCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEVuY29kZUZsb2F0UHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBFbmNvZGVGbG9hdFBhY2tlZFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW5jb2RlRmxvYXRQYWNrZWRQcm9ncmFtKG91dHB1dFNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLnBhY2tlZElucHV0cyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFja2VkT3V0cHV0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3V0VGV4VXNhZ2UgPSBUZXh0dXJlVXNhZ2UuRE9XTkxPQUQ7XG4gICAgICAgIHZhciBnbHNsID0gZ2V0R2xzbERpZmZlcmVuY2VzKCk7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgXCIgKyBFTkNPREVfRkxPQVRfU05JUFBFVCArIFwiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0Q2hhbm5lbChnZXRBQXRPdXRDb29yZHMoKSwgdmVjMihjb29yZHMueSwgY29vcmRzLnopKTtcXG4gICAgICAgIFwiICsgZ2xzbC5vdXRwdXQgKyBcIiA9IGVuY29kZV9mbG9hdCh4KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gRW5jb2RlRmxvYXRQYWNrZWRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIEVuY29kZU1hdHJpeFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW5jb2RlTWF0cml4UHJvZ3JhbShvdXRwdXRTaGFwZSwgdGV4U2hhcGUsIGlucHV0SXNVbnNpZ25lZEJ5dGUpIHtcbiAgICAgICAgaWYgKGlucHV0SXNVbnNpZ25lZEJ5dGUgPT09IHZvaWQgMCkgeyBpbnB1dElzVW5zaWduZWRCeXRlID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHZhciBnbHNsID0gZ2V0R2xzbERpZmZlcmVuY2VzKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXhTaGFwZVswXSwgd2lkdGggPSB0ZXhTaGFwZVsxXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB2YXIgb3V0cHV0ID0gXCJyZXN1bHRcIjtcbiAgICAgICAgaWYgKGlucHV0SXNVbnNpZ25lZEJ5dGUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IFwiZmxvb3IocmVzdWx0ICogMjU1LiArIDAuNSlcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBcIiArIGdldEZsYXRJbmRleEZyb20zRChvdXRwdXRTaGFwZSkgKyBcIlxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgaW50IGZsYXRJbmRleCA9IGdldEZsYXRJbmRleChjb29yZHMpO1xcbiAgICAgICAgaW50IG9mZnNldCA9IGltb2QoZmxhdEluZGV4LCA0KTtcXG5cXG4gICAgICAgIGZsYXRJbmRleCA9IGlkaXYoZmxhdEluZGV4LCA0LCAxLik7XFxuXFxuICAgICAgICBpbnQgciA9IGZsYXRJbmRleCAvIFwiICsgd2lkdGggKyBcIjtcXG4gICAgICAgIGludCBjID0gaW1vZChmbGF0SW5kZXgsIFwiICsgd2lkdGggKyBcIik7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoYywgcikgKyBoYWxmQ1IpIC8gdmVjMihcIiArIHdpZHRoICsgXCIuMCwgXCIgKyBoZWlnaHQgKyBcIi4wKTtcXG4gICAgICAgIHZlYzQgdmFsdWVzID0gXCIgKyBnbHNsLnRleHR1cmUyRCArIFwiKEEsIHV2KTtcXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdDtcXG5cXG4gICAgICAgIGlmKG9mZnNldCA9PSAwKSB7XFxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlc1swXTtcXG4gICAgICAgIH0gZWxzZSBpZihvZmZzZXQgPT0gMSkge1xcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZXNbMV07XFxuICAgICAgICB9IGVsc2UgaWYob2Zmc2V0ID09IDIpIHtcXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzJdO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzNdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIgKyBnbHNsLm91dHB1dCArIFwiID0gdmVjNChcIiArIG91dHB1dCArIFwiLCAwLiwgMC4sIDAuKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gRW5jb2RlTWF0cml4UHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qXG5UaGlzIGlzIGhvdyB0aGUgc2hhZGVyIGVuY29kZXMgYSB0ZW5zb3Igd2l0aCBzaGFwZSA9IFsyLCAzLCA1XVxuKGluZGljZXMgYXJlIFtiYXRjaCwgcm93LCBjb2xdKS5cblxuMDAwfDAwMSAgIDAwMnwwMDMgICAwMDR8eHh4ICAgMDIwfDAyMSAgIDAyMnwwMjMgICAwMjR8eHh4XG4tLS0tLS0tICAgLS0tLS0tLSAgIC0tLS0tLS0gICAtLS0tLS0tICAgLS0tLS0tLSAgIC0tLS0tLS1cbjAxMHwwMTEgICAwMTJ8MDEzICAgMDE0fHh4eCAgIHh4eHx4eHggICB4eHh8eHh4ICAgeHh4fHh4eFxuXG4xMDB8MTAxICAgMTAyfDEwMyAgIDEwNHx4eHggICAxMjB8MTIxICAgMTIyfDEyMyAgIDEyNHx4eHhcbi0tLS0tLS0gICAtLS0tLS0tICAgLS0tLS0tLSAgIC0tLS0tLS0gICAtLS0tLS0tICAgLS0tLS0tLVxuMTEwfDExMSAgIDExMnwxMTMgICAxMTR8eHh4ICAgeHh4fHh4eCAgIHh4eHx4eHggICB4eHh8eHh4XG5cblNpbmdsZSB0ZXhlbHMgY29udGFpbiBvbmx5IHZhbHVlcyBmcm9tIHRoZSBzYW1lIGJhdGNoLCBhbmQgZnJvbSBhZGphY2VudCByb3dzXG5hbmQgY29sdW1ucy5cbiAqL1xudmFyIEVuY29kZU1hdHJpeFBhY2tlZFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW5jb2RlTWF0cml4UGFja2VkUHJvZ3JhbShvdXRwdXRTaGFwZSwgdGV4U2hhcGUsIGlucHV0SXNVbnNpZ25lZEJ5dGUpIHtcbiAgICAgICAgaWYgKGlucHV0SXNVbnNpZ25lZEJ5dGUgPT09IHZvaWQgMCkgeyBpbnB1dElzVW5zaWduZWRCeXRlID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMucGFja2VkSW5wdXRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFja2VkT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGdsc2wgPSBnZXRHbHNsRGlmZmVyZW5jZXMoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRleFNoYXBlWzBdLCB3aWR0aCA9IHRleFNoYXBlWzFdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHZhciBtYWluTG9vcCA9ICcnO1xuICAgICAgICB2YXIgb3V0cHV0ID0gJ3Jlc3VsdCc7XG4gICAgICAgIGlmIChpbnB1dElzVW5zaWduZWRCeXRlKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSAnZmxvb3IocmVzdWx0ICogMjU1LiArIDAuNSknO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8PSAxOyByb3crKykge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDw9IDE7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSByb3cgKiAyICsgY29sO1xuICAgICAgICAgICAgICAgIG1haW5Mb29wICs9IFwiXFxuICAgICAgICAgIGxvY2FsQ29vcmRzID0gY29vcmRzO1xcbiAgICAgICAgICBpZihsb2NhbENvb3Jkc1syXSArIFwiICsgY29sICsgXCIgPCBcIiArIG91dHB1dFNoYXBlWzJdICsgXCIpIHtcXG4gICAgICAgICAgICBsb2NhbENvb3Jkc1syXSArPSBcIiArIGNvbCArIFwiO1xcbiAgICAgICAgICAgIGlmKGxvY2FsQ29vcmRzWzFdICsgXCIgKyByb3cgKyBcIiA8IFwiICsgb3V0cHV0U2hhcGVbMV0gKyBcIikge1xcbiAgICAgICAgICAgICAgbG9jYWxDb29yZHNbMV0gKz0gXCIgKyByb3cgKyBcIjtcXG5cXG4gICAgICAgICAgICAgIGZsYXRJbmRleCA9IGdldEZsYXRJbmRleChsb2NhbENvb3Jkcyk7XFxuICAgICAgICAgICAgICBvZmZzZXQgPSBpbW9kKGZsYXRJbmRleCwgNCk7XFxuXFxuICAgICAgICAgICAgICBmbGF0SW5kZXggPSBpZGl2KGZsYXRJbmRleCwgNCwgMS4pO1xcblxcbiAgICAgICAgICAgICAgciA9IGZsYXRJbmRleCAvIFwiICsgd2lkdGggKyBcIjtcXG4gICAgICAgICAgICAgIGMgPSBpbW9kKGZsYXRJbmRleCwgXCIgKyB3aWR0aCArIFwiKTtcXG4gICAgICAgICAgICAgIHV2ID0gKHZlYzIoYywgcikgKyBoYWxmQ1IpIC8gdmVjMihcIiArIHdpZHRoICsgXCIuMCwgXCIgKyBoZWlnaHQgKyBcIi4wKTtcXG4gICAgICAgICAgICAgIHZhbHVlcyA9IFwiICsgZ2xzbC50ZXh0dXJlMkQgKyBcIihBLCB1dik7XFxuXFxuICAgICAgICAgICAgICBpZihvZmZzZXQgPT0gMCkge1xcbiAgICAgICAgICAgICAgICByZXN1bHRbXCIgKyBjaGFubmVsICsgXCJdID0gdmFsdWVzWzBdO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKG9mZnNldCA9PSAxKSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdFtcIiArIGNoYW5uZWwgKyBcIl0gPSB2YWx1ZXNbMV07XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYob2Zmc2V0ID09IDIpIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0W1wiICsgY2hhbm5lbCArIFwiXSA9IHZhbHVlc1syXTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdFtcIiArIGNoYW5uZWwgKyBcIl0gPSB2YWx1ZXNbM107XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBcIiArIGdldEZsYXRJbmRleEZyb20zRChvdXRwdXRTaGFwZSkgKyBcIlxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgIGludCBmbGF0SW5kZXgsIHIsIGMsIG9mZnNldDtcXG4gICAgICAgIGl2ZWMzIGxvY2FsQ29vcmRzO1xcbiAgICAgICAgdmVjMiB1djtcXG4gICAgICAgIHZlYzQgdmFsdWVzO1xcblxcbiAgICAgICAgXCIgKyBtYWluTG9vcCArIFwiXFxuXFxuICAgICAgICBcIiArIGdsc2wub3V0cHV0ICsgXCIgPSBcIiArIG91dHB1dCArIFwiO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBFbmNvZGVNYXRyaXhQYWNrZWRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVmVydGV4U2hhZGVyJDEoZ2wpIHtcbiAgICB2YXIgZ2xzbCA9IGdldEdsc2xEaWZmZXJlbmNlcygpO1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBnbHNsLnZlcnNpb24gKyBcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIFwiICsgZ2xzbC5hdHRyaWJ1dGUgKyBcIiB2ZWMzIGNsaXBTcGFjZVBvcztcXG4gICAgXCIgKyBnbHNsLmF0dHJpYnV0ZSArIFwiIHZlYzIgdXY7XFxuICAgIFwiICsgZ2xzbC52YXJ5aW5nVnMgKyBcIiB2ZWMyIHJlc3VsdFVWO1xcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBTcGFjZVBvcywgMSk7XFxuICAgICAgcmVzdWx0VVYgPSB1djtcXG4gICAgfVwiO1xuICAgIHJldHVybiBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIHZlcnRleFNoYWRlclNvdXJjZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhCdWZmZXIoZ2wpIHtcbiAgICAvLyBbeCB5IHogdSB2XSAqIFt1cHBlci1sZWZ0LCBsb3dlci1sZWZ0LCB1cHBlci1yaWdodCwgbG93ZXItcmlnaHRdXG4gICAgdmFyIHZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbLTEsIDEsIDAsIDAsIDEsIC0xLCAtMSwgMCwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMSwgLTEsIDAsIDEsIDBdKTtcbiAgICByZXR1cm4gY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyKGdsLCB2ZXJ0ZXhBcnJheSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmRleEJ1ZmZlcihnbCkge1xuICAgIC8vIE9wZW5HTCAoYW5kIFdlYkdMKSBoYXZlIFwiQ0NXID09IGZyb250XCIgd2luZGluZ1xuICAgIHZhciB0cmlhbmdsZVZlcnRleEluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDIsIDEsIDNdKTtcbiAgICByZXR1cm4gY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIoZ2wsIHRyaWFuZ2xlVmVydGV4SW5kaWNlcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCwgdGV4dHVyZUZvcm1hdCwgdGV4dHVyZVR5cGUpIHtcbiAgICB2YWxpZGF0ZVRleHR1cmVTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciB0ZXh0dXJlID0gY3JlYXRlVGV4dHVyZShnbCk7XG4gICAgdmFyIHRleDJkID0gZ2wuVEVYVFVSRV8yRDtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKHRleDJkLCB0ZXh0dXJlKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhJbWFnZTJEKHRleDJkLCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgdGV4dHVyZUZvcm1hdCwgdGV4dHVyZVR5cGUsIG51bGwpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpOyB9KTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbn1cbmZ1bmN0aW9uIGdldEludGVybmFsRm9ybWF0Rm9yRmxvYXQzMk1hdHJpeFRleHR1cmUodGV4dHVyZUNvbmZpZykge1xuICAgIHJldHVybiB0ZXh0dXJlQ29uZmlnLmludGVybmFsRm9ybWF0RmxvYXQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucywgdGV4dHVyZUNvbmZpZykge1xuICAgIHZhciBfYSA9IGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBnZXRJbnRlcm5hbEZvcm1hdEZvckZsb2F0MzJNYXRyaXhUZXh0dXJlKHRleHR1cmVDb25maWcpLCB0ZXh0dXJlQ29uZmlnLnRleHR1cmVGb3JtYXRGbG9hdCwgZ2wuRkxPQVQpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxGb3JtYXRGb3JGbG9hdDE2TWF0cml4VGV4dHVyZSh0ZXh0dXJlQ29uZmlnKSB7XG4gICAgcmV0dXJuIHRleHR1cmVDb25maWcuaW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucywgdGV4dHVyZUNvbmZpZykge1xuICAgIHZhciBfYSA9IGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBnZXRJbnRlcm5hbEZvcm1hdEZvckZsb2F0MTZNYXRyaXhUZXh0dXJlKHRleHR1cmVDb25maWcpLCB0ZXh0dXJlQ29uZmlnLnRleHR1cmVGb3JtYXRGbG9hdCwgdGV4dHVyZUNvbmZpZy50ZXh0dXJlVHlwZUhhbGZGbG9hdCk7XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbEZvcm1hdEZvclVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlKHRleHR1cmVDb25maWcpIHtcbiAgICByZXR1cm4gdGV4dHVyZUNvbmZpZy5kb3dubG9hZFRleHR1cmVGb3JtYXQ7XG59XG5mdW5jdGlvbiBjcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucywgdGV4dHVyZUNvbmZpZykge1xuICAgIHZhciBfYSA9IGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBnZXRJbnRlcm5hbEZvcm1hdEZvclVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlKHRleHR1cmVDb25maWcpLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFKTtcbn1cbmZ1bmN0aW9uIGdldEludGVybmFsRm9ybWF0Rm9yUGFja2VkTWF0cml4VGV4dHVyZSh0ZXh0dXJlQ29uZmlnKSB7XG4gICAgcmV0dXJuIHRleHR1cmVDb25maWcuaW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMsIHRleHR1cmVDb25maWcpIHtcbiAgICB2YXIgX2EgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgcmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIGdldEludGVybmFsRm9ybWF0Rm9yUGFja2VkTWF0cml4VGV4dHVyZSh0ZXh0dXJlQ29uZmlnKSwgZ2wuUkdCQSwgZ2wuRkxPQVQpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxGb3JtYXRGb3JGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZSh0ZXh0dXJlQ29uZmlnKSB7XG4gICAgcmV0dXJuIHRleHR1cmVDb25maWcuaW50ZXJuYWxGb3JtYXRQYWNrZWRIYWxmRmxvYXQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucywgdGV4dHVyZUNvbmZpZykge1xuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICByZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgZ2V0SW50ZXJuYWxGb3JtYXRGb3JGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZSh0ZXh0dXJlQ29uZmlnKSwgZ2wuUkdCQSwgdGV4dHVyZUNvbmZpZy50ZXh0dXJlVHlwZUhhbGZGbG9hdCk7XG59XG5mdW5jdGlvbiBiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMoZ2wsIHByb2dyYW0sIHZlcnRleEJ1ZmZlcikge1xuICAgIHZhciBwb3NPZmZzZXQgPSAwOyAvLyB4IGlzIHRoZSBmaXJzdCBidWZmZXIgZWxlbWVudFxuICAgIHZhciB1dk9mZnNldCA9IDMgKiA0OyAvLyB1diBjb21lcyBhZnRlciBbeCB5IHpdXG4gICAgdmFyIHN0cmlkZSA9ICgzICogNCkgKyAoMiAqIDQpOyAvLyB4eXogKyB1diwgZWFjaCBlbnRyeSBpcyA0LWJ5dGUgZmxvYXQuXG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyKTsgfSk7XG4gICAgdmFyIHN1Y2Nlc3MgPSBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKGdsLCBwcm9ncmFtLCAnY2xpcFNwYWNlUG9zJywgdmVydGV4QnVmZmVyLCAzLCBzdHJpZGUsIHBvc09mZnNldCk7XG4gICAgcmV0dXJuIHN1Y2Nlc3MgJiZcbiAgICAgICAgYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgJ3V2JywgdmVydGV4QnVmZmVyLCAyLCBzdHJpZGUsIHV2T2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIHVwbG9hZERlbnNlTWF0cml4VG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBkYXRhLCB0ZXh0dXJlQ29uZmlnKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTsgfSk7XG4gICAgdmFyIGRhdGFGb3JVcGxvYWQsIHRleGVsRGF0YVR5cGUsIGludGVybmFsRm9ybWF0O1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBkYXRhRm9yVXBsb2FkID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgdGV4ZWxEYXRhVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgICAgIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGFGb3JVcGxvYWQgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgIHRleGVsRGF0YVR5cGUgPSBnbC5GTE9BVDtcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSB0ZXh0dXJlQ29uZmlnLmludGVybmFsRm9ybWF0UGFja2VkRmxvYXQ7XG4gICAgfVxuICAgIGRhdGFGb3JVcGxvYWQuc2V0KGRhdGEpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgdGV4ZWxEYXRhVHlwZSwgZGF0YUZvclVwbG9hZCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZnVuY3Rpb24gdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCBwaXhlbHMpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbiAgICBpZiAocGl4ZWxzLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBwaXhlbHMud2lkdGgsIHBpeGVscy5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscy5kYXRhKTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTsgfSk7XG4gICAgfVxuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyRnJvbU91dHB1dFRleHR1cmUoZ2wyLCByb3dzLCBjb2x1bW5zLCB0ZXh0dXJlQ29uZmlnKSB7XG4gICAgLy8gQ3JlYXRlIGFuZCBiaW5kIHRoZSBidWZmZXIuXG4gICAgdmFyIGJ1ZmZlciA9IGdsMi5jcmVhdGVCdWZmZXIoKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wyLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbDIuYmluZEJ1ZmZlcihnbDIuUElYRUxfUEFDS19CVUZGRVIsIGJ1ZmZlcik7IH0pO1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGJ1ZmZlciB0byB0aGUgc2l6ZSBvZiB0aGUgdGV4dHVyZSBpbiBieXRlcy5cbiAgICB2YXIgYnl0ZXNQZXJGbG9hdCA9IDQ7XG4gICAgdmFyIHZhbHVlc1BlclRleGVsID0gNDtcbiAgICB2YXIgYnVmZmVyU2l6ZUJ5dGVzID0gYnl0ZXNQZXJGbG9hdCAqIHZhbHVlc1BlclRleGVsICogcm93cyAqIGNvbHVtbnM7XG4gICAgY2FsbEFuZENoZWNrKGdsMiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wyLmJ1ZmZlckRhdGEoZ2wyLlBJWEVMX1BBQ0tfQlVGRkVSLCBidWZmZXJTaXplQnl0ZXMsIGdsMi5TVFJFQU1fUkVBRCk7IH0pO1xuICAgIC8vIEVucXVldWUgYSBjb21tYW5kIG9uIHRoZSBHUFUgY29tbWFuZCBxdWV1ZSB0byBjb3B5IG9mIHRleHR1cmUgaW50byB0aGVcbiAgICAvLyBidWZmZXIuXG4gICAgY2FsbEFuZENoZWNrKGdsMiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wyLnJlYWRQaXhlbHMoMCwgMCwgY29sdW1ucywgcm93cywgZ2wyLlJHQkEsIGdsMi5GTE9BVCwgMCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbDIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsMi5iaW5kQnVmZmVyKGdsMi5QSVhFTF9QQUNLX0JVRkZFUiwgbnVsbCk7IH0pO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyKGdsLCBidWZmZXIsIHNpemUpIHtcbiAgICB2YXIgZ2wyID0gZ2w7XG4gICAgdmFyIGRvd25sb2FkVGFyZ2V0ID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICBnbDIuYmluZEJ1ZmZlcihnbDIuUElYRUxfUEFDS19CVUZGRVIsIGJ1ZmZlcik7XG4gICAgZ2wyLmdldEJ1ZmZlclN1YkRhdGEoZ2wyLlBJWEVMX1BBQ0tfQlVGRkVSLCAwLCBkb3dubG9hZFRhcmdldCk7XG4gICAgZ2wyLmJpbmRCdWZmZXIoZ2wyLlBJWEVMX1BBQ0tfQlVGRkVSLCBudWxsKTtcbiAgICByZXR1cm4gZG93bmxvYWRUYXJnZXQ7XG59XG5mdW5jdGlvbiBkb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShnbCwgcm93cywgY29sdW1ucywgdGV4dHVyZUNvbmZpZykge1xuICAgIHZhciBfYSA9IGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHZhciBudW1DaGFubmVscyA9IDQ7XG4gICAgdmFyIGRvd25sb2FkVGFyZ2V0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShyb3dzICogY29sdW1ucywgbnVtQ2hhbm5lbHMpKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnJlYWRQaXhlbHMoMCwgMCwgdywgaCwgdGV4dHVyZUNvbmZpZy5kb3dubG9hZFRleHR1cmVGb3JtYXQsIGdsLlVOU0lHTkVEX0JZVEUsIGRvd25sb2FkVGFyZ2V0KTsgfSk7XG4gICAgLy8gQnkgd3JhcHBpbmcgdGhlIGJ1ZmZlciBpbiBhIEZsb2F0MzJBcnJheSwgd2UgdXNlIG5hdGl2ZSBicm93c2VyIElFRUUgNzU0XG4gICAgLy8gZGVjb2Rpbmcgb2YgdGhlIDQgYnl0ZXMgdGhhdCBiYWNrIGVhY2ggMzIgYml0IGZsb2F0LlxuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGRvd25sb2FkVGFyZ2V0LmJ1ZmZlcik7XG59XG5mdW5jdGlvbiBkb3dubG9hZFBhY2tlZE1hdHJpeEZyb21CdWZmZXIoZ2wsIGJ1ZmZlciwgYmF0Y2gsIHJvd3MsIGNvbHMsIHBoeXNpY2FsUm93cywgcGh5c2ljYWxDb2xzLCB0ZXh0dXJlQ29uZmlnKSB7XG4gICAgdmFyIGdsMiA9IGdsO1xuICAgIHZhciBkb3dubG9hZFRhcmdldCA9IG5ldyBGbG9hdDMyQXJyYXkoZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShwaHlzaWNhbFJvd3MsIHBoeXNpY2FsQ29scykpO1xuICAgIGdsMi5iaW5kQnVmZmVyKGdsMi5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbDIuZ2V0QnVmZmVyU3ViRGF0YShnbDIuUElYRUxfUEFDS19CVUZGRVIsIDAsIGRvd25sb2FkVGFyZ2V0KTtcbiAgICBnbDIuYmluZEJ1ZmZlcihnbDIuUElYRUxfUEFDS19CVUZGRVIsIG51bGwpO1xuICAgIHJldHVybiBkb3dubG9hZFRhcmdldDtcbn1cbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUoZ2wsIHBoeXNpY2FsUm93cywgcGh5c2ljYWxDb2xzKSB7XG4gICAgdmFyIHBhY2tlZFJHQkEgPSBuZXcgRmxvYXQzMkFycmF5KHBoeXNpY2FsUm93cyAqIHBoeXNpY2FsQ29scyAqIDQpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wucmVhZFBpeGVscygwLCAwLCBwaHlzaWNhbENvbHMsIHBoeXNpY2FsUm93cywgZ2wuUkdCQSwgZ2wuRkxPQVQsIHBhY2tlZFJHQkEpOyB9KTtcbiAgICByZXR1cm4gcGFja2VkUkdCQTtcbn1cblxudmFyIGdwZ3B1X3V0aWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNyZWF0ZVZlcnRleFNoYWRlcjogY3JlYXRlVmVydGV4U2hhZGVyJDEsXG4gICAgY3JlYXRlVmVydGV4QnVmZmVyOiBjcmVhdGVWZXJ0ZXhCdWZmZXIsXG4gICAgY3JlYXRlSW5kZXhCdWZmZXI6IGNyZWF0ZUluZGV4QnVmZmVyLFxuICAgIGdldEludGVybmFsRm9ybWF0Rm9yRmxvYXQzMk1hdHJpeFRleHR1cmU6IGdldEludGVybmFsRm9ybWF0Rm9yRmxvYXQzMk1hdHJpeFRleHR1cmUsXG4gICAgY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmU6IGNyZWF0ZUZsb2F0MzJNYXRyaXhUZXh0dXJlLFxuICAgIGdldEludGVybmFsRm9ybWF0Rm9yRmxvYXQxNk1hdHJpeFRleHR1cmU6IGdldEludGVybmFsRm9ybWF0Rm9yRmxvYXQxNk1hdHJpeFRleHR1cmUsXG4gICAgY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmU6IGNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlLFxuICAgIGdldEludGVybmFsRm9ybWF0Rm9yVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmU6IGdldEludGVybmFsRm9ybWF0Rm9yVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmUsXG4gICAgY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmU6IGNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlLFxuICAgIGdldEludGVybmFsRm9ybWF0Rm9yUGFja2VkTWF0cml4VGV4dHVyZTogZ2V0SW50ZXJuYWxGb3JtYXRGb3JQYWNrZWRNYXRyaXhUZXh0dXJlLFxuICAgIGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmU6IGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUsXG4gICAgZ2V0SW50ZXJuYWxGb3JtYXRGb3JGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZTogZ2V0SW50ZXJuYWxGb3JtYXRGb3JGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZSxcbiAgICBjcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZTogY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmUsXG4gICAgYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zOiBiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMsXG4gICAgdXBsb2FkRGVuc2VNYXRyaXhUb1RleHR1cmU6IHVwbG9hZERlbnNlTWF0cml4VG9UZXh0dXJlLFxuICAgIHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZTogdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlLFxuICAgIGNyZWF0ZUJ1ZmZlckZyb21PdXRwdXRUZXh0dXJlOiBjcmVhdGVCdWZmZXJGcm9tT3V0cHV0VGV4dHVyZSxcbiAgICBkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyOiBkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyLFxuICAgIGRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlOiBkb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZSxcbiAgICBkb3dubG9hZFBhY2tlZE1hdHJpeEZyb21CdWZmZXI6IGRvd25sb2FkUGFja2VkTWF0cml4RnJvbUJ1ZmZlcixcbiAgICBkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlOiBkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgR1BHUFVDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdQR1BVQ29udGV4dChnbCkge1xuICAgICAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLml0ZW1zVG9Qb2xsID0gW107XG4gICAgICAgIHZhciBnbFZlcnNpb24gPSB0Zi5lbnYoKS5nZXROdW1iZXIoJ1dFQkdMX1ZFUlNJT04nKTtcbiAgICAgICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgICAgIHNldFdlYkdMQ29udGV4dChnbFZlcnNpb24sIGdsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBnZXRXZWJHTENvbnRleHQoZ2xWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZWJHTCAyLjAgZW5hYmxlcyB0ZXh0dXJlIGZsb2F0cyB3aXRob3V0IGFuIGV4dGVuc2lvbi5cbiAgICAgICAgdmFyIENPTE9SX0JVRkZFUl9GTE9BVCA9ICdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnO1xuICAgICAgICB2YXIgQ09MT1JfQlVGRkVSX0hBTEZfRkxPQVQgPSAnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JztcbiAgICAgICAgaWYgKHRmLmVudigpLmdldE51bWJlcignV0VCR0xfVkVSU0lPTicpID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgVEVYVFVSRV9GTE9BVCA9ICdPRVNfdGV4dHVyZV9mbG9hdCc7XG4gICAgICAgICAgICB2YXIgVEVYVFVSRV9IQUxGX0ZMT0FUID0gJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIGdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgVEVYVFVSRV9GTE9BVCk7XG4gICAgICAgICAgICBpZiAoaGFzRXh0ZW5zaW9uKHRoaXMuZ2wsIFRFWFRVUkVfSEFMRl9GTE9BVCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgICAgICBnZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsIFRFWFRVUkVfSEFMRl9GTE9BVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0Zi5lbnYoKS5nZXQoJ1dFQkdMX0ZPUkNFX0YxNl9URVhUVVJFUycpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHTCBjb250ZXh0IGRvZXMgbm90IHN1cHBvcnQgaGFsZiBmbG9hdCB0ZXh0dXJlcywgeWV0IHRoZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2Vudmlyb25tZW50IGZsYWcgV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTIGlzIHNldCB0byB0cnVlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oQ09MT1JfQlVGRkVSX0ZMT0FUKTtcbiAgICAgICAgICAgIGlmIChoYXNFeHRlbnNpb24odGhpcy5nbCwgQ09MT1JfQlVGRkVSX0hBTEZfRkxPQVQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvckJ1ZmZlckhhbGZGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgICAgIGdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgQ09MT1JfQlVGRkVSX0hBTEZfRkxPQVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGYuZW52KCkuZ2V0KCdXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVMnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR0wgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IGNvbG9yIHJlbmRlcmFibGUgaGFsZiBmbG9hdHMsIHlldCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RoZSBlbnZpcm9ubWVudCBmbGFnIFdFQkdMX0ZPUkNFX0YxNl9URVhUVVJFUyBpcyBzZXQgdG8gdHJ1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIENPTE9SX0JVRkZFUl9GTE9BVCA9ICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JztcbiAgICAgICAgICAgIGlmIChoYXNFeHRlbnNpb24odGhpcy5nbCwgQ09MT1JfQlVGRkVSX0ZMT0FUKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKENPTE9SX0JVRkZFUl9GTE9BVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNFeHRlbnNpb24odGhpcy5nbCwgQ09MT1JfQlVGRkVSX0hBTEZfRkxPQVQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvckJ1ZmZlckhhbGZGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKENPTE9SX0JVRkZFUl9IQUxGX0ZMT0FUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR0wgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IGNvbG9yIHJlbmRlcmFibGUgZmxvYXRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBjcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5nbCk7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBjcmVhdGVJbmRleEJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlciA9IGNyZWF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICB0aGlzLnRleHR1cmVDb25maWcgPVxuICAgICAgICAgICAgZ2V0VGV4dHVyZUNvbmZpZyh0aGlzLmdsLCB0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1BHUFVDb250ZXh0LnByb3RvdHlwZSwgXCJkZWJ1Z1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRmLmVudigpLmdldEJvb2woJ0RFQlVHJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9ncmFtICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgV2ViR0xQcm9ncmFtLicgK1xuICAgICAgICAgICAgICAgICcgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgcHJvZ3JhbSB3aXRoICcgK1xuICAgICAgICAgICAgICAgICdHUEdQVUNvbnRleHQuZGVsZXRlUHJvZ3JhbSBiZWZvcmUgZGlzcG9zaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBvdXRwdXQgbWF0cml4ICcgK1xuICAgICAgICAgICAgICAgICd0ZXh0dXJlLiAgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgb3V0cHV0ICcgK1xuICAgICAgICAgICAgICAgICdtYXRyaXggdGV4dHVyZSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVNYXRyaXhUZXh0dXJlIGJlZm9yZSAnICtcbiAgICAgICAgICAgICAgICAnZGlzcG9zaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZmluaXNoKCk7IH0pO1xuICAgICAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7IH0pO1xuICAgICAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKF90aGlzLmZyYW1lYnVmZmVyKTsgfSk7XG4gICAgICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpOyB9KTtcbiAgICAgICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGVsZXRlQnVmZmVyKF90aGlzLmluZGV4QnVmZmVyKTsgfSk7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zLCB0aGlzLnRleHR1cmVDb25maWcpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zLCB0aGlzLnRleHR1cmVDb25maWcpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zLCB0aGlzLnRleHR1cmVDb25maWcpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcGl4ZWxzKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCBwaXhlbHMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS51cGxvYWREZW5zZU1hdHJpeFRvVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBkYXRhKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHVwbG9hZERlbnNlTWF0cml4VG9UZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmUsIHdpZHRoLCBoZWlnaHQsIGRhdGEsIHRoaXMudGV4dHVyZUNvbmZpZyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlKHRoaXMuZ2wsIHJvd3MsIGNvbHVtbnMsIHRoaXMudGV4dHVyZUNvbmZpZyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zLCB0aGlzLnRleHR1cmVDb25maWcpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kZWxldGVNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodGV4dHVyZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmUoX3RoaXMuZ2wsIHJvd3MsIGNvbHVtbnMsIF90aGlzLnRleHR1cmVDb25maWcpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRQYWNrZWRNYXRyaXhGcm9tQnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlciwgYmF0Y2gsIHJvd3MsIGNvbHVtbnMsIHBoeXNpY2FsUm93cywgcGh5c2ljYWxDb2xzKSB7XG4gICAgICAgIHJldHVybiBkb3dubG9hZFBhY2tlZE1hdHJpeEZyb21CdWZmZXIodGhpcy5nbCwgYnVmZmVyLCBiYXRjaCwgcm93cywgY29sdW1ucywgcGh5c2ljYWxSb3dzLCBwaHlzaWNhbENvbHMsIHRoaXMudGV4dHVyZUNvbmZpZyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyLCBzaXplKSB7XG4gICAgICAgIHJldHVybiBkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyKHRoaXMuZ2wsIGJ1ZmZlciwgc2l6ZSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZUJ1ZmZlckZyb21UZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIodGV4dHVyZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCdWZmZXJGcm9tT3V0cHV0VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zLCB0aGlzLnRleHR1cmVDb25maWcpO1xuICAgICAgICB0aGlzLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZUFuZFdhaXRGb3JGZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZlbmNlQ29udGV4dCA9IHRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvbGxGZW5jZShmZW5jZUNvbnRleHQpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVGZW5jZSA9IGZ1bmN0aW9uIChnbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcXVlcnk7XG4gICAgICAgIHZhciBpc0ZlbmNlUGFzc2VkO1xuICAgICAgICBpZiAodGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfRkVOQ0VfQVBJX0VOQUJMRUQnKSkge1xuICAgICAgICAgICAgdmFyIGdsMl8xID0gZ2w7XG4gICAgICAgICAgICB2YXIgc3luY18xID0gZ2wyXzEuZmVuY2VTeW5jKGdsMl8xLlNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFLCAwKTtcbiAgICAgICAgICAgIGdsLmZsdXNoKCk7XG4gICAgICAgICAgICBpc0ZlbmNlUGFzc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSBnbDJfMS5jbGllbnRXYWl0U3luYyhzeW5jXzEsIDAsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0dXMgPT09IGdsMl8xLkFMUkVBRFlfU0lHTkFMRUQgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID09PSBnbDJfMS5DT05ESVRJT05fU0FUSVNGSUVEO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gc3luY18xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRmLmVudigpLmdldE51bWJlcignV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5iZWdpblF1ZXJ5KCk7XG4gICAgICAgICAgICB0aGlzLmVuZFF1ZXJ5KCk7XG4gICAgICAgICAgICBpc0ZlbmNlUGFzc2VkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaXNRdWVyeUF2YWlsYWJsZShxdWVyeSwgdGYuZW52KCkuZ2V0TnVtYmVyKCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbm8gd2F5IHRvIGZlbmNlLCByZXR1cm4gdHJ1ZSBpbW1lZGlhdGVseS4gVGhpcyB3aWxsIGZpcmUgaW5cbiAgICAgICAgICAgIC8vIFdlYkdMIDEuMCB3aGVuIHRoZXJlIGlzIG5vIGRpc2pvaW50IHF1ZXJ5IHRpbWVyLiBJbiB0aGlzIGNhc2UsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHRoZSBmZW5jZSBwYXNzZXMgaW1tZWRpYXRlbHksIHdlJ2xsIGltbWVkaWF0ZWx5IGFzayBmb3IgYSBkb3dubG9hZCBvZlxuICAgICAgICAgICAgLy8gdGhlIHRleHR1cmUsIHdoaWNoIHdpbGwgY2F1c2UgdGhlIFVJIHRocmVhZCB0byBoYW5nLlxuICAgICAgICAgICAgaXNGZW5jZVBhc3NlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcXVlcnk6IHF1ZXJ5LCBpc0ZlbmNlUGFzc2VkOiBpc0ZlbmNlUGFzc2VkIH07XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcGh5c2ljYWxSb3dzLCBwaHlzaWNhbENvbHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodGV4dHVyZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZShfdGhpcy5nbCwgcGh5c2ljYWxSb3dzLCBwaHlzaWNhbENvbHMpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBjcmVhdGVGcmFnbWVudFNoYWRlcihnbCwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gY3JlYXRlVmVydGV4U2hhZGVyJDEoZ2wpO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oZ2wpO1xuICAgICAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpOyB9KTtcbiAgICAgICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpOyB9KTtcbiAgICAgICAgbGlua1Byb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgdmFsaWRhdGVQcm9ncmFtKGdsLCBwcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudmVydGV4QXR0cnNBcmVCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhBdHRyc0FyZUJvdW5kID0gYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zKGdsLCB0aGlzLnByb2dyYW0sIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGVsZXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmIChwcm9ncmFtID09PSB0aGlzLnByb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldFByb2dyYW0gPSBmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICBpZiAoKHRoaXMucHJvZ3JhbSAhPSBudWxsKSAmJiB0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVByb2dyYW0odGhpcy5nbCwgdGhpcy5wcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbiA9IGZ1bmN0aW9uIChwcm9ncmFtLCB1bmlmb3JtTmFtZSwgc2hvdWxkVGhyb3cpIHtcbiAgICAgICAgaWYgKHNob3VsZFRocm93ID09PSB2b2lkIDApIHsgc2hvdWxkVGhyb3cgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KHRoaXMuZ2wsIHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uKHRoaXMuZ2wsIHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVMb2NhdGlvbiA9IGZ1bmN0aW9uIChwcm9ncmFtLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGUpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyA9IGZ1bmN0aW9uIChwcm9ncmFtLCB1bmlmb3JtTmFtZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRJbnB1dE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAoaW5wdXRNYXRyaXhUZXh0dXJlLCB1bmlmb3JtTG9jYXRpb24sIHRleHR1cmVVbml0KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO1xuICAgICAgICBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyKHRoaXMuZ2wsIGlucHV0TWF0cml4VGV4dHVyZSwgdW5pZm9ybUxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAob3V0cHV0TWF0cml4VGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIob3V0cHV0TWF0cml4VGV4dHVyZSwgY29sdW1ucywgcm93cyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAob3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgX2EgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihvdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb24gPSBmdW5jdGlvbiAoc3RhcnRSb3csIG51bVJvd3MsIHN0YXJ0Q29sdW1uLCBudW1Db2x1bW5zKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXIoc3RhcnRDb2x1bW4sIHN0YXJ0Um93LCBudW1Db2x1bW5zLCBudW1Sb3dzKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb24gPSBmdW5jdGlvbiAoc3RhcnRSb3csIG51bVJvd3MsIHN0YXJ0Q29sdW1uLCBudW1Db2x1bW5zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb24gbm90IGltcGxlbWVudGVkLicpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kZWJ1Z1ZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9ncmFtICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmV4ZWN1dGVQcm9ncmFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLnRocm93SWZOb1Byb2dyYW0oKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWdWYWxpZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuYmxvY2tVbnRpbEFsbFByb2dyYW1zQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBjYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZmluaXNoKCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIGdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgdGYuZW52KCkuZ2V0TnVtYmVyKCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpID09PSAyID9cbiAgICAgICAgICAgICAgICAgICAgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInIDpcbiAgICAgICAgICAgICAgICAgICAgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbjtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbigpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmJlZ2luUXVlcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0Zi5lbnYoKS5nZXROdW1iZXIoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgICAgIHZhciBnbDIgPSB0aGlzLmdsO1xuICAgICAgICAgICAgdmFyIGV4dF8xID0gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCk7XG4gICAgICAgICAgICB2YXIgcXVlcnlfMSA9IGdsMi5jcmVhdGVRdWVyeSgpO1xuICAgICAgICAgICAgZ2wyLmJlZ2luUXVlcnkoZXh0XzEuVElNRV9FTEFQU0VEX0VYVCwgcXVlcnlfMSk7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlfMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0ID0gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCk7XG4gICAgICAgIHZhciBxdWVyeSA9IGV4dC5jcmVhdGVRdWVyeUVYVCgpO1xuICAgICAgICBleHQuYmVnaW5RdWVyeUVYVChleHQuVElNRV9FTEFQU0VEX0VYVCwgcXVlcnkpO1xuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmVuZFF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGYuZW52KCkuZ2V0TnVtYmVyKCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgZ2wyID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHZhciBleHRfMiA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpO1xuICAgICAgICAgICAgZ2wyLmVuZFF1ZXJ5KGV4dF8yLlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHQgPSB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKTtcbiAgICAgICAgZXh0LmVuZFF1ZXJ5RVhUKGV4dC5USU1FX0VMQVBTRURfRVhUKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0Zi51dGlsLnJlcGVhdGVkVHJ5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRpc3Bvc2VkIHx8IC8vIHdoaWxlIHRlc3RpbmcgY29udGV4dHMgYXJlIGNyZWF0ZWQgLyBkaXNwb3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHJhcGlkIHN1Y2Nlc3Npb24sIHNvIHdpdGhvdXQgdGhpcyBjaGVjayB3ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heSBwb2xsIGZvciB0aGUgcXVlcnkgdGltZXIgaW5kZWZpbml0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNRdWVyeUF2YWlsYWJsZShxdWVyeSwgdGYuZW52KCkuZ2V0TnVtYmVyKCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpKTsgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5nZXRRdWVyeVRpbWUocXVlcnksIHRmLmVudigpLmdldE51bWJlcignV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lID0gZnVuY3Rpb24gKHF1ZXJ5LCBxdWVyeVRpbWVyVmVyc2lvbikge1xuICAgICAgICBpZiAocXVlcnlUaW1lclZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeVRpbWVyVmVyc2lvbiA9PT0gMikge1xuICAgICAgICAgICAgdmFyIGdsMiA9IHRoaXMuZ2w7XG4gICAgICAgICAgICB2YXIgdGltZUVsYXBzZWROYW5vcyA9IGdsMi5nZXRRdWVyeVBhcmFtZXRlcihxdWVyeSwgZ2wyLlFVRVJZX1JFU1VMVCk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgICAgcmV0dXJuIHRpbWVFbGFwc2VkTmFub3MgLyAxMDAwMDAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4dCA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO1xuICAgICAgICAgICAgdmFyIHRpbWVFbGFwc2VkTmFub3MgPSBleHQuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIGV4dC5RVUVSWV9SRVNVTFRfRVhUKTtcbiAgICAgICAgICAgIC8vIFJldHVybiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgICByZXR1cm4gdGltZUVsYXBzZWROYW5vcyAvIDEwMDAwMDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuaXNRdWVyeUF2YWlsYWJsZSA9IGZ1bmN0aW9uIChxdWVyeSwgcXVlcnlUaW1lclZlcnNpb24pIHtcbiAgICAgICAgaWYgKHF1ZXJ5VGltZXJWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnlUaW1lclZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgICAgIHZhciBnbDIgPSB0aGlzLmdsO1xuICAgICAgICAgICAgdmFyIGV4dCA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZSA9IGdsMi5nZXRRdWVyeVBhcmFtZXRlcihxdWVyeSwgZ2wyLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzam9pbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzam9pbnQgPSB0aGlzLmdsLmdldFBhcmFtZXRlcihleHQuR1BVX0RJU0pPSU5UX0VYVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlICYmICF0aGlzLmRpc2pvaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4dCA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZSA9IGV4dC5nZXRRdWVyeU9iamVjdEVYVChxdWVyeSwgZXh0LlFVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2pvaW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2pvaW50ID0gdGhpcy5nbC5nZXRQYXJhbWV0ZXIoZXh0LkdQVV9ESVNKT0lOVF9FWFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZSAmJiAhdGhpcy5kaXNqb2ludDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5wb2xsRmVuY2UgPSBmdW5jdGlvbiAoZmVuY2VDb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3RoaXMuYWRkSXRlbVRvUG9sbChmdW5jdGlvbiAoKSB7IHJldHVybiBmZW5jZUNvbnRleHQuaXNGZW5jZVBhc3NlZCgpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUucG9sbEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHF1ZXJ5IHRoYXQgaGFzIGZpbmlzaGVkLlxuICAgICAgICB2YXIgaW5kZXggPSBsaW5lYXJTZWFyY2hMYXN0VHJ1ZSh0aGlzLml0ZW1zVG9Qb2xsLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pc0RvbmVGbjsgfSkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBpbmRleDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZUZuID0gdGhpcy5pdGVtc1RvUG9sbFtpXS5yZXNvbHZlRm47XG4gICAgICAgICAgICByZXNvbHZlRm4oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZW1zVG9Qb2xsID0gdGhpcy5pdGVtc1RvUG9sbC5zbGljZShpbmRleCArIDEpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5hZGRJdGVtVG9Qb2xsID0gZnVuY3Rpb24gKGlzRG9uZUZuLCByZXNvbHZlRm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pdGVtc1RvUG9sbC5wdXNoKHsgaXNEb25lRm46IGlzRG9uZUZuLCByZXNvbHZlRm46IHJlc29sdmVGbiB9KTtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGEgcnVubmluZyBsb29wIHRoYXQgcG9sbHMuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgYSBuZXcgbG9vcCB0aGF0IHBvbGxzLlxuICAgICAgICB0Zi51dGlsLnJlcGVhdGVkVHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnBvbGxJdGVtcygpO1xuICAgICAgICAgICAgLy8gRW5kIHRoZSBsb29wIGlmIG5vIG1vcmUgaXRlbXMgdG8gcG9sbC5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5pdGVtc1RvUG9sbC5sZW5ndGggPT09IDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIgPSBmdW5jdGlvbiAodGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcih0aGlzLmdsLCB0ZXh0dXJlLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5vdXRwdXRUZXh0dXJlLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcih0aGlzLmdsLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBkb3dubG9hZEFuZERlY29kZSkge1xuICAgICAgICB0aGlzLmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcih0ZXh0dXJlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRvd25sb2FkQW5kRGVjb2RlKCk7XG4gICAgICAgIHRoaXMudW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlciA9IGZ1bmN0aW9uIChvdXRwdXRNYXRyaXhUZXh0dXJlTWF5YmVQYWNrZWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIoZ2wsIG91dHB1dE1hdHJpeFRleHR1cmVNYXliZVBhY2tlZCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZyYW1lYnVmZmVyKGdsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBvdXRwdXRNYXRyaXhUZXh0dXJlTWF5YmVQYWNrZWQ7XG4gICAgICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgICAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNjaXNzb3IoMCwgMCwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5zY2lzc29yKHgsIHksIHdpZHRoLCBoZWlnaHQpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudGhyb3dJZkRpc3Bvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gdXNlIGRpc3Bvc2VkIEdQR1BVQ29udGV4dC4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS50aHJvd0lmTm9Qcm9ncmFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9ncmFtID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gR1BVIHByb2dyYW0gaXMgY3VycmVudGx5IHNldC4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdQR1BVQ29udGV4dDtcbn0oKSk7XG4vKipcbiAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB0cnVlIGVsZW1lbnQgdXNpbmcgbGluZWFyIHNlYXJjaC5cbiAqIE5vdGU6IFdlIGNhbid0IGRvIGJpbmFyeSBzZWFyY2ggYmVjYXVzZSBDaHJvbWUgZXhwZWN0cyB1cyB0byBleHBsaWNpdGx5XG4gKiB0ZXN0IGFsbCBmZW5jZXMgYmVmb3JlIGRvd25sb2FkOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9pc3N1ZXMvMTE0NVxuICovXG5mdW5jdGlvbiBsaW5lYXJTZWFyY2hMYXN0VHJ1ZShhcnIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGlzRG9uZSA9IGFycltpXSgpO1xuICAgICAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGkgLSAxO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZ2V0QnJvYWRjYXN0RGltcyA9IHRmLmJhY2tlbmRfdXRpbC5nZXRCcm9hZGNhc3REaW1zO1xuZnVuY3Rpb24gbWFrZVNoYWRlcihpbnB1dHNJbmZvLCBvdXRwdXRTaGFwZSwgdXNlckNvZGUsIHVzZXNQYWNrZWRUZXh0dXJlcykge1xuICAgIHZhciBwcmVmaXhTbmlwcGV0cyA9IFtdO1xuICAgIGlucHV0c0luZm8uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgc2l6ZSA9IHRmLnV0aWwuc2l6ZUZyb21TaGFwZSh4LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO1xuICAgICAgICAvLyBTbmlwcGV0IHdoZW4gd2UgZGVjaWRlZCB0byB1cGxvYWQgdGhlIHZhbHVlcyBhcyB1bmlmb3JtLlxuICAgICAgICBpZiAoeC5zaGFwZUluZm8uaXNVbmlmb3JtKSB7XG4gICAgICAgICAgICBwcmVmaXhTbmlwcGV0cy5wdXNoKFwidW5pZm9ybSBmbG9hdCBcIiArIHgubmFtZSArIChzaXplID4gMSA/IFwiW1wiICsgc2l6ZSArIFwiXVwiIDogJycpICsgXCI7XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJlZml4U25pcHBldHMucHVzaChcInVuaWZvcm0gc2FtcGxlcjJEIFwiICsgeC5uYW1lICsgXCI7XCIpO1xuICAgICAgICAgICAgcHJlZml4U25pcHBldHMucHVzaChcInVuaWZvcm0gaW50IG9mZnNldFwiICsgeC5uYW1lICsgXCI7XCIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGlucHV0UHJlZml4U25pcHBldCA9IHByZWZpeFNuaXBwZXRzLmpvaW4oJ1xcbicpO1xuICAgIHZhciBpbnB1dFNhbXBsaW5nU25pcHBldCA9IGlucHV0c0luZm9cbiAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gZ2V0SW5wdXRTYW1wbGluZ1NuaXBwZXQoeCwgb3V0cHV0U2hhcGUsIHVzZXNQYWNrZWRUZXh0dXJlcyk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB2YXIgb3V0VGV4U2hhcGUgPSBvdXRwdXRTaGFwZS50ZXhTaGFwZTtcbiAgICB2YXIgZ2xzbCA9IGdldEdsc2xEaWZmZXJlbmNlcygpO1xuICAgIHZhciBmbG9hdFRleHR1cmVTYW1wbGVTbmlwcGV0ID0gZ2V0RmxvYXRUZXh0dXJlU2FtcGxlU25pcHBldChnbHNsKTtcbiAgICB2YXIgb3V0cHV0U2FtcGxpbmdTbmlwcGV0O1xuICAgIHZhciBmbG9hdFRleHR1cmVTZXRPdXRwdXRTbmlwcGV0O1xuICAgIHZhciBzaGFkZXJQcmVmaXggPSBnZXRTaGFkZXJQcmVmaXgoZ2xzbCk7XG4gICAgaWYgKG91dHB1dFNoYXBlLmlzUGFja2VkKSB7XG4gICAgICAgIG91dHB1dFNhbXBsaW5nU25pcHBldCA9XG4gICAgICAgICAgICBnZXRQYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0cHV0U2hhcGUubG9naWNhbFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGZsb2F0VGV4dHVyZVNldE91dHB1dFNuaXBwZXQgPSBnZXRGbG9hdFRleHR1cmVTZXRSR0JBU25pcHBldChnbHNsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG91dHB1dFNhbXBsaW5nU25pcHBldCA9XG4gICAgICAgICAgICBnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0cHV0U2hhcGUubG9naWNhbFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGZsb2F0VGV4dHVyZVNldE91dHB1dFNuaXBwZXQgPSBnZXRGbG9hdFRleHR1cmVTZXRSU25pcHBldChnbHNsKTtcbiAgICB9XG4gICAgaWYgKHVzZXNQYWNrZWRUZXh0dXJlcykge1xuICAgICAgICBzaGFkZXJQcmVmaXggKz0gU0hBREVSX1BBQ0tFRF9QUkVGSVg7XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSBbXG4gICAgICAgIHNoYWRlclByZWZpeCwgZmxvYXRUZXh0dXJlU2FtcGxlU25pcHBldCwgZmxvYXRUZXh0dXJlU2V0T3V0cHV0U25pcHBldCxcbiAgICAgICAgaW5wdXRQcmVmaXhTbmlwcGV0LCBvdXRwdXRTYW1wbGluZ1NuaXBwZXQsIGlucHV0U2FtcGxpbmdTbmlwcGV0LCB1c2VyQ29kZVxuICAgIF0uam9pbignXFxuJyk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJGcm9tSW5JbmZvKGluSW5mbykge1xuICAgIHZhciBzaGFwZSA9IGluSW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyU2NhbGFyKGluSW5mbyk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyMUQoaW5JbmZvKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXIyRChpbkluZm8pO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjNEKGluSW5mbyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyNEQoaW5JbmZvKTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXI1RChpbkluZm8pO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjZEKGluSW5mbyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2hhcGUubGVuZ3RoICsgXCItRCBpbnB1dCBzYW1wbGluZ1wiICtcbiAgICAgICAgICAgICAgICBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQYWNrZWRTYW1wbGVyRnJvbUluSW5mbyhpbkluZm8pIHtcbiAgICB2YXIgc2hhcGUgPSBpbkluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICBzd2l0Y2ggKHNoYXBlLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gZ2V0UGFja2VkU2FtcGxlclNjYWxhcihpbkluZm8pO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZ2V0UGFja2VkU2FtcGxlcjFEKGluSW5mbyk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBnZXRQYWNrZWRTYW1wbGVyMkQoaW5JbmZvKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGdldFBhY2tlZFNhbXBsZXIzRChpbkluZm8pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGdldFBhY2tlZFNhbXBsZXJORChpbkluZm8pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldElucHV0U2FtcGxpbmdTbmlwcGV0KGluSW5mbywgb3V0U2hhcGVJbmZvLCB1c2VzUGFja2VkVGV4dHVyZXMpIHtcbiAgICBpZiAodXNlc1BhY2tlZFRleHR1cmVzID09PSB2b2lkIDApIHsgdXNlc1BhY2tlZFRleHR1cmVzID0gZmFsc2U7IH1cbiAgICB2YXIgcmVzID0gJyc7XG4gICAgaWYgKHVzZXNQYWNrZWRUZXh0dXJlcykge1xuICAgICAgICByZXMgKz0gZ2V0UGFja2VkU2FtcGxlckZyb21JbkluZm8oaW5JbmZvKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcyArPSBnZXRTYW1wbGVyRnJvbUluSW5mbyhpbkluZm8pO1xuICAgIH1cbiAgICB2YXIgaW5TaGFwZSA9IGluSW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciBvdXRTaGFwZSA9IG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgaWYgKGluU2hhcGUubGVuZ3RoIDw9IG91dFNoYXBlLmxlbmd0aCkge1xuICAgICAgICBpZiAodXNlc1BhY2tlZFRleHR1cmVzKSB7XG4gICAgICAgICAgICByZXMgKz0gZ2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKGluSW5mbywgb3V0U2hhcGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBnZXRTYW1wbGVyQXRPdXRwdXRDb29yZHMoaW5JbmZvLCBvdXRTaGFwZUluZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRQYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0U2hhcGUsIG91dFRleFNoYXBlKSB7XG4gICAgc3dpdGNoIChvdXRTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dFNjYWxhckNvb3JkcygpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0UGFja2VkMURDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dFBhY2tlZDJEQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXRQYWNrZWQzRENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dFBhY2tlZE5EQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KG91dFNoYXBlLCBvdXRUZXhTaGFwZSkge1xuICAgIHN3aXRjaCAob3V0U2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDFEQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQyRENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0M0RDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDREQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQ1RENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0NkRDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvdXRTaGFwZS5sZW5ndGggKyBcIi1EIG91dHB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRGbG9hdFRleHR1cmVTYW1wbGVTbmlwcGV0KGdsc2wpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcXG4gICAgICByZXR1cm4gXCIgKyBnbHNsLnRleHR1cmUyRCArIFwiKHRleHR1cmVTYW1wbGVyLCB1dikucjtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRGbG9hdFRleHR1cmVTZXRSU25pcHBldChnbHNsKSB7XG4gICAgcmV0dXJuIFwiXFxuICAgIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHZhbCkge1xcbiAgICAgIFwiICsgZ2xzbC5vdXRwdXQgKyBcIiA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRGbG9hdFRleHR1cmVTZXRSR0JBU25pcHBldChnbHNsKSB7XG4gICAgcmV0dXJuIFwiXFxuICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XFxuICAgICAgXCIgKyBnbHNsLm91dHB1dCArIFwiID0gdmFsO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNoYWRlclByZWZpeChnbHNsKSB7XG4gICAgdmFyIFNIQURFUl9QUkVGSVggPSBnbHNsLnZlcnNpb24gKyBcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuICAgIFwiICsgZ2xzbC52YXJ5aW5nRnMgKyBcIiB2ZWMyIHJlc3VsdFVWO1xcbiAgICBcIiArIGdsc2wuZGVmaW5lT3V0cHV0ICsgXCJcXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gICAgc3RydWN0IGl2ZWM1XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgfTtcXG5cXG4gICAgc3RydWN0IGl2ZWM2XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgICBpbnQgdjtcXG4gICAgfTtcXG5cXG4gICAgdW5pZm9ybSBmbG9hdCBOQU47XFxuICAgIFwiICsgZ2xzbC5kZWZpbmVTcGVjaWFsTmFOICsgXCJcXG4gICAgXCIgKyBnbHNsLmRlZmluZVNwZWNpYWxJbmYgKyBcIlxcbiAgICBcIiArIGdsc2wuZGVmaW5lUm91bmQgKyBcIlxcblxcbiAgICBpbnQgaW1vZChpbnQgeCwgaW50IHkpIHtcXG4gICAgICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xcbiAgICB9XFxuXFxuICAgIGludCBpZGl2KGludCBhLCBpbnQgYiwgZmxvYXQgc2lnbikge1xcbiAgICAgIGludCByZXMgPSBhIC8gYjtcXG4gICAgICBpbnQgbW9kID0gaW1vZChhLCBiKTtcXG4gICAgICBpZiAoc2lnbiA8IDAuICYmIG1vZCAhPSAwKSB7XFxuICAgICAgICByZXMgLT0gMTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlcztcXG4gICAgfVxcblxcbiAgICAvL0Jhc2VkIG9uIHRoZSB3b3JrIG9mIERhdmUgSG9za2luc1xcbiAgICAvL2h0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80ZGpTUldcXG4gICAgI2RlZmluZSBIQVNIU0NBTEUxIDQ0My44OTc1XFxuICAgIGZsb2F0IHJhbmRvbShmbG9hdCBzZWVkKXtcXG4gICAgICB2ZWMyIHAgPSByZXN1bHRVViAqIHNlZWQ7XFxuICAgICAgdmVjMyBwMyAgPSBmcmFjdCh2ZWMzKHAueHl4KSAqIEhBU0hTQ0FMRTEpO1xcbiAgICAgIHAzICs9IGRvdChwMywgcDMueXp4ICsgMTkuMTkpO1xcbiAgICAgIHJldHVybiBmcmFjdCgocDMueCArIHAzLnkpICogcDMueik7XFxuICAgIH1cXG5cXG4gICAgXCIgKyBTQU1QTEVfMURfU05JUFBFVCArIFwiXFxuICAgIFwiICsgU0FNUExFXzJEX1NOSVBQRVQgKyBcIlxcbiAgICBcIiArIFNBTVBMRV8zRF9TTklQUEVUICsgXCJcXG4gIFwiO1xuICAgIHJldHVybiBTSEFERVJfUFJFRklYO1xufVxudmFyIFNBTVBMRV8xRF9TTklQUEVUID0gXCJcXG52ZWMyIHV2RnJvbUZsYXQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcbnZlYzIgcGFja2VkVVZmcm9tMUQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xcbiAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNBTVBMRV8yRF9TTklQUEVUID0gXCJcXG52ZWMyIHBhY2tlZFVWZnJvbTJEKGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCB0ZXhOdW1SLFxcbiAgaW50IHRleE51bUMsIGludCByb3csIGludCBjb2wpIHtcXG4gIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNBTVBMRV8zRF9TTklQUEVUID0gXCJcXG52ZWMyIHBhY2tlZFVWZnJvbTNEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQyxcXG4gICAgaW50IHRleGVsc0luQmF0Y2gsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCBiLFxcbiAgICBpbnQgcm93LCBpbnQgY29sKSB7XFxuICBpbnQgaW5kZXggPSBiICogdGV4ZWxzSW5CYXRjaCArIChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNIQURFUl9QQUNLRURfUFJFRklYID0gXCJcXG4gIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCB2ZWMyIGlubmVyRGltcykge1xcbiAgICB2ZWMyIG1vZENvb3JkID0gbW9kKGlubmVyRGltcywgMi4pO1xcbiAgICByZXR1cm4gbW9kQ29vcmQueCA9PSAwLiA/XFxuICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmcpIDpcXG4gICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuYiA6IGZyYWcuYSk7XFxuICB9XFxuICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgaW50IGRpbSkge1xcbiAgICBmbG9hdCBtb2RDb29yZCA9IG1vZChmbG9hdChkaW0pLCAyLik7XFxuICAgIHJldHVybiBtb2RDb29yZCA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZztcXG4gIH1cXG5cIjtcbmZ1bmN0aW9uIGdldE91dHB1dFNjYWxhckNvb3JkcygpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXRQYWNrZWQxRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICB2YXIgcGFja2VkVGV4U2hhcGUgPSBbTWF0aC5jZWlsKHRleFNoYXBlWzBdIC8gMiksIE1hdGguY2VpbCh0ZXhTaGFwZVsxXSAvIDIpXTtcbiAgICBpZiAocGFja2VkVGV4U2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAyICogaW50KHJlc3VsdFVWLnggKiBcIiArIHBhY2tlZFRleFNoYXBlWzFdICsgXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHBhY2tlZFRleFNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gMiAqIGludChyZXN1bHRVVi55ICogXCIgKyBwYWNrZWRUZXhTaGFwZVswXSArIFwiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHBhY2tlZFRleFNoYXBlWzBdICsgXCIsIFwiICsgcGFja2VkVGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIHJldHVybiAyICogKHJlc1RleFJDLnggKiBcIiArIHBhY2tlZFRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQxRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICBpZiAodGV4U2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4U2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueSAqIFwiICsgdGV4U2hhcGVbMF0gKyBcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgdmFyIHBhY2tlZFRleFNoYXBlID0gW01hdGguY2VpbCh0ZXhTaGFwZVswXSAvIDIpLCBNYXRoLmNlaWwodGV4U2hhcGVbMV0gLyAyKV07XG4gICAgdmFyIHRleGVsc0luTG9naWNhbFJvdyA9IE1hdGguY2VpbChzaGFwZVsyXSAvIDIpO1xuICAgIHZhciB0ZXhlbHNJbkJhdGNoID0gdGV4ZWxzSW5Mb2dpY2FsUm93ICogTWF0aC5jZWlsKHNoYXBlWzFdIC8gMik7XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyBwYWNrZWRUZXhTaGFwZVswXSArIFwiLCBcIiArIHBhY2tlZFRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyBwYWNrZWRUZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBpbnQgYiA9IGluZGV4IC8gXCIgKyB0ZXhlbHNJbkJhdGNoICsgXCI7XFxuICAgICAgaW5kZXggLT0gYiAqIFwiICsgdGV4ZWxzSW5CYXRjaCArIFwiO1xcblxcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiICsgdGV4ZWxzSW5Mb2dpY2FsUm93ICsgXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIgKyB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyBcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQzRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICB2YXIgY29vcmRzRnJvbUluZGV4U25pcHBldCA9IGdldExvZ2ljYWxDb29yZGluYXRlc0Zyb21GbGF0SW5kZXgoWydyJywgJ2MnLCAnZCddLCBzaGFwZSk7XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICBcIiArIGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgKyBcIlxcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXRQYWNrZWRORENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICB2YXIgcGFja2VkVGV4U2hhcGUgPSBbTWF0aC5jZWlsKHRleFNoYXBlWzBdIC8gMiksIE1hdGguY2VpbCh0ZXhTaGFwZVsxXSAvIDIpXTtcbiAgICB2YXIgdGV4ZWxzSW5Mb2dpY2FsUm93ID0gTWF0aC5jZWlsKHNoYXBlW3NoYXBlLmxlbmd0aCAtIDFdIC8gMik7XG4gICAgdmFyIHRleGVsc0luQmF0Y2ggPSB0ZXhlbHNJbkxvZ2ljYWxSb3cgKiBNYXRoLmNlaWwoc2hhcGVbc2hhcGUubGVuZ3RoIC0gMl0gLyAyKTtcbiAgICB2YXIgdGV4ZWxzSW5CYXRjaE4gPSB0ZXhlbHNJbkJhdGNoO1xuICAgIHZhciBiYXRjaGVzID0gXCJcIjtcbiAgICB2YXIgY29vcmRzID0gJ2IsIHIsIGMnO1xuICAgIGZvciAodmFyIGIgPSAyOyBiIDwgc2hhcGUubGVuZ3RoIC0gMTsgYisrKSB7XG4gICAgICAgIHRleGVsc0luQmF0Y2hOICo9IHNoYXBlW3NoYXBlLmxlbmd0aCAtIGIgLSAxXTtcbiAgICAgICAgYmF0Y2hlcyA9IFwiXFxuICAgICAgaW50IGJcIiArIGIgKyBcIiA9IGluZGV4IC8gXCIgKyB0ZXhlbHNJbkJhdGNoTiArIFwiO1xcbiAgICAgIGluZGV4IC09IGJcIiArIGIgKyBcIiAqIFwiICsgdGV4ZWxzSW5CYXRjaE4gKyBcIjtcXG4gICAgXCIgKyBiYXRjaGVzO1xuICAgICAgICBjb29yZHMgPSBcImJcIiArIGIgKyBcIiwgXCIgKyBjb29yZHM7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBpdmVjXCIgKyBzaGFwZS5sZW5ndGggKyBcIiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgcGFja2VkVGV4U2hhcGVbMF0gKyBcIiwgXCIgKyBwYWNrZWRUZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgcGFja2VkVGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgXCIgKyBiYXRjaGVzICsgXCJcXG5cXG4gICAgICBpbnQgYiA9IGluZGV4IC8gXCIgKyB0ZXhlbHNJbkJhdGNoICsgXCI7XFxuICAgICAgaW5kZXggLT0gYiAqIFwiICsgdGV4ZWxzSW5CYXRjaCArIFwiO1xcblxcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiICsgdGV4ZWxzSW5Mb2dpY2FsUm93ICsgXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIgKyB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyBcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjXCIgKyBzaGFwZS5sZW5ndGggKyBcIihcIiArIGNvb3JkcyArIFwiKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQ0RENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICB2YXIgY29vcmRzRnJvbUluZGV4U25pcHBldCA9IGdldExvZ2ljYWxDb29yZGluYXRlc0Zyb21GbGF0SW5kZXgoWydyJywgJ2MnLCAnZCcsICdkMiddLCBzaGFwZSk7XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICBcIiArIGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgKyBcIlxcbiAgICAgIHJldHVybiBpdmVjNChyLCBjLCBkLCBkMik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0NURDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgdmFyIGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPSBnZXRMb2dpY2FsQ29vcmRpbmF0ZXNGcm9tRmxhdEluZGV4KFsncicsICdjJywgJ2QnLCAnZDInLCAnZDMnXSwgc2hhcGUpO1xuICAgIHJldHVybiBcIlxcbiAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuXFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgXCIgKyBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ICsgXCJcXG5cXG4gICAgICBpdmVjNSBvdXRTaGFwZSA9IGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XFxuICAgICAgcmV0dXJuIG91dFNoYXBlO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDZEQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIHZhciBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID0gZ2V0TG9naWNhbENvb3JkaW5hdGVzRnJvbUZsYXRJbmRleChbJ3InLCAnYycsICdkJywgJ2QyJywgJ2QzJywgJ2Q0J10sIHNoYXBlKTtcbiAgICByZXR1cm4gXCJcXG4gICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIFwiICsgY29vcmRzRnJvbUluZGV4U25pcHBldCArIFwiXFxuXFxuICAgICAgaXZlYzYgcmVzdWx0ID0gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICB2YXIgcGFja2VkVGV4U2hhcGUgPSBbTWF0aC5jZWlsKHRleFNoYXBlWzBdIC8gMiksIE1hdGguY2VpbCh0ZXhTaGFwZVsxXSAvIDIpXTtcbiAgICBpZiAodGYudXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAyICogaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiICsgcGFja2VkVGV4U2hhcGVbMF0gKyBcIiwgXCIgKyBwYWNrZWRUZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgLy8gdGV4ZWxzIG5lZWRlZCB0byBhY2NvbW1vZGF0ZSBhIGxvZ2ljYWwgcm93XG4gICAgdmFyIHRleGVsc0luTG9naWNhbFJvdyA9IE1hdGguY2VpbChzaGFwZVsxXSAvIDIpO1xuICAgIC8qKlxuICAgICAqIGdldE91dHB1dENvb3Jkc1xuICAgICAqXG4gICAgICogcmVzVGV4UkM6IFRoZSByb3dzIGFuZCBjb2x1bW5zIG9mIHRoZSB0ZXhlbHMuIElmIHlvdSBtb3ZlIG92ZXIgb25lXG4gICAgICogdGV4ZWwgdG8gdGhlIHJpZ2h0IGluIHRoZSBwYWNrZWQgdGV4dHVyZSwgeW91IGFyZSBtb3Zpbmcgb3ZlciBvbmUgY29sdW1uXG4gICAgICogKG5vdCB0d28pLlxuICAgICAqXG4gICAgICogaW5kZXg6IFRoZSB0ZXhlbCBpbmRleFxuICAgICAqL1xuICAgIHJldHVybiBcIlxcbiAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgcGFja2VkVGV4U2hhcGVbMF0gKyBcIiwgXCIgKyBwYWNrZWRUZXhTaGFwZVsxXSArIFwiKSk7XFxuXFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgcGFja2VkVGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gXCIgKyB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyBcIik7XFxuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCBcIiArIHRleGVsc0luTG9naWNhbFJvdyArIFwiKSAqIDI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDJEQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIGlmICh0Zi51dGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmIChzaGFwZVsxXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoaW5kZXgsIDApO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmIChzaGFwZVswXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoMCwgaW5kZXgpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc2hhcGVbMV0gKyBcIjtcXG4gICAgICBpbnQgYyA9IGluZGV4IC0gciAqIFwiICsgc2hhcGVbMV0gKyBcIjtcXG4gICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0RmxhdE9mZnNldFVuaWZvcm1OYW1lKHRleE5hbWUpIHtcbiAgICByZXR1cm4gXCJvZmZzZXRcIiArIHRleE5hbWU7XG59XG5mdW5jdGlvbiBnZXRQYWNrZWRTYW1wbGVyU2NhbGFyKGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgZ2xzbCA9IGdldEdsc2xEaWZmZXJlbmNlcygpO1xuICAgIHJldHVybiBcIlxcbiAgICB2ZWM0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICByZXR1cm4gXCIgKyBnbHNsLnRleHR1cmUyRCArIFwiKFwiICsgdGV4TmFtZSArIFwiLCBoYWxmQ1IpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJTY2FsYXIoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIGlmIChpbnB1dEluZm8uc2hhcGVJbmZvLmlzVW5pZm9ybSkge1xuICAgICAgICByZXR1cm4gXCJmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoKSB7cmV0dXJuIFwiICsgdGV4TmFtZSArIFwiO31cIjtcbiAgICB9XG4gICAgdmFyIF9hID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZSwgdGV4TnVtUiA9IF9hWzBdLCB0ZXhOdW1DID0gX2FbMV07XG4gICAgaWYgKHRleE51bVIgPT09IDEgJiYgdGV4TnVtQyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoKSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgaGFsZkNSKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICB2YXIgX2IgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlLCB0TnVtUiA9IF9iWzBdLCB0TnVtQyA9IF9iWzFdO1xuICAgIHZhciBvZmZzZXQgPSBnZXRGbGF0T2Zmc2V0VW5pZm9ybU5hbWUodGV4TmFtZSk7XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIiArIHROdW1SICsgXCIsIFwiICsgdE51bUMgKyBcIiwgXCIgKyBvZmZzZXQgKyBcIik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRQYWNrZWRTYW1wbGVyMUQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHBhY2tlZFRleFNoYXBlID0gW01hdGguY2VpbCh0ZXhTaGFwZVswXSAvIDIpLCBNYXRoLmNlaWwodGV4U2hhcGVbMV0gLyAyKV07XG4gICAgdmFyIGdsc2wgPSBnZXRHbHNsRGlmZmVyZW5jZXMoKTtcbiAgICByZXR1cm4gXCJcXG4gICAgdmVjNCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxcbiAgICAgICAgXCIgKyBwYWNrZWRUZXhTaGFwZVswXSArIFwiLCBcIiArIHBhY2tlZFRleFNoYXBlWzFdICsgXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gXCIgKyBnbHNsLnRleHR1cmUyRCArIFwiKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjFEKGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICBpZiAoaW5wdXRJbmZvLnNoYXBlSW5mby5pc1VuaWZvcm0pIHtcbiAgICAgICAgLy8gVW5pZm9ybSBhcnJheXMgd2lsbCBiZSBsZXNzIHRoYW4gNjU1MDUgKG5vIHJpc2sgb2YgZmxvYXQxNiBvdmVyZmxvdykuXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIFwiICsgZ2V0VW5pZm9ybVNhbXBsZXIoaW5wdXRJbmZvKSArIFwiXFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdE51bUMgPSB0ZXhTaGFwZVsxXTtcbiAgICBpZiAodE51bUMgPT09IDEgJiYgdE51bVIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIGhhbGZDUik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IGdldEZsYXRPZmZzZXRVbmlmb3JtTmFtZSh0ZXhOYW1lKTtcbiAgICBpZiAodE51bUMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXggKyBcIiArIG9mZnNldCArIFwiKSArIDAuNSkgLyBcIiArIHROdW1SICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0TnVtUiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXggKyBcIiArIG9mZnNldCArIFwiKSArIDAuNSkgLyBcIiArIHROdW1DICsgXCIuMCwgMC41KTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIiArIHROdW1SICsgXCIsIFwiICsgdE51bUMgKyBcIiwgaW5kZXggKyBcIiArIG9mZnNldCArIFwiKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFBhY2tlZFNhbXBsZXIyRChpbnB1dEluZm8pIHtcbiAgICB2YXIgc2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0ZXhOdW1DID0gdGV4U2hhcGVbMV07XG4gICAgdmFyIGdsc2wgPSBnZXRHbHNsRGlmZmVyZW5jZXMoKTtcbiAgICBpZiAodGV4U2hhcGUgIT0gbnVsbCAmJiB0Zi51dGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgdmVjNCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcblxcbiAgICAgICAgcmV0dXJuIFwiICsgZ2xzbC50ZXh0dXJlMkQgKyBcIihcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHZhciBwYWNrZWRUZXhTaGFwZSA9IFtNYXRoLmNlaWwodGV4U2hhcGVbMF0gLyAyKSwgTWF0aC5jZWlsKHRleFNoYXBlWzFdIC8gMildO1xuICAgIHZhciB2YWx1ZXNQZXJSb3cgPSBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcbiAgICByZXR1cm4gXCJcXG4gICAgdmVjNCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20yRChcIiArIHZhbHVlc1BlclJvdyArIFwiLCBcIiArIHBhY2tlZFRleFNoYXBlWzBdICsgXCIsIFwiICsgcGFja2VkVGV4U2hhcGVbMV0gKyBcIiwgcm93LCBjb2wpO1xcbiAgICAgIHJldHVybiBcIiArIGdsc2wudGV4dHVyZTJEICsgXCIoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyMkQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgaWYgKHRleFNoYXBlICE9IG51bGwgJiYgdGYudXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICAgIHZhciB0ZXhOdW1SXzEgPSB0ZXhTaGFwZVswXTtcbiAgICAgICAgdmFyIHRleE51bUNfMSA9IHRleFNoYXBlWzFdO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB0ZXhOdW1DXzEgKyBcIi4wLCBcIiArIHRleE51bVJfMSArIFwiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICB2YXIgX2EgPSB0Zi51dGlsLnNxdWVlemVTaGFwZShzaGFwZSksIG5ld1NoYXBlID0gX2EubmV3U2hhcGUsIGtlcHREaW1zID0gX2Eua2VwdERpbXM7XG4gICAgdmFyIHNxdWVlemVkU2hhcGUgPSBuZXdTaGFwZTtcbiAgICBpZiAoc3F1ZWV6ZWRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFsncm93JywgJ2NvbCddO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKGlucHV0SW5mby5zaGFwZUluZm8uaXNVbmlmb3JtKSB7XG4gICAgICAgIC8vIFVuaWZvcm0gYXJyYXlzIHdpbGwgYmUgbGVzcyB0aGFuIDY1NTA1IChubyByaXNrIG9mIGZsb2F0MTYgb3ZlcmZsb3cpLlxuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKFwiICsgc2hhcGVbMV0gKyBcIiwgMSkpKTtcXG4gICAgICAgIFwiICsgZ2V0VW5pZm9ybVNhbXBsZXIoaW5wdXRJbmZvKSArIFwiXFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgdmFyIHRleE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIHZhciBvZmZzZXQgPSBnZXRGbGF0T2Zmc2V0VW5pZm9ybU5hbWUodGV4TmFtZSk7XG4gICAgaWYgKHRleE51bUMgPT09IDEpIHtcbiAgICAgICAgLy8gaW5kZXggaXMgdXNlZCBkaXJlY3RseSBhcyBwaHlzaWNhbCAobm8gcmlzayBvZiBmbG9hdDE2IG92ZXJmbG93KS5cbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgXCIgKyBvZmZzZXQgKyBcIiksIHZlYzMoXCIgKyBzaGFwZVsxXSArIFwiLCAxLCAxKSk7XFxuICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoaW5kZXggKyAwLjUpIC8gXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1SID09PSAxKSB7XG4gICAgICAgIC8vIGluZGV4IGlzIHVzZWQgZGlyZWN0bHkgYXMgcGh5c2ljYWwgKG5vIHJpc2sgb2YgZmxvYXQxNiBvdmVyZmxvdykuXG4gICAgICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsIFwiICsgb2Zmc2V0ICsgXCIpLCB2ZWMzKFwiICsgc2hhcGVbMV0gKyBcIiwgMSwgMSkpO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKChpbmRleCArIDAuNSkgLyBcIiArIHRleE51bUMgKyBcIi4wLCAwLjUpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgaW50IGluZGV4ID0gcm93ICogXCIgKyBzaGFwZVsxXSArIFwiICsgY29sICsgXCIgKyBvZmZzZXQgKyBcIjtcXG4gICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBpbmRleCk7XFxuICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICB9XFxuXCI7XG59XG5mdW5jdGlvbiBnZXRQYWNrZWRTYW1wbGVyM0QoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHBhY2tlZFRleFNoYXBlID0gW01hdGguY2VpbCh0ZXhTaGFwZVswXSAvIDIpLCBNYXRoLmNlaWwodGV4U2hhcGVbMV0gLyAyKV07XG4gICAgaWYgKHNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgIHZhciBzcXVlZXplZFNoYXBlID0gc2hhcGUuc2xpY2UoMSk7XG4gICAgICAgIHZhciBrZXB0RGltcyA9IFsxLCAyXTtcbiAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFsnYicsICdyb3cnLCAnY29sJ107XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgXCIgKyBnZXRQYWNrZWRTYW1wbGVyRnJvbUluSW5mbyhuZXdJbnB1dEluZm8pICsgXCJcXG4gICAgICAgIHZlYzQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSArIFwiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICB9XG4gICAgdmFyIHRleE51bVIgPSBwYWNrZWRUZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHBhY2tlZFRleFNoYXBlWzFdO1xuICAgIHZhciB2YWx1ZXNQZXJSb3cgPSBNYXRoLmNlaWwoc2hhcGVbMl0gLyAyKTtcbiAgICB2YXIgdGV4ZWxzSW5CYXRjaCA9IHZhbHVlc1BlclJvdyAqIE1hdGguY2VpbChzaGFwZVsxXSAvIDIpO1xuICAgIHZhciBnbHNsID0gZ2V0R2xzbERpZmZlcmVuY2VzKCk7XG4gICAgcmV0dXJuIFwiXFxuICAgIHZlYzQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxcbiAgICAgICAgXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBcIiArIHRleGVsc0luQmF0Y2ggKyBcIiwgXCIgKyB2YWx1ZXNQZXJSb3cgKyBcIiwgYiwgcm93LCBjb2wpO1xcbiAgICAgIHJldHVybiBcIiArIGdsc2wudGV4dHVyZTJEICsgXCIoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyM0QoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzaGFwZVsyXTtcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdO1xuICAgIHZhciBfYSA9IHRmLnV0aWwuc3F1ZWV6ZVNoYXBlKHNoYXBlKSwgbmV3U2hhcGUgPSBfYS5uZXdTaGFwZSwga2VwdERpbXMgPSBfYS5rZXB0RGltcztcbiAgICB2YXIgc3F1ZWV6ZWRTaGFwZSA9IG5ld1NoYXBlO1xuICAgIGlmIChzcXVlZXplZFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV3SW5wdXRJbmZvID0gc3F1ZWV6ZUlucHV0SW5mbyhpbnB1dEluZm8sIHNxdWVlemVkU2hhcGUpO1xuICAgICAgICB2YXIgcGFyYW1zID0gWydyb3cnLCAnY29sJywgJ2RlcHRoJ107XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgXCIgKyBnZXRTYW1wbGVyRnJvbUluSW5mbyhuZXdJbnB1dEluZm8pICsgXCJcXG4gICAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgICAgcmV0dXJuIFwiICsgZnVuY05hbWUgKyBcIihcIiArIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpICsgXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgIH1cbiAgICBpZiAoaW5wdXRJbmZvLnNoYXBlSW5mby5pc1VuaWZvcm0pIHtcbiAgICAgICAgLy8gVW5pZm9ybSBhcnJheXMgd2lsbCBiZSBsZXNzIHRoYW4gNjU1MDUgKG5vIHJpc2sgb2YgZmxvYXQxNiBvdmVyZmxvdykuXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdCh2ZWMzKHJvdywgY29sLCBkZXB0aCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzKFwiICsgc3RyaWRlMCArIFwiLCBcIiArIHN0cmlkZTEgKyBcIiwgMSkpKTtcXG4gICAgICAgIFwiICsgZ2V0VW5pZm9ybVNhbXBsZXIoaW5wdXRJbmZvKSArIFwiXFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0ZXhOdW1DID0gdGV4U2hhcGVbMV07XG4gICAgdmFyIGZsYXRPZmZzZXQgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmZsYXRPZmZzZXQ7XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTAgJiYgZmxhdE9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgIC8vIHRleEMgaXMgdXNlZCBkaXJlY3RseSBhcyBwaHlzaWNhbCAobm8gcmlzayBvZiBmbG9hdDE2IG92ZXJmbG93KS5cbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIGZsb2F0IHRleFIgPSBmbG9hdChyb3cpO1xcbiAgICAgICAgICBmbG9hdCB0ZXhDID0gZG90KHZlYzIoY29sLCBkZXB0aCksIHZlYzIoXCIgKyBzdHJpZGUxICsgXCIsIDEpKTtcXG4gICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTEgJiYgZmxhdE9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgIC8vIHRleFIgaXMgdXNlZCBkaXJlY3RseSBhcyBwaHlzaWNhbCAobm8gcmlzayBvZiBmbG9hdDE2IG92ZXJmbG93KS5cbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKFwiICsgc2hhcGVbMV0gKyBcIiwgMSkpO1xcbiAgICAgIGZsb2F0IHRleEMgPSBmbG9hdChkZXB0aCk7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSBnZXRGbGF0T2Zmc2V0VW5pZm9ybU5hbWUodGV4TmFtZSk7XG4gICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgICAgaW50IGluZGV4ID0gcm93ICogXCIgKyBzdHJpZGUwICsgXCIgKyBjb2wgKiBcIiArIHN0cmlkZTEgKyBcIiArIGRlcHRoICsgXCIgKyBvZmZzZXQgKyBcIjtcXG4gICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiICsgdGV4TnVtUiArIFwiLCBcIiArIHRleE51bUMgKyBcIiwgaW5kZXgpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFBhY2tlZFNhbXBsZXJORChpbnB1dEluZm8pIHtcbiAgICB2YXIgc2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICB2YXIgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgcGFja2VkVGV4U2hhcGUgPSBbTWF0aC5jZWlsKHRleFNoYXBlWzBdIC8gMiksIE1hdGguY2VpbCh0ZXhTaGFwZVsxXSAvIDIpXTtcbiAgICB2YXIgdGV4TnVtUiA9IHBhY2tlZFRleFNoYXBlWzBdO1xuICAgIHZhciB0ZXhOdW1DID0gcGFja2VkVGV4U2hhcGVbMV07XG4gICAgdmFyIHZhbHVlc1BlclJvdyA9IE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMV0gLyAyKTtcbiAgICB2YXIgdGV4ZWxzSW5CYXRjaCA9IHZhbHVlc1BlclJvdyAqIE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMl0gLyAyKTtcbiAgICB2YXIgcGFyYW1zID0gXCJpbnQgYiwgaW50IHJvdywgaW50IGNvbFwiO1xuICAgIHZhciBpbmRleCA9IFwiYiAqIFwiICsgdGV4ZWxzSW5CYXRjaCArIFwiICsgKHJvdyAvIDIpICogXCIgKyB2YWx1ZXNQZXJSb3cgKyBcIiArIChjb2wgLyAyKVwiO1xuICAgIGZvciAodmFyIGIgPSAyOyBiIDwgcmFuayAtIDE7IGIrKykge1xuICAgICAgICBwYXJhbXMgPSBcImludCBiXCIgKyBiICsgXCIsIFwiICsgcGFyYW1zO1xuICAgICAgICB0ZXhlbHNJbkJhdGNoICo9IHNoYXBlW3JhbmsgLSBiIC0gMV07XG4gICAgICAgIGluZGV4ID0gXCJiXCIgKyBiICsgXCIgKiBcIiArIHRleGVsc0luQmF0Y2ggKyBcIiArIFwiICsgaW5kZXg7XG4gICAgfVxuICAgIHZhciBnbHNsID0gZ2V0R2xzbERpZmZlcmVuY2VzKCk7XG4gICAgcmV0dXJuIFwiXFxuICAgIHZlYzQgXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgcGFyYW1zICsgXCIpIHtcXG4gICAgICBpbnQgaW5kZXggPSBcIiArIGluZGV4ICsgXCI7XFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvIFwiICsgdGV4TnVtQyArIFwiO1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogXCIgKyB0ZXhOdW1DICsgXCI7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIsIFwiICsgdGV4TnVtUiArIFwiKTtcXG4gICAgICByZXR1cm4gXCIgKyBnbHNsLnRleHR1cmUyRCArIFwiKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjREKGlucHV0SW5mbykge1xuICAgIHZhciBzaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgc3RyaWRlMiA9IHNoYXBlWzNdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuICAgIHZhciBfYSA9IHRmLnV0aWwuc3F1ZWV6ZVNoYXBlKHNoYXBlKSwgbmV3U2hhcGUgPSBfYS5uZXdTaGFwZSwga2VwdERpbXMgPSBfYS5rZXB0RGltcztcbiAgICBpZiAobmV3U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXdJbnB1dEluZm8gPSBzcXVlZXplSW5wdXRJbmZvKGlucHV0SW5mbywgbmV3U2hhcGUpO1xuICAgICAgICB2YXIgcGFyYW1zID0gWydyb3cnLCAnY29sJywgJ2RlcHRoJywgJ2RlcHRoMiddO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAoaW5wdXRJbmZvLnNoYXBlSW5mby5pc1VuaWZvcm0pIHtcbiAgICAgICAgLy8gVW5pZm9ybSBhcnJheXMgd2lsbCBiZSBsZXNzIHRoYW4gNjU1MDUgKG5vIHJpc2sgb2YgZmxvYXQxNiBvdmVyZmxvdykuXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdCh2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQoXCIgKyBzdHJpZGUwICsgXCIsIFwiICsgc3RyaWRlMSArIFwiLCBcIiArIHN0cmlkZTIgKyBcIiwgMSkpKTtcXG4gICAgICAgIFwiICsgZ2V0VW5pZm9ybVNhbXBsZXIoaW5wdXRJbmZvKSArIFwiXFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgdmFyIGZsYXRPZmZzZXQgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmZsYXRPZmZzZXQ7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0ZXhOdW1DID0gdGV4U2hhcGVbMV07XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTAgJiYgZmxhdE9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgIC8vIHRleEMgaXMgdXNlZCBkaXJlY3RseSBhcyBwaHlzaWNhbCAobm8gcmlzayBvZiBmbG9hdDE2IG92ZXJmbG93KS5cbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGZsb2F0KHJvdyk7XFxuICAgICAgICBmbG9hdCB0ZXhDID1cXG4gICAgICAgICAgICBkb3QodmVjMyhjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICAgICAgICB2ZWMzKFwiICsgc3RyaWRlMSArIFwiLCBcIiArIHN0cmlkZTIgKyBcIiwgMSkpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUyICYmIGZsYXRPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAvLyB0ZXhSIGlzIHVzZWQgZGlyZWN0bHkgYXMgcGh5c2ljYWwgKG5vIHJpc2sgb2YgZmxvYXQxNiBvdmVyZmxvdykuXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjMyhyb3csIGNvbCwgZGVwdGgpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzKFwiICsgc2hhcGVbMV0gKiBzaGFwZVsyXSArIFwiLCBcIiArIHNoYXBlWzJdICsgXCIsIDEpKTtcXG4gICAgICAgIGZsb2F0IHRleEMgPSBmbG9hdChkZXB0aDIpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IGdldEZsYXRPZmZzZXRVbmlmb3JtTmFtZSh0ZXhOYW1lKTtcbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIiArIHN0cmlkZTAgKyBcIiArIGNvbCAqIFwiICsgc3RyaWRlMSArIFwiICtcXG4gICAgICAgICAgZGVwdGggKiBcIiArIHN0cmlkZTIgKyBcIiArIGRlcHRoMjtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIiArIHRleE51bVIgKyBcIiwgXCIgKyB0ZXhOdW1DICsgXCIsIGluZGV4ICsgXCIgKyBvZmZzZXQgKyBcIik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyNUQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciBzdHJpZGUzID0gc2hhcGVbNF07XG4gICAgdmFyIHN0cmlkZTIgPSBzaGFwZVszXSAqIHN0cmlkZTM7XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG4gICAgdmFyIF9hID0gdGYudXRpbC5zcXVlZXplU2hhcGUoc2hhcGUpLCBuZXdTaGFwZSA9IF9hLm5ld1NoYXBlLCBrZXB0RGltcyA9IF9hLmtlcHREaW1zO1xuICAgIGlmIChuZXdTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBuZXdTaGFwZSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnLCAnZGVwdGgyJywgJ2RlcHRoMyddO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAoaW5wdXRJbmZvLnNoYXBlSW5mby5pc1VuaWZvcm0pIHtcbiAgICAgICAgLy8gVW5pZm9ybSBhcnJheXMgd2lsbCBiZSBsZXNzIHRoYW4gNjU1MDUgKG5vIHJpc2sgb2YgZmxvYXQxNiBvdmVyZmxvdykuXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIiArIHN0cmlkZTAgKyBcIiwgXCIgKyBzdHJpZGUxICsgXCIsIFwiICsgc3RyaWRlMiArIFwiLCBcIiArIHN0cmlkZTMgKyBcIikpICtcXG4gICAgICAgICAgZGVwdGgzO1xcbiAgICAgICAgXCIgKyBnZXRVbmlmb3JtU2FtcGxlcihpbnB1dEluZm8pICsgXCJcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICB2YXIgZmxhdE9mZnNldCA9IGlucHV0SW5mby5zaGFwZUluZm8uZmxhdE9mZnNldDtcbiAgICB2YXIgdGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciB0ZXhOdW1SID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlMCAmJiBmbGF0T2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgLy8gdGV4QyBpcyB1c2VkIGRpcmVjdGx5IGFzIHBoeXNpY2FsIChubyByaXNrIG9mIGZsb2F0MTYgb3ZlcmZsb3cpLlxuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjNChjb2wsIGRlcHRoLCBkZXB0aDIsIGRlcHRoMyksXFxuICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQoXCIgKyBzdHJpZGUxICsgXCIsIFwiICsgc3RyaWRlMiArIFwiLCBcIiArIHN0cmlkZTMgKyBcIiwgMSkpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUzICYmIGZsYXRPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAvLyB0ZXhSIGlzIHVzZWQgZGlyZWN0bHkgYXMgcGh5c2ljYWwgKG5vIHJpc2sgb2YgZmxvYXQxNiBvdmVyZmxvdykuXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QoXFxuICAgICAgICAgIHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICB2ZWM0KFwiICsgc2hhcGVbMV0gKiBzaGFwZVsyXSAqIHNoYXBlWzNdICsgXCIsXFxuICAgICAgICAgICAgICAgXCIgKyBzaGFwZVsyXSAqIHNoYXBlWzNdICsgXCIsIFwiICsgc2hhcGVbM10gKyBcIiwgMSkpO1xcbiAgICAgICAgaW50IHRleEMgPSBkZXB0aDM7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gZ2V0RmxhdE9mZnNldFVuaWZvcm1OYW1lKHRleE5hbWUpO1xuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiICsgc3RyaWRlMCArIFwiICsgY29sICogXCIgKyBzdHJpZGUxICsgXCIgKyBkZXB0aCAqIFwiICsgc3RyaWRlMiArIFwiICtcXG4gICAgICAgICAgZGVwdGgyICogXCIgKyBzdHJpZGUzICsgXCIgKyBkZXB0aDMgKyBcIiArIG9mZnNldCArIFwiO1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiICsgdGV4TnVtUiArIFwiLCBcIiArIHRleE51bUMgKyBcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjZEKGlucHV0SW5mbykge1xuICAgIHZhciBzaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgX2EgPSB0Zi51dGlsLnNxdWVlemVTaGFwZShzaGFwZSksIG5ld1NoYXBlID0gX2EubmV3U2hhcGUsIGtlcHREaW1zID0gX2Eua2VwdERpbXM7XG4gICAgaWYgKG5ld1NoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV3SW5wdXRJbmZvID0gc3F1ZWV6ZUlucHV0SW5mbyhpbnB1dEluZm8sIG5ld1NoYXBlKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInLCAnZGVwdGgzJywgJ2RlcHRoNCddO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgdmFyIHN0cmlkZTQgPSBzaGFwZVs1XTtcbiAgICB2YXIgc3RyaWRlMyA9IHNoYXBlWzRdICogc3RyaWRlNDtcbiAgICB2YXIgc3RyaWRlMiA9IHNoYXBlWzNdICogc3RyaWRlMztcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICB2YXIgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcbiAgICBpZiAoaW5wdXRJbmZvLnNoYXBlSW5mby5pc1VuaWZvcm0pIHtcbiAgICAgICAgLy8gVW5pZm9ybSBhcnJheXMgd2lsbCBiZSBsZXNzIHRoYW4gNjU1MDUgKG5vIHJpc2sgb2YgZmxvYXQxNiBvdmVyZmxvdykuXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIiArIHN0cmlkZTAgKyBcIiwgXCIgKyBzdHJpZGUxICsgXCIsIFwiICsgc3RyaWRlMiArIFwiLCBcIiArIHN0cmlkZTMgKyBcIikpICtcXG4gICAgICAgICAgZG90KFxcbiAgICAgICAgICAgIHZlYzIoZGVwdGgzLCBkZXB0aDQpLFxcbiAgICAgICAgICAgIHZlYzIoXCIgKyBzdHJpZGU0ICsgXCIsIDEpKSk7XFxuICAgICAgICBcIiArIGdldFVuaWZvcm1TYW1wbGVyKGlucHV0SW5mbykgKyBcIlxcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHZhciBmbGF0T2Zmc2V0ID0gaW5wdXRJbmZvLnNoYXBlSW5mby5mbGF0T2Zmc2V0O1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHRleE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUwICYmIGZsYXRPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAvLyB0ZXhDIGlzIHVzZWQgZGlyZWN0bHkgYXMgcGh5c2ljYWwgKG5vIHJpc2sgb2YgZmxvYXQxNiBvdmVyZmxvdykuXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjNChjb2wsIGRlcHRoLCBkZXB0aDIsIGRlcHRoMyksXFxuICAgICAgICAgIHZlYzQoXCIgKyBzdHJpZGUxICsgXCIsIFwiICsgc3RyaWRlMiArIFwiLCBcIiArIHN0cmlkZTMgKyBcIiwgXCIgKyBzdHJpZGU0ICsgXCIpKSArXFxuICAgICAgICAgICAgICAgZmxvYXQoZGVwdGg0KTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlNCAmJiBmbGF0T2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgLy8gdGV4UiBpcyB1c2VkIGRpcmVjdGx5IGFzIHBoeXNpY2FsIChubyByaXNrIG9mIGZsb2F0MTYgb3ZlcmZsb3cpLlxuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIiArIHNoYXBlWzFdICogc2hhcGVbMl0gKiBzaGFwZVszXSAqIHNoYXBlWzRdICsgXCIsXFxuICAgICAgICAgICAgICAgXCIgKyBzaGFwZVsyXSAqIHNoYXBlWzNdICogc2hhcGVbNF0gKyBcIixcXG4gICAgICAgICAgICAgICBcIiArIHNoYXBlWzNdICogc2hhcGVbNF0gKyBcIixcXG4gICAgICAgICAgICAgICBcIiArIHNoYXBlWzRdICsgXCIpKSArIGZsb2F0KGRlcHRoMyk7XFxuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoNDtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSBnZXRGbGF0T2Zmc2V0VW5pZm9ybU5hbWUodGV4TmFtZSk7XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIiArIHN0cmlkZTAgKyBcIiArIGNvbCAqIFwiICsgc3RyaWRlMSArIFwiICsgZGVwdGggKiBcIiArIHN0cmlkZTIgKyBcIiArXFxuICAgICAgICAgIGRlcHRoMiAqIFwiICsgc3RyaWRlMyArIFwiICsgZGVwdGgzICogXCIgKyBzdHJpZGU0ICsgXCIgKyBkZXB0aDQgKyBcIiArIG9mZnNldCArIFwiO1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiICsgdGV4TnVtUiArIFwiLCBcIiArIHRleE51bUMgKyBcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0VW5pZm9ybVNhbXBsZXIoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgaW5TaXplID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlKTtcbiAgICBpZiAoaW5TaXplIDwgMikge1xuICAgICAgICByZXR1cm4gXCJyZXR1cm4gXCIgKyB0ZXhOYW1lICsgXCI7XCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgaW5TaXplICsgXCI7IGkrKykge1xcbiAgICAgIGlmIChpID09IGluZGV4KSB7XFxuICAgICAgICByZXR1cm4gXCIgKyB0ZXhOYW1lICsgXCJbaV07XFxuICAgICAgfVxcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhpbnB1dEluZm8sIG91dFNoYXBlSW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIHRleEZ1bmNTbmlwcGV0ID0gdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhGdW5jU25pcHBldCArICdBdE91dENvb3Jkcyc7XG4gICAgdmFyIGluUmFuayA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgb3V0UmFuayA9IG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoO1xuICAgIHZhciBicm9hZGNhc3REaW1zID0gZ2V0QnJvYWRjYXN0RGltcyhpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSwgb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7XG4gICAgdmFyIHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRSYW5rKTtcbiAgICB2YXIgcmFua0RpZmYgPSBvdXRSYW5rIC0gaW5SYW5rO1xuICAgIHZhciBjb29yZHNTbmlwcGV0O1xuICAgIHZhciBmaWVsZHMgPSBbJ3gnLCAneScsICd6JywgJ3cnLCAndScsICd2J107XG4gICAgaWYgKGluUmFuayA9PT0gMCkge1xuICAgICAgICBjb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dFJhbmsgPCAyICYmIGJyb2FkY2FzdERpbXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgY29vcmRzU25pcHBldCA9ICdjb29yZHMgPSAwOyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb29yZHNTbmlwcGV0ID1cbiAgICAgICAgICAgIGJyb2FkY2FzdERpbXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBcImNvb3Jkcy5cIiArIGZpZWxkc1tkICsgcmFua0RpZmZdICsgXCIgPSAwO1wiOyB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgdmFyIHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9ICdjb29yZHMnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGVcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMsIGkpIHsgcmV0dXJuIFwiY29vcmRzLlwiICsgZmllbGRzW2kgKyByYW5rRGlmZl07IH0pXG4gICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IFwicmV0dXJuIG91dHB1dFZhbHVlO1wiO1xuICAgIHZhciBpblNpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUoaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO1xuICAgIHZhciBpc0lucHV0U2NhbGFyID0gaW5TaXplID09PSAxO1xuICAgIHZhciBvdXRTaXplID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO1xuICAgIHZhciBpc091dHB1dFNjYWxhciA9IG91dFNpemUgPT09IDE7XG4gICAgaWYgKGluUmFuayA9PT0gMSAmJiAhaXNJbnB1dFNjYWxhciAmJiAhaXNPdXRwdXRTY2FsYXIpIHtcbiAgICAgICAgb3V0cHV0ID0gXCJcXG4gICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eSwgb3V0cHV0VmFsdWUueHkpO1xcbiAgICBcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNJbnB1dFNjYWxhciAmJiAhaXNPdXRwdXRTY2FsYXIpIHtcbiAgICAgICAgaWYgKG91dFJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IFwiXFxuICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS54LCAwLiwgMC4pO1xcbiAgICAgIFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0gXCJcXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1xcbiAgICAgIFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb2FkY2FzdERpbXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciByb3dzID0gaW5SYW5rIC0gMjtcbiAgICAgICAgdmFyIGNvbHMgPSBpblJhbmsgLSAxO1xuICAgICAgICBpZiAoYnJvYWRjYXN0RGltcy5pbmRleE9mKHJvd3MpID4gLTEgJiYgYnJvYWRjYXN0RGltcy5pbmRleE9mKGNvbHMpID4gLTEpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IFwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnJvYWRjYXN0RGltcy5pbmRleE9mKHJvd3MpID4gLTEpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IFwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgXCIgK1xuICAgICAgICAgICAgICAgIFwib3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnJvYWRjYXN0RGltcy5pbmRleE9mKGNvbHMpID4gLTEpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IFwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHgsIG91dHB1dFZhbHVlLnp6KTtcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgdmVjNCBcIiArIGZ1bmNOYW1lICsgXCIoKSB7XFxuICAgICAgXCIgKyB0eXBlICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgXCIgKyBjb29yZHNTbmlwcGV0ICsgXCJcXG4gICAgICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0XCIgKyB0ZXhGdW5jU25pcHBldCArIFwiKFwiICsgdW5wYWNrZWRDb29yZHNTbmlwcGV0ICsgXCIpO1xcbiAgICAgIFwiICsgb3V0cHV0ICsgXCJcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyQXRPdXRwdXRDb29yZHMoaW5wdXRJbmZvLCBvdXRTaGFwZUluZm8pIHtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciB0ZXhGdW5jU25pcHBldCA9IHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4RnVuY1NuaXBwZXQgKyAnQXRPdXRDb29yZHMnO1xuICAgIHZhciBvdXRUZXhTaGFwZSA9IG91dFNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgaW5UZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIGluUmFuayA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgb3V0UmFuayA9IG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoO1xuICAgIGlmICghaW5wdXRJbmZvLnNoYXBlSW5mby5pc1VuaWZvcm0gJiYgaW5SYW5rID09PSBvdXRSYW5rICYmXG4gICAgICAgIGlucHV0SW5mby5zaGFwZUluZm8uZmxhdE9mZnNldCA9PSBudWxsICYmXG4gICAgICAgIHRmLnV0aWwuYXJyYXlzRXF1YWwoaW5UZXhTaGFwZSwgb3V0VGV4U2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCByZXN1bHRVVik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRSYW5rKTtcbiAgICB2YXIgYnJvYWRjYXN0RGltcyA9IGdldEJyb2FkY2FzdERpbXMoaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsIG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO1xuICAgIHZhciByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG4gICAgdmFyIGNvb3Jkc1NuaXBwZXQ7XG4gICAgdmFyIGZpZWxkcyA9IFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXTtcbiAgICBpZiAoaW5SYW5rID09PSAwKSB7XG4gICAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0UmFuayA8IDIgJiYgYnJvYWRjYXN0RGltcy5sZW5ndGggPj0gMSkge1xuICAgICAgICBjb29yZHNTbmlwcGV0ID0gJ2Nvb3JkcyA9IDA7JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvb3Jkc1NuaXBwZXQgPVxuICAgICAgICAgICAgYnJvYWRjYXN0RGltcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIFwiY29vcmRzLlwiICsgZmllbGRzW2QgKyByYW5rRGlmZl0gKyBcIiA9IDA7XCI7IH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICB2YXIgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgaWYgKG91dFJhbmsgPCAyICYmIGluUmFuayA+IDApIHtcbiAgICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJ2Nvb3Jkcyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocywgaSkgeyByZXR1cm4gXCJjb29yZHMuXCIgKyBmaWVsZHNbaSArIHJhbmtEaWZmXTsgfSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgIFwiICsgdHlwZSArIFwiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIFwiICsgY29vcmRzU25pcHBldCArIFwiXFxuICAgICAgcmV0dXJuIGdldFwiICsgdGV4RnVuY1NuaXBwZXQgKyBcIihcIiArIHVucGFja2VkQ29vcmRzU25pcHBldCArIFwiKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRDb29yZHNEYXRhVHlwZShyYW5rKSB7XG4gICAgaWYgKHJhbmsgPD0gMSkge1xuICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjMic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjMyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjNCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDUpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjNSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDYpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjNic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkdQVSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG4vKiogUmV0dXJucyBhIG5ldyBpbnB1dCBpbmZvIChhIGNvcHkpIHRoYXQgaGFzIGEgc3F1ZWV6ZWQgbG9naWNhbCBzaGFwZS4gKi9cbmZ1bmN0aW9uIHNxdWVlemVJbnB1dEluZm8oaW5JbmZvLCBzcXVlZXplZFNoYXBlKSB7XG4gICAgLy8gRGVlcCBjb3B5LlxuICAgIHZhciBuZXdJbnB1dEluZm8gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGluSW5mbykpO1xuICAgIG5ld0lucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlID0gc3F1ZWV6ZWRTaGFwZTtcbiAgICByZXR1cm4gbmV3SW5wdXRJbmZvO1xufVxuZnVuY3Rpb24gZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykge1xuICAgIHJldHVybiBrZXB0RGltcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHBhcmFtc1tkXTsgfSkuam9pbignLCAnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZVByb2dyYW0oZ3BncHUsIHByb2dyYW0sIGlucHV0cywgb3V0cHV0KSB7XG4gICAgdmFyIHVzZXJDb2RlID0gcHJvZ3JhbS51c2VyQ29kZTtcbiAgICB2YXIgaW5wdXRJbmZvcyA9IGlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBpKSB7XG4gICAgICAgIHZhciBzaGFwZUluZm8gPSB7XG4gICAgICAgICAgICBsb2dpY2FsU2hhcGU6IGlucHV0LnNoYXBlLFxuICAgICAgICAgICAgdGV4U2hhcGU6IGlucHV0LmlzVW5pZm9ybSA/IG51bGwgOiBpbnB1dC50ZXhEYXRhLnRleFNoYXBlLFxuICAgICAgICAgICAgaXNVbmlmb3JtOiBpbnB1dC5pc1VuaWZvcm0sXG4gICAgICAgICAgICBpc1BhY2tlZDogaW5wdXQuaXNVbmlmb3JtID8gZmFsc2UgOiBpbnB1dC50ZXhEYXRhLmlzUGFja2VkLFxuICAgICAgICAgICAgZmxhdE9mZnNldDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5wdXQudGV4RGF0YSAhPSBudWxsICYmIGlucHV0LnRleERhdGEuc2xpY2UgIT0gbnVsbCAmJlxuICAgICAgICAgICAgaW5wdXQudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgc2hhcGVJbmZvLmZsYXRPZmZzZXQgPSBpbnB1dC50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbmFtZTogcHJvZ3JhbS52YXJpYWJsZU5hbWVzW2ldLCBzaGFwZUluZm86IHNoYXBlSW5mbyB9O1xuICAgIH0pO1xuICAgIHZhciBpblNoYXBlSW5mb3MgPSBpbnB1dEluZm9zLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaGFwZUluZm87IH0pO1xuICAgIHZhciBvdXRTaGFwZUluZm8gPSB7XG4gICAgICAgIGxvZ2ljYWxTaGFwZTogb3V0cHV0LnNoYXBlLFxuICAgICAgICB0ZXhTaGFwZTogb3V0cHV0LnRleERhdGEudGV4U2hhcGUsXG4gICAgICAgIGlzVW5pZm9ybTogZmFsc2UsXG4gICAgICAgIGlzUGFja2VkOiBvdXRwdXQudGV4RGF0YS5pc1BhY2tlZCxcbiAgICAgICAgZmxhdE9mZnNldDogbnVsbFxuICAgIH07XG4gICAgdmFyIHNvdXJjZSA9IG1ha2VTaGFkZXIoaW5wdXRJbmZvcywgb3V0U2hhcGVJbmZvLCB1c2VyQ29kZSwgcHJvZ3JhbS5wYWNrZWRJbnB1dHMpO1xuICAgIHZhciB3ZWJHTFByb2dyYW0gPSBncGdwdS5jcmVhdGVQcm9ncmFtKHNvdXJjZSk7XG4gICAgLy8gQWRkIHNwZWNpYWwgdW5pZm9ybXMgKE5BTiwgSU5GSU5JVFkpXG4gICAgdmFyIGluZkxvYyA9IG51bGw7XG4gICAgdmFyIG5hbkxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sICdOQU4nLCBmYWxzZSk7XG4gICAgaWYgKHRmLmVudigpLmdldE51bWJlcignV0VCR0xfVkVSU0lPTicpID09PSAxKSB7XG4gICAgICAgIGluZkxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sICdJTkZJTklUWScsIGZhbHNlKTtcbiAgICB9XG4gICAgLy8gQWRkIHVzZXItZGVmaW5lZCB1bmlmb3Jtc1xuICAgIHZhciB1bmlmb3JtTG9jYXRpb25zID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9ncmFtLnZhcmlhYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhck5hbWUgPSBwcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV07XG4gICAgICAgIHZhciBzaG91bGRUaHJvdyA9IGZhbHNlO1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zW3Zhck5hbWVdID1cbiAgICAgICAgICAgIGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sIHZhck5hbWUsIHNob3VsZFRocm93KTtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uc1tcIm9mZnNldFwiICsgdmFyTmFtZV0gPVxuICAgICAgICAgICAgZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgXCJvZmZzZXRcIiArIHZhck5hbWUsIHNob3VsZFRocm93KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHdlYkdMUHJvZ3JhbTogd2ViR0xQcm9ncmFtLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zOiB1bmlmb3JtTG9jYXRpb25zLFxuICAgICAgICBpblNoYXBlSW5mb3M6IGluU2hhcGVJbmZvcyxcbiAgICAgICAgb3V0U2hhcGVJbmZvOiBvdXRTaGFwZUluZm8sXG4gICAgICAgIGluZkxvYzogaW5mTG9jLFxuICAgICAgICBuYW5Mb2M6IG5hbkxvYyxcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKHNoYXBlSW5mb3MsIGlucHV0cykge1xuICAgIGlmIChzaGFwZUluZm9zLmxlbmd0aCAhPT0gaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBcIiArIHNoYXBlSW5mb3MubGVuZ3RoICsgXCIgaW5wdXRzLCBidXQgXCIgK1xuICAgICAgICAgICAgKFwid2FzIGV4ZWN1dGVkIHdpdGggXCIgKyBpbnB1dHMubGVuZ3RoICsgXCIgaW5wdXRzXCIpKTtcbiAgICB9XG4gICAgc2hhcGVJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgIHZhciBzaGFwZUEgPSBzLmxvZ2ljYWxTaGFwZTtcbiAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzW2ldO1xuICAgICAgICB2YXIgc2hhcGVCID0gaW5wdXQuc2hhcGU7XG4gICAgICAgIGlmICghdGYudXRpbC5hcnJheXNFcXVhbChzaGFwZUEsIHNoYXBlQikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCBzaGFwZXMgdGhhbiBcIiArXG4gICAgICAgICAgICAgICAgKFwidGhlIGN1cnJlbnQgYXJncy4gU2hhcGVzIFwiICsgc2hhcGVBICsgXCIgYW5kIFwiICsgc2hhcGVCICsgXCIgbXVzdCBtYXRjaFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGlucHV0IGlzIHVwbG9hZGVkIGFzIHVuaWZvcm0uXG4gICAgICAgIGlmIChzLmlzVW5pZm9ybSAmJiBpbnB1dC5pc1VuaWZvcm0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4U2hhcGVBID0gcy50ZXhTaGFwZTtcbiAgICAgICAgdmFyIHRleFNoYXBlQiA9IGlucHV0LmlzVW5pZm9ybSA/IG51bGwgOiBpbnB1dC50ZXhEYXRhLnRleFNoYXBlO1xuICAgICAgICBpZiAoIXRmLnV0aWwuYXJyYXlzRXF1YWwodGV4U2hhcGVBLCB0ZXhTaGFwZUIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgdGV4dHVyZSBzaGFwZXMgdGhhbiB0aGVcIiArXG4gICAgICAgICAgICAgICAgKFwiIGN1cnJlbnQgYXJncy4gU2hhcGUgXCIgKyB0ZXhTaGFwZUEgKyBcIiBhbmQgXCIgKyB0ZXhTaGFwZUIgKyBcIiBtdXN0IG1hdGNoXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcnVuUHJvZ3JhbShncGdwdSwgYmluYXJ5LCBpbnB1dHMsIG91dHB1dCwgY3VzdG9tU2V0dXApIHtcbiAgICB2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0oYmluYXJ5LmluU2hhcGVJbmZvcywgaW5wdXRzKTtcbiAgICB2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0oW2JpbmFyeS5vdXRTaGFwZUluZm9dLCBbb3V0cHV0XSk7XG4gICAgdmFyIG91dFRleCA9IG91dHB1dC50ZXhEYXRhLnRleHR1cmU7XG4gICAgdmFyIG91dFRleFNoYXBlID0gb3V0cHV0LnRleERhdGEudGV4U2hhcGU7XG4gICAgaWYgKG91dHB1dC50ZXhEYXRhLmlzUGFja2VkKSB7XG4gICAgICAgIGdwZ3B1LnNldE91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUob3V0VGV4LCBvdXRUZXhTaGFwZVswXSwgb3V0VGV4U2hhcGVbMV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShvdXRUZXgsIG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSk7XG4gICAgfVxuICAgIGdwZ3B1LnNldFByb2dyYW0oYmluYXJ5LndlYkdMUHJvZ3JhbSk7XG4gICAgLy8gU2V0IHNwZWNpYWwgdW5pZm9ybXMgKE5BTiwgSU5GSU5JVFkpXG4gICAgaWYgKHRmLmVudigpLmdldE51bWJlcignV0VCR0xfVkVSU0lPTicpID09PSAxKSB7XG4gICAgICAgIGlmIChiaW5hcnkuaW5mTG9jICE9PSBudWxsKSB7XG4gICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMWYoYmluYXJ5LmluZkxvYywgSW5maW5pdHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChiaW5hcnkubmFuTG9jICE9PSBudWxsKSB7XG4gICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihiaW5hcnkubmFuTG9jLCBOYU4pO1xuICAgIH1cbiAgICAvLyBTZXQgdXNlci1kZWZpbmVkIGlucHV0c1xuICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCwgaSkge1xuICAgICAgICB2YXIgdmFyTmFtZSA9IGJpbmFyeS5wcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV07XG4gICAgICAgIHZhciB2YXJMb2MgPSBiaW5hcnkudW5pZm9ybUxvY2F0aW9uc1t2YXJOYW1lXTtcbiAgICAgICAgdmFyIHZhck9mZnNldExvYyA9IGJpbmFyeS51bmlmb3JtTG9jYXRpb25zW1wib2Zmc2V0XCIgKyB2YXJOYW1lXTtcbiAgICAgICAgaWYgKHZhckxvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29tcGlsZXIgaW5mZXJyZWQgdGhhdCB0aGlzIHZhcmlhYmxlIGlzIG5vdCB1c2VkIGluIHRoaXMgc2hhZGVyLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC5pc1VuaWZvcm0pIHtcbiAgICAgICAgICAgIC8vIFVwbG9hZCB0aGUgdmFsdWVzIG9mIHRoZSB0ZW5zb3IgYXMgdW5pZm9ybS5cbiAgICAgICAgICAgIGlmICh0Zi51dGlsLnNpemVGcm9tU2hhcGUoaW5wdXQuc2hhcGUpIDwgMikge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZih2YXJMb2MsIGlucHV0LnVuaWZvcm1WYWx1ZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHMgPSBpbnB1dC51bmlmb3JtVmFsdWVzO1xuICAgICAgICAgICAgICAgIGlmICghKHZhbHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMWZ2KHZhckxvYywgdmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IHdhcyBzbGljZWQsIHVwbG9hZCB0aGUgZmxhdCBvZmZzZXQgaW5kZXguXG4gICAgICAgIGlmIChpbnB1dC50ZXhEYXRhLnNsaWNlICE9IG51bGwgJiYgdmFyT2Zmc2V0TG9jICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xaSh2YXJPZmZzZXRMb2MsIGlucHV0LnRleERhdGEuc2xpY2UuZmxhdE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKGlucHV0LnRleERhdGEudGV4dHVyZSwgdmFyTG9jLCBpKTtcbiAgICB9KTtcbiAgICBpZiAoY3VzdG9tU2V0dXAgIT0gbnVsbCkge1xuICAgICAgICBjdXN0b21TZXR1cChncGdwdSwgYmluYXJ5LndlYkdMUHJvZ3JhbSk7XG4gICAgfVxuICAgIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG5mdW5jdGlvbiBtYWtlU2hhZGVyS2V5KHByb2dyYW0sIGlucHV0cywgb3V0cHV0KSB7XG4gICAgdmFyIGtleUlucHV0cyA9ICcnO1xuICAgIGlucHV0cy5jb25jYXQob3V0cHV0KS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBoYXNPZmZzZXQgPSB4LnRleERhdGEgIT0gbnVsbCAmJiB4LnRleERhdGEuc2xpY2UgIT0gbnVsbCAmJlxuICAgICAgICAgICAgeC50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQgPiAwO1xuICAgICAgICB2YXIgdGV4U2hhcGUgPSB4LmlzVW5pZm9ybSA/ICd1bmlmb3JtJyA6IHgudGV4RGF0YS50ZXhTaGFwZTtcbiAgICAgICAga2V5SW5wdXRzICs9IHguc2hhcGUgKyBcIl9cIiArIHRleFNoYXBlICsgXCJfXCIgKyBoYXNPZmZzZXQ7XG4gICAgfSk7XG4gICAgdmFyIGtleVVzZXJDb2RlID0gcHJvZ3JhbS51c2VyQ29kZTtcbiAgICB2YXIga2V5ID0gcHJvZ3JhbS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIC8vIEZhc3Qgc3RyaW5nIGNvbmNhdC4gU2VlIGh0dHBzOi8vanNwZXJmLmNvbS9zdHJpbmctY29uY2F0ZW5hdGlvbi8xNC5cbiAgICBrZXkgKz0gJ18nICsga2V5SW5wdXRzICsgJ18nICsga2V5VXNlckNvZGU7XG4gICAgcmV0dXJuIGtleTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUFic0ltcGwodmFscykge1xuICAgIGNvbnN0IHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFscy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmFicyh2YWxzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFZhbHVlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBUZW1wbGF0ZSB0aGF0IGNyZWF0ZXMgaW1wbGVtZW50YXRpb24gZm9yIGJpbmFyeSBvcHMuIFN1cHBvcnRzIGJyb2FkY2FzdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2ltcGxlQmluYXJ5S2VybmVsSW1wbChvcCkge1xuICAgIHJldHVybiAoYVNoYXBlLCBiU2hhcGUsIGFWYWxzLCBiVmFscywgZHR5cGUpID0+IHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB0Zi5iYWNrZW5kX3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYVNoYXBlLCBiU2hhcGUpO1xuICAgICAgICBjb25zdCByZXN1bHRSYW5rID0gbmV3U2hhcGUubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHRTdHJpZGVzID0gdGYudXRpbC5jb21wdXRlU3RyaWRlcyhuZXdTaGFwZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdFNpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0Zi51dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoZHR5cGUsIHJlc3VsdFNpemUpO1xuICAgICAgICBjb25zdCBhUmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJSYW5rID0gYlNoYXBlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYVN0cmlkZXMgPSB0Zi51dGlsLmNvbXB1dGVTdHJpZGVzKGFTaGFwZSk7XG4gICAgICAgIGNvbnN0IGJTdHJpZGVzID0gdGYudXRpbC5jb21wdXRlU3RyaWRlcyhiU2hhcGUpO1xuICAgICAgICBjb25zdCBhQnJvYWRjYXN0RGltcyA9IHRmLmJhY2tlbmRfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGFTaGFwZSwgbmV3U2hhcGUpO1xuICAgICAgICBjb25zdCBiQnJvYWRjYXN0RGltcyA9IHRmLmJhY2tlbmRfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGJTaGFwZSwgbmV3U2hhcGUpO1xuICAgICAgICBpZiAoYUJyb2FkY2FzdERpbXMubGVuZ3RoICsgYkJyb2FkY2FzdERpbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IG9wKGFWYWxzW2kgJSBhVmFscy5sZW5ndGhdLCBiVmFsc1tpICUgYlZhbHMubGVuZ3RoXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYyA9IHRmLnV0aWwuaW5kZXhUb0xvYyhpLCByZXN1bHRSYW5rLCByZXN1bHRTdHJpZGVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhTG9jID0gbG9jLnNsaWNlKC1hUmFuayk7XG4gICAgICAgICAgICAgICAgYUJyb2FkY2FzdERpbXMuZm9yRWFjaChkID0+IGFMb2NbZF0gPSAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhSW5kZXggPSB0Zi51dGlsLmxvY1RvSW5kZXgoYUxvYywgYVJhbmssIGFTdHJpZGVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiTG9jID0gbG9jLnNsaWNlKC1iUmFuayk7XG4gICAgICAgICAgICAgICAgYkJyb2FkY2FzdERpbXMuZm9yRWFjaChkID0+IGJMb2NbZF0gPSAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiSW5kZXggPSB0Zi51dGlsLmxvY1RvSW5kZXgoYkxvYywgYlJhbmssIGJTdHJpZGVzKTtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBvcChhVmFsc1thSW5kZXhdLCBiVmFsc1tiSW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3Jlc3VsdCwgbmV3U2hhcGVdO1xuICAgIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmNvbnN0IGFkZEltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKCgoYSwgYikgPT4gYSArIGIpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gYmluY291bnRJbXBsKHhWYWxzLCB3ZWlnaHRzVmFscywgd2VpZ2h0c0R0eXBlLCB3ZWlnaHRzU2hhcGUsIHNpemUpIHtcbiAgICBjb25zdCB3ZWlnaHRzU2l6ZSA9IHRmLnV0aWwuc2l6ZUZyb21TaGFwZSh3ZWlnaHRzU2hhcGUpO1xuICAgIGNvbnN0IG91dFZhbHMgPSB0Zi51dGlsLm1ha2VaZXJvc1R5cGVkQXJyYXkoc2l6ZSwgd2VpZ2h0c0R0eXBlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHhWYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0geFZhbHNbaV07XG4gICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgeCBtdXN0IGJlIG5vbi1uZWdhdGl2ZSEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPj0gc2l6ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlaWdodHNTaXplID4gMCkge1xuICAgICAgICAgICAgb3V0VmFsc1t2YWx1ZV0gKz0gd2VpZ2h0c1ZhbHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRWYWxzW3ZhbHVlXSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRWYWxzO1xufVxuZnVuY3Rpb24gYmluY291bnRSZWR1Y2VJbXBsKHhCdWYsIHdlaWdodHNCdWYsIHNpemUsIGJpbmFyeU91dHB1dCA9IGZhbHNlKSB7XG4gICAgY29uc3QgbnVtUm93cyA9IHhCdWYuc2hhcGVbMF07XG4gICAgY29uc3QgbnVtQ29scyA9IHhCdWYuc2hhcGVbMV07XG4gICAgY29uc3Qgb3V0QnVmID0gdGYuYnVmZmVyKFtudW1Sb3dzLCBzaXplXSwgd2VpZ2h0c0J1Zi5kdHlwZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Sb3dzOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1Db2xzOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0geEJ1Zi5nZXQoaSwgaik7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCB4IG11c3QgYmUgbm9uLW5lZ2F0aXZlIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID49IHNpemUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5hcnlPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBvdXRCdWYuc2V0KDEsIGksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh3ZWlnaHRzQnVmLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dEJ1Zi5zZXQob3V0QnVmLmdldChpLCB2YWx1ZSkgKyB3ZWlnaHRzQnVmLmdldChpLCBqKSwgaSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0QnVmLnNldChvdXRCdWYuZ2V0KGksIHZhbHVlKSArIDEsIGksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dEJ1Zjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBUZW1wbGF0ZSB0aGF0IGNyZWF0ZXMgaW1wbGVtZW50YXRpb24gZm9yIHVuYXJ5IG9wLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVVbmFyeUltcGwob3ApIHtcbiAgICByZXR1cm4gKHZhbHVlcywgZHR5cGUsIGF0dHJzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlcyA9IHRmLnV0aWwuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShkdHlwZSwgdmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBvcCh2YWx1ZXNbaV0sIGF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3VmFsdWVzO1xuICAgIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5jb25zdCBjZWlsSW1wbCA9IGNyZWF0ZVNpbXBsZVVuYXJ5SW1wbCgoeGkpID0+IE1hdGguY2VpbCh4aSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBjb25jYXRJbXBsKGlucHV0cywgb3V0U2hhcGUsIGR0eXBlLCBzaW1wbHlDb25jYXQpIHtcbiAgICBjb25zdCBvdXRWYWxzID0gdGYudXRpbC5nZXRBcnJheUZyb21EVHlwZShkdHlwZSwgdGYudXRpbC5zaXplRnJvbVNoYXBlKG91dFNoYXBlKSk7XG4gICAgaWYgKHNpbXBseUNvbmNhdCAmJiBkdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gVXNlIGJ1aWx0LWluIFR5cGVkQXJyYXkuc2V0KCkgbWV0aG9kIGZvciBzcGVlZC5cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUoaW5wdXQuc2hhcGUpO1xuICAgICAgICAgICAgb3V0VmFscy5zZXQoaW5wdXQudmFscywgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBjb2xPZmZzZXQgPSAwO1xuICAgICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkRGF0YSA9IGR0eXBlID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAgICAgdGYuYmFja2VuZF91dGlsLmZyb21VaW50OFRvU3RyaW5nQXJyYXkoaW5wdXQudmFscykgOlxuICAgICAgICAgICAgICAgIGlucHV0LnZhbHM7XG4gICAgICAgICAgICBsZXQgdElkeCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBpbnB1dC5zaGFwZVswXTsgKytyb3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNJZHggPSByb3cgKiBvdXRTaGFwZVsxXSArIGNvbE9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBpbnB1dC5zaGFwZVsxXTsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0VmFsc1tyZXNJZHggKyBjb2xdID0gZGVjb2RlZERhdGFbdElkeCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xPZmZzZXQgKz0gaW5wdXQuc2hhcGVbMV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0VmFscztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmNvbnN0IGV4cEltcGwgPSBjcmVhdGVTaW1wbGVVbmFyeUltcGwoKHhpKSA9PiBNYXRoLmV4cCh4aSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuY29uc3QgZXhwbTFJbXBsID0gY3JlYXRlU2ltcGxlVW5hcnlJbXBsKCh4aSkgPT4gTWF0aC5leHBtMSh4aSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuY29uc3QgZmxvb3JJbXBsID0gY3JlYXRlU2ltcGxlVW5hcnlJbXBsKCh4aSkgPT4gTWF0aC5mbG9vcih4aSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBnYXRoZXJWMkltcGwoeEJ1ZiwgaW5kaWNlc0J1ZiwgZmxhdHRlbk91dHB1dFNoYXBlKSB7XG4gICAgY29uc3Qgb3V0QnVmID0gdGYuYnVmZmVyKGZsYXR0ZW5PdXRwdXRTaGFwZSwgeEJ1Zi5kdHlwZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRCdWYuc2l6ZTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5ld0xvYyA9IG91dEJ1Zi5pbmRleFRvTG9jKGkpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbExvYyA9IG5ld0xvYy5zbGljZSgpO1xuICAgICAgICBjb25zdCBiYXRjaElkeCA9IG9yaWdpbmFsTG9jWzBdO1xuICAgICAgICBjb25zdCBpbmRpY2VzSWR4ID0gb3JpZ2luYWxMb2NbMl07XG4gICAgICAgIGNvbnN0IGluZGljZXNJbmRleCA9IGluZGljZXNCdWYubG9jVG9JbmRleChbYmF0Y2hJZHgsIGluZGljZXNJZHhdKTtcbiAgICAgICAgb3JpZ2luYWxMb2NbMl0gPSBpbmRpY2VzQnVmLnZhbHVlc1tpbmRpY2VzSW5kZXhdO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGV4ID0geEJ1Zi5sb2NUb0luZGV4KG9yaWdpbmFsTG9jKTtcbiAgICAgICAgb3V0QnVmLnZhbHVlc1tpXSA9IHhCdWYudmFsdWVzW29yaWdpbmFsSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0QnVmO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5jb25zdCBncmVhdGVySW1wbCA9IGNyZWF0ZVNpbXBsZUJpbmFyeUtlcm5lbEltcGwoKGEsIGIpID0+IChhID4gYikgPyAxIDogMCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmNvbnN0IGxlc3NJbXBsID0gY3JlYXRlU2ltcGxlQmluYXJ5S2VybmVsSW1wbCgoYSwgYikgPT4gKGEgPCBiKSA/IDEgOiAwKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbGluU3BhY2VJbXBsKHN0YXJ0LCBzdG9wLCBudW0pIHtcbiAgICBjb25zdCBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyAobnVtIC0gMSk7XG4gICAgY29uc3QgdmFsdWVzID0gdGYudXRpbC5tYWtlWmVyb3NUeXBlZEFycmF5KG51bSwgJ2Zsb2F0MzInKTtcbiAgICB2YWx1ZXNbMF0gPSBzdGFydDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbaSAtIDFdICsgc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmNvbnN0IGxvZ0ltcGwgPSBjcmVhdGVTaW1wbGVVbmFyeUltcGwoKHhpKSA9PiBNYXRoLmxvZyh4aSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBtYXhJbXBsKGFWYWxzLCByZWR1Y2VTaXplLCBvdXRTaGFwZSwgZHR5cGUpIHtcbiAgICBjb25zdCB2YWxzID0gdGYudXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKGR0eXBlLCB0Zi51dGlsLnNpemVGcm9tU2hhcGUob3V0U2hhcGUpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgIGxldCBtYXggPSBhVmFsc1tvZmZzZXRdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbHNbaV0gPSBtYXg7XG4gICAgfVxuICAgIHJldHVybiB2YWxzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5jb25zdCBtYXhpbXVtSW1wbCA9IGNyZWF0ZVNpbXBsZUJpbmFyeUtlcm5lbEltcGwoKChhVmFsdWUsIGJWYWx1ZSkgPT4gTWF0aC5tYXgoYVZhbHVlLCBiVmFsdWUpKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmNvbnN0IG1pbmltdW1JbXBsID0gY3JlYXRlU2ltcGxlQmluYXJ5S2VybmVsSW1wbCgoKGFWYWx1ZSwgYlZhbHVlKSA9PiBNYXRoLm1pbihhVmFsdWUsIGJWYWx1ZSkpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuY29uc3QgbXVsdGlwbHlJbXBsID0gY3JlYXRlU2ltcGxlQmluYXJ5S2VybmVsSW1wbCgoKGFWYWx1ZSwgYlZhbHVlKSA9PiBhVmFsdWUgKiBiVmFsdWUpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbmVnSW1wbCh4VmFscywgeFNoYXBlLCB4RHR5cGUpIHtcbiAgICBjb25zdCBtaW51c09uZSA9IHRmLnV0aWwuY3JlYXRlU2NhbGFyVmFsdWUoLTEsIHhEdHlwZSk7XG4gICAgcmV0dXJuIG11bHRpcGx5SW1wbChbXSwgeFNoYXBlLCBtaW51c09uZSwgeFZhbHMsIHhEdHlwZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcG9zZUltcGwoeFZhbHMsIHhTaGFwZSwgZHR5cGUsIHBlcm0sIG5ld1NoYXBlKSB7XG4gICAgY29uc3QgeFJhbmsgPSB4U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHhTaXplID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKHhTaGFwZSk7XG4gICAgY29uc3QgeFN0cmlkZXMgPSB0Zi51dGlsLmNvbXB1dGVTdHJpZGVzKHhTaGFwZSk7XG4gICAgY29uc3QgbmV3U3RyaWRlcyA9IHRmLnV0aWwuY29tcHV0ZVN0cmlkZXMobmV3U2hhcGUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRmLnV0aWwuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShkdHlwZSwgdGYudXRpbC5zaXplRnJvbVNoYXBlKG5ld1NoYXBlKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4U2l6ZTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGxvYyA9IHRmLnV0aWwuaW5kZXhUb0xvYyhpLCB4UmFuaywgeFN0cmlkZXMpO1xuICAgICAgICAvLyBQZXJtdXRlIGxvY2F0aW9uLlxuICAgICAgICBjb25zdCBuZXdMb2MgPSBuZXcgQXJyYXkobG9jLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3TG9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdMb2NbaV0gPSBsb2NbcGVybVtpXV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0Zi51dGlsLmxvY1RvSW5kZXgobmV3TG9jLCB4UmFuaywgbmV3U3RyaWRlcyk7XG4gICAgICAgIHJlc3VsdFtuZXdJbmRleF0gPSB4VmFsc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gcHJvZEltcGwoeFNoYXBlLCB4RHR5cGUsIHhWYWxzLCByZWR1Y3Rpb25BeGVzKSB7XG4gICAgY29uc3QgW291dFNoYXBlLCByZWR1Y2VTaGFwZV0gPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4U2hhcGUsIHJlZHVjdGlvbkF4ZXMpO1xuICAgIGNvbnN0IG91dER0eXBlID0gdGYudXBjYXN0VHlwZSh4RHR5cGUsICdpbnQzMicpO1xuICAgIGNvbnN0IG91dFZhbHMgPSB0Zi51dGlsLm1ha2VaZXJvc1R5cGVkQXJyYXkodGYudXRpbC5zaXplRnJvbVNoYXBlKG91dFNoYXBlKSwgb3V0RHR5cGUpO1xuICAgIGNvbnN0IHJlZHVjZVNpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0VmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgbGV0IHByb2QgPSAxO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgcHJvZCAqPSB4VmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgfVxuICAgICAgICBvdXRWYWxzW2ldID0gcHJvZDtcbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0VmFscywgb3V0U2hhcGUsIG91dER0eXBlIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHJhbmdlSW1wbChzdGFydCwgc3RvcCwgc3RlcCwgZHR5cGUpIHtcbiAgICBjb25zdCBzYW1lU3RhcnRTdG9wID0gc3RhcnQgPT09IHN0b3A7XG4gICAgY29uc3QgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwID0gc3RhcnQgPCBzdG9wICYmIHN0ZXAgPCAwO1xuICAgIGNvbnN0IGRlY3JlYXNpbmdSYW5nZVBvc2l0aXZlU3RlcCA9IHN0b3AgPCBzdGFydCAmJiBzdGVwID4gMTtcbiAgICBpZiAoc2FtZVN0YXJ0U3RvcCB8fCBpbmNyZWFzaW5nUmFuZ2VOZWdhdGl2ZVN0ZXAgfHxcbiAgICAgICAgZGVjcmVhc2luZ1JhbmdlUG9zaXRpdmVTdGVwKSB7XG4gICAgICAgIHJldHVybiB0Zi51dGlsLm1ha2VaZXJvc1R5cGVkQXJyYXkoMCwgZHR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBudW1FbGVtZW50cyA9IE1hdGguYWJzKE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApKTtcbiAgICBjb25zdCB2YWx1ZXMgPSB0Zi51dGlsLm1ha2VaZXJvc1R5cGVkQXJyYXkobnVtRWxlbWVudHMsIGR0eXBlKTtcbiAgICBpZiAoc3RvcCA8IHN0YXJ0ICYmIHN0ZXAgPT09IDEpIHtcbiAgICAgICAgLy8gQXV0byBhZGp1c3QgdGhlIHN0ZXAncyBzaWduIGlmIGl0IGhhc24ndCBiZWVuIHNldFxuICAgICAgICAvLyAob3Igd2FzIHNldCB0byAxKVxuICAgICAgICBzdGVwID0gLTE7XG4gICAgfVxuICAgIHZhbHVlc1swXSA9IHN0YXJ0O1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbHVlc1tpIC0gMV0gKyBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuY29uc3QgcnNxcnRJbXBsID0gY3JlYXRlU2ltcGxlVW5hcnlJbXBsKCh4aSkgPT4gMSAvIE1hdGguc3FydCh4aSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBzbGljZUltcGwodmFscywgYmVnaW4sIHNpemUsIHNoYXBlLCBkdHlwZSkge1xuICAgIGNvbnN0IGlzQ29udGlub3VzID0gdGYuc2xpY2VfdXRpbC5pc1NsaWNlQ29udGlub3VzKHNoYXBlLCBiZWdpbiwgc2l6ZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKHNpemUpO1xuICAgIGNvbnN0IHhTdHJpZGVzID0gdGYudXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZSk7XG4gICAgaWYgKGlzQ29udGlub3VzKSB7XG4gICAgICAgIGNvbnN0IGZsYXRPZmZzZXQgPSB0Zi5zbGljZV91dGlsLmNvbXB1dGVGbGF0T2Zmc2V0KGJlZ2luLCB4U3RyaWRlcyk7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxzLnNsaWNlKGZsYXRPZmZzZXQsIGZsYXRPZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxzLnN1YmFycmF5KGZsYXRPZmZzZXQsIGZsYXRPZmZzZXQgKyBsZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVkRGF0YSA9IGR0eXBlID09PSAnc3RyaW5nJyA/XG4gICAgICAgIHRmLmJhY2tlbmRfdXRpbC5mcm9tVWludDhUb1N0cmluZ0FycmF5KHZhbHMpIDpcbiAgICAgICAgdmFscztcbiAgICBjb25zdCBpbkJ1ZiA9IHRmLmJ1ZmZlcihzaGFwZSwgZHR5cGUsIGRlY29kZWREYXRhKTtcbiAgICBjb25zdCBvdXRCdWYgPSB0Zi5idWZmZXIoc2l6ZSwgZHR5cGUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0QnVmLnNpemU7ICsraSkge1xuICAgICAgICBjb25zdCBvdXRMb2MgPSBvdXRCdWYuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgY29uc3QgaW5Mb2MgPSBvdXRMb2MubWFwKChpZHgsIGopID0+IGlkeCArIGJlZ2luW2pdKTtcbiAgICAgICAgb3V0QnVmLnNldChpbkJ1Zi5nZXQoLi4uaW5Mb2MpLCAuLi5vdXRMb2MpO1xuICAgIH1cbiAgICBpZiAoZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0Zi5iYWNrZW5kX3V0aWwuZnJvbVN0cmluZ0FycmF5VG9VaW50OChvdXRCdWYudmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dEJ1Zi52YWx1ZXM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHN0cmlkZWRTbGljZUltcGwob3V0U2hhcGUsIHhCdWYsIHN0cmlkZXMsIGJlZ2luKSB7XG4gICAgY29uc3Qgb3V0QnVmID0gdGYuYnVmZmVyKG91dFNoYXBlLCB4QnVmLmR0eXBlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dEJ1Zi5zaXplOyBpKyspIHtcbiAgICAgICAgY29uc3QgbG9jID0gb3V0QnVmLmluZGV4VG9Mb2MoaSk7XG4gICAgICAgIGNvbnN0IG5ld0xvYyA9IG5ldyBBcnJheShsb2MubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuZXdMb2MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG5ld0xvY1tqXSA9IGxvY1tqXSAqIHN0cmlkZXNbal0gKyBiZWdpbltqXTtcbiAgICAgICAgfVxuICAgICAgICBvdXRCdWYuc2V0KHhCdWYuZ2V0KC4uLm5ld0xvYyksIC4uLmxvYyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRCdWY7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmNvbnN0IHN1YkltcGwgPSBjcmVhdGVTaW1wbGVCaW5hcnlLZXJuZWxJbXBsKCgoYVZhbHVlLCBiVmFsdWUpID0+IGFWYWx1ZSAtIGJWYWx1ZSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSB0aWxlIGtlcm5lbCBzaGFyZWQgYmV0d2VlbiB3ZWJnbCBhbmQgY3B1IGZvciBzdHJpbmdcbiAqIHRlbnNvcnMgb25seS5cbiAqL1xuZnVuY3Rpb24gdGlsZUltcGwoeEJ1ZiwgcmVwcykge1xuICAgIGNvbnN0IG5ld1NoYXBlID0gbmV3IEFycmF5KHhCdWYucmFuayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdTaGFwZVtpXSA9IHhCdWYuc2hhcGVbaV0gKiByZXBzW2ldO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0Zi5idWZmZXIobmV3U2hhcGUsIHhCdWYuZHR5cGUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0LnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBuZXdMb2MgPSByZXN1bHQuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxMb2MgPSBuZXcgQXJyYXkoeEJ1Zi5yYW5rKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvcmlnaW5hbExvYy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgb3JpZ2luYWxMb2Nbal0gPSBuZXdMb2Nbal0gJSB4QnVmLnNoYXBlW2pdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kZXggPSB4QnVmLmxvY1RvSW5kZXgob3JpZ2luYWxMb2MpO1xuICAgICAgICByZXN1bHQudmFsdWVzW2ldID0geEJ1Zi52YWx1ZXNbb3JpZ2luYWxJbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHRvcEtJbXBsKHgsIHhTaGFwZSwgeER0eXBlLCBrLCBzb3J0ZWQpIHtcbiAgICAvLyBSZXNoYXBlIGludG8gYSAyZCB0ZW5zb3IgW2JhdGNoLCBsYXN0RGltXSBhbmQgY29tcHV0ZSB0b3BrIGFsb25nIGxhc3REaW0uXG4gICAgY29uc3QgbGFzdERpbSA9IHhTaGFwZVt4U2hhcGUubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgW2JhdGNoLCBzaXplXSA9IFt4Lmxlbmd0aCAvIGxhc3REaW0sIGxhc3REaW1dO1xuICAgIGNvbnN0IGFsbFRvcEtWYWxzID0gdGYudXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKHhEdHlwZSwgYmF0Y2ggKiBrKTtcbiAgICBjb25zdCBhbGxUb3BLSW5kaWNlcyA9IHRmLnV0aWwuZ2V0VHlwZWRBcnJheUZyb21EVHlwZSgnaW50MzInLCBiYXRjaCAqIGspO1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmF0Y2g7IGIrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBiICogc2l6ZTtcbiAgICAgICAgY29uc3QgdmFscyA9IHguc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBzaXplKTtcbiAgICAgICAgY29uc3QgdmFsQW5kSW5kID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsQW5kSW5kLnB1c2goeyB2YWx1ZTogdmFsc1tpXSwgaW5kZXg6IGkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsQW5kSW5kLnNvcnQoKGEsIGIpID0+IGIudmFsdWUgLSBhLnZhbHVlKTtcbiAgICAgICAgY29uc3Qgb3V0T2Zmc2V0ID0gYiAqIGs7XG4gICAgICAgIGNvbnN0IHRvcEtWYWxzID0gYWxsVG9wS1ZhbHMuc3ViYXJyYXkob3V0T2Zmc2V0LCBvdXRPZmZzZXQgKyBrKTtcbiAgICAgICAgY29uc3QgdG9wS0luZGljZXMgPSBhbGxUb3BLSW5kaWNlcy5zdWJhcnJheShvdXRPZmZzZXQsIG91dE9mZnNldCArIGspO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICAgICAgdG9wS1ZhbHNbaV0gPSB2YWxBbmRJbmRbaV0udmFsdWU7XG4gICAgICAgICAgICB0b3BLSW5kaWNlc1tpXSA9IHZhbEFuZEluZFtpXS5pbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXNoYXBlIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGlucHV0IHNoYXBlLCBleGNlcHQgdGhhdCB0aGUgbGFzdFxuICAgIC8vIGRpbWVuc2lvbiBpcyBrLlxuICAgIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlLnNsaWNlKCk7XG4gICAgb3V0cHV0U2hhcGVbb3V0cHV0U2hhcGUubGVuZ3RoIC0gMV0gPSBrO1xuICAgIHJldHVybiBbXG4gICAgICAgIHRmLmJ1ZmZlcihvdXRwdXRTaGFwZSwgeER0eXBlLCBhbGxUb3BLVmFscyksXG4gICAgICAgIHRmLmJ1ZmZlcihvdXRwdXRTaGFwZSwgJ2ludDMyJywgYWxsVG9wS0luZGljZXMpXG4gICAgXTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlSW1wbCh2YWx1ZXMsIGF4aXMsIHNoYXBlLCBkdHlwZSkge1xuICAgIC8vIE5vcm1hbGl6ZSBhbmQgdmFsaWRhdGUgYXhpcy5cbiAgICBjb25zdCAkYXhpcyA9IHRmLnV0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgc2hhcGUpWzBdO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IHNoYXBlIHRoYXQgaXMgc3VpdGFibGUgZm9yIGV4dHJhY3RpbmcgZGF0YSBhbG9uZyB0aGVcbiAgICAvLyBnaXZlbiBheGlzLlxuICAgIC8vXG4gICAgLy8gVGhlIHJhbmsgaXMgMy5cbiAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgMXN0IGRpbWVuc2lvbiBpcyB0aGUgc2l6ZSBvZiBhbGwgdGhlIGF4ZXMgPCB0aGUgZ2l2ZW4gYXhpcy5cbiAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgMm5kIGRpbWVuc2lvbiBpcyB0aGUgc2FtZSBhcyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpcy5cbiAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgM3JkIGRpbWVuc2lvbiBpcyB0aGUgc2l6ZSBvZiBhbGwgdGhlIGF4ZXMgPiB0aGUgZ2l2ZW4gYXhpcy5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCBmb3IgYSA0RCB0ZW5zb3Igd2l0aCBzaGFwZT1bMiwgMywgNSwgNF0gYW5kIGF4aXM9MiwgdGhlXG4gICAgLy8gbmV3U2hhcGUgd291bGQgYmU6IFsyKjMsIDUsIDRdLlxuICAgIC8vXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgbm90IHRoZSBmaW5hbCBvdXRwdXQgc2hhcGUuIFRoaXMgd2lsbCBiZSB0aGUgc2hhcGUgZm9yIGFuXG4gICAgLy8gaW50ZXJtZWRpYXRlIFRlbnNvckJ1ZmZlciAoc2VlIGlucHV0QnVmZmVyIGJlbG93KSB0byBhbGxvdyB1cyB0byBleHRyYWN0XG4gICAgLy8gdmFsdWVzIGFsb25nIHRoZSBnaXZlbiBheGlzLiBUbyBkZW1vbnN0cmF0ZSBob3cgaXQgd29ya3MsIGNvbnNpZGVyIHRoZVxuICAgIC8vIGZvbGxvd2luZyBleGFtcGxlOlxuICAgIC8vXG4gICAgLy8gSW5wdXQ6IGEgM0QgdGVuc29yLCB3aXRoIHNoYXBlIFsxLCAyLCAzXVxuICAgIC8vIFtcbiAgICAvLyAgIFtcbiAgICAvLyAgICAgIFsxLDIsM10sXG4gICAgLy8gICAgICBbNCw1LDZdXG4gICAgLy8gICBdXG4gICAgLy8gXVxuICAgIC8vIEF4aXM6IDIgKHRoZSBsYXN0IGF4aXMpLlxuICAgIC8vIEFsb25nIGF4aXMgMiwgd2UgZXhwZWN0IHRvIGV4dHJhY3QgMyB0ZW5zb3JzOiBbMSw0XSwgWzIsNV0sIFszLDZdLlxuICAgIC8vXG4gICAgLy8gRm9yIHRoaXMgZXhhbXBsZSwgbmV3U2hhcGUgd291bGQgYmU6IFsyLCAzLCAxXSwgd2hlcmUgMiBpcyBjYWxjdWxhdGVkIGZyb21cbiAgICAvLyAxKjIuIFRoZSByZS1zaGFwZWQgZGF0YSB3b3VsZCBsb29rIGxpa2U6XG4gICAgLy9cbiAgICAvLyBbXG4gICAgLy8gICBbXG4gICAgLy8gICAgIFsxXSwgWzJdLCBbM11cbiAgICAvLyAgIF0sXG4gICAgLy8gICBbXG4gICAgLy8gICAgIFs0XSwgWzVdLCBbNl1cbiAgICAvLyAgIF1cbiAgICAvLyBdXG4gICAgLy9cbiAgICAvLyBUaGVuLCB3ZSBjYW4gY29uc3RydWN0IGEgMy1sZXZlbCBuZXN0ZWQgbG9vcCBieSB0aGUgZm9sbG93aW5nIGRpbWVuc2lvblxuICAgIC8vIG9yZGVyIHRvIGV4dHJhY3QgdGhlIHZhbHVlcyBhbG9uZyB0aGUgYXhpcyAoZGltZW5zaW9uMSk6XG4gICAgLy8gaTogZGltZW5zaW9uMSAgICAgICAvLyAwLDEsMiAobmV3U2hhcGVbMV0pXG4gICAgLy8gICBtOiBkaW1lbnNpb24wICAgICAvLyAwLDEgICAobmV3U2hhcGVbMF0pXG4gICAgLy8gICAgIG46IGRpbWVuc2lvbjIgICAvLyAwICAgICAobmV3U2hhcGVbMl0pXG4gICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgbSwgaSwgblxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIC0tLS0tLS0tLVxuICAgIC8vIEl0ZXJhdGlvbiAwOiBkYXRhIGF0IFswLCAwLCAwXSA9PiBcIjFcIlxuICAgIC8vIEl0ZXJhdGlvbiAxOiBkYXRhIGF0IFsxLCAwLCAwXSA9PiBcIjRcIlxuICAgIC8vIFdlIGdvdCBbMSw0XS5cbiAgICAvLyBJdGVyYXRpb24gMjogZGF0YSBhdCBbMCwgMSwgMF0gPT4gXCIyXCJcbiAgICAvLyBJdGVyYXRpb24gMzogZGF0YSBhdCBbMSwgMSwgMF0gPT4gXCI1XCJcbiAgICAvLyBXZSBnb3QgWzIsNV0uXG4gICAgLy8gSXRlcmF0aW9uIDQ6IGRhdGEgYXQgWzAsIDIsIDBdID0+IFwiM1wiXG4gICAgLy8gSXRlcmF0aW9uIDU6IGRhdGEgYXQgWzEsIDIsIDBdID0+IFwiNlwiXG4gICAgLy8gV2UgZ290IFszLDZdLlxuICAgIGNvbnN0IG5ld1NoYXBlID0gWzEsIHNoYXBlWzBdLCAxXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRheGlzOyBpKyspIHtcbiAgICAgICAgbmV3U2hhcGVbMF0gKj0gc2hhcGVbaV07XG4gICAgfVxuICAgIG5ld1NoYXBlWzFdID0gc2hhcGVbJGF4aXNdO1xuICAgIGZvciAobGV0IGkgPSAkYXhpcyArIDE7IGkgPCBzaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdTaGFwZVsyXSAqPSBzaGFwZVtpXTtcbiAgICB9XG4gICAgLy8gQSBtYXAgZnJvbSB1bmlxdWUgZWxlbWVudHMgKHRoZWlyIHN0cmluZyByZXByZXNlbnRhdGlvbnMpIHRvIHRoZWlyIHZhbHVlc1xuICAgIC8vIGluIFwiaW5kaWNlc1wiIChiZWxvdykuXG4gICAgY29uc3QgdW5pcXVlRWxlbWVudHMgPSB7fTtcbiAgICAvLyBUaGUgaW5kaWNlcyBvZiBlYWNoIHVuaXF1ZSBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCB0ZW5zb3IgYWxvbmcgdGhlIGdpdmVuXG4gICAgLy8gYXhpcy4gSXQgaXMgMUQgYW5kIGhhcyB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBheGlzLlxuICAgIGNvbnN0IGluZGljZXMgPSBuZXcgSW50MzJBcnJheShzaGFwZVskYXhpc10pO1xuICAgIC8vIENyZWF0ZSBhIGJ1ZmZlciBzbyB3ZSBjYW4gZWFzaWx5IGV4dHJhY3QgdmFsdWUgYXQgYSBnaXZlbiBsb2NhdGlvbi5cbiAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IG5ldyB0Zi5UZW5zb3JCdWZmZXIobmV3U2hhcGUsIGR0eXBlLCB2YWx1ZXMpO1xuICAgIC8vIFRoZSBpbmRpY2VzIGFsb25nIHRoZSBnaXZlbiBheGlzIHRoYXQgaGF2ZSB1bmlxdWUgZWxlbWVudHMuIFRoaXMgaXMgYVxuICAgIC8vIGRlLWR1cGVkIHZlcnNpb24gb2YgXCJpbmRpY2VzXCIgYWJvdmUuXG4gICAgY29uc3QgdW5pcXVlSW5kaWNlcyA9IFtdO1xuICAgIGNvbnN0IGlzMURUZW5zb3IgPSBuZXdTaGFwZVswXSA9PT0gMSAmJiBuZXdTaGFwZVsyXSA9PT0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlWyRheGlzXTsgaSsrKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgdmFsdWVzIGFsb25nIHRoZSBheGlzLlxuICAgICAgICBsZXQgZWxlbWVudDtcbiAgICAgICAgaWYgKGlzMURUZW5zb3IpIHtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgMUQgdGVuc29yIGlucHV0LlxuICAgICAgICAgICAgZWxlbWVudCA9IHZhbHVlc1tpXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXhpc1ZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgbSA9IDA7IG0gPCBuZXdTaGFwZVswXTsgbSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBuZXdTaGFwZVsyXTsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNWYWx1ZXMucHVzaChpbnB1dEJ1ZmZlci5nZXQobSwgaSwgbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQgPSBheGlzVmFsdWVzLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWR1cCBhbmQgdXBkYXRlIHZhcmlvdXMgaW5kaWNlcy5cbiAgICAgICAgaWYgKHVuaXF1ZUVsZW1lbnRzW2VsZW1lbnRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluZGljZXNbaV0gPSB1bmlxdWVFbGVtZW50c1tlbGVtZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUluZGV4ID0gT2JqZWN0LmtleXModW5pcXVlRWxlbWVudHMpLmxlbmd0aDtcbiAgICAgICAgICAgIHVuaXF1ZUVsZW1lbnRzW2VsZW1lbnRdID0gdW5pcXVlSW5kZXg7XG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gdW5pcXVlSW5kZXg7XG4gICAgICAgICAgICB1bmlxdWVJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm93IHdlIGtub3cgd2hlcmUgZWFjaCBvZiB0aGUgdW5pcXVlIGVsZW1lbnRzIGFyZSBsb2NhdGVkIGFsb25nIHRoZSBheGlzXG4gICAgLy8gKHVuaXF1ZUluZGljZXMpLiBFeHRyYWN0IHRoZW0gZnJvbSBpbnB1dCBidWZmZXIgYW5kIHN0b3JlIHRoZW0gaW4gdGhlXG4gICAgLy8gb3V0cHV0IGJ1ZmZlci5cbiAgICBjb25zdCBvdXRwdXRUbXBTaGFwZSA9IG5ld1NoYXBlLnNsaWNlKCk7XG4gICAgb3V0cHV0VG1wU2hhcGVbMV0gPSBPYmplY3Qua2V5cyh1bmlxdWVFbGVtZW50cykubGVuZ3RoO1xuICAgIGNvbnN0IG91dHB1dEJ1ZmZlciA9IG5ldyB0Zi5UZW5zb3JCdWZmZXIob3V0cHV0VG1wU2hhcGUsIGR0eXBlKTtcbiAgICB1bmlxdWVJbmRpY2VzLmZvckVhY2goKHVuaXF1ZUVsZW1lbnRJbmRleCwgaSkgPT4ge1xuICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IG5ld1NoYXBlWzBdOyBtKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbmV3U2hhcGVbMl07IG4rKykge1xuICAgICAgICAgICAgICAgIG91dHB1dEJ1ZmZlci5zZXQoaW5wdXRCdWZmZXIuZ2V0KG0sIHVuaXF1ZUVsZW1lbnRJbmRleCwgbiksIG0sIGksIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gVGhlIG91dHB1dCBzaGFwZSBjYW4gYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBpbnB1dCBzaGFwZSB3aXRoIHRoZSBzaXplIG9mXG4gICAgLy8gdGhlIGdpdmVuIGF4aXMgcmVwbGFjZWQgYnkgdGhlIG51bWJlciBvZiB1bmlxdWUgZWxlbWVudHMgYWxvbmcgdGhhdCBheGlzLlxuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gc2hhcGUuc2xpY2UoKTtcbiAgICBvdXRwdXRTaGFwZVskYXhpc10gPSBvdXRwdXRUbXBTaGFwZVsxXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvdXRwdXRWYWx1ZXM6IG91dHB1dEJ1ZmZlci52YWx1ZXMsXG4gICAgICAgIG91dHB1dFNoYXBlLFxuICAgICAgICBpbmRpY2VzLFxuICAgIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBhZGRJbXBsQ1BVID0gYWRkSW1wbCwgYmluY291bnRJbXBsQ1BVID0gYmluY291bnRJbXBsLCBiaW5jb3VudFJlZHVjZUltcGxDUFUgPSBiaW5jb3VudFJlZHVjZUltcGwsIGNlaWxJbXBsQ1BVID0gY2VpbEltcGwsIGNvbmNhdEltcGxDUFUgPSBjb25jYXRJbXBsLCBleHBJbXBsQ1BVID0gZXhwSW1wbCwgZXhwbTFJbXBsQ1BVID0gZXhwbTFJbXBsLCBmbG9vckltcGxDUFUgPSBmbG9vckltcGwsIGdhdGhlclYySW1wbENQVSA9IGdhdGhlclYySW1wbCwgZ3JlYXRlckltcGxDUFUgPSBncmVhdGVySW1wbCwgbGVzc0ltcGxDUFUgPSBsZXNzSW1wbCwgbGluU3BhY2VJbXBsQ1BVID0gbGluU3BhY2VJbXBsLCBsb2dJbXBsQ1BVID0gbG9nSW1wbCwgbWF4SW1wbENQVSA9IG1heEltcGwsIG1heGltdW1JbXBsQ1BVID0gbWF4aW11bUltcGwsIG1pbmltdW1JbXBsQ1BVID0gbWluaW11bUltcGwsIG11bHRpcGx5SW1wbENQVSA9IG11bHRpcGx5SW1wbCwgbmVnSW1wbENQVSA9IG5lZ0ltcGwsIHByb2RJbXBsQ1BVID0gcHJvZEltcGwsIHJhbmdlSW1wbENQVSA9IHJhbmdlSW1wbCwgcnNxcnRJbXBsQ1BVID0gcnNxcnRJbXBsLCBzaW1wbGVBYnNJbXBsQ1BVID0gc2ltcGxlQWJzSW1wbCwgc2xpY2VJbXBsQ1BVID0gc2xpY2VJbXBsLCBzdHJpZGVkU2xpY2VJbXBsQ1BVID0gc3RyaWRlZFNsaWNlSW1wbCwgc3ViSW1wbENQVSA9IHN1YkltcGwsIHRpbGVJbXBsQ1BVID0gdGlsZUltcGwsIHRvcEtJbXBsQ1BVID0gdG9wS0ltcGwsIHRyYW5zcG9zZUltcGxDUFUgPSB0cmFuc3Bvc2VJbXBsLCB1bmlxdWVJbXBsQ1BVID0gdW5pcXVlSW1wbDtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZ2V0VmVjQ2hhbm5lbHMobmFtZSwgcmFuaykge1xuICAgIHJldHVybiBbJ3gnLCAneScsICd6JywgJ3cnLCAndScsICd2J10uc2xpY2UoMCwgcmFuaykubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBuYW1lICsgXCIuXCIgKyBkOyB9KTtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWxzKG5hbWUsIHJhbmspIHtcbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0VmVjQ2hhbm5lbHMobmFtZSwgcmFuayk7XG59XG5mdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMocmFuaywgZGltcykge1xuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiAncmMnO1xuICAgIH1cbiAgICB2YXIgY29vcmRzID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5rOyBpKyspIHtcbiAgICAgICAgY29vcmRzICs9IGRpbXNbaV07XG4gICAgICAgIGlmIChpIDwgcmFuayAtIDEpIHtcbiAgICAgICAgICAgIGNvb3JkcyArPSAnLCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvb3Jkcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFBhY2tQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhY2tQcm9ncmFtKG91dHB1dFNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLnBhY2tlZElucHV0cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhY2tlZE91dHB1dCA9IHRydWU7XG4gICAgICAgIC8vIE9ubHkgaW5wdXQgLyBvdXRwdXQgM0QgdGVuc29ycy5cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB2YXIgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmVjNChnZXRBKCksIDAuLCAwLiwgMC4pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVscyA9IGdldENoYW5uZWxzKCdyYycsIHJhbmspO1xuICAgICAgICAgICAgdmFyIGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgICAgICAgICB2YXIgb3V0T2ZCb3VuZHNDb25kaXRpb24gPSBnZXRPdXRPZkJvdW5kc0NvbmRpdGlvbihyYW5rLCBvdXRwdXRTaGFwZSwgY2hhbm5lbHMpO1xuICAgICAgICAgICAgdmFyIHNldHVwID0gZ2V0U2V0dXAocmFuaywgb3V0cHV0U2hhcGVbb3V0cHV0U2hhcGUubGVuZ3RoIC0gMV0sIG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDJdLCBjaGFubmVscyk7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gZ2V0T3V0cHV0KG91dHB1dFNoYXBlLCBjaGFubmVscyk7XG4gICAgICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIgKyBkdHlwZSArIFwiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICAgIGlmKFwiICsgb3V0T2ZCb3VuZHNDb25kaXRpb24gKyBcIikge1xcbiAgICAgICAgICAgIHNldE91dHB1dCh2ZWM0KDApKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBcIiArIHNldHVwICsgXCJcXG5cXG4gICAgICAgICAgICBzZXRPdXRwdXQodmVjNChcIiArIG91dHB1dCArIFwiKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUGFja1Byb2dyYW07XG59KCkpO1xuZnVuY3Rpb24gZ2V0U291cmNlQ29vcmRzQXJyKHJhbmssIGRpbXMpIHtcbiAgICB2YXIgY29vcmRzID0gW107XG4gICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDw9IDE7IHJvdysrKSB7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8PSAxOyBjb2wrKykge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gKHJvdyA9PT0gMCA/ICdyJyA6ICdycDEnKSArIFwiLCBcIiArIChjb2wgPT09IDAgPyAnYycgOiAnY3AxJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMjsgZCA8IHJhbms7IGQrKykge1xuICAgICAgICAgICAgICAgIGNvb3JkID0gZGltc1tkaW1zLmxlbmd0aCAtIDEgLSBkXSArIFwiLFwiICsgY29vcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb29yZHMucHVzaChjb29yZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvb3Jkcztcbn1cbmZ1bmN0aW9uIGdldE91dE9mQm91bmRzQ29uZGl0aW9uKHJhbmssIHNoYXBlLCBkaW1zKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwicmMgPiBcIiArIHNoYXBlWzBdO1xuICAgIH1cbiAgICB2YXIgY29uZCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSByYW5rIC0gMjsgaSA8IHJhbms7IGkrKykge1xuICAgICAgICBjb25kICs9IGRpbXNbaV0gKyBcIiA+PSBcIiArIHNoYXBlW2ldO1xuICAgICAgICBpZiAoaSA8IHJhbmsgLSAxKSB7XG4gICAgICAgICAgICBjb25kICs9ICd8fCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbmQ7XG59XG5mdW5jdGlvbiBnZXRTZXR1cChyYW5rLCBjb2xzLCByb3dzLCBkaW1zKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgaW5uZXJEaW1zID0gZGltcy5zbGljZSgtMik7XG4gICAgcmV0dXJuIFwiXFxuICAgIGludCByID0gXCIgKyBpbm5lckRpbXNbMF0gKyBcIjtcXG4gICAgaW50IGMgPSBcIiArIGlubmVyRGltc1sxXSArIFwiO1xcbiAgICBpbnQgcnAxID0gciArIDE7XFxuICAgIGludCBjcDEgPSBjICsgMTtcXG5cXG4gICAgYm9vbCBjRWRnZSA9IGNwMSA+PSBcIiArIGNvbHMgKyBcIjtcXG4gICAgYm9vbCByRWRnZSA9IHJwMSA+PSBcIiArIHJvd3MgKyBcIjtcXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0KHNoYXBlLCBkaW1zKSB7XG4gICAgdmFyIHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgdmFyIHNvdXJjZUNvb3JkcyA9IGdldFNvdXJjZUNvb3Jkc0FycihyYW5rLCBkaW1zKTtcbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJnZXRBKHJjKSxcXG4gICAgICAgICAgICByYyArIDEgPj0gXCIgKyBzaGFwZVswXSArIFwiID8gMC4gOiBnZXRBKHJjICsgMSksXFxuICAgICAgICAgICAgMCwgMFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJnZXRBKFwiICsgc291cmNlQ29vcmRzWzBdICsgXCIpLFxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QShcIiArIHNvdXJjZUNvb3Jkc1sxXSArIFwiKSxcXG4gICAgICAgICAgckVkZ2UgPyAwLiA6IGdldEEoXCIgKyBzb3VyY2VDb29yZHNbMl0gKyBcIiksXFxuICAgICAgICAgIHJFZGdlIHx8IGNFZGdlID8gMC4gOiBnZXRBKFwiICsgc291cmNlQ29vcmRzWzNdICsgXCIpXCI7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBSZXNoYXBlUGFja2VkUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNoYXBlUGFja2VkUHJvZ3JhbShvdXRwdXRTaGFwZSwgaW5wdXRTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5wYWNrZWRJbnB1dHMgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhY2tlZE91dHB1dCA9IHRydWU7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdmFyIG1haW5Mb29wID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0aGlzUkMgPSBcInRoaXNSQyA9IHJjO1wiO1xuICAgICAgICAgICAgaWYgKGkgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpc1JDICs9IFwidGhpc1JDLnogKz0gMTtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXNSQyArPSBcInRoaXNSQy55ICs9IDE7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWluTG9vcCArPSBcIlxcbiAgICAgICAgXCIgKyB0aGlzUkMgKyBcIlxcbiAgICAgICAgXCIgKyAoaSA+IDAgPyBcImlmKHRoaXNSQy55IDwgcm93cyAmJiB0aGlzUkMueiA8IGNvbHMpe1wiIDogJycpICsgXCJcXG4gICAgICAgICAgaW50IGZsYXRJbmRleCA9IGdldEZsYXRJbmRleCh0aGlzUkMpO1xcblxcbiAgICAgICAgICBpdmVjMyBpbnB1dFJDID0gaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoZmxhdEluZGV4KTtcXG4gICAgICAgICAgdmVjMiBpbnB1dFJDSW5uZXJEaW1zID0gdmVjMihmbG9hdChpbnB1dFJDLnkpLGZsb2F0KGlucHV0UkMueikpO1xcblxcbiAgICAgICAgICByZXN1bHRbXCIgKyBpICsgXCJdID1cXG4gICAgICAgICAgICBnZXRDaGFubmVsKGdldEEoaW5wdXRSQy54LCBpbnB1dFJDLnksIGlucHV0UkMueiksIGlucHV0UkNJbm5lckRpbXMpO1xcbiAgICAgICAgXCIgKyAoaSA+IDAgPyAnfScgOiAnJykgKyBcIlxcbiAgICAgIFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIFwiICsgZ2V0UmVzaGFwZWRJbnB1dENvb3JkcyhpbnB1dFNoYXBlKSArIFwiXFxuICAgICAgXCIgKyBnZXRGbGF0SW5kZXhGcm9tM0Qob3V0cHV0U2hhcGUpICsgXCJcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG5cXG4gICAgICAgIGl2ZWMzIHRoaXNSQztcXG4gICAgICAgIGludCByb3dzID0gXCIgKyBvdXRwdXRTaGFwZVsxXSArIFwiO1xcbiAgICAgICAgaW50IGNvbHMgPSBcIiArIG91dHB1dFNoYXBlWzJdICsgXCI7XFxuXFxuICAgICAgICBcIiArIG1haW5Mb29wICsgXCJcXG5cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZXNoYXBlUGFja2VkUHJvZ3JhbTtcbn0oKSk7XG5mdW5jdGlvbiBnZXRSZXNoYXBlZElucHV0Q29vcmRzKHNoYXBlKSB7XG4gICAgdmFyIGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPSBnZXRMb2dpY2FsQ29vcmRpbmF0ZXNGcm9tRmxhdEluZGV4KFsncicsICdjJywgJ2QnXSwgc2hhcGUpO1xuICAgIHJldHVybiBcIlxcbiAgICBpdmVjMyBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhpbnQgaW5kZXgpIHtcXG4gICAgICBcIiArIGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgKyBcIlxcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXCI7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBUZXh0dXJlTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0dXJlTWFuYWdlcihncGdwdSkge1xuICAgICAgICB0aGlzLmdwZ3B1ID0gZ3BncHU7XG4gICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzID0gMDtcbiAgICAgICAgdGhpcy5udW1GcmVlVGV4dHVyZXMgPSAwO1xuICAgICAgICB0aGlzLl9udW1CeXRlc0FsbG9jYXRlZCA9IDA7XG4gICAgICAgIHRoaXMuX251bUJ5dGVzRnJlZSA9IDA7IC8vIEhvdyBtYW55IGJ5dGVzIHRoYXQgaGF2ZSBiZWVuIGFsbG9jYXRlZFxuICAgICAgICAvLyBhcmUgYXZhaWxhYmxlIGZvciByZXVzZS5cbiAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXMgPSB7fTtcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXNlZFRleHR1cmVzID0ge307XG4gICAgfVxuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZSA9IGZ1bmN0aW9uIChzaGFwZVJDLCB1c2FnZSwgaXNQYWNrZWQpIHtcbiAgICAgICAgdmFyIHBoeXNpY2FsVGV4VHlwZSA9IGdldFBoeXNpY2FsRnJvbUxvZ2ljYWxUZXh0dXJlVHlwZSh1c2FnZSwgaXNQYWNrZWQpO1xuICAgICAgICB2YXIgc2hhcGVLZXkgPSBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlUkMsIHBoeXNpY2FsVGV4VHlwZSwgaXNQYWNrZWQpO1xuICAgICAgICBpZiAoIShzaGFwZUtleSBpbiB0aGlzLmZyZWVUZXh0dXJlcykpIHtcbiAgICAgICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMudXNlZFRleHR1cmVzKSkge1xuICAgICAgICAgICAgdGhpcy51c2VkVGV4dHVyZXNbc2hhcGVLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleEJ5dGVzID0gY29tcHV0ZUJ5dGVzKHNoYXBlUkMsIHBoeXNpY2FsVGV4VHlwZSwgdGhpcy5ncGdwdS5nbCwgdGhpcy5ncGdwdS50ZXh0dXJlQ29uZmlnLCBpc1BhY2tlZCk7XG4gICAgICAgIGlmICh0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5udW1GcmVlVGV4dHVyZXMtLTtcbiAgICAgICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzKys7XG4gICAgICAgICAgICB0aGlzLl9udW1CeXRlc0ZyZWUgLT0gdGV4Qnl0ZXM7XG4gICAgICAgICAgICB0aGlzLmxvZygpO1xuICAgICAgICAgICAgdmFyIG5ld1RleHR1cmVfMSA9IHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy51c2VkVGV4dHVyZXNbc2hhcGVLZXldLnB1c2gobmV3VGV4dHVyZV8xKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdUZXh0dXJlXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1RleHR1cmU7XG4gICAgICAgIGlmIChwaHlzaWNhbFRleFR5cGUgPT09IFBoeXNpY2FsVGV4dHVyZVR5cGUuUEFDS0VEXzJYMl9GTE9BVDMyKSB7XG4gICAgICAgICAgICBuZXdUZXh0dXJlID0gdGhpcy5ncGdwdS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKHNoYXBlUkNbMF0sIHNoYXBlUkNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBoeXNpY2FsVGV4VHlwZSA9PT0gUGh5c2ljYWxUZXh0dXJlVHlwZS5QQUNLRURfMlgyX0ZMT0FUMTYpIHtcbiAgICAgICAgICAgIG5ld1RleHR1cmUgPVxuICAgICAgICAgICAgICAgIHRoaXMuZ3BncHUuY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmUoc2hhcGVSQ1swXSwgc2hhcGVSQ1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGh5c2ljYWxUZXhUeXBlID09PSBQaHlzaWNhbFRleHR1cmVUeXBlLlVOUEFDS0VEX0ZMT0FUMzIpIHtcbiAgICAgICAgICAgIG5ld1RleHR1cmUgPVxuICAgICAgICAgICAgICAgIHRoaXMuZ3BncHUuY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmUoc2hhcGVSQ1swXSwgc2hhcGVSQ1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGh5c2ljYWxUZXhUeXBlID09PSBQaHlzaWNhbFRleHR1cmVUeXBlLlVOUEFDS0VEX0ZMT0FUMTYpIHtcbiAgICAgICAgICAgIG5ld1RleHR1cmUgPVxuICAgICAgICAgICAgICAgIHRoaXMuZ3BncHUuY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmUoc2hhcGVSQ1swXSwgc2hhcGVSQ1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGh5c2ljYWxUZXhUeXBlID09PSBQaHlzaWNhbFRleHR1cmVUeXBlLlBBQ0tFRF80WDFfVU5TSUdORURfQllURSkge1xuICAgICAgICAgICAgbmV3VGV4dHVyZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5ncGdwdS5jcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZShzaGFwZVJDWzBdLCBzaGFwZVJDWzFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZWRUZXh0dXJlc1tzaGFwZUtleV0ucHVzaChuZXdUZXh0dXJlKTtcbiAgICAgICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMrKztcbiAgICAgICAgdGhpcy5fbnVtQnl0ZXNBbGxvY2F0ZWQgKz0gdGV4Qnl0ZXM7XG4gICAgICAgIHRoaXMubG9nKCk7XG4gICAgICAgIHJldHVybiBuZXdUZXh0dXJlO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLnJlbGVhc2VUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHNoYXBlLCBsb2dpY2FsVGV4VHlwZSwgaXNQYWNrZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJlZVRleHR1cmVzID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEFscmVhZHkgZGlzcG9zZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBoeXNpY2FsVGV4VHlwZSA9IGdldFBoeXNpY2FsRnJvbUxvZ2ljYWxUZXh0dXJlVHlwZShsb2dpY2FsVGV4VHlwZSwgaXNQYWNrZWQpO1xuICAgICAgICB2YXIgc2hhcGVLZXkgPSBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlLCBwaHlzaWNhbFRleFR5cGUsIGlzUGFja2VkKTtcbiAgICAgICAgaWYgKCEoc2hhcGVLZXkgaW4gdGhpcy5mcmVlVGV4dHVyZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4Qnl0ZXMgPSBjb21wdXRlQnl0ZXMoc2hhcGUsIHBoeXNpY2FsVGV4VHlwZSwgdGhpcy5ncGdwdS5nbCwgdGhpcy5ncGdwdS50ZXh0dXJlQ29uZmlnLCBpc1BhY2tlZCk7XG4gICAgICAgIHZhciBkZWxldGVUZXhUaHJlc2hvbGQgPSB0Zi5lbnYoKS5nZXQoJ1dFQkdMX0RFTEVURV9URVhUVVJFX1RIUkVTSE9MRCcpO1xuICAgICAgICBpZiAoZGVsZXRlVGV4VGhyZXNob2xkICE9PSAtMSAmJlxuICAgICAgICAgICAgdGhpcy5fbnVtQnl0ZXNBbGxvY2F0ZWQgPiBkZWxldGVUZXhUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgICAgICAgIHRoaXMuX251bUJ5dGVzQWxsb2NhdGVkIC09IHRleEJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldLnB1c2godGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLm51bUZyZWVUZXh0dXJlcysrO1xuICAgICAgICAgICAgdGhpcy5fbnVtQnl0ZXNGcmVlICs9IHRleEJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzLS07XG4gICAgICAgIHZhciB0ZXhMaXN0ID0gdGhpcy51c2VkVGV4dHVyZXNbc2hhcGVLZXldO1xuICAgICAgICB2YXIgdGV4SW5kZXggPSB0ZXhMaXN0LmluZGV4T2YodGV4dHVyZSk7XG4gICAgICAgIGlmICh0ZXhJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlbGVhc2UgYSB0ZXh0dXJlIHRoYXQgd2FzIG5ldmVyIHByb3ZpZGVkIGJ5IHRoaXMgJyArXG4gICAgICAgICAgICAgICAgJ3RleHR1cmUgbWFuYWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHRleExpc3Quc3BsaWNlKHRleEluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5sb2coKTtcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5udW1GcmVlVGV4dHVyZXMgKyB0aGlzLm51bVVzZWRUZXh0dXJlcztcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyZWUvVXNlZCcsIHRoaXMubnVtRnJlZVRleHR1cmVzICsgXCIgLyBcIiArIHRoaXMubnVtVXNlZFRleHR1cmVzLCBcIihcIiArIHRvdGFsICsgXCIpXCIpO1xuICAgICAgICB2YXIgZnJlZVJhdGlvID0gdGhpcy5fbnVtQnl0ZXNGcmVlIC8gdGhpcy5fbnVtQnl0ZXNBbGxvY2F0ZWQ7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQnl0ZXMgYWxsb2NhdGVkOiBcIiArIHRoaXMuX251bUJ5dGVzQWxsb2NhdGVkKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJCeXRlcyB1bnVzZWQ6IFwiICsgdGhpcy5fbnVtQnl0ZXNGcmVlICsgXCIgKFwiICsgTWF0aC5yb3VuZCgxMDAgKiBmcmVlUmF0aW8pICsgXCIlKVwiKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUsIFwibnVtQnl0ZXNBbGxvY2F0ZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9udW1CeXRlc0FsbG9jYXRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZSwgXCJudW1CeXRlc0ZyZWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9udW1CeXRlc0ZyZWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5nZXROdW1Vc2VkVGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlcztcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5nZXROdW1GcmVlVGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bUZyZWVUZXh0dXJlcztcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5mcmVlVGV4dHVyZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBkaXNwb3NlZC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB0ZXhTaGFwZSBpbiB0aGlzLmZyZWVUZXh0dXJlcykge1xuICAgICAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbdGV4U2hhcGVdLmZvckVhY2goZnVuY3Rpb24gKHRleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUodGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHRleFNoYXBlIGluIHRoaXMudXNlZFRleHR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLnVzZWRUZXh0dXJlc1t0ZXhTaGFwZV0uZm9yRWFjaChmdW5jdGlvbiAodGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZSh0ZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnVzZWRUZXh0dXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzID0gMDtcbiAgICAgICAgdGhpcy5udW1GcmVlVGV4dHVyZXMgPSAwO1xuICAgICAgICB0aGlzLl9udW1CeXRlc0FsbG9jYXRlZCA9IDA7XG4gICAgICAgIHRoaXMuX251bUJ5dGVzRnJlZSA9IDA7XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dHVyZU1hbmFnZXI7XG59KCkpO1xuZnVuY3Rpb24gbnVtQnl0ZXNGb3JJbnRlcm5hbEZvcm1hdChnbCwgaW50ZXJuYWxGb3JtYXQpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgdmFyIGdsYW55ID0gZ2w7XG4gICAgaWYgKGludGVybmFsRm9ybWF0ID09PSBnbGFueS5SMzJGKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnRlcm5hbEZvcm1hdCA9PT0gZ2xhbnkuUjE2Rikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW50ZXJuYWxGb3JtYXQgPT09IGdsYW55LlJHQkEzMkYpIHtcbiAgICAgICAgcmV0dXJuIDE2O1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnRlcm5hbEZvcm1hdCA9PT0gZ2wuUkdCQSkge1xuICAgICAgICByZXR1cm4gMTY7XG4gICAgfVxuICAgIGVsc2UgaWYgKGludGVybmFsRm9ybWF0ID09PSBnbGFueS5SR0JBMTZGKSB7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGludGVybmFsIGZvcm1hdCBcIiArIGludGVybmFsRm9ybWF0KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVCeXRlcyhzaGFwZSwgcGh5c2ljYWxUZXhUeXBlLCBnbCwgdGV4dHVyZUNvbmZpZywgaXNQYWNrZWQpIHtcbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gaW5mZXIgcGFja2VkIHN0YXR1cyBmcm9tIHRoZSB0ZXh0dXJlIHR5cGUgYmVjYXVzZVxuICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgdGV4dHVyZUNvbmZpZywgZGlmZmVyZW50ICB0ZXh0dXJlIHR5cGVzIG1heSByZXNvbHZlIHRvIHRoZVxuICAgIC8vIHNhbWUgaW50ZXJuYWwgZm9ybWF0IChlLmcuIGluIFdlYkdMMSwgdGhlIGludGVybmFsIGZvcm1hdCBmb3JcbiAgICAvLyBVTlBBQ0tFRF9GTE9BVDE2IHRleHR1cmVzIGlzIGdsLlJHQkEpLiBUaGVyZWZvcmUgd2UgcGFzcyBpbiBgaXNQYWNrZWRgXG4gICAgLy8gZXhwbGljaXRseS5cbiAgICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBpbnRlcm5hbEZvcm1hdEZvclBoeXNpY2FsVGV4VHlwZShwaHlzaWNhbFRleFR5cGUsIHRleHR1cmVDb25maWcpO1xuICAgIHZhciBudW1FbGVtZW50cztcbiAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQoc2hhcGVbMF0sIHNoYXBlWzFdKSwgcGFja2VkV2lkdGggPSBfYVswXSwgcGFja2VkSGVpZ2h0ID0gX2FbMV07XG4gICAgICAgIG51bUVsZW1lbnRzID0gcGFja2VkV2lkdGggKiBwYWNrZWRIZWlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgX2IgPSBnZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHNoYXBlWzBdLCBzaGFwZVsxXSksIHdpZHRoID0gX2JbMF0sIGhlaWdodCA9IF9iWzFdO1xuICAgICAgICBudW1FbGVtZW50cyA9IHdpZHRoICogaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgYnl0ZXNQZXJFbGVtZW50ID0gbnVtQnl0ZXNGb3JJbnRlcm5hbEZvcm1hdChnbCwgaW50ZXJuYWxGb3JtYXQpO1xuICAgIHJldHVybiBudW1FbGVtZW50cyAqIGJ5dGVzUGVyRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGludGVybmFsRm9ybWF0Rm9yUGh5c2ljYWxUZXhUeXBlKHBoeXNpY2FsVGV4VHlwZSwgdGV4dHVyZUNvbmZpZykge1xuICAgIHN3aXRjaCAocGh5c2ljYWxUZXhUeXBlKSB7XG4gICAgICAgIGNhc2UgUGh5c2ljYWxUZXh0dXJlVHlwZS5QQUNLRURfMlgyX0ZMT0FUMzI6XG4gICAgICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxGb3JtYXRGb3JQYWNrZWRNYXRyaXhUZXh0dXJlKHRleHR1cmVDb25maWcpO1xuICAgICAgICBjYXNlIFBoeXNpY2FsVGV4dHVyZVR5cGUuUEFDS0VEXzJYMl9GTE9BVDE2OlxuICAgICAgICAgICAgcmV0dXJuIGdldEludGVybmFsRm9ybWF0Rm9yRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmUodGV4dHVyZUNvbmZpZyk7XG4gICAgICAgIGNhc2UgUGh5c2ljYWxUZXh0dXJlVHlwZS5VTlBBQ0tFRF9GTE9BVDMyOlxuICAgICAgICAgICAgcmV0dXJuIGdldEludGVybmFsRm9ybWF0Rm9yRmxvYXQzMk1hdHJpeFRleHR1cmUodGV4dHVyZUNvbmZpZyk7XG4gICAgICAgIGNhc2UgUGh5c2ljYWxUZXh0dXJlVHlwZS5VTlBBQ0tFRF9GTE9BVDE2OlxuICAgICAgICAgICAgcmV0dXJuIGdldEludGVybmFsRm9ybWF0Rm9yRmxvYXQxNk1hdHJpeFRleHR1cmUodGV4dHVyZUNvbmZpZyk7XG4gICAgICAgIGNhc2UgUGh5c2ljYWxUZXh0dXJlVHlwZS5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEU6XG4gICAgICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxGb3JtYXRGb3JVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZSh0ZXh0dXJlQ29uZmlnKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcGh5c2ljYWwgdGV4dHVyZSB0eXBlIFwiICsgcGh5c2ljYWxUZXhUeXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQaHlzaWNhbFRleHR1cmVGb3JSZW5kZXJpbmcoaXNQYWNrZWQpIHtcbiAgICBpZiAodGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRCcpKSB7XG4gICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFBoeXNpY2FsVGV4dHVyZVR5cGUuUEFDS0VEXzJYMl9GTE9BVDMyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQaHlzaWNhbFRleHR1cmVUeXBlLlVOUEFDS0VEX0ZMT0FUMzI7XG4gICAgfVxuICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICByZXR1cm4gUGh5c2ljYWxUZXh0dXJlVHlwZS5QQUNLRURfMlgyX0ZMT0FUMTY7XG4gICAgfVxuICAgIHJldHVybiBQaHlzaWNhbFRleHR1cmVUeXBlLlVOUEFDS0VEX0ZMT0FUMTY7XG59XG5mdW5jdGlvbiBnZXRQaHlzaWNhbEZyb21Mb2dpY2FsVGV4dHVyZVR5cGUobG9naWNhbFRleFR5cGUsIGlzUGFja2VkKSB7XG4gICAgaWYgKGxvZ2ljYWxUZXhUeXBlID09PSBUZXh0dXJlVXNhZ2UuVVBMT0FEKSB7XG4gICAgICAgIHJldHVybiBQaHlzaWNhbFRleHR1cmVUeXBlLlBBQ0tFRF8yWDJfRkxPQVQzMjtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9naWNhbFRleFR5cGUgPT09IFRleHR1cmVVc2FnZS5SRU5ERVIgfHwgbG9naWNhbFRleFR5cGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0UGh5c2ljYWxUZXh0dXJlRm9yUmVuZGVyaW5nKGlzUGFja2VkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9naWNhbFRleFR5cGUgPT09IFRleHR1cmVVc2FnZS5ET1dOTE9BRCB8fFxuICAgICAgICBsb2dpY2FsVGV4VHlwZSA9PT0gVGV4dHVyZVVzYWdlLlBJWEVMUykge1xuICAgICAgICByZXR1cm4gUGh5c2ljYWxUZXh0dXJlVHlwZS5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbG9naWNhbCB0ZXh0dXJlIHR5cGUgXCIgKyBsb2dpY2FsVGV4VHlwZSk7XG59XG5mdW5jdGlvbiBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlUm93c0NvbCwgcGh5c2ljYWxUZXhUeXBlLCBpc1BhY2tlZCkge1xuICAgIHJldHVybiBzaGFwZVJvd3NDb2xbMF0gKyBcIl9cIiArIHNoYXBlUm93c0NvbFsxXSArIFwiX1wiICsgcGh5c2ljYWxUZXhUeXBlICsgXCJfXCIgKyBpc1BhY2tlZDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFVuYXJ5T3BQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuYXJ5T3BQcm9ncmFtKGFTaGFwZSwgb3BTbmlwcGV0KSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gYVNoYXBlO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBmbG9hdCB1bmFyeU9wZXJhdGlvbihmbG9hdCB4KSB7XFxuICAgICAgICBcIiArIG9wU25pcHBldCArIFwiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHkgPSB1bmFyeU9wZXJhdGlvbih4KTtcXG5cXG4gICAgICAgIHNldE91dHB1dCh5KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gVW5hcnlPcFByb2dyYW07XG59KCkpO1xudmFyIENIRUNLX05BTl9TTklQUEVUID0gXCJpZiAoaXNuYW4oeCkpIHJldHVybiB4O1wiO1xudmFyIExJTkVBUiA9IFwicmV0dXJuIHg7XCI7XG52YXIgQUJTID0gXCJyZXR1cm4gYWJzKHgpO1wiO1xudmFyIEVMVSA9IFwicmV0dXJuICh4ID49IDAuMCkgPyB4IDogKGV4cCh4KSAtIDEuMCk7XCI7XG52YXIgUkVMVSA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiAoeCA8IDAuMCkgPyAwLjAgOiB4O1xcblwiO1xudmFyIFJFTFU2ID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IG1pbig2LjAsIHgpO1xcblwiO1xudmFyIENMT05FID0gJ3JldHVybiB4Oyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBMSU5FQVIkMSA9IFwicmV0dXJuIHg7XCI7XG52YXIgRUxVJDEgPSBcIlxcbiAgdmVjNCByZXN1bHQ7XFxuXFxuICByZXN1bHQuciA9ICh4LnIgPj0gMC4wKSA/IHguciA6IChleHAoeC5yKSAtIDEuMCk7XFxuICByZXN1bHQuZyA9ICh4LmcgPj0gMC4wKSA/IHguZyA6IChleHAoeC5nKSAtIDEuMCk7XFxuICByZXN1bHQuYiA9ICh4LmIgPj0gMC4wKSA/IHguYiA6IChleHAoeC5iKSAtIDEuMCk7XFxuICByZXN1bHQuYSA9ICh4LmEgPj0gMC4wKSA/IHguYSA6IChleHAoeC5hKSAtIDEuMCk7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiO1xudmFyIFJFTFUkMSA9IFwiXFxuICB2ZWM0IHJlc3VsdCA9IHggKiB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoeCwgdmVjNCgwLjApKSk7XFxuICBidmVjNCBpc05hTiA9IGlzbmFuKHgpO1xcblxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID8geC5yIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPyB4LmcgOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IHguYiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID8geC5hIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiO1xudmFyIFJFTFU2JDEgPSBcIlxcbiAgdmVjNCByZXN1bHQgPSBtaW4oeCwgdmVjNCg2LikpICogdmVjNChncmVhdGVyVGhhbkVxdWFsKHgsIHZlYzQoMC4wKSkpO1xcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcXG5cXG4gIHJlc3VsdC5yID0gaXNOYU4uciA/IHguciA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8geC5nIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPyB4LmIgOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA/IHguYSA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIjtcbnZhciBVbmFyeU9wUGFja2VkUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbmFyeU9wUGFja2VkUHJvZ3JhbShhU2hhcGUsIG9wU25pcHBldCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5wYWNrZWRJbnB1dHMgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhY2tlZE91dHB1dCA9IHRydWU7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBhU2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZlYzQgdW5hcnlPcGVyYXRpb24odmVjNCB4KSB7XFxuICAgICAgICBcIiArIG9wU25pcHBldCArIFwiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgeCA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCB5ID0gdW5hcnlPcGVyYXRpb24oeCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoeSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFVuYXJ5T3BQYWNrZWRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFVucGFja1Byb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5wYWNrUHJvZ3JhbShvdXRwdXRTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5wYWNrZWRJbnB1dHMgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhY2tlZE91dHB1dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHZhciByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgY2hhbm5lbHMgPSBnZXRDaGFubmVscygncmMnLCByYW5rKTtcbiAgICAgICAgdmFyIGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgICAgIHZhciBzb3VyY2VDb29yZHMgPSBnZXRTb3VyY2VDb29yZHMocmFuaywgY2hhbm5lbHMpO1xuICAgICAgICB2YXIgaW5uZXJEaW1zID0gY2hhbm5lbHMuc2xpY2UoLTIpO1xuICAgICAgICB2YXIgY29vcmRzID0gcmFuayA8PSAxID8gJ3JjJyA6IFwidmVjMihcIiArIGlubmVyRGltcy5qb2luKCcsJykgKyBcIilcIjtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHBhY2tlZElucHV0ID0gZ2V0QShcIiArIHNvdXJjZUNvb3JkcyArIFwiKTtcXG5cXG4gICAgICAgIHNldE91dHB1dChnZXRDaGFubmVsKHBhY2tlZElucHV0LCBcIiArIGNvb3JkcyArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFVucGFja1Byb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgd2hlcmVJbXBsID0gdGYua2VybmVsX2ltcGxzLndoZXJlSW1wbDtcbnZhciBFUFNJTE9OX0ZMT0FUMzIgPSAxZS03O1xudmFyIEVQU0lMT05fRkxPQVQxNiA9IDFlLTQ7XG52YXIgYmluYXJ5Q2FjaGVzID0ge307XG5mdW5jdGlvbiBnZXRCaW5hcnlDYWNoZSh3ZWJHTFZlcnNpb24pIHtcbiAgICBpZiAod2ViR0xWZXJzaW9uIGluIGJpbmFyeUNhY2hlcykge1xuICAgICAgICByZXR1cm4gYmluYXJ5Q2FjaGVzW3dlYkdMVmVyc2lvbl07XG4gICAgfVxuICAgIGJpbmFyeUNhY2hlc1t3ZWJHTFZlcnNpb25dID0ge307XG4gICAgcmV0dXJuIGJpbmFyeUNhY2hlc1t3ZWJHTFZlcnNpb25dO1xufVxuLy8gRW1waXJpY2FsbHkgZGV0ZXJtaW5lZCBjb25zdGFudCB1c2VkIHRvIGRldGVybWluZSBzaXplIHRocmVzaG9sZCBmb3IgaGFuZGluZ1xuLy8gb2ZmIGV4ZWN1dGlvbiB0byB0aGUgQ1BVLlxudmFyIENQVV9IQU5ET0ZGX1NJWkVfVEhSRVNIT0xEID0gMTI4O1xuLy8gRW1waXJpY2FsbHkgZGV0ZXJtaW5lZCBjb25zdGFudCB1c2VkIHRvIGRlY2lkZSB0aGUgbnVtYmVyIG9mIE1CIG9uIEdQVVxuLy8gYmVmb3JlIHdlIHdhcm4gYWJvdXQgaGlnaCBtZW1vcnkgdXNlLiBUaGUgTUIgYXJlIHRoaXMgY29uc3RhbnQgKiBzY3JlZW4gYXJlYVxuLy8gKiBkcGkgLyAxMDI0IC8gMTAyNC5cbnZhciBCRUZPUkVfUEFHSU5HX0NPTlNUQU5UID0gNjAwO1xuZnVuY3Rpb24gbnVtTUJCZWZvcmVXYXJuaW5nKCkge1xuICAgIGlmICh0Zi5lbnYoKS5nbG9iYWwuc2NyZWVuID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDEwMjQ7IC8vIDEgR0IuXG4gICAgfVxuICAgIHJldHVybiAodGYuZW52KCkuZ2xvYmFsLnNjcmVlbi5oZWlnaHQgKiB0Zi5lbnYoKS5nbG9iYWwuc2NyZWVuLndpZHRoICpcbiAgICAgICAgd2luZG93LmRldmljZVBpeGVsUmF0aW8pICpcbiAgICAgICAgQkVGT1JFX1BBR0lOR19DT05TVEFOVCAvIDEwMjQgLyAxMDI0O1xufVxudmFyIE1hdGhCYWNrZW5kV2ViR0wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hdGhCYWNrZW5kV2ViR0wsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF0aEJhY2tlbmRXZWJHTChncGdwdSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyBNYXBzIGRhdGEgaWRzIHRoYXQgaGF2ZSBhIHBlbmRpbmcgcmVhZCBvcGVyYXRpb24sIHRvIGxpc3Qgb2Ygc3Vic2NyaWJlcnMuXG4gICAgICAgIF90aGlzLnBlbmRpbmdSZWFkID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgLy8gTGlzdCBvZiBkYXRhIGlkcyB0aGF0IGFyZSBzY2hlZHVsZWQgZm9yIGRpc3Bvc2FsLCBidXQgYXJlIHdhaXRpbmcgb24gYVxuICAgICAgICAvLyBwZW5kaW5nIHJlYWQgb3BlcmF0aW9uLlxuICAgICAgICBfdGhpcy5wZW5kaW5nRGlzcG9zYWwgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICAvLyBVc2VkIHRvIGNvdW50IHRoZSBudW1iZXIgb2YgJ3NoYWxsb3cnIHNsaWNlZCB0ZW5zb3JzIHRoYXQgcG9pbnQgdG8gdGhlXG4gICAgICAgIC8vIHNhbWUgZGF0YSBpZC5cbiAgICAgICAgX3RoaXMuZGF0YVJlZkNvdW50ID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgX3RoaXMubnVtQnl0ZXNJbkdQVSA9IDA7XG4gICAgICAgIC8vIEFjY3VtdWxhdGVkIHRpbWUgc3BlbnQgKGluY2x1ZGluZyBibG9ja2luZykgaW4gdXBsb2FkaW5nIGRhdGEgdG8gd2ViZ2wuXG4gICAgICAgIF90aGlzLnVwbG9hZFdhaXRNcyA9IDA7XG4gICAgICAgIC8vIEFjY3VtdWxhdGVkIHRpbWUgc3BlbnQgKGluY2x1ZGluZyBibG9ja2luZyBpbiBkb3dubG9hZGluZyBkYXRhIGZyb20gd2ViZ2wuXG4gICAgICAgIF90aGlzLmRvd25sb2FkV2FpdE1zID0gMDtcbiAgICAgICAgX3RoaXMud2FybmVkQWJvdXRNZW1vcnkgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMud2FybmVkQWJvdXRDUFVCYWNrZW5kID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnBlbmRpbmdEZWxldGVzID0gMDtcbiAgICAgICAgX3RoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0Zi5lbnYoKS5nZXRCb29sKCdIQVNfV0VCR0wnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdwZ3B1ID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBnbCA9IGdldFdlYkdMQ29udGV4dCh0Zi5lbnYoKS5nZXROdW1iZXIoJ1dFQkdMX1ZFUlNJT04nKSk7XG4gICAgICAgICAgICBfdGhpcy5iaW5hcnlDYWNoZSA9IGdldEJpbmFyeUNhY2hlKHRmLmVudigpLmdldE51bWJlcignV0VCR0xfVkVSU0lPTicpKTtcbiAgICAgICAgICAgIF90aGlzLmdwZ3B1ID0gbmV3IEdQR1BVQ29udGV4dChnbCk7XG4gICAgICAgICAgICBfdGhpcy5jYW52YXMgPSBnbC5jYW52YXM7XG4gICAgICAgICAgICBfdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmdwZ3B1ID0gZ3BncHU7XG4gICAgICAgICAgICBfdGhpcy5iaW5hcnlDYWNoZSA9IHt9O1xuICAgICAgICAgICAgX3RoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuY2FudmFzID0gZ3BncHUuZ2wuY2FudmFzO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnRleHR1cmVNYW5hZ2VyID0gbmV3IFRleHR1cmVNYW5hZ2VyKF90aGlzLmdwZ3B1KTtcbiAgICAgICAgX3RoaXMubnVtTUJCZWZvcmVXYXJuaW5nID0gbnVtTUJCZWZvcmVXYXJuaW5nKCk7XG4gICAgICAgIF90aGlzLnRleERhdGEgPSBuZXcgdGYuRGF0YVN0b3JhZ2UoX3RoaXMsIHRmLmVuZ2luZSgpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5udW1EYXRhSWRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXhEYXRhLm51bURhdGFJZHMoKSArXG4gICAgICAgICAgICAodGhpcy5jcHVCYWNrZW5kID8gdGhpcy5jcHVCYWNrZW5kLm51bURhdGFJZHMoKSA6IDApIC1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RlbGV0ZXM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAodGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfQ0hFQ0tfTlVNRVJJQ0FMX1BST0JMRU1TJykgfHxcbiAgICAgICAgICAgIHRmLmVudigpLmdldEJvb2woJ0RFQlVHJykpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tOdW1lcmljYWxQcm9ibGVtcyh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkdHlwZSA9PT0gJ2NvbXBsZXg2NCcgJiYgdmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB3cml0ZSB0byBhIGNvbXBsZXg2NCBkdHlwZS4gXCIgK1xuICAgICAgICAgICAgICAgIFwiUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YUlkID0ge307XG4gICAgICAgIHRoaXMudGV4RGF0YS5zZXQoZGF0YUlkLCB7XG4gICAgICAgICAgICBzaGFwZTogc2hhcGUsXG4gICAgICAgICAgICBkdHlwZTogZHR5cGUsXG4gICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICAgIHVzYWdlOiBUZXh0dXJlVXNhZ2UuVVBMT0FELFxuICAgICAgICAgICAgcmVmQ291bnQ6IDEsXG4gICAgICAgICAgICBjb21wbGV4UGFyZW50UmVmQ291bnQ6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhSWQ7XG4gICAgfTtcbiAgICAvKiogSW5jcmVhc2UgcmVmQ291bnQgb2YgYSBgVGV4dHVyZURhdGFgLiAqL1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmluY1JlZiA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgdmFyIHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgICAgIHRleERhdGEucmVmQ291bnQrKztcbiAgICB9O1xuICAgIC8qKiBEZWNyZWFzZSByZWZDb3VudCBvZiBhIGBUZXh0dXJlRGF0YWAuICovXG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZGVjUmVmID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICBpZiAodGhpcy50ZXhEYXRhLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICB2YXIgdGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgICAgIHRleERhdGEucmVmQ291bnQtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVjcmVhc2UgcmVmQ291bnQgb2YgYSBgVGV4dHVyZURhdGFgIGlmIGl0IGlzIGEgY29tcG9uZW50IG9mIGNvbXBsZXhcbiAgICAgKiB0ZW5zb3IuXG4gICAgICovXG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZGVjQ29tcGxleFJlZiA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4RGF0YS5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgdmFyIHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgICAgICAgICBpZiAodGV4RGF0YS5jb21wbGV4UGFyZW50UmVmQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGV4RGF0YS5yZWZDb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGRhdGFJZCwgdmFsdWVzLCBzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKHRmLmVudigpLmdldEJvb2woJ0RFQlVHJykpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tOdW1lcmljYWxQcm9ibGVtcyh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB3cml0ZSB0byBhIGNvbXBsZXg2NCBkdHlwZS4gXCIgK1xuICAgICAgICAgICAgICAgIFwiUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleERhdGEuc2V0KGRhdGFJZCwge1xuICAgICAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICAgICAgZHR5cGU6IGR0eXBlLFxuICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICB1c2FnZTogVGV4dHVyZVVzYWdlLlVQTE9BRCxcbiAgICAgICAgICAgIHJlZkNvdW50OiAxLFxuICAgICAgICAgICAgY29tcGxleFBhcmVudFJlZkNvdW50OiAwXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8gPSBmdW5jdGlvbiAodGVuc29ySW5mbykge1xuICAgICAgICB2YXIgZGF0YUlkID0gdGVuc29ySW5mby5kYXRhSWQ7XG4gICAgICAgIGlmICh0aGlzLnRleERhdGEuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlRGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgICAgIHRleHR1cmVEYXRhLnJlZkNvdW50LS07XG4gICAgICAgICAgICBpZiAodGV4dHVyZURhdGEucmVmQ291bnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlRGF0YShkYXRhSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZWFkU3luYyA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgdmFyIHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0ZXhEYXRhLnZhbHVlcywgZHR5cGUgPSB0ZXhEYXRhLmR0eXBlLCBjb21wbGV4VGVuc29ySW5mb3MgPSB0ZXhEYXRhLmNvbXBsZXhUZW5zb3JJbmZvcywgc2xpY2UgPSB0ZXhEYXRhLnNsaWNlLCBzaGFwZSA9IHRleERhdGEuc2hhcGUsIGlzUGFja2VkID0gdGV4RGF0YS5pc1BhY2tlZDtcbiAgICAgICAgLy8gVGhlIHByZXNlbmNlIG9mIGBzbGljZWAgaW5kaWNhdGVzIHRoaXMgdGVuc29yIGlzIGEgc2hhbGxvdyBzbGljZSBvZiBhXG4gICAgICAgIC8vIGRpZmZlcmVudCB0ZW5zb3IsIGFuZCBpcyB1c2luZyB0aGF0IG9yaWdpbmFsIHRlbnNvcidzIHRleHR1cmUuIFJ1blxuICAgICAgICAvLyBgY2xvbmVgIGluIG9yZGVyIHRvIGNvcHkgdGhhdCB0ZXh0dXJlIGFuZCByZWFkIGZyb20gaXQuXG4gICAgICAgIGlmIChzbGljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICAgIHByb2dyYW0gPSBuZXcgVW5hcnlPcFBhY2tlZFByb2dyYW0oc2hhcGUsIENMT05FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oc2hhcGUsIENMT05FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbeyBkYXRhSWQ6IGRhdGFJZCwgc2hhcGU6IHNoYXBlLCBkdHlwZTogZHR5cGUgfV0sIGR0eXBlKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5yZWFkU3luYyhyZXMuZGF0YUlkKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEFuZENhY2hlT25DUFUoZGF0YUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRUaW1lUHJvZ3JhbSA9IHRoaXMuYWN0aXZlVGltZXJzICE9IG51bGw7XG4gICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgaWYgKHNob3VsZFRpbWVQcm9ncmFtKSB7XG4gICAgICAgICAgICBzdGFydCA9IHRmLnV0aWwubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKGR0eXBlID09PSAnY29tcGxleDY0Jykge1xuICAgICAgICAgICAgdmFyIHJlYWxWYWx1ZXMgPSB0aGlzLnJlYWRTeW5jKGNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLmRhdGFJZCk7XG4gICAgICAgICAgICB2YXIgaW1hZ1ZhbHVlcyA9IHRoaXMucmVhZFN5bmMoY29tcGxleFRlbnNvckluZm9zLmltYWcuZGF0YUlkKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRmLmJhY2tlbmRfdXRpbC5tZXJnZVJlYWxBbmRJbWFnQXJyYXlzKHJlYWxWYWx1ZXMsIGltYWdWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5nZXRWYWx1ZXNGcm9tVGV4dHVyZShkYXRhSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRUaW1lUHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5kb3dubG9hZFdhaXRNcyArPSB0Zi51dGlsLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEFuZENhY2hlT25DUFUoZGF0YUlkLCByZXN1bHQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmliZXJzXzEsIHRleERhdGEsIHZhbHVlcywgc2hhcGUsIHNsaWNlLCBkdHlwZSwgY29tcGxleFRlbnNvckluZm9zLCBpc1BhY2tlZCwgcHJvZ3JhbSwgcmVzLCBkYXRhLCBidWZmZXIsIHRtcERvd25sb2FkVGFyZ2V0LCB0bXBEYXRhLCB2YWxzLCBwcywgcmVhbFZhbHVlcywgaW1hZ1ZhbHVlcywgc2l6ZSwgZFR5cGVWYWxzLCBzdWJzY3JpYmVycztcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdSZWFkLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnNfMSA9IHRoaXMucGVuZGluZ1JlYWQuZ2V0KGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiBzdWJzY3JpYmVyc18xLnB1c2gocmVzb2x2ZSk7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB0ZXhEYXRhLnZhbHVlcywgc2hhcGUgPSB0ZXhEYXRhLnNoYXBlLCBzbGljZSA9IHRleERhdGEuc2xpY2UsIGR0eXBlID0gdGV4RGF0YS5kdHlwZSwgY29tcGxleFRlbnNvckluZm9zID0gdGV4RGF0YS5jb21wbGV4VGVuc29ySW5mb3MsIGlzUGFja2VkID0gdGV4RGF0YS5pc1BhY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwcmVzZW5jZSBvZiBgc2xpY2VgIGluZGljYXRlcyB0aGlzIHRlbnNvciBpcyBhIHNoYWxsb3cgc2xpY2Ugb2YgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50IHRlbnNvciwgYW5kIGlzIHVzaW5nIHRoYXQgb3JpZ2luYWwgdGVuc29yJ3MgdGV4dHVyZS4gUnVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgY2xvbmVgIGluIG9yZGVyIHRvIGNvcHkgdGhhdCB0ZXh0dXJlIGFuZCByZWFkIGZyb20gaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW0gPSBuZXcgVW5hcnlPcFBhY2tlZFByb2dyYW0oc2hhcGUsIENMT05FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oc2hhcGUsIENMT05FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpcy5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3sgZGF0YUlkOiBkYXRhSWQsIHNoYXBlOiBzaGFwZSwgZHR5cGU6IGR0eXBlIH1dLCBkdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMucmVhZChyZXMuZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuY29udmVydEFuZENhY2hlT25DUFUoZGF0YUlkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRmLmVudigpLmdldEJvb2woJ1dFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRUQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmLmVudigpLmdldE51bWJlcignV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGVuc29yLmRhdGEoKSB3aXRoIFdFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRUQ9ZmFsc2UgYW5kIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJXRUJHTF9WRVJTSU9OPTIgbm90IHlldCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdHlwZSAhPT0gJ2NvbXBsZXg2NCcgJiYgdGYuZW52KCkuZ2V0KCdXRUJHTF9CVUZGRVJfU1VQUE9SVEVEJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NzaWJseSBjb3B5IHRoZSB0ZXh0dXJlIGludG8gYSBidWZmZXIgYmVmb3JlIGluc2VydGluZyBhIGZlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcERvd25sb2FkVGFyZ2V0ID0gdGhpcy5kZWNvZGUoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBEYXRhID0gdGhpcy50ZXhEYXRhLmdldCh0bXBEb3dubG9hZFRhcmdldC5kYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IChfYSA9IHRoaXMuZ3BncHUpLmNyZWF0ZUJ1ZmZlckZyb21UZXh0dXJlLmFwcGx5KF9hLCBbdG1wRGF0YS50ZXh0dXJlXS5jb25jYXQoZ2V0RGVuc2VUZXhTaGFwZShzaGFwZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlYWQuc2V0KGRhdGFJZCwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZHR5cGUgIT09ICdjb21wbGV4NjQnKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBmZW5jZSBhbmQgd2FpdCBmb3IgaXQgdG8gcmVzb2x2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ3BncHUuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBmZW5jZSBhbmQgd2FpdCBmb3IgaXQgdG8gcmVzb2x2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZHR5cGUgPT09ICdjb21wbGV4NjQnKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZChjb21wbGV4VGVuc29ySW5mb3MucmVhbC5kYXRhSWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWQoY29tcGxleFRlbnNvckluZm9zLmltYWcuZGF0YUlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHMgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsVmFsdWVzID0gcHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnVmFsdWVzID0gcHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxzID0gdGYuYmFja2VuZF91dGlsLm1lcmdlUmVhbEFuZEltYWdBcnJheXMocmVhbFZhbHVlcywgaW1hZ1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFscyA9IHRoaXMuZ2V0VmFsdWVzRnJvbVRleHR1cmUoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHMgPSB0aGlzLmdwZ3B1LmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXIoYnVmZmVyLCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcERvd25sb2FkVGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHRtcERvd25sb2FkVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRUeXBlVmFscyA9IHRoaXMuY29udmVydEFuZENhY2hlT25DUFUoZGF0YUlkLCB2YWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzID0gdGhpcy5wZW5kaW5nUmVhZC5nZXQoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlYWQuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RpZnkgYWxsIHBlbmRpbmcgcmVhZHMuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiByZXNvbHZlKGRUeXBlVmFscyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGlzcG9zYWwuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlRGF0YShkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RlbGV0ZXMtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkVHlwZVZhbHNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmJ1ZmZlclN5bmMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucmVhZFN5bmModC5kYXRhSWQpO1xuICAgICAgICB2YXIgZGVjb2RlZERhdGEgPSBkYXRhO1xuICAgICAgICBpZiAodC5kdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIHRoZSBieXRlcyBpbnRvIHN0cmluZy5cbiAgICAgICAgICAgICAgICBkZWNvZGVkRGF0YSA9IGRhdGEubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiB0Zi51dGlsLmRlY29kZVN0cmluZyhkKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNvZGUgZW5jb2RlZCBzdHJpbmcgYnl0ZXMgaW50byB1dGYtOCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0Zi5idWZmZXIodC5zaGFwZSwgdC5kdHlwZSwgZGVjb2RlZERhdGEpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY2hlY2tOdW1lcmljYWxQcm9ibGVtcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBudW0gPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBpZiAoIWNhbkJlUmVwcmVzZW50ZWQobnVtKSkge1xuICAgICAgICAgICAgICAgIGlmICh0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9SRU5ERVJfRkxPQVQzMl9DQVBBQkxFJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgdmFsdWUgXCIgKyBudW0gKyBcIiBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgd2l0aCB5b3VyIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY3VycmVudCBzZXR0aW5ncy4gQ29uc2lkZXIgZW5hYmxpbmcgZmxvYXQzMiByZW5kZXJpbmc6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJ3RmLmVudigpLnNldCgnV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRCcsIHRydWUpOydcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIHZhbHVlIFwiICsgbnVtICsgXCIgY2Fubm90IGJlIHJlcHJlc2VudGVkIG9uIHRoaXMgZGV2aWNlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ2V0VmFsdWVzRnJvbVRleHR1cmUgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpLCBzaGFwZSA9IF9iLnNoYXBlLCBkdHlwZSA9IF9iLmR0eXBlLCBpc1BhY2tlZCA9IF9iLmlzUGFja2VkO1xuICAgICAgICB2YXIgc2l6ZSA9IHRmLnV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgICAgIGlmICh0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEJykpIHtcbiAgICAgICAgICAgIHZhciB0bXBUYXJnZXQgPSB0aGlzLmRlY29kZShkYXRhSWQpO1xuICAgICAgICAgICAgdmFyIHRtcERhdGFfMSA9IHRoaXMudGV4RGF0YS5nZXQodG1wVGFyZ2V0LmRhdGFJZCk7XG4gICAgICAgICAgICB2YXIgdmFsc18xID0gKF9hID0gdGhpcy5ncGdwdSkuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZS5hcHBseShfYSwgW3RtcERhdGFfMS50ZXh0dXJlXS5jb25jYXQoZ2V0RGVuc2VUZXhTaGFwZShzaGFwZSkpKS5zdWJhcnJheSgwLCBzaXplKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odG1wVGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiB2YWxzXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZFVzZVBhY2tlZFByb2dyYW0gPSB0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9QQUNLJykgJiYgaXNQYWNrZWQgPT09IHRydWU7XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IHNob3VsZFVzZVBhY2tlZFByb2dyYW0gPyBnZXRTaGFwZUFzM0Qoc2hhcGUpIDogc2hhcGU7XG4gICAgICAgIHZhciBwcm9ncmFtID0gc2hvdWxkVXNlUGFja2VkUHJvZ3JhbSA/XG4gICAgICAgICAgICBuZXcgRW5jb2RlRmxvYXRQYWNrZWRQcm9ncmFtKG91dHB1dFNoYXBlKSA6XG4gICAgICAgICAgICBuZXcgRW5jb2RlRmxvYXRQcm9ncmFtKG91dHB1dFNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt7IHNoYXBlOiBvdXRwdXRTaGFwZSwgZHR5cGU6IGR0eXBlLCBkYXRhSWQ6IGRhdGFJZCB9XSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgdmFyIHRtcERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KG91dHB1dC5kYXRhSWQpO1xuICAgICAgICB2YXIgdmFscyA9IHRoaXMuZ3BncHVcbiAgICAgICAgICAgIC5kb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZSh0bXBEYXRhLnRleHR1cmUsIHRtcERhdGEudGV4U2hhcGVbMF0sIHRtcERhdGEudGV4U2hhcGVbMV0pXG4gICAgICAgICAgICAuc3ViYXJyYXkoMCwgc2l6ZSk7XG4gICAgICAgIHRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50aW1lID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9sZEFjdGl2ZVRpbWVycywgbmV3QWN0aXZlVGltZXJzLCBvdXRlck1vc3RUaW1lLCBmbGF0dGVuZWRBY3RpdmVUaW1lclF1ZXJpZXMsIGZsYXR0ZW5lZEFjdGl2ZVRpbWVyTmFtZXMsIHJlcywga2VybmVsTXNfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZEFjdGl2ZVRpbWVycyA9IHRoaXMuYWN0aXZlVGltZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QWN0aXZlVGltZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlck1vc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9ncmFtVGltZXJzU3RhY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrID0gbmV3QWN0aXZlVGltZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyTW9zdFRpbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVUaW1lcnMucHVzaChuZXdBY3RpdmVUaW1lcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVUaW1lcnMgPSBuZXdBY3RpdmVUaW1lcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuZWRBY3RpdmVUaW1lclF1ZXJpZXMgPSB0Zi51dGlsLmZsYXR0ZW4odGhpcy5hY3RpdmVUaW1lcnMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnF1ZXJ5OyB9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkICE9IG51bGw7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlbmVkQWN0aXZlVGltZXJOYW1lcyA9IHRmLnV0aWwuZmxhdHRlbih0aGlzLmFjdGl2ZVRpbWVycy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZTsgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCAhPSBudWxsOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlVGltZXJzID0gb2xkQWN0aXZlVGltZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGVyTW9zdFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2dyYW1UaW1lcnNTdGFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkV2FpdE1zOiB0aGlzLnVwbG9hZFdhaXRNcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZFdhaXRNczogdGhpcy5kb3dubG9hZFdhaXRNcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXJuZWxNczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxsTXM6IG51bGwgLy8gd2lsbCBiZSBmaWxsZWQgYnkgdGhlIGVuZ2luZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRmLmVudigpLmdldE51bWJlcignV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJykgPiAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChmbGF0dGVuZWRBY3RpdmVUaW1lclF1ZXJpZXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAga2VybmVsTXNfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1sna2VybmVsTXMnXSA9IHRmLnV0aWwuc3VtKGtlcm5lbE1zXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzWydnZXRFeHRyYVByb2ZpbGVJbmZvJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtlcm5lbE1zXzEubWFwKGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiAoeyBuYW1lOiBmbGF0dGVuZWRBY3RpdmVUaW1lck5hbWVzW2ldLCBtczogZCB9KTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lICsgXCI6IFwiICsgZC5tczsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1sna2VybmVsTXMnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ1dlYkdMIHF1ZXJ5IHRpbWVycyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LidcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBsb2FkV2FpdE1zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRXYWl0TXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWVtb3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5yZWxpYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBudW1CeXRlc0luR1BVOiB0aGlzLm51bUJ5dGVzSW5HUFUsXG4gICAgICAgICAgICBudW1CeXRlc0luR1BVQWxsb2NhdGVkOiB0aGlzLnRleHR1cmVNYW5hZ2VyLm51bUJ5dGVzQWxsb2NhdGVkLFxuICAgICAgICAgICAgbnVtQnl0ZXNJbkdQVUZyZWU6IHRoaXMudGV4dHVyZU1hbmFnZXIubnVtQnl0ZXNGcmVlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zdGFydFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGYuZW52KCkuZ2V0TnVtYmVyKCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEUnKSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdwZ3B1LmJlZ2luUXVlcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGFydE1zOiB0Zi51dGlsLm5vdygpLCBlbmRNczogbnVsbCB9O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZW5kVGltZXIgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgaWYgKHRmLmVudigpLmdldE51bWJlcignV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJykgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1LmVuZFF1ZXJ5KCk7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnkuZW5kTXMgPSB0Zi51dGlsLm5vdygpO1xuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nZXRRdWVyeVRpbWUgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRpbWVyUXVlcnk7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRmLmVudigpLmdldE51bWJlcignV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmdwZ3B1LndhaXRGb3JRdWVyeUFuZEdldFRpbWUocXVlcnkpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZXJRdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aW1lclF1ZXJ5LmVuZE1zIC0gdGltZXJRdWVyeS5zdGFydE1zXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmRpc3Bvc2VEYXRhID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nRGlzcG9zYWwuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nUmVhZC5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGlzcG9zYWwuYWRkKGRhdGFJZCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEZWxldGVzKys7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8tb3AgaWYgYWxyZWFkeSBkaXNwb3NlZC5cbiAgICAgICAgaWYgKCF0aGlzLnRleERhdGEuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnlpbmcgdG8gZGlzcG9zZSBhIHRleHR1cmVEYXRhIHRoYXQgaGFzIGEgJ2tlcHQnIHJlZkNvdW50LCBlLmcuIHRyeWluZ1xuICAgICAgICAvLyB0byBkaXNwb3NlIGEgdGVuc29yIHdob3NlIGRhdGEgYnVja2V0IGlzIHNoYXJlZCB3aXRoIGEgY29tcGxleCB0ZW5zb3IuIEluXG4gICAgICAgIC8vIHRoaXMgY2FzZSB3ZSBhcmUgcmVtb3ZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIHRleHR1cmVEYXRhLCBidXQgd2VcbiAgICAgICAgLy8gc2hvdWxkbid0IGFjdHVhbGx5IGRpc3Bvc2UgdGhlIHRleHR1cmUuXG4gICAgICAgIGlmICh0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCkuY29tcGxleFBhcmVudFJlZkNvdW50ID4gMCkge1xuICAgICAgICAgICAgdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpLnJlZkNvdW50LS07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWxlYXNlR1BVRGF0YShkYXRhSWQpO1xuICAgICAgICB2YXIgY29tcGxleFRlbnNvckluZm9zID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpLmNvbXBsZXhUZW5zb3JJbmZvcztcbiAgICAgICAgaWYgKGNvbXBsZXhUZW5zb3JJbmZvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRleERhdGEuZ2V0KGNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLmRhdGFJZCkuY29tcGxleFBhcmVudFJlZkNvdW50LS07XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsKTtcbiAgICAgICAgICAgIHRoaXMudGV4RGF0YS5nZXQoY29tcGxleFRlbnNvckluZm9zLmltYWcuZGF0YUlkKS5jb21wbGV4UGFyZW50UmVmQ291bnQtLTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oY29tcGxleFRlbnNvckluZm9zLmltYWcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4RGF0YS5kZWxldGUoZGF0YUlkKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlbGVhc2VHUFVEYXRhID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCksIHRleHR1cmUgPSBfYS50ZXh0dXJlLCBkdHlwZSA9IF9hLmR0eXBlLCB0ZXhTaGFwZSA9IF9hLnRleFNoYXBlLCB1c2FnZSA9IF9hLnVzYWdlLCBpc1BhY2tlZCA9IF9hLmlzUGFja2VkLCBzbGljZSA9IF9hLnNsaWNlO1xuICAgICAgICB2YXIga2V5ID0gc2xpY2UgJiYgc2xpY2Uub3JpZ0RhdGFJZCB8fCBkYXRhSWQ7XG4gICAgICAgIHZhciByZWZDb3VudCA9IHRoaXMuZGF0YVJlZkNvdW50LmdldChrZXkpO1xuICAgICAgICBpZiAocmVmQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFSZWZDb3VudC5zZXQoa2V5LCByZWZDb3VudCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhUmVmQ291bnQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBpZiAodGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5udW1CeXRlc0luR1BVIC09IHRoaXMuY29tcHV0ZUJ5dGVzKHRleFNoYXBlLCBkdHlwZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0ZXh0dXJlLCB0ZXhTaGFwZSwgdXNhZ2UsIGlzUGFja2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgdGV4RGF0YS50ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGV4RGF0YS50ZXhTaGFwZSA9IG51bGw7XG4gICAgICAgIHRleERhdGEuaXNQYWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGV4RGF0YS5zbGljZSA9IG51bGw7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nZXRUZXh0dXJlID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICB0aGlzLnVwbG9hZFRvR1BVKGRhdGFJZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCkudGV4dHVyZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW50ZXJuYWwgaW5mb3JtYXRpb24gZm9yIHRoZSBzcGVjaWZpYyBkYXRhIGJ1Y2tldC4gVXNlZCBpbiB1bml0XG4gICAgICogdGVzdHMuXG4gICAgICovXG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ2V0RGF0YUluZm8gPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nZXRDUFVCYWNrZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRmLmVudigpLmdldEJvb2woJ1dFQkdMX0NQVV9GT1JXQVJEJykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNwdUJhY2tlbmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jcHVCYWNrZW5kID0gdGYuZW5naW5lKCkuZmluZEJhY2tlbmQoJ2NwdScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNwdUJhY2tlbmQ7XG4gICAgfTtcbiAgICAvKlxuICAgIFRlc3RzIHdoZXRoZXIgYWxsIHRoZSBpbnB1dHMgdG8gYW4gb3AgYXJlIHNtYWxsIGFuZCBvbiB0aGUgQ1BVLiBUaGlzIGhldXJpc3RpY1xuICAgIGRldGVybWluZXMgd2hlbiBpdCB3b3VsZCBiZSBmYXN0ZXIgdG8gZXhlY3V0ZSBhIGtlcm5lbCBvbiB0aGUgQ1BVLiBXZWJHTFxuICAgIGtlcm5lbHMgb3B0IGludG8gcnVubmluZyB0aGlzIGNoZWNrIGFuZCBmb3J3YXJkaW5nIHdoZW4gYXBwcm9wcmlhdGUuXG4gICAgVE9ETyhodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2lzc3Vlcy84NzIpOiBEZXZlbG9wIGEgbW9yZVxuICAgIHN1c3RhaW5hYmxlIHN0cmF0ZWd5IGZvciBvcHRpbWl6aW5nIGJhY2tlbmQgZXhlY3V0aW9uIG9mIG9wcy5cbiAgICAgKi9cbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zaG91bGRFeGVjdXRlT25DUFUgPSBmdW5jdGlvbiAoaW5wdXRzLCBzaXplVGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzaXplVGhyZXNob2xkID09PSB2b2lkIDApIHsgc2l6ZVRocmVzaG9sZCA9IENQVV9IQU5ET0ZGX1NJWkVfVEhSRVNIT0xEOyB9XG4gICAgICAgIHZhciBjcHVCYWNrZW5kID0gdGhpcy5nZXRDUFVCYWNrZW5kKCk7XG4gICAgICAgIGlmICghdGYuZW52KCkuZ2V0Qm9vbCgnSVNfVEVTVCcpICYmICF0aGlzLndhcm5lZEFib3V0Q1BVQmFja2VuZCAmJlxuICAgICAgICAgICAgY3B1QmFja2VuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1lvdXIgYXBwbGljYXRpb24gY29udGFpbnMgb3BzIHRoYXQgYXJlIHNtYWxsIGVub3VnaCB0byBiZSAnICtcbiAgICAgICAgICAgICAgICAnZXhlY3V0ZWQgb24gdGhlIENQVSBiYWNrZW5kLCBob3dldmVyIHRoZSBDUFUgYmFja2VuZCBjYW5ub3QgJyArXG4gICAgICAgICAgICAgICAgJ2JlIGZvdW5kLiBDb25zaWRlciBpbXBvcnRpbmcgdGhlIENQVSBiYWNrZW5kICcgK1xuICAgICAgICAgICAgICAgICcoQHRlbnNvcmZsb3cvdGZqcy1iYWNrZW5kLWNwdSkgZm9yIGJldHRlciBwZXJmb3JtYW5jZS4nKTtcbiAgICAgICAgICAgIHRoaXMud2FybmVkQWJvdXRDUFVCYWNrZW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3B1QmFja2VuZCAhPSBudWxsICYmXG4gICAgICAgICAgICBpbnB1dHMuZXZlcnkoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBfdGhpcy50ZXhEYXRhLmdldChpbnB1dC5kYXRhSWQpLnRleHR1cmUgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRmLnV0aWwuc2l6ZUZyb21TaGFwZShpbnB1dC5zaGFwZSkgPCBzaXplVGhyZXNob2xkOyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdldEdQR1BVQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3BncHU7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgdGYuYmFja2VuZF91dGlsLndhcm4oJ3RmLndoZXJlKCkgaW4gd2ViZ2wgbG9ja3MgdGhlIFVJIHRocmVhZC4gJyArXG4gICAgICAgICAgICAnQ2FsbCB0Zi53aGVyZUFzeW5jKCkgaW5zdGVhZCcpO1xuICAgICAgICB2YXIgY29uZFZhbHMgPSBjb25kaXRpb24uZGF0YVN5bmMoKTtcbiAgICAgICAgcmV0dXJuIHdoZXJlSW1wbChjb25kaXRpb24uc2hhcGUsIGNvbmRWYWxzKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnBhY2tlZFVuYXJ5T3AgPSBmdW5jdGlvbiAoeCwgb3AsIGR0eXBlKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IFVuYXJ5T3BQYWNrZWRQcm9ncmFtKHguc2hhcGUsIG9wKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0sIGR0eXBlKTtcbiAgICB9O1xuICAgIC8vIFRPRE8obXNvdWxhbmlsbGUpIHJlbW92ZSB0aGlzIG9uY2UgdGhlIGJhY2tlbmQgaGFzIGJlZW4gbW9kdWxhcml6ZWRcbiAgICAvLyBhIGNvcHkgaXMgbmVlZGVkIGhlcmUgdG8gYnJlYWsgYSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIC8vIEFsc28gcmVtb3ZlIHRoZSBvcCBmcm9tIHVuYXJ5X29wLlxuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSBjYXNlcyB3aGVuIHggaXMgY29tcGxleC5cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt4XSkgJiYgeC5kdHlwZSAhPT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgICAgICAgIHZhciBvdXRWYWx1ZXMgPSBzaW1wbGVBYnNJbXBsQ1BVKHRoaXMudGV4RGF0YS5nZXQoeC5kYXRhSWQpLnZhbHVlcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlT3V0cHV0KHguc2hhcGUsIHguZHR5cGUsIG91dFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRmLmVudigpLmdldEJvb2woJ1dFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OUycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHgsIEFCUywgeC5kdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgQUJTKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWFrZVRlbnNvckluZm8gPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGFJZDtcbiAgICAgICAgaWYgKGR0eXBlID09PSAnc3RyaW5nJyAmJiB2YWx1ZXMgIT0gbnVsbCAmJiB2YWx1ZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGYudXRpbC5pc1N0cmluZyh2YWx1ZXNbMF0pKSB7XG4gICAgICAgICAgICB2YXIgZW5jb2RlZFZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHRmLnV0aWwuZW5jb2RlU3RyaW5nKGQpOyB9KTtcbiAgICAgICAgICAgIGRhdGFJZCA9IHRoaXMud3JpdGUoZW5jb2RlZFZhbHVlcywgc2hhcGUsIGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFJZCA9IHRoaXMud3JpdGUodmFsdWVzLCBzaGFwZSwgZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKS51c2FnZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB7IGRhdGFJZDogZGF0YUlkLCBzaGFwZTogc2hhcGUsIGR0eXBlOiBkdHlwZSB9O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWFrZU91dHB1dCA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUsIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YUlkID0gdGhpcy5tYWtlVGVuc29ySW5mbyhzaGFwZSwgZHR5cGUsIHZhbHVlcykuZGF0YUlkO1xuICAgICAgICByZXR1cm4gdGYuZW5naW5lKCkubWFrZVRlbnNvckZyb21EYXRhSWQoZGF0YUlkLCBzaGFwZSwgZHR5cGUsIHRoaXMpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUudW5wYWNrVGVuc29yID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IFVucGFja1Byb2dyYW0oaW5wdXQuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2lucHV0XSwgaW5wdXQuZHR5cGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucGFja1RlbnNvciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBQYWNrUHJvZ3JhbShpbnB1dC5zaGFwZSk7XG4gICAgICAgIHZhciBwcmV2ZW50RWFnZXJVbnBhY2tpbmdPdXRwdXQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2lucHV0XSwgaW5wdXQuZHR5cGUsIG51bGwgLyogY3VzdG9tU2V0dXAgKi8sIHByZXZlbnRFYWdlclVucGFja2luZ091dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5wYWNrZWRSZXNoYXBlID0gZnVuY3Rpb24gKGlucHV0LCBhZnRlclNoYXBlKSB7XG4gICAgICAgIHZhciBpbnB1dDNEU2hhcGUgPSBbXG4gICAgICAgICAgICBnZXRCYXRjaERpbShpbnB1dC5zaGFwZSlcbiAgICAgICAgXS5jb25jYXQoZ2V0Um93c0NvbHMoaW5wdXQuc2hhcGUpKTtcbiAgICAgICAgdmFyIGlucHV0M0QgPSB7XG4gICAgICAgICAgICBkdHlwZTogaW5wdXQuZHR5cGUsXG4gICAgICAgICAgICBzaGFwZTogaW5wdXQzRFNoYXBlLFxuICAgICAgICAgICAgZGF0YUlkOiBpbnB1dC5kYXRhSWRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFmdGVyU2hhcGVBczNEID0gW1xuICAgICAgICAgICAgZ2V0QmF0Y2hEaW0oYWZ0ZXJTaGFwZSlcbiAgICAgICAgXS5jb25jYXQoZ2V0Um93c0NvbHMoYWZ0ZXJTaGFwZSkpO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBSZXNoYXBlUGFja2VkUHJvZ3JhbShhZnRlclNoYXBlQXMzRCwgaW5wdXQzRFNoYXBlKTtcbiAgICAgICAgdmFyIHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFtpbnB1dDNEXSwgaW5wdXQuZHR5cGUsIG51bGwgLyogY3VzdG9tU2V0dXAgKi8sIHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUlkOiBvdXRwdXQuZGF0YUlkLCBzaGFwZTogYWZ0ZXJTaGFwZSwgZHR5cGU6IG91dHB1dC5kdHlwZSB9O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICB2YXIgdGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgdmFyIGlzUGFja2VkID0gdGV4RGF0YS5pc1BhY2tlZCwgc2hhcGUgPSB0ZXhEYXRhLnNoYXBlLCBkdHlwZSA9IHRleERhdGEuZHR5cGU7XG4gICAgICAgIHZhciBzaGFwZUFzM0QgPSBnZXRTaGFwZUFzM0Qoc2hhcGUpO1xuICAgICAgICB2YXIgcHJvZ3JhbTtcbiAgICAgICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgICAgICBwcm9ncmFtID0gbmV3IERlY29kZU1hdHJpeFBhY2tlZFByb2dyYW0oc2hhcGVBczNEKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb2dyYW0gPSBuZXcgRGVjb2RlTWF0cml4UHJvZ3JhbShzaGFwZUFzM0QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2ZW50RWFnZXJVbnBhY2tpbmdPZk91dHB1dCA9IHRydWU7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbeyBzaGFwZTogc2hhcGVBczNELCBkdHlwZTogZHR5cGUsIGRhdGFJZDogZGF0YUlkIH1dLCBkdHlwZSwgbnVsbCAvKiBjdXN0b21TZXR1cCAqLywgcHJldmVudEVhZ2VyVW5wYWNraW5nT2ZPdXRwdXQpO1xuICAgICAgICByZXR1cm4geyBkdHlwZTogZHR5cGUsIHNoYXBlOiBzaGFwZSwgZGF0YUlkOiBvdXQuZGF0YUlkIH07XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5ydW5XZWJHTFByb2dyYW0gPSBmdW5jdGlvbiAocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXREdHlwZSwgY3VzdG9tU2V0dXAsIHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChwcmV2ZW50RWFnZXJVbnBhY2tpbmdPZk91dHB1dCA9PT0gdm9pZCAwKSB7IHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZVRlbnNvckluZm8ocHJvZ3JhbS5vdXRwdXRTaGFwZSwgb3V0cHV0RHR5cGUpO1xuICAgICAgICB2YXIgb3V0RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQob3V0cHV0LmRhdGFJZCk7XG4gICAgICAgIGlmIChwcm9ncmFtLnBhY2tlZE91dHB1dCkge1xuICAgICAgICAgICAgb3V0RGF0YS5pc1BhY2tlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW0ub3V0UGFja2luZ1NjaGVtZSA9PT0gUGFja2luZ1NjaGVtZS5ERU5TRSkge1xuICAgICAgICAgICAgdmFyIHRleGVsU2hhcGUgPSBnZXREZW5zZVRleFNoYXBlKHByb2dyYW0ub3V0cHV0U2hhcGUpO1xuICAgICAgICAgICAgLy8gRm9yIGEgZGVuc2VseSBwYWNrZWQgb3V0cHV0LCB3ZSBleHBsaWNpdGx5IHNldCB0ZXhTaGFwZVxuICAgICAgICAgICAgLy8gc28gaXQgZG9lc24ndCBnZXQgYXNzaWduZWQgbGF0ZXIgYWNjb3JkaW5nIHRvIG91ciB0eXBpY2FsIHBhY2tpbmdcbiAgICAgICAgICAgIC8vIHNjaGVtZSB3aGVyZWluIGEgc2luZ2xlIHRleGVsIGNhbiBvbmx5IGNvbnRhaW4gdmFsdWVzIGZyb20gYWRqYWNlbnRcbiAgICAgICAgICAgIC8vIHJvd3MvY29scy5cbiAgICAgICAgICAgIG91dERhdGEudGV4U2hhcGUgPSB0ZXhlbFNoYXBlLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCAqIDI7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtLm91dFRleFVzYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dERhdGEudXNhZ2UgPSBwcm9ncmFtLm91dFRleFVzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0Zi51dGlsLnNpemVGcm9tU2hhcGUob3V0cHV0LnNoYXBlKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gU2hvcnQtY2lyY3VpdCB0aGUgY29tcHV0YXRpb24gc2luY2UgdGhlIHJlc3VsdCBpcyBlbXB0eSAoaGFzIDAgaW4gaXRzXG4gICAgICAgICAgICAvLyBzaGFwZSkuXG4gICAgICAgICAgICBvdXREYXRhLnZhbHVlcyA9XG4gICAgICAgICAgICAgICAgdGYudXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKG91dHB1dC5kdHlwZSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhVG9EaXNwb3NlID0gW107XG4gICAgICAgIHZhciBpbnB1dHNEYXRhID0gaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5kdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHUEdQVVByb2dyYW0gZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV4NjQgaW5wdXQuIEZvciBjb21wbGV4NjQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImR0eXBlcywgcGxlYXNlIHNlcGFyYXRlIHRoZSBwcm9ncmFtIGludG8gcmVhbCBhbmQgaW1hZ2luYXJ5IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJwYXJ0cy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGV4RGF0YSA9IF90aGlzLnRleERhdGEuZ2V0KGlucHV0LmRhdGFJZCk7XG4gICAgICAgICAgICBpZiAodGV4RGF0YS50ZXh0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb2dyYW0ucGFja2VkSW5wdXRzICYmXG4gICAgICAgICAgICAgICAgICAgIHRmLnV0aWwuc2l6ZUZyb21TaGFwZShpbnB1dC5zaGFwZSkgPD1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRmLmVudigpLmdldE51bWJlcignV0VCR0xfU0laRV9VUExPQURfVU5JRk9STScpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwbG9hZCBzbWFsbCB0ZW5zb3JzIHRoYXQgbGl2ZSBvbiB0aGUgQ1BVIGFzIHVuaWZvcm1zLCBub3QgYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdGV4dHVyZXMuIERvIHRoaXMgb25seSB3aGVuIHRoZSBlbnZpcm9ubWVudCBzdXBwb3J0cyAzMmJpdCBmbG9hdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVlIHRvIHByb2JsZW1zIHdoZW4gY29tcGFyaW5nIDE2Yml0IGZsb2F0cyB3aXRoIDMyYml0IGZsb2F0cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2lzc3Vlcy84MjEpOiBNYWtlIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc3NpYmxlIGZvciBwYWNrZWQgc2hhZGVycyB0byBzYW1wbGUgZnJvbSB1bmlmb3Jtcy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiBpbnB1dC5zaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleERhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1VuaWZvcm06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtVmFsdWVzOiB0ZXhEYXRhLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCBpZiBhIHBhY2tlZCBwcm9ncmFtJ3MgaW5wdXRzIGhhdmUgbm90IHlldCBiZWVuXG4gICAgICAgICAgICAgICAgLy8gdXBsb2FkZWQgdG8gdGhlIEdQVSwgdGhleSBnZXQgdXBsb2FkZWQgYXMgcGFja2VkIHJpZ2h0IG9mZiB0aGUgYmF0LlxuICAgICAgICAgICAgICAgIGlmIChwcm9ncmFtLnBhY2tlZElucHV0cykge1xuICAgICAgICAgICAgICAgICAgICB0ZXhEYXRhLmlzUGFja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGV4RGF0YS5zaGFwZSA9IGlucHV0LnNoYXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEhdGV4RGF0YS5pc1BhY2tlZCAhPT0gISFwcm9ncmFtLnBhY2tlZElucHV0cykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gdGV4RGF0YS5pc1BhY2tlZCA/IF90aGlzLnVucGFja1RlbnNvcihpbnB1dCkgOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYWNrVGVuc29yKGlucHV0KTtcbiAgICAgICAgICAgICAgICBkYXRhVG9EaXNwb3NlLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgICAgIHRleERhdGEgPSBfdGhpcy50ZXhEYXRhLmdldChpbnB1dC5kYXRhSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4RGF0YS5pc1BhY2tlZCAmJlxuICAgICAgICAgICAgICAgICFpc1Jlc2hhcGVGcmVlKHRleERhdGEuc2hhcGUsIGlucHV0LnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgYSB0ZXh0dXJlIGV4aXN0cyBmb3IgYSB0ZW5zb3JcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhlIHNoYXBlcyBhcmUgaW5jb21wYXRpYmxlIChkdWUgdG8gcGFja2luZyBjb25zdHJhaW50cykgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB0ZW5zb3IgZGlkIG5vdCBoYXZlIGEgY2hhbmNlIHRvIGdvIHRocm91Z2ggdGhlIHBhY2tlZCByZXNoYXBlXG4gICAgICAgICAgICAgICAgLy8gc2hhZGVyLiBUaGlzIG9ubHkgaGFwcGVucyB3aGVuIHdlIHJlc2hhcGUgdGhlICpzYW1lKiB0ZW5zb3IgdG8gZm9ybVxuICAgICAgICAgICAgICAgIC8vICpkaXN0aW5jdCogaW5wdXRzIHRvIGFuIG9wLCBlLmcuIGRvdHRpbmcgYSB2ZWN0b3Igd2l0aCBpdHNlbGYuIFRoaXNcbiAgICAgICAgICAgICAgICAvLyBjYXNlIHdpbGwgZGlzYXBwZWFyIG9uY2UgcGFja2VkIHVwbG9hZGluZyBpcyB0aGUgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICB2YXIgc2F2ZWRJbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IGlucHV0LnNoYXBlO1xuICAgICAgICAgICAgICAgIGlucHV0LnNoYXBlID0gdGV4RGF0YS5zaGFwZTtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IF90aGlzLnBhY2tlZFJlc2hhcGUoaW5wdXQsIHRhcmdldFNoYXBlKTtcbiAgICAgICAgICAgICAgICBkYXRhVG9EaXNwb3NlLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgICAgIHRleERhdGEgPSBfdGhpcy50ZXhEYXRhLmdldChpbnB1dC5kYXRhSWQpO1xuICAgICAgICAgICAgICAgIHNhdmVkSW5wdXQuc2hhcGUgPSB0YXJnZXRTaGFwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnVwbG9hZFRvR1BVKGlucHV0LmRhdGFJZCk7XG4gICAgICAgICAgICByZXR1cm4geyBzaGFwZTogaW5wdXQuc2hhcGUsIHRleERhdGE6IHRleERhdGEsIGlzVW5pZm9ybTogZmFsc2UgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBsb2FkVG9HUFUob3V0cHV0LmRhdGFJZCk7XG4gICAgICAgIHZhciBvdXRwdXREYXRhID0geyBzaGFwZTogb3V0cHV0LnNoYXBlLCB0ZXhEYXRhOiBvdXREYXRhLCBpc1VuaWZvcm06IGZhbHNlIH07XG4gICAgICAgIHZhciBrZXkgPSBtYWtlU2hhZGVyS2V5KHByb2dyYW0sIGlucHV0c0RhdGEsIG91dHB1dERhdGEpO1xuICAgICAgICB2YXIgYmluYXJ5ID0gdGhpcy5nZXRBbmRTYXZlQmluYXJ5KGtleSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVQcm9ncmFtKF90aGlzLmdwZ3B1LCBwcm9ncmFtLCBpbnB1dHNEYXRhLCBvdXRwdXREYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzaG91bGRUaW1lUHJvZ3JhbSA9IHRoaXMuYWN0aXZlVGltZXJzICE9IG51bGw7XG4gICAgICAgIHZhciBxdWVyeTtcbiAgICAgICAgaWYgKHNob3VsZFRpbWVQcm9ncmFtKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuc3RhcnRUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIHJ1blByb2dyYW0odGhpcy5ncGdwdSwgYmluYXJ5LCBpbnB1dHNEYXRhLCBvdXRwdXREYXRhLCBjdXN0b21TZXR1cCk7XG4gICAgICAgIGRhdGFUb0Rpc3Bvc2UuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gX3RoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaW5mbyk7IH0pO1xuICAgICAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5lbmRUaW1lcihxdWVyeSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVRpbWVycy5wdXNoKHsgbmFtZTogcHJvZ3JhbS5jb25zdHJ1Y3Rvci5uYW1lLCBxdWVyeTogdGhpcy5nZXRRdWVyeVRpbWUocXVlcnkpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfTEFaSUxZX1VOUEFDSycpICYmIG91dERhdGEuaXNQYWNrZWQgJiZcbiAgICAgICAgICAgIHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIHVucGFja2VkID0gdGhpcy51bnBhY2tUZW5zb3Iob3V0cHV0KTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ob3V0cHV0KTtcbiAgICAgICAgICAgIHJldHVybiB1bnBhY2tlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29tcGlsZUFuZFJ1biA9IGZ1bmN0aW9uIChwcm9ncmFtLCBpbnB1dHMsIG91dHB1dER0eXBlLCBjdXN0b21TZXR1cCwgcHJldmVudEVhZ2VyVW5wYWNraW5nT2ZPdXRwdXQpIHtcbiAgICAgICAgaWYgKHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0ID09PSB2b2lkIDApIHsgcHJldmVudEVhZ2VyVW5wYWNraW5nT2ZPdXRwdXQgPSBmYWxzZTsgfVxuICAgICAgICBvdXRwdXREdHlwZSA9IG91dHB1dER0eXBlIHx8IGlucHV0c1swXS5kdHlwZTtcbiAgICAgICAgdmFyIG91dEluZm8gPSB0aGlzLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBpbnB1dHMsIG91dHB1dER0eXBlLCBjdXN0b21TZXR1cCwgcHJldmVudEVhZ2VyVW5wYWNraW5nT2ZPdXRwdXQpO1xuICAgICAgICByZXR1cm4gdGYuZW5naW5lKCkubWFrZVRlbnNvckZyb21EYXRhSWQob3V0SW5mby5kYXRhSWQsIG91dEluZm8uc2hhcGUsIG91dEluZm8uZHR5cGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ2V0QW5kU2F2ZUJpbmFyeSA9IGZ1bmN0aW9uIChrZXksIGdldEJpbmFyeSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5iaW5hcnlDYWNoZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5Q2FjaGVba2V5XSA9IGdldEJpbmFyeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyeUNhY2hlW2tleV07XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nZXRUZXh0dXJlTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXI7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF2b2lkIGRpc3Bvc2luZyB0aGUgY29tcGlsZWQgd2ViZ2wgcHJvZ3JhbXMgZHVyaW5nIHVuaXQgdGVzdGluZyBiZWNhdXNlXG4gICAgICAgIC8vIGl0IHNsb3dzIGRvd24gdGVzdCBleGVjdXRpb24uXG4gICAgICAgIGlmICghdGYuZW52KCkuZ2V0Qm9vbCgnSVNfVEVTVCcpKSB7XG4gICAgICAgICAgICB2YXIgYWxsS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuYmluYXJ5Q2FjaGUpO1xuICAgICAgICAgICAgYWxsS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ncGdwdS5kZWxldGVQcm9ncmFtKF90aGlzLmJpbmFyeUNhY2hlW2tleV0ud2ViR0xQcm9ncmFtKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuYmluYXJ5Q2FjaGVba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5jYW52YXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgKHR5cGVvZiAoSFRNTENhbnZhc0VsZW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5KSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1LnByb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ncGdwdS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5mbG9hdFByZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZmxvYXRQcmVjaXNpb25WYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWUgPSB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRmLmVudigpLmdldCgnV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vbWVudGFyaWx5IHN3aXRjaGluZyBERUJVRyBmbGFnIHRvIGZhbHNlIHNvIHdlIGRvbid0IHRocm93IGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIHRyeWluZyB0byB1cGxvYWQgYSBzbWFsbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlYnVnRmxhZyA9IHRmLmVudigpLmdldEJvb2woJ0RFQlVHJyk7XG4gICAgICAgICAgICAgICAgICAgIHRmLmVudigpLnNldCgnREVCVUcnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmRlcmZsb3dDaGVja1ZhbHVlID0gX3RoaXMuYWJzKHRmLnNjYWxhcigxZS04KSkuZGF0YVN5bmMoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdGYuZW52KCkuc2V0KCdERUJVRycsIGRlYnVnRmxhZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmRlcmZsb3dDaGVja1ZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWU7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgc21hbGxlc3QgcmVwcmVzZW50YWJsZSBudW1iZXIuICAqL1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmVwc2lsb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0UHJlY2lzaW9uKCkgPT09IDMyID8gRVBTSUxPTl9GTE9BVDMyIDogRVBTSUxPTl9GTE9BVDE2O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUudXBsb2FkVG9HUFUgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgICAgIHZhciBzaGFwZSA9IHRleERhdGEuc2hhcGUsIGR0eXBlID0gdGV4RGF0YS5kdHlwZSwgdmFsdWVzID0gdGV4RGF0YS52YWx1ZXMsIHRleHR1cmUgPSB0ZXhEYXRhLnRleHR1cmUsIHVzYWdlID0gdGV4RGF0YS51c2FnZSwgaXNQYWNrZWQgPSB0ZXhEYXRhLmlzUGFja2VkO1xuICAgICAgICBpZiAodGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBBcnJheSBpcyBhbHJlYWR5IG9uIEdQVS4gTm8tb3AuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZFRpbWVQcm9ncmFtID0gdGhpcy5hY3RpdmVUaW1lcnMgIT0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGYudXRpbC5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4U2hhcGUgPSB0ZXhEYXRhLnRleFNoYXBlO1xuICAgICAgICBpZiAodGV4U2hhcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGV4U2hhcGUgPSBnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlKHNoYXBlLCBpc1BhY2tlZCk7XG4gICAgICAgICAgICB0ZXhEYXRhLnRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGVBczNEID0gZ2V0U2hhcGVBczNEKHNoYXBlKTtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGV4U2hhcGVbMV0sIGhlaWdodCA9IHRleFNoYXBlWzBdO1xuICAgICAgICAgICAgdmFyIGlzQnl0ZUFycmF5ID0gdmFsdWVzIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICAgIF9hID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQodGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgICAgICAgICAgICAgcHJvZ3JhbSA9IG5ldyBFbmNvZGVNYXRyaXhQYWNrZWRQcm9ncmFtKHNoYXBlQXMzRCwgW2hlaWdodCwgd2lkdGhdLCBpc0J5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtID1cbiAgICAgICAgICAgICAgICAgICAgbmV3IEVuY29kZU1hdHJpeFByb2dyYW0oc2hhcGVBczNELCBbaGVpZ2h0LCB3aWR0aF0sIGlzQnl0ZUFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ZW1wRGVuc2VJbnB1dEhhbmRsZSA9IHRoaXMubWFrZVRlbnNvckluZm8oW2hlaWdodCwgd2lkdGhdLCBkdHlwZSk7XG4gICAgICAgICAgICBpZiAoaXNCeXRlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleERhdGEuZ2V0KHRlbXBEZW5zZUlucHV0SGFuZGxlLmRhdGFJZCkudXNhZ2UgPVxuICAgICAgICAgICAgICAgICAgICBUZXh0dXJlVXNhZ2UuUElYRUxTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXhEYXRhLmdldCh0ZW1wRGVuc2VJbnB1dEhhbmRsZS5kYXRhSWQpLnVzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgVGV4dHVyZVVzYWdlLlVQTE9BRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ3BncHUudXBsb2FkRGVuc2VNYXRyaXhUb1RleHR1cmUodGhpcy5nZXRUZXh0dXJlKHRlbXBEZW5zZUlucHV0SGFuZGxlLmRhdGFJZCksIHdpZHRoLCBoZWlnaHQsIHZhbHVlcyk7XG4gICAgICAgICAgICAvLyBXZSB3YW50IHRoZSBvdXRwdXQgdG8gcmVtYWluIHBhY2tlZCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZlxuICAgICAgICAgICAgLy8gV0VCR0xfUEFDSy5cbiAgICAgICAgICAgIHZhciBwcmV2ZW50RWFnZXJVbnBhY2tpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGVuY29kZWRPdXRwdXRUYXJnZXQgPSB0aGlzLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbdGVtcERlbnNlSW5wdXRIYW5kbGVdLCBkdHlwZSwgbnVsbCwgcHJldmVudEVhZ2VyVW5wYWNraW5nKTtcbiAgICAgICAgICAgIC8vIEhhdmUgdGhlIG9yaWdpbmFsIHRleHR1cmUgYXNzdW1lIHRoZSBpZGVudGl0eSBvZiB0aGUgZW5jb2RlZCBvdXRwdXQuXG4gICAgICAgICAgICB2YXIgb3V0cHV0VGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZW5jb2RlZE91dHB1dFRhcmdldC5kYXRhSWQpO1xuICAgICAgICAgICAgdGV4RGF0YS50ZXh0dXJlID0gb3V0cHV0VGV4RGF0YS50ZXh0dXJlO1xuICAgICAgICAgICAgdGV4RGF0YS50ZXhTaGFwZSA9IG91dHB1dFRleERhdGEudGV4U2hhcGU7XG4gICAgICAgICAgICB0ZXhEYXRhLmlzUGFja2VkID0gb3V0cHV0VGV4RGF0YS5pc1BhY2tlZDtcbiAgICAgICAgICAgIHRleERhdGEudXNhZ2UgPSBvdXRwdXRUZXhEYXRhLnVzYWdlO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh0ZW1wRGVuc2VJbnB1dEhhbmRsZSk7XG4gICAgICAgICAgICB0aGlzLnRleERhdGEuZGVsZXRlKGVuY29kZWRPdXRwdXRUYXJnZXQuZGF0YUlkKTtcbiAgICAgICAgICAgIC8vIE9uY2UgdXBsb2FkZWQsIGRvbid0IHN0b3JlIHRoZSB2YWx1ZXMgb24gY3B1LlxuICAgICAgICAgICAgdGV4RGF0YS52YWx1ZXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNob3VsZFRpbWVQcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGxvYWRXYWl0TXMgKz0gdGYudXRpbC5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5ld1RleHR1cmUgPSB0aGlzLmFjcXVpcmVUZXh0dXJlKHRleFNoYXBlLCB1c2FnZSwgZHR5cGUsIGlzUGFja2VkKTtcbiAgICAgICAgICAgIHRleERhdGEudGV4dHVyZSA9IG5ld1RleHR1cmU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNvbnZlcnRBbmRDYWNoZU9uQ1BVID0gZnVuY3Rpb24gKGRhdGFJZCwgZmxvYXQzMlZhbHVlcykge1xuICAgICAgICB2YXIgdGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgdmFyIGR0eXBlID0gdGV4RGF0YS5kdHlwZTtcbiAgICAgICAgdGhpcy5yZWxlYXNlR1BVRGF0YShkYXRhSWQpO1xuICAgICAgICBpZiAoZmxvYXQzMlZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0ZXhEYXRhLnZhbHVlcyA9IGZsb2F0MzJUb1R5cGVkQXJyYXkoZmxvYXQzMlZhbHVlcywgZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXhEYXRhLnZhbHVlcztcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFjcXVpcmVUZXh0dXJlID0gZnVuY3Rpb24gKHRleFNoYXBlLCB0ZXhUeXBlLCBkdHlwZSwgaXNQYWNrZWQpIHtcbiAgICAgICAgdGhpcy5udW1CeXRlc0luR1BVICs9IHRoaXMuY29tcHV0ZUJ5dGVzKHRleFNoYXBlLCBkdHlwZSk7XG4gICAgICAgIGlmICghdGhpcy53YXJuZWRBYm91dE1lbW9yeSAmJlxuICAgICAgICAgICAgdGhpcy5udW1CeXRlc0luR1BVID4gdGhpcy5udW1NQkJlZm9yZVdhcm5pbmcgKiAxMDI0ICogMTAyNCkge1xuICAgICAgICAgICAgdmFyIG1iID0gKHRoaXMubnVtQnl0ZXNJbkdQVSAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgdGhpcy53YXJuZWRBYm91dE1lbW9yeSA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJIaWdoIG1lbW9yeSB1c2FnZSBpbiBHUFU6IFwiICsgbWIgKyBcIiBNQiwgXCIgK1xuICAgICAgICAgICAgICAgIFwibW9zdCBsaWtlbHkgZHVlIHRvIGEgbWVtb3J5IGxlYWtcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodGV4U2hhcGUsIHRleFR5cGUsIGlzUGFja2VkKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNvbXB1dGVCeXRlcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNoYXBlWzBdICogc2hhcGVbMV0gKiB0Zi51dGlsLmJ5dGVzUGVyRWxlbWVudChkdHlwZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWF0aEJhY2tlbmRXZWJHTDtcbn0odGYuS2VybmVsQmFja2VuZCkpO1xuZnVuY3Rpb24gZmxvYXQzMlRvVHlwZWRBcnJheShhLCBkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInIHx8IGR0eXBlID09PSAnY29tcGxleDY0Jykge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicgfHwgZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gKGR0eXBlID09PSAnaW50MzInKSA/IG5ldyBJbnQzMkFycmF5KGEubGVuZ3RoKSA6XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBNYXRoLnJvdW5kKGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cblxuLyoqIEBsaWNlbnNlIFNlZSB0aGUgTElDRU5TRSBmaWxlLiAqL1xuLy8gVGhpcyBjb2RlIGlzIGF1dG8tZ2VuZXJhdGVkLCBkbyBub3QgbW9kaWZ5IHRoaXMgZmlsZSFcbnZhciB2ZXJzaW9uID0gJzIuOC42JztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBFbmZvcmNlIHVzZSBvZiBoYWxmIHByZWNpc2lvbiB0ZXh0dXJlcyBpZiBhdmFpbGFibGUgb24gdGhlIHBsYXRmb3JtLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdFbnZpcm9ubWVudCcsIG5hbWVzcGFjZTogJ3dlYmdsJ31cbiAqL1xuZnVuY3Rpb24gZm9yY2VIYWxmRmxvYXQoKSB7XG4gICAgdGYuZW52KCkuc2V0KCdXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVMnLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuaWYgKHRmLmRldmljZV91dGlsLmlzQnJvd3NlcigpKSB7XG4gICAgdGYucmVnaXN0ZXJCYWNrZW5kKCd3ZWJnbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXRoQmFja2VuZFdlYkdMKCk7IH0sIDIgLyogcHJpb3JpdHkgKi8pO1xufVxudmFyIHdlYmdsID0geyBmb3JjZUhhbGZGbG9hdDogZm9yY2VIYWxmRmxvYXQgfTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIENIRUNLX05BTl9TTklQUEVUJDEgPSBcIlxcbiAgaWYgKGlzbmFuKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc25hbihiKSkgcmV0dXJuIGI7XFxuXCI7XG52YXIgQmluYXJ5T3BQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmFyeU9wUHJvZ3JhbShvcCwgYVNoYXBlLCBiU2hhcGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJywgJ0InXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHRmLmJhY2tlbmRfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhU2hhcGUsIGJTaGFwZSk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wZXJhdGlvbihmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgICAgICBcIiArIG9wICsgXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGJpbmFyeU9wZXJhdGlvbihhLCBiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEJpbmFyeU9wUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBDSEVDS19OQU5fU05JUFBFVCQyID0gXCJcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXCI7XG52YXIgQmluYXJ5T3BQYWNrZWRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmFyeU9wUGFja2VkUHJvZ3JhbShvcCwgYVNoYXBlLCBiU2hhcGUsIGNoZWNrT3V0T2ZCb3VuZHMpIHtcbiAgICAgICAgaWYgKGNoZWNrT3V0T2ZCb3VuZHMgPT09IHZvaWQgMCkgeyBjaGVja091dE9mQm91bmRzID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJywgJ0InXTtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFja2VkSW5wdXRzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWNrZWRPdXRwdXQgPSB0cnVlO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gdGYuYmFja2VuZF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGFTaGFwZSwgYlNoYXBlKTtcbiAgICAgICAgdmFyIHJhbmsgPSB0aGlzLm91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGNoZWNrT3V0T2ZCb3VuZHNTdHJpbmcgPSAnJztcbiAgICAgICAgaWYgKGNoZWNrT3V0T2ZCb3VuZHMpIHtcbiAgICAgICAgICAgIGlmIChyYW5rID09PSAwIHx8IHRmLnV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLm91dHB1dFNoYXBlKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNoZWNrT3V0T2ZCb3VuZHNTdHJpbmcgPSBcIlxcbiAgICAgICAgICByZXN1bHQueSA9IDAuO1xcbiAgICAgICAgICByZXN1bHQueiA9IDAuO1xcbiAgICAgICAgICByZXN1bHQudyA9IDAuO1xcbiAgICAgICAgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcbiAgICAgICAgICAgICAgICBjaGVja091dE9mQm91bmRzU3RyaW5nID0gXCJcXG4gICAgICAgICAgXCIgKyBkdHlwZSArIFwiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tPdXRPZkJvdW5kc1N0cmluZyArPSBcIlxcbiAgICAgICAgICAgIHJlc3VsdC55ID0gKGNvb3JkcyArIDEpID49IFwiICsgdGhpcy5vdXRwdXRTaGFwZVswXSArIFwiID8gMC4gOiByZXN1bHQueTtcXG4gICAgICAgICAgICByZXN1bHQueiA9IDAuO1xcbiAgICAgICAgICAgIHJlc3VsdC53ID0gMC47XFxuICAgICAgICAgIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWxzID0gZ2V0Q2hhbm5lbHMoJ2Nvb3JkcycsIHJhbmspO1xuICAgICAgICAgICAgICAgICAgICBjaGVja091dE9mQm91bmRzU3RyaW5nICs9IFwiXFxuICAgICAgICAgICAgYm9vbCBuZXh0Um93T3V0T2ZCb3VuZHMgPVxcbiAgICAgICAgICAgICAgKFwiICsgY2hhbm5lbHNbcmFuayAtIDJdICsgXCIgKyAxKSA+PSBcIiArIHRoaXMub3V0cHV0U2hhcGVbcmFuayAtIDJdICsgXCI7XFxuICAgICAgICAgICAgYm9vbCBuZXh0Q29sT3V0T2ZCb3VuZHMgPVxcbiAgICAgICAgICAgICAgKFwiICsgY2hhbm5lbHNbcmFuayAtIDFdICsgXCIgKyAxKSA+PSBcIiArIHRoaXMub3V0cHV0U2hhcGVbcmFuayAtIDFdICsgXCI7XFxuICAgICAgICAgICAgcmVzdWx0LnkgPSBuZXh0Q29sT3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC55O1xcbiAgICAgICAgICAgIHJlc3VsdC56ID0gbmV4dFJvd091dE9mQm91bmRzID8gMC4gOiByZXN1bHQuejtcXG4gICAgICAgICAgICByZXN1bHQudyA9IG5leHRDb2xPdXRPZkJvdW5kcyB8fCBuZXh0Um93T3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC53O1xcbiAgICAgICAgICBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdmVjNCBiaW5hcnlPcGVyYXRpb24odmVjNCBhLCB2ZWM0IGIpIHtcXG4gICAgICAgIFwiICsgb3AgKyBcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSBiaW5hcnlPcGVyYXRpb24oYSwgYik7XFxuICAgICAgICBcIiArIGNoZWNrT3V0T2ZCb3VuZHNTdHJpbmcgKyBcIlxcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEJpbmFyeU9wUGFja2VkUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQ7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICBiYWNrZW5kLmluY1JlZih4LmRhdGFJZCk7XG4gICAgcmV0dXJuIHsgZGF0YUlkOiB4LmRhdGFJZCwgc2hhcGU6IHguc2hhcGUsIGR0eXBlOiB4LmR0eXBlIH07XG59XG52YXIgaWRlbnRpdHlDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuSWRlbnRpdHksXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogaWRlbnRpdHlcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogSW4gV2ViR0wgZGF0YSBpcyBzdG9yZWQgaW4gR1BVIHRleHR1cmVzIHdoaWNoIGNhbid0IGJlIGVmZmljaWVudGx5IGNvcGllZCwgc29cbiAqIGNvbXBsZXggdGVuc29ycyBzaGFyZSBkYXRhIHdpdGggdGhlaXIgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvbXBvbmVudHMuIENvbXBsZXhcbiAqIHRlbnNvcnMgaW5jcmVtZW50IHRoZSBgY29tcGxleFBhcmVudFJlZkNvdW50YCBwcm9wZXJ0aWVzIG9mIHRoZSB1bmRlcmx5aW5nXG4gKiBkYXRhIGJ1Y2tldHMgdG8gcHJldmVudCB0aGVtIGZyb20gYmVpbmcgZGlzcG9zZWQsIGFzIHRoZSBlbmdpbmUncyBkaXNwb3NhbFxuICogbG9naWMgZG9lcyBub3QgYWNjb3VudCBmb3IgZGF0YSBzaGFyaW5nIGJ5IGNvbXBsZXggdGVuc29ycy5cbiAqXG4gKiBXaGVuIGEgY29tcGxleCB0ZW5zb3IgaXMgZGlzcG9zZWQsIGl0IHdpbGwgZXhwbGljaXRseSBkZWNyZWFzZSB0aGVcbiAqIGBjb21wbGV4UGFyZW50UmVmQ291bnRgIHByb3BlcnRpZXMgb2YgaXRzIHVuZGVybHlpbmcgY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gY29tcGxleChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciByZWFsID0gaW5wdXRzLnJlYWwsIGltYWcgPSBpbnB1dHMuaW1hZztcbiAgICB2YXIgY29tcGxleEluZm8gPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKHJlYWwuc2hhcGUsICdjb21wbGV4NjQnKTtcbiAgICB2YXIgY29tcGxleCA9IGJhY2tlbmQudGV4RGF0YS5nZXQoY29tcGxleEluZm8uZGF0YUlkKTtcbiAgICB2YXIgcmVhbFRlbnNvckluZm8gPSBpZGVudGl0eSh7IGlucHV0czogeyB4OiByZWFsIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgdmFyIHJlYWxEYXRhID0gYmFja2VuZC50ZXhEYXRhLmdldChyZWFsVGVuc29ySW5mby5kYXRhSWQpO1xuICAgIHJlYWxEYXRhLmNvbXBsZXhQYXJlbnRSZWZDb3VudCsrO1xuICAgIHZhciBpbWFnVGVuc29ySW5mbyA9IGlkZW50aXR5KHsgaW5wdXRzOiB7IHg6IGltYWcgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB2YXIgaW1hZ0RhdGEgPSBiYWNrZW5kLnRleERhdGEuZ2V0KGltYWdUZW5zb3JJbmZvLmRhdGFJZCk7XG4gICAgaW1hZ0RhdGEuY29tcGxleFBhcmVudFJlZkNvdW50Kys7XG4gICAgY29tcGxleC5jb21wbGV4VGVuc29ySW5mb3MgPSB7IHJlYWw6IHJlYWxUZW5zb3JJbmZvLCBpbWFnOiBpbWFnVGVuc29ySW5mbyB9O1xuICAgIHJldHVybiBjb21wbGV4SW5mbztcbn1cbnZhciBjb21wbGV4Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkNvbXBsZXgsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogY29tcGxleFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIExFQUtZUkVMVSA9IFwicmV0dXJuIChhIDwgMC4pID8gYiAqIGEgOiBhO1wiO1xudmFyIExFQUtZUkVMVV9QQUNLRUQgPSBcIlxcbiAgdmVjNCBhTGVzc1RoYW5aZXJvID0gdmVjNChsZXNzVGhhbihhLCB2ZWM0KDAuKSkpO1xcbiAgcmV0dXJuIChhTGVzc1RoYW5aZXJvICogKGIgKiBhKSkgKyAoKHZlYzQoMS4wKSAtIGFMZXNzVGhhblplcm8pICogYSk7XFxuXCI7XG5mdW5jdGlvbiBsZWFreVJlbHUoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGFscGhhID0gYXR0cnMuYWxwaGE7XG4gICAgdmFyICRhbHBoYSA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8oW10sICdmbG9hdDMyJywgdGYudXRpbC5jcmVhdGVTY2FsYXJWYWx1ZShhbHBoYSwgJ2Zsb2F0MzInKSk7XG4gICAgdmFyIHByb2dyYW0gPSB0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TJykgP1xuICAgICAgICBuZXcgQmluYXJ5T3BQYWNrZWRQcm9ncmFtKExFQUtZUkVMVV9QQUNLRUQsIHguc2hhcGUsICRhbHBoYS5zaGFwZSkgOlxuICAgICAgICBuZXcgQmluYXJ5T3BQcm9ncmFtKExFQUtZUkVMVSwgeC5zaGFwZSwgJGFscGhhLnNoYXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3gsICRhbHBoYV0sIHguZHR5cGUpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oJGFscGhhKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGxlYWt5UmVsdUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5MZWFreVJlbHUsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogbGVha3lSZWx1XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgUFJFTFUgPSBcInJldHVybiAoYSA8IDAuKSA/IGIgKiBhIDogYTtcIjtcbnZhciBQUkVMVV9QQUNLRUQgPSBcIlxcbiAgdmVjNCBhTGVzc1RoYW5aZXJvID0gdmVjNChsZXNzVGhhbihhLCB2ZWM0KDAuKSkpO1xcbiAgcmV0dXJuIChhTGVzc1RoYW5aZXJvICogKGIgKiBhKSkgKyAoKHZlYzQoMS4wKSAtIGFMZXNzVGhhblplcm8pICogYSk7XFxuXCI7XG5mdW5jdGlvbiBwcmVsdShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciB4ID0gaW5wdXRzLngsIGFscGhhID0gaW5wdXRzLmFscGhhO1xuICAgIHZhciBwcm9ncmFtID0gdGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OUycpID9cbiAgICAgICAgbmV3IEJpbmFyeU9wUGFja2VkUHJvZ3JhbShQUkVMVV9QQUNLRUQsIHguc2hhcGUsIGFscGhhLnNoYXBlKSA6XG4gICAgICAgIG5ldyBCaW5hcnlPcFByb2dyYW0oUFJFTFUsIHguc2hhcGUsIGFscGhhLnNoYXBlKTtcbiAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3gsIGFscGhhXSwgeC5kdHlwZSk7XG59XG52YXIgcHJlbHVDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuUHJlbHUsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogcHJlbHVcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBDSEVDS19OQU5fU05JUFBFVF9VTkFSWSA9IFwiaWYgKGlzbmFuKHgpKSByZXR1cm4geDtcIjtcbnZhciBDSEVDS19OQU5fU05JUFBFVF9CSU5BUlkgPSBcIlxcbiAgaWYgKGlzbmFuKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc25hbihiKSkgcmV0dXJuIGI7XFxuXCI7XG52YXIgQ0hFQ0tfTkFOX1NOSVBQRVRfQklOQVJZX1BBQ0tFRCA9IFwiXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblwiO1xuLyoqXG4gKiBUZW1wbGF0ZSB0aGF0IGNyZWF0ZXMgYSBgS2VybmVsRnVuY2AgZm9yIHVuYXJ5IG9wcy5cbiAqIEBwYXJhbSBvcFNuaXBwZXQgT3Agc25pcHBldCB0byBjcmVhdGUgYFVuYXJ5T3BQcm9ncmFtYC5cbiAqIEBwYXJhbSBwYWNrZWRPcFNuaXBwZXQgT3Agc25pcHBldCB0byBjcmVhdGUgYFVuYXJ5T3BQYWNrZWRQcm9ncmFtYC5cbiAqIEBwYXJhbSBkdHlwZSBPcHRpb25hbC4gSWYgc2V0LCB0aGUgcmVzdWx0IGhhcyB0aGlzIGR0eXBlLiBPdGhlcndpc2UsIHRoZVxuICogICAgIHJlc3VsdCBoYXMgdGhlIHNhbWUgZHR5cGUgYXMgdGhlIGZpcnN0IGlucHV0LiBUaGlzIGlzIG1haW5seSB1c2VkIGluXG4gKiAgICAgY29tcGFyaXNvbiBrZXJuZWxzLCBzdWNoIGFzIEVxdWFsLCBMZXNzLCBHcmVhdGVyLCBldGMuXG4gKi9cbmZ1bmN0aW9uIHVuYXJ5S2VybmVsRnVuYyhfYSkge1xuICAgIHZhciBvcFNuaXBwZXQgPSBfYS5vcFNuaXBwZXQsIHBhY2tlZE9wU25pcHBldCA9IF9hLnBhY2tlZE9wU25pcHBldCwgY3B1S2VybmVsSW1wbCA9IF9hLmNwdUtlcm5lbEltcGwsIGR0eXBlID0gX2EuZHR5cGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaW5wdXRzID0gX2EuaW5wdXRzLCBiYWNrZW5kID0gX2EuYmFja2VuZDtcbiAgICAgICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICAgICAgdmFyIHdlYmdsQmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgICAgIHZhciAkZHR5cGUgPSBkdHlwZSB8fCB4LmR0eXBlO1xuICAgICAgICBpZiAod2ViZ2xCYWNrZW5kLnNob3VsZEV4ZWN1dGVPbkNQVShbeF0pICYmIGNwdUtlcm5lbEltcGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHhEYXRhID0gd2ViZ2xCYWNrZW5kLnRleERhdGEuZ2V0KHguZGF0YUlkKTtcbiAgICAgICAgICAgIHZhciBvdXRWYWx1ZXMgPSBjcHVLZXJuZWxJbXBsKHhEYXRhLnZhbHVlcywgJGR0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiB3ZWJnbEJhY2tlbmQubWFrZVRlbnNvckluZm8oeC5zaGFwZSwgJGR0eXBlLCBvdXRWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRVc2VQYWNrZWRQcm9ncmFtID0gdGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TJykgJiYgcGFja2VkT3BTbmlwcGV0ICE9IG51bGw7XG4gICAgICAgIHZhciBwcm9ncmFtO1xuICAgICAgICBpZiAoc2hvdWxkVXNlUGFja2VkUHJvZ3JhbSkge1xuICAgICAgICAgICAgcHJvZ3JhbSA9IG5ldyBVbmFyeU9wUGFja2VkUHJvZ3JhbSh4LnNoYXBlLCBwYWNrZWRPcFNuaXBwZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvZ3JhbSA9IG5ldyBVbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCBvcFNuaXBwZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWJnbEJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt4XSwgJGR0eXBlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBUZW1wbGF0ZSB0aGF0IGNyZWF0ZXMgYSBgS2VybmVsRnVuY2AgZm9yIGJpbmFyeSBvcHMuXG4gKiBAcGFyYW0gb3BTbmlwcGV0IE9wIHNuaXBwZXQgdG8gY3JlYXRlIGBCaW5hcnlPcFByb2dyYW1gLlxuICogQHBhcmFtIHBhY2tlZE9wU25pcHBldCBPcCBzbmlwcGV0IHRvIGNyZWF0ZSBgQmluYXJ5T3BQYWNrZWRQcm9ncmFtYC5cbiAqIEBwYXJhbSBjaGVja091dE9mQm91bmRzRm9yUGFja2VkUHJvZ3JhbSBXaGV0aGVyIHRvIHNldCBjaGVja091dE9mQm91bmRzPXRydWVcbiAqICAgICB3aGVuIGNyZWF0aW5nIEJpbmFyeU9wUGFja2VkUHJvZ3JhbS5cbiAqIEBwYXJhbSBkdHlwZSBPcHRpb25hbC4gSWYgc2V0LCB0aGUgcmVzdWx0IGhhcyB0aGlzIGR0eXBlLiBPdGhlcndpc2UsIHRoZVxuICogICAgIHJlc3VsdCBoYXMgdGhlIHNhbWUgZHR5cGUgYXMgdGhlIGZpcnN0IGlucHV0LiBUaGlzIGlzIG1haW5seSB1c2VkIGluXG4gKiAgICAgY29tcGFyaXNvbiBrZXJuZWxzLCBzdWNoIGFzIEVxdWFsLCBMZXNzLCBHcmVhdGVyLCBldGMuXG4gKi9cbmZ1bmN0aW9uIGJpbmFyeUtlcm5lbEZ1bmMoX2EpIHtcbiAgICB2YXIgb3BTbmlwcGV0ID0gX2Eub3BTbmlwcGV0LCBwYWNrZWRPcFNuaXBwZXQgPSBfYS5wYWNrZWRPcFNuaXBwZXQsIF9iID0gX2EuY2hlY2tPdXRPZkJvdW5kcywgY2hlY2tPdXRPZkJvdW5kcyA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBfYyA9IF9hLnN1cHBvcnRzQ29tcGxleCwgc3VwcG9ydHNDb21wbGV4ID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIGNwdUtlcm5lbEltcGwgPSBfYS5jcHVLZXJuZWxJbXBsLCBkdHlwZSA9IF9hLmR0eXBlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGlucHV0cyA9IF9hLmlucHV0cywgYmFja2VuZCA9IF9hLmJhY2tlbmQ7XG4gICAgICAgIHZhciBfYiA9IGlucHV0cywgYSA9IF9iLmEsIGIgPSBfYi5iO1xuICAgICAgICB2YXIgd2ViZ2xCYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgaWYgKHN1cHBvcnRzQ29tcGxleCAmJiBhLmR0eXBlID09PSAnY29tcGxleDY0Jykge1xuICAgICAgICAgICAgdmFyIGFEYXRhID0gd2ViZ2xCYWNrZW5kLnRleERhdGEuZ2V0KGEuZGF0YUlkKTtcbiAgICAgICAgICAgIHZhciBiRGF0YSA9IHdlYmdsQmFja2VuZC50ZXhEYXRhLmdldChiLmRhdGFJZCk7XG4gICAgICAgICAgICB2YXIgX2MgPSBbXG4gICAgICAgICAgICAgICAgW2FEYXRhLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLCBiRGF0YS5jb21wbGV4VGVuc29ySW5mb3MucmVhbF0sXG4gICAgICAgICAgICAgICAgW2FEYXRhLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLCBiRGF0YS5jb21wbGV4VGVuc29ySW5mb3MuaW1hZ11cbiAgICAgICAgICAgIF0ubWFwKGZ1bmN0aW9uIChjb21wbGV4UGFydHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYVBhcnQgPSBjb21wbGV4UGFydHNbMF0sIGJQYXJ0ID0gY29tcGxleFBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBhSGFuZGxlID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSWQ6IGFQYXJ0LmRhdGFJZCxcbiAgICAgICAgICAgICAgICAgICAgZHR5cGU6IGFQYXJ0LmR0eXBlLFxuICAgICAgICAgICAgICAgICAgICBzaGFwZTogYS5zaGFwZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGJIYW5kbGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFJZDogYlBhcnQuZGF0YUlkLFxuICAgICAgICAgICAgICAgICAgICBkdHlwZTogYlBhcnQuZHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBiLnNoYXBlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBCaW5hcnlPcFByb2dyYW0ob3BTbmlwcGV0LCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2ViZ2xCYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbYUhhbmRsZSwgYkhhbmRsZV0sIHRmLnVwY2FzdFR5cGUoYVBhcnQuZHR5cGUsIGJQYXJ0LmR0eXBlKSk7XG4gICAgICAgICAgICB9KSwgcmVhbCA9IF9jWzBdLCBpbWFnID0gX2NbMV07XG4gICAgICAgICAgICB2YXIgY29tcGxleE91dHB1dCA9IGNvbXBsZXgoeyBpbnB1dHM6IHsgcmVhbDogcmVhbCwgaW1hZzogaW1hZyB9LCBiYWNrZW5kOiB3ZWJnbEJhY2tlbmQgfSk7XG4gICAgICAgICAgICB3ZWJnbEJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVhbCk7XG4gICAgICAgICAgICB3ZWJnbEJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaW1hZyk7XG4gICAgICAgICAgICAvLyBUT0RPKGFubnhpbmd5dWFuKTogSW1wbGVtZW50IENQVSBmb3J3YXJkaW5nIGZvciBjb21wbGV4IGlucHV0cy5cbiAgICAgICAgICAgIHJldHVybiBjb21wbGV4T3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHZhciAkZHR5cGUgPSBkdHlwZSB8fCB0Zi51cGNhc3RUeXBlKGEuZHR5cGUsIGIuZHR5cGUpO1xuICAgICAgICBpZiAod2ViZ2xCYWNrZW5kLnNob3VsZEV4ZWN1dGVPbkNQVShbYSwgYl0pICYmIGNwdUtlcm5lbEltcGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGFEYXRhID0gd2ViZ2xCYWNrZW5kLnRleERhdGEuZ2V0KGEuZGF0YUlkKTtcbiAgICAgICAgICAgIHZhciBiRGF0YSA9IHdlYmdsQmFja2VuZC50ZXhEYXRhLmdldChiLmRhdGFJZCk7XG4gICAgICAgICAgICB2YXIgX2QgPSBjcHVLZXJuZWxJbXBsKGEuc2hhcGUsIGIuc2hhcGUsIGFEYXRhLnZhbHVlcywgYkRhdGEudmFsdWVzLCAkZHR5cGUpLCBvdXRWYWx1ZXMgPSBfZFswXSwgb3V0U2hhcGUgPSBfZFsxXTtcbiAgICAgICAgICAgIHZhciBvdXQgPSB3ZWJnbEJhY2tlbmQubWFrZVRlbnNvckluZm8ob3V0U2hhcGUsICRkdHlwZSk7XG4gICAgICAgICAgICB2YXIgb3V0RGF0YSA9IHdlYmdsQmFja2VuZC50ZXhEYXRhLmdldChvdXQuZGF0YUlkKTtcbiAgICAgICAgICAgIG91dERhdGEudmFsdWVzID0gb3V0VmFsdWVzO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkVXNlUGFja2VkUHJvZ3JhbSA9IHRmLmVudigpLmdldEJvb2woJ1dFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlMnKSAmJlxuICAgICAgICAgICAgcGFja2VkT3BTbmlwcGV0ICE9IG51bGw7XG4gICAgICAgIHZhciBwcm9ncmFtO1xuICAgICAgICBpZiAoc2hvdWxkVXNlUGFja2VkUHJvZ3JhbSkge1xuICAgICAgICAgICAgcHJvZ3JhbSA9IG5ldyBCaW5hcnlPcFBhY2tlZFByb2dyYW0ocGFja2VkT3BTbmlwcGV0LCBhLnNoYXBlLCBiLnNoYXBlLCBjaGVja091dE9mQm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb2dyYW0gPSBuZXcgQmluYXJ5T3BQcm9ncmFtKG9wU25pcHBldCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlYmdsQmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2EsIGJdLCAkZHR5cGUpO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXBBY3RpdmF0aW9uVG9TaGFkZXJQcm9ncmFtKGFjdGl2YXRpb24sIHBhY2tlZCkge1xuICAgIGlmIChwYWNrZWQgPT09IHZvaWQgMCkgeyBwYWNrZWQgPSBmYWxzZTsgfVxuICAgIGlmIChhY3RpdmF0aW9uID09PSAnbGluZWFyJykge1xuICAgICAgICBpZiAocGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gTElORUFSJDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIExJTkVBUjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWN0aXZhdGlvbiA9PT0gJ3JlbHUnKSB7XG4gICAgICAgIGlmIChwYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBSRUxVJDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJFTFU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdlbHUnKSB7XG4gICAgICAgIGlmIChwYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBFTFUkMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRUxVO1xuICAgIH1cbiAgICBlbHNlIGlmIChhY3RpdmF0aW9uID09PSAncmVsdTYnKSB7XG4gICAgICAgIGlmIChwYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBSRUxVNiQxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSRUxVNjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWN0aXZhdGlvbiA9PT0gJ3ByZWx1Jykge1xuICAgICAgICBpZiAocGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gUFJFTFVfUEFDS0VEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQUkVMVTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWN0aXZhdGlvbiA9PT0gJ2xlYWt5cmVsdScpIHtcbiAgICAgICAgaWYgKHBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIExFQUtZUkVMVV9QQUNLRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIExFQUtZUkVMVTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQWN0aXZhdGlvbiBcIiArIGFjdGl2YXRpb24gKyBcIiBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIHRoZSBXZWJHTCBiYWNrZW5kLlwiKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIE1hdE11bFBhY2tlZFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0TXVsUGFja2VkUHJvZ3JhbShhU2hhcGUsIGJTaGFwZSwgb3V0cHV0U2hhcGUsIHRyYW5zcG9zZUEsIHRyYW5zcG9zZUIsIGFkZEJpYXMsIGFjdGl2YXRpb24sIGhhc1ByZWx1QWN0aXZhdGlvbiwgaGFzTGVha3lyZWx1QWN0aXZhdGlvbikge1xuICAgICAgICBpZiAodHJhbnNwb3NlQSA9PT0gdm9pZCAwKSB7IHRyYW5zcG9zZUEgPSBmYWxzZTsgfVxuICAgICAgICBpZiAodHJhbnNwb3NlQiA9PT0gdm9pZCAwKSB7IHRyYW5zcG9zZUIgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoYWRkQmlhcyA9PT0gdm9pZCAwKSB7IGFkZEJpYXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoYWN0aXZhdGlvbiA9PT0gdm9pZCAwKSB7IGFjdGl2YXRpb24gPSBudWxsOyB9XG4gICAgICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb24gPT09IHZvaWQgMCkgeyBoYXNQcmVsdUFjdGl2YXRpb24gPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaGFzTGVha3lyZWx1QWN0aXZhdGlvbiA9PT0gdm9pZCAwKSB7IGhhc0xlYWt5cmVsdUFjdGl2YXRpb24gPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ21hdHJpeEEnLCAnbWF0cml4QiddO1xuICAgICAgICB0aGlzLnBhY2tlZElucHV0cyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFja2VkT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB2YXIgc2hhcmVkRGltID0gdHJhbnNwb3NlQSA/IGFTaGFwZVsxXSA6IGFTaGFwZVsyXTtcbiAgICAgICAgdmFyIHNoYXJlZERpbWVuc2lvblBhY2tlZCA9IE1hdGguY2VpbChzaGFyZWREaW0gLyAyKTtcbiAgICAgICAgdmFyIGFTYW1wbGUgPSB0cmFuc3Bvc2VBID8gJ2kgKiAyLCByYy55JyA6ICdyYy55LCBpICogMic7XG4gICAgICAgIHZhciBiU2FtcGxlID0gdHJhbnNwb3NlQiA/ICdyYy56LCBpICogMicgOiAnaSAqIDIsIHJjLnonO1xuICAgICAgICB2YXIgYVN3aXp6bGUgPSB0cmFuc3Bvc2VBID8gWydhLnh4eXknLCAnYS56end3J10gOiBbJ2EueHh6eicsICdhLnl5d3cnXTtcbiAgICAgICAgdmFyIGJTd2l6emxlID0gdHJhbnNwb3NlQiA/IFsnYi54enh6JywgJ2IueXd5dyddIDogWydiLnh5eHknLCAnYi56d3p3J107XG4gICAgICAgIHZhciBhY3RpdmF0aW9uU25pcHBldCA9ICcnLCBhcHBseUFjdGl2YXRpb25TbmlwcGV0ID0gJyc7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaGFzUHJlbHVBY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBcInZlYzQgYWN0aXZhdGlvbih2ZWM0IGEpIHtcXG4gICAgICAgICAgdmVjNCBiID0gZ2V0UHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICAgIFwiICsgYWN0aXZhdGlvbiArIFwiXFxuICAgICAgICB9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNMZWFreXJlbHVBY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBcInZlYzQgYWN0aXZhdGlvbih2ZWM0IGEpIHtcXG4gICAgICAgICAgdmVjNCBiID0gZ2V0TGVha3lyZWx1QWxwaGFBdE91dENvb3JkcygpO1xcbiAgICAgICAgICBcIiArIGFjdGl2YXRpb24gKyBcIlxcbiAgICAgICAgfVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBcInZlYzQgYWN0aXZhdGlvbih2ZWM0IHgpIHtcXG4gICAgICAgICAgXCIgKyBhY3RpdmF0aW9uICsgXCJcXG4gICAgICAgIH1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwcGx5QWN0aXZhdGlvblNuaXBwZXQgPSBcInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRkQmlhc1NuaXBwZXQgPSBhZGRCaWFzID8gJ3Jlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTsnIDogJyc7XG4gICAgICAgIGlmIChhZGRCaWFzKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdwcmVsdUFjdGl2YXRpb25XZWlnaHRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xlYWt5cmVsdUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdsZWFreXJlbHVBbHBoYScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXRjaEFTbmlwcGV0ID0gJ3JjLngnO1xuICAgICAgICB2YXIgYmF0Y2hCU25pcHBldCA9ICdyYy54JztcbiAgICAgICAgaWYgKGFTaGFwZVswXSA8IGJTaGFwZVswXSkge1xuICAgICAgICAgICAgYmF0Y2hBU25pcHBldCA9IFwiaW50KG1pbihmbG9hdChyYy54KSwgXCIgKyAoYVNoYXBlWzBdIC0gMSkgKyBcIi4pKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJTaGFwZVswXSA8IGFTaGFwZVswXSkge1xuICAgICAgICAgICAgYmF0Y2hCU25pcHBldCA9IFwiaW50KG1pbihmbG9hdChyYy54KSwgXCIgKyAoYlNoYXBlWzBdIC0gMSkgKyBcIi4pKVwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIFwiICsgYWN0aXZhdGlvblNuaXBwZXQgKyBcIlxcblxcbiAgICAgIGNvbnN0IGZsb2F0IHNoYXJlZERpbWVuc2lvbiA9IFwiICsgc2hhcmVkRGltZW5zaW9uUGFja2VkICsgXCIuMDtcXG5cXG4gICAgICB2ZWM0IGRvdDJ4MkFSb3dCQ29sKGl2ZWMzIHJjKSB7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMCk7XFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgc2hhcmVkRGltZW5zaW9uUGFja2VkICsgXCI7IGkrKykge1xcbiAgICAgICAgICBpbnQgYmF0Y2hBID0gXCIgKyBiYXRjaEFTbmlwcGV0ICsgXCI7XFxuICAgICAgICAgIGludCBiYXRjaEIgPSBcIiArIGJhdGNoQlNuaXBwZXQgKyBcIjtcXG4gICAgICAgICAgdmVjNCBhID0gZ2V0TWF0cml4QShiYXRjaEEsIFwiICsgYVNhbXBsZSArIFwiKTtcXG4gICAgICAgICAgdmVjNCBiID0gZ2V0TWF0cml4QihiYXRjaEIsIFwiICsgYlNhbXBsZSArIFwiKTtcXG5cXG4gICAgICAgICAgLy8gVGhlc2Ugc3dpenpsZWQgcHJvZHVjdHMgbmVlZCB0byBiZSBzZXBhcmF0ZWx5IGFkZGVkLlxcbiAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvaXNzdWVzLzE3MzVcXG4gICAgICAgICAgcmVzdWx0ICs9IChcIiArIGFTd2l6emxlWzBdICsgXCIgKiBcIiArIGJTd2l6emxlWzBdICsgXCIpO1xcbiAgICAgICAgICByZXN1bHQgKz0gKFwiICsgYVN3aXp6bGVbMV0gKyBcIiAqIFwiICsgYlN3aXp6bGVbMV0gKyBcIik7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSBkb3QyeDJBUm93QkNvbChyYyk7XFxuXFxuICAgICAgICBcIiArIGFkZEJpYXNTbmlwcGV0ICsgXCJcXG5cXG4gICAgICAgIFwiICsgYXBwbHlBY3RpdmF0aW9uU25pcHBldCArIFwiXFxuXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gTWF0TXVsUGFja2VkUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8vIChBciArIEFpKShCciArIEJpKSA9XG4vLyBBckJyICsgQXJCaSArIEFpQnIgKyBBaUJpID0gQXJCciAtIEFCICsgQXJCaSArIEFpQnJcbi8vIFlyID0gQXJCciAtIEFCXG4vLyBZaSA9IEFyQmkgKyBBaUJyXG52YXIgQ09NUExFWF9NVUxUSVBMWSA9IHtcbiAgICBSRUFMOiAncmV0dXJuIGFyZWFsICogYnJlYWwgLSBhaW1hZyAqIGJpbWFnOycsXG4gICAgSU1BRzogJ3JldHVybiBhcmVhbCAqIGJpbWFnICsgYWltYWcgKiBicmVhbDsnXG59O1xudmFyIEJpbmFyeU9wQ29tcGxleFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluYXJ5T3BDb21wbGV4UHJvZ3JhbShvcCwgYVNoYXBlLCBiU2hhcGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBUmVhbCcsICdBSW1hZycsICdCUmVhbCcsICdCSW1hZyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gdGYuYmFja2VuZF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGFTaGFwZSwgYlNoYXBlKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgZmxvYXQgYmluYXJ5T3BDb21wbGV4KFxcbiAgICAgICAgICBmbG9hdCBhcmVhbCwgZmxvYXQgYWltYWcsIGZsb2F0IGJyZWFsLCBmbG9hdCBiaW1hZykge1xcbiAgICAgICAgXCIgKyBvcCArIFwiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IGFyZWFsID0gZ2V0QVJlYWxBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYWltYWcgPSBnZXRBSW1hZ0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBicmVhbCA9IGdldEJSZWFsQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGJpbWFnID0gZ2V0QkltYWdBdE91dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGJpbmFyeU9wQ29tcGxleChhcmVhbCwgYWltYWcsIGJyZWFsLCBiaW1hZykpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBCaW5hcnlPcENvbXBsZXhQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIE1VTCA9ICdyZXR1cm4gYSAqIGI7JztcbmZ1bmN0aW9uIG11bHRpcGx5KGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQ7XG4gICAgdmFyIGEgPSBpbnB1dHMuYSwgYiA9IGlucHV0cy5iO1xuICAgIHZhciBkdHlwZSA9IHRmLmJhY2tlbmRfdXRpbC51cGNhc3RUeXBlKGEuZHR5cGUsIGIuZHR5cGUpO1xuICAgIGlmIChhLmR0eXBlID09PSAnY29tcGxleDY0Jykge1xuICAgICAgICB2YXIgYURhdGEgPSBiYWNrZW5kLnRleERhdGEuZ2V0KGEuZGF0YUlkKTtcbiAgICAgICAgdmFyIGJEYXRhID0gYmFja2VuZC50ZXhEYXRhLmdldChiLmRhdGFJZCk7XG4gICAgICAgIHZhciByZWFsUHJvZ3JhbSA9IG5ldyBCaW5hcnlPcENvbXBsZXhQcm9ncmFtKENPTVBMRVhfTVVMVElQTFkuUkVBTCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBpbWFnUHJvZ3JhbSA9IG5ldyBCaW5hcnlPcENvbXBsZXhQcm9ncmFtKENPTVBMRVhfTVVMVElQTFkuSU1BRywgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBpbnB1dHNfMSA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkYXRhSWQ6IGFEYXRhLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLmRhdGFJZCxcbiAgICAgICAgICAgICAgICBkdHlwZTogYURhdGEuY29tcGxleFRlbnNvckluZm9zLnJlYWwuZHR5cGUsXG4gICAgICAgICAgICAgICAgc2hhcGU6IGEuc2hhcGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGF0YUlkOiBhRGF0YS5jb21wbGV4VGVuc29ySW5mb3MuaW1hZy5kYXRhSWQsXG4gICAgICAgICAgICAgICAgZHR5cGU6IGFEYXRhLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLmR0eXBlLFxuICAgICAgICAgICAgICAgIHNoYXBlOiBhLnNoYXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRhdGFJZDogYkRhdGEuY29tcGxleFRlbnNvckluZm9zLnJlYWwuZGF0YUlkLFxuICAgICAgICAgICAgICAgIGR0eXBlOiBiRGF0YS5jb21wbGV4VGVuc29ySW5mb3MucmVhbC5kdHlwZSxcbiAgICAgICAgICAgICAgICBzaGFwZTogYi5zaGFwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkYXRhSWQ6IGJEYXRhLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLmRhdGFJZCxcbiAgICAgICAgICAgICAgICBkdHlwZTogYkRhdGEuY29tcGxleFRlbnNvckluZm9zLmltYWcuZHR5cGUsXG4gICAgICAgICAgICAgICAgc2hhcGU6IGIuc2hhcGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgICAgdmFyIHJlYWxQYXJ0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocmVhbFByb2dyYW0sIGlucHV0c18xLCAnZmxvYXQzMicpO1xuICAgICAgICB2YXIgaW1hZ1BhcnQgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShpbWFnUHJvZ3JhbSwgaW5wdXRzXzEsICdmbG9hdDMyJyk7XG4gICAgICAgIHZhciBjb21wbGV4T3V0cHV0ID0gY29tcGxleCh7IGlucHV0czogeyByZWFsOiByZWFsUGFydCwgaW1hZzogaW1hZ1BhcnQgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyZWFsUGFydCk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaW1hZ1BhcnQpO1xuICAgICAgICAvLyBUT0RPKGFubnhpbmd5dWFuKTogQ1BVIGZvcndhcmRpbmcgZm9yIGNvbXBsZXggaW5wdXRzLlxuICAgICAgICByZXR1cm4gY29tcGxleE91dHB1dDtcbiAgICB9XG4gICAgaWYgKGJhY2tlbmQuc2hvdWxkRXhlY3V0ZU9uQ1BVKFthLCBiXSkpIHtcbiAgICAgICAgdmFyIGFEYXRhID0gYmFja2VuZC50ZXhEYXRhLmdldChhLmRhdGFJZCk7XG4gICAgICAgIHZhciBiRGF0YSA9IGJhY2tlbmQudGV4RGF0YS5nZXQoYi5kYXRhSWQpO1xuICAgICAgICB2YXIgX2EgPSBtdWx0aXBseUltcGxDUFUoYS5zaGFwZSwgYi5zaGFwZSwgYURhdGEudmFsdWVzLCBiRGF0YS52YWx1ZXMsIGR0eXBlKSwgb3V0VmFsdWVzID0gX2FbMF0sIG91dFNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBvdXQgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dFNoYXBlLCBkdHlwZSk7XG4gICAgICAgIHZhciBvdXREYXRhID0gYmFja2VuZC50ZXhEYXRhLmdldChvdXQuZGF0YUlkKTtcbiAgICAgICAgb3V0RGF0YS52YWx1ZXMgPSBvdXRWYWx1ZXM7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHZhciBwcm9ncmFtO1xuICAgIGlmICh0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TJykpIHtcbiAgICAgICAgcHJvZ3JhbSA9IG5ldyBCaW5hcnlPcFBhY2tlZFByb2dyYW0oTVVMLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByb2dyYW0gPSBuZXcgQmluYXJ5T3BQcm9ncmFtKE1VTCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgfVxuICAgIHJldHVybiBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbYSwgYl0sIGR0eXBlKTtcbn1cbnZhciBtdWx0aXBseUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5NdWx0aXBseSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBtdWx0aXBseVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gcGFja2VkUmVzaGFwZShpbnB1dCwgYWZ0ZXJTaGFwZSwgYmFja2VuZCkge1xuICAgIHZhciBpbnB1dDNEU2hhcGUgPSBbZ2V0QmF0Y2hEaW0oaW5wdXQuc2hhcGUpXS5jb25jYXQoZ2V0Um93c0NvbHMoaW5wdXQuc2hhcGUpKTtcbiAgICB2YXIgaW5wdXQzRCA9IHtcbiAgICAgICAgZHR5cGU6IGlucHV0LmR0eXBlLFxuICAgICAgICBzaGFwZTogaW5wdXQzRFNoYXBlLFxuICAgICAgICBkYXRhSWQ6IGlucHV0LmRhdGFJZFxuICAgIH07XG4gICAgdmFyIGFmdGVyU2hhcGVBczNEID0gW2dldEJhdGNoRGltKGFmdGVyU2hhcGUpXS5jb25jYXQoZ2V0Um93c0NvbHMoYWZ0ZXJTaGFwZSkpO1xuICAgIHZhciBwcm9ncmFtID0gbmV3IFJlc2hhcGVQYWNrZWRQcm9ncmFtKGFmdGVyU2hhcGVBczNELCBpbnB1dDNEU2hhcGUpO1xuICAgIHZhciBwcmV2ZW50RWFnZXJVbnBhY2tpbmdPZk91dHB1dCA9IHRydWU7XG4gICAgdmFyIG91dHB1dCA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFtpbnB1dDNEXSwgaW5wdXQuZHR5cGUsIG51bGwgLyogY3VzdG9tU2V0dXAgKi8sIHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0KTtcbiAgICByZXR1cm4geyBkYXRhSWQ6IG91dHB1dC5kYXRhSWQsIHNoYXBlOiBhZnRlclNoYXBlLCBkdHlwZTogb3V0cHV0LmR0eXBlIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHJlc2hhcGUoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIHNoYXBlID0gYXR0cnMuc2hhcGU7XG4gICAgdmFyIHdlYmdsQmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgdmFyIHhTaXplID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKHguc2hhcGUpO1xuICAgIHZhciAkc2hhcGUgPSB0Zi51dGlsLmluZmVyRnJvbUltcGxpY2l0U2hhcGUoc2hhcGUsIHhTaXplKTtcbiAgICB2YXIgJHhTaXplID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKCRzaGFwZSk7XG4gICAgdGYudXRpbC5hc3NlcnQoeFNpemUgPT09ICR4U2l6ZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJUaGUgbmV3IHNoYXBlIChcIiArICRzaGFwZSArIFwiKSBoYXMgXCIgKyAkeFNpemUgKyBcIiBlbGVtZW50cyBhbmQgdGhlIG9sZCBcIiArXG4gICAgICAgIChcInNoYXBlIChcIiArIHguc2hhcGUgKyBcIikgaGFzIFwiICsgeFNpemUgKyBcIiBlbGVtZW50cy4gVGhlIG5ldyBzaGFwZSBhbmQgb2xkIFwiKSArXG4gICAgICAgIFwic2hhcGUgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy5cIjsgfSk7XG4gICAgdmFyIHhUZXhEYXRhID0gd2ViZ2xCYWNrZW5kLnRleERhdGEuZ2V0KHguZGF0YUlkKTtcbiAgICBpZiAoeFRleERhdGEuaXNQYWNrZWQgJiYgIWlzUmVzaGFwZUZyZWUoeC5zaGFwZSwgJHNoYXBlKSAmJlxuICAgICAgICAhKHhUZXhEYXRhLnRleHR1cmUgIT09IG51bGwgJiYgaXNSZXNoYXBlRnJlZSh4VGV4RGF0YS5zaGFwZSwgJHNoYXBlKSkpIHtcbiAgICAgICAgcmV0dXJuIHBhY2tlZFJlc2hhcGUoeCwgJHNoYXBlLCB3ZWJnbEJhY2tlbmQpO1xuICAgIH1cbiAgICB3ZWJnbEJhY2tlbmQuaW5jUmVmKHguZGF0YUlkKTtcbiAgICByZXR1cm4geyBkYXRhSWQ6IHguZGF0YUlkLCBzaGFwZTogJHNoYXBlLCBkdHlwZTogeC5kdHlwZSB9O1xufVxudmFyIHJlc2hhcGVDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuUmVzaGFwZSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiByZXNoYXBlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgTWVhblByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVhblByb2dyYW0ocmVkdWNlSW5mbywgZGl2aXNvcikge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSByZWR1Y2VJbmZvLndpbmRvd1NpemUsIGJhdGNoU2l6ZSA9IHJlZHVjZUluZm8uYmF0Y2hTaXplLCBpblNpemUgPSByZWR1Y2VJbmZvLmluU2l6ZSwgb3V0U2l6ZSA9IHJlZHVjZUluZm8ub3V0U2l6ZTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dFNpemVdO1xuICAgICAgICB2YXIgd2luZG93U2l6ZU5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcih3aW5kb3dTaXplIC8gNCkgKiA0O1xuICAgICAgICB2YXIgd2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPSB3aW5kb3dTaXplICUgNDtcbiAgICAgICAgdmFyIHVwZGF0ZVNuaXBwZXQgPSBcInN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1wiO1xuICAgICAgICBpZiAoZGl2aXNvciAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxIC8gZGl2aXNvcjtcbiAgICAgICAgICAgIHVwZGF0ZVNuaXBwZXQgPSBcInN1bVZhbHVlICs9IGRvdCh2YWx1ZXMgKiBcIiArICh0Zi51dGlsLmlzSW50KGRlbm9taW5hdG9yKSA/IGRlbm9taW5hdG9yLnRvUHJlY2lzaW9uKDIpIDpcbiAgICAgICAgICAgICAgICBkZW5vbWluYXRvcikgKyBcIiwgb25lcyk7XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoZWNrT3V0T2ZCb3VuZHMgPSAnJztcbiAgICAgICAgaWYgKGluU2l6ZSAlIHdpbmRvd1NpemUgPiAwKSB7XG4gICAgICAgICAgICBjaGVja091dE9mQm91bmRzID0gXCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIgKyBpblNpemUgKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gMC4wO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCBpbklkeCkge1xcbiAgICAgICAgXCIgKyBjaGVja091dE9mQm91bmRzICsgXCJcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IG91dElkeCAqIFwiICsgd2luZG93U2l6ZSArIFwiO1xcblxcbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgd2luZG93U2l6ZU5lYXJlc3RWZWM0ICsgXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIFwiICsgd2luZG93U2l6ZU5lYXJlc3RWZWM0ICsgXCI7XFxuICAgICAgICBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KGdldFZhbHVlKGJhdGNoLCBpbklkeCksIDAuMCwgMC4wLCAwLjApO1xcblxcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSwgMC4wLCAwLjApO1xcblxcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSwgMC4wKTtcXG5cXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChzdW1WYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIE1lYW5Qcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFJlZHVjZVByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVkdWNlUHJvZ3JhbShyZWR1Y2VJbmZvLCByZWR1Y2VUeXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZUluZm8ud2luZG93U2l6ZSwgYmF0Y2hTaXplID0gcmVkdWNlSW5mby5iYXRjaFNpemUsIGluU2l6ZSA9IHJlZHVjZUluZm8uaW5TaXplLCBvdXRTaXplID0gcmVkdWNlSW5mby5vdXRTaXplO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0U2l6ZV07XG4gICAgICAgIHZhciBpbml0aWFsaXphdGlvblZhbHVlID0gJzAuMCc7XG4gICAgICAgIHZhciBjb21wYXJlT3AgPSBcIlwiO1xuICAgICAgICBpZiAocmVkdWNlVHlwZSA9PT0gJ3Byb2QnKSB7XG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzEuMCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVkdWNlVHlwZSA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgIC8vIFdlYkdMIG9uIEZpcmVmb3ggTGludXggY2FuJ3QgY29tcGlsZSAxLzAgc28gd2UgZG8gMS9lcHMuXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzEuMCAvIDFlLTIwJztcbiAgICAgICAgICAgIGNvbXBhcmVPcCA9IFwibWluXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVkdWNlVHlwZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICAgIC8vIFdlYkdMIG9uIEZpcmVmb3ggTGludXggY2FuJ3QgY29tcGlsZSAxLzAgc28gd2UgZG8gMS9lcHMuXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJy0xLjAgLyAxZS0yMCc7XG4gICAgICAgICAgICBjb21wYXJlT3AgPSBcIm1heFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHJlZHVjZVR5cGUgKyBcIihcIiArIHJlZHVjZVR5cGUgKyBcIihcIiArIHJlZHVjZVR5cGUgKyBcIihcIiArXG4gICAgICAgICAgICAnbWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSknO1xuICAgICAgICBpZiAocmVkdWNlVHlwZSA9PT0gJ3N1bScpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gXCJzdW1WYWx1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZHVjZVR5cGUgPT09ICdwcm9kJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBcInByb2RWYWx1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZHVjZVR5cGUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IFwiYWxsVmFsdWVcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWR1Y2VUeXBlID09PSAnYW55Jykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBcImFueVZhbHVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpbmRvd1NpemVOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3Iod2luZG93U2l6ZSAvIDQpICogNDtcbiAgICAgICAgdmFyIHdpbmRvd1NpemVWZWM0UmVtYWluZGVyID0gd2luZG93U2l6ZSAlIDQ7XG4gICAgICAgIHZhciB1cGRhdGVTbmlwcGV0ID0gXCJcXG4gICAgICBpZiAoXCIgKyAocmVkdWNlVHlwZSA9PT0gJ3N1bScpICsgXCIpIHtcXG4gICAgICAgIHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIgKyAocmVkdWNlVHlwZSA9PT0gJ3Byb2QnKSArIFwiKSB7XFxuICAgICAgICB2ZWMyIHRtcCA9IHZlYzIodmFsdWVzWzBdLCB2YWx1ZXNbMV0pICogdmVjMih2YWx1ZXNbMl0sIHZhbHVlc1szXSk7XFxuICAgICAgICBwcm9kVmFsdWUgKj0gdG1wWzBdICogdG1wWzFdO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IFwiICsgY29tcGFyZU9wICsgXCIodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICAgICAgdmFyIHZlY1R5cGUgPSBcInZlYzRcIjtcbiAgICAgICAgaWYgKHJlZHVjZVR5cGUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzEuMCc7XG4gICAgICAgICAgICB1cGRhdGVTbmlwcGV0ID0gXCJcXG4gICAgICAgIGJvb2wgcmVkdWNlZEFsbFZhbHVlID0gYWxsKHZhbHVlcyk7XFxuICAgICAgICBmbG9hdCBmbG9hdGVkUmVkdWNlZEFsbFZhbHVlID0gZmxvYXQocmVkdWNlZEFsbFZhbHVlKTtcXG4gICAgICAgIGFsbFZhbHVlID0gZmxvYXQoYWxsVmFsdWUgPj0gMS4wICYmIGZsb2F0ZWRSZWR1Y2VkQWxsVmFsdWUgPj0gMS4wKTtcXG4gICAgICBcIjtcbiAgICAgICAgICAgIHZlY1R5cGUgPSBcImJ2ZWM0XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVkdWNlVHlwZSA9PT0gJ2FueScpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMC4wJztcbiAgICAgICAgICAgIHVwZGF0ZVNuaXBwZXQgPSBcIlxcbiAgICAgICAgYm9vbCByZWR1Y2VkQW55VmFsdWUgPSBhbnkodmFsdWVzKTtcXG4gICAgICAgIGZsb2F0IGZsb2F0ZWRSZWR1Y2VkQW55VmFsdWUgPSBmbG9hdChyZWR1Y2VkQW55VmFsdWUpO1xcbiAgICAgICAgYW55VmFsdWUgPSBmbG9hdChhbnlWYWx1ZSA+PSAxLjAgfHwgZmxvYXRlZFJlZHVjZWRBbnlWYWx1ZSA+PSAxLjApO1xcbiAgICAgIFwiO1xuICAgICAgICAgICAgdmVjVHlwZSA9IFwiYnZlYzRcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hlY2tPdXRPZkJvdW5kcyA9ICcnO1xuICAgICAgICBpZiAoaW5TaXplICUgd2luZG93U2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNoZWNrT3V0T2ZCb3VuZHMgPSBcIlxcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSBcIiArIGluU2l6ZSArIFwiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSBcIiArIGluaXRpYWxpemF0aW9uVmFsdWUgKyBcIjtcXG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgaW5JZHgpIHtcXG4gICAgICAgIFwiICsgY2hlY2tPdXRPZkJvdW5kcyArIFwiXFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgaW5JZHgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiBcIiArIHdpbmRvd1NpemUgKyBcIjtcXG5cXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiKTtcXG4gICAgICAgIGZsb2F0IHByb2RWYWx1ZSA9IDEuMDtcXG4gICAgICAgIGZsb2F0IHN1bVZhbHVlID0gMC4wO1xcbiAgICAgICAgZmxvYXQgYWxsVmFsdWUgPSAxLjA7XFxuICAgICAgICBmbG9hdCBhbnlWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyB3aW5kb3dTaXplTmVhcmVzdFZlYzQgKyBcIjsgaSArPSA0KSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcXG4gICAgICAgICAgXCIgKyB2ZWNUeXBlICsgXCIgdmFsdWVzID0gXCIgKyB2ZWNUeXBlICsgXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAzKVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBcIiArIHdpbmRvd1NpemVOZWFyZXN0VmVjNCArIFwiO1xcbiAgICAgICAgaWYgKFwiICsgKHdpbmRvd1NpemVWZWM0UmVtYWluZGVyID09PSAxKSArIFwiKSB7XFxuICAgICAgICAgIFwiICsgdmVjVHlwZSArIFwiIHZhbHVlcyA9IFwiICsgdmVjVHlwZSArIFwiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgXCIgKyB2ZWNUeXBlICsgXCIgdmFsdWVzID0gXCIgKyB2ZWNUeXBlICsgXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgXCIgKyB2ZWNUeXBlICsgXCIgdmFsdWVzID0gXCIgKyB2ZWNUeXBlICsgXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoXCIgKyByZXR1cm5WYWx1ZSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUmVkdWNlUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgY29uZmlndXJhdGlvbiBvYmplY3RzIHRoYXQgZGVzY3JpYmUgZWFjaCBzdGFnZSBvZiB0aGVcbi8vIHJlZHVjdGlvbi5cbmZ1bmN0aW9uIGdldFJlZHVjdGlvblN0YWdlcyhpblNoYXBlKSB7XG4gICAgdmFyIHN0YWdlcyA9IFtdO1xuICAgIHdoaWxlIChzdGFnZXMubGVuZ3RoID09PSAwIHx8IHN0YWdlc1tzdGFnZXMubGVuZ3RoIC0gMV0ub3V0U2l6ZSAhPT0gMSkge1xuICAgICAgICB2YXIgb3V0U2l6ZSA9IHN0YWdlcy5sZW5ndGggPyBzdGFnZXNbc3RhZ2VzLmxlbmd0aCAtIDFdLm91dFNpemUgOiBpblNoYXBlWzFdO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHRmLmJhY2tlbmRfdXRpbC5jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUob3V0U2l6ZSk7XG4gICAgICAgIHN0YWdlcy5wdXNoKHtcbiAgICAgICAgICAgIGluU2l6ZTogb3V0U2l6ZSxcbiAgICAgICAgICAgIHdpbmRvd1NpemU6IHdpbmRvd1NpemUsXG4gICAgICAgICAgICBvdXRTaXplOiBNYXRoLmNlaWwob3V0U2l6ZSAvIHdpbmRvd1NpemUpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhZ2VzO1xufVxuZnVuY3Rpb24gcmVkdWNlKHgsIGR0eXBlLCByZWR1Y3Rpb25UeXBlLCBiYWNrZW5kKSB7XG4gICAgdmFyIHJlZHVjdGlvblN0YWdlcyA9IGdldFJlZHVjdGlvblN0YWdlcyh4LnNoYXBlKTtcbiAgICB2YXIgcmVzdWx0ID0geDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjdGlvblN0YWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2EgPSByZWR1Y3Rpb25TdGFnZXNbaV0sIGluU2l6ZSA9IF9hLmluU2l6ZSwgd2luZG93U2l6ZSA9IF9hLndpbmRvd1NpemUsIG91dFNpemUgPSBfYS5vdXRTaXplO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHByZXZpb3VzUmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICBpZiAocmVkdWN0aW9uVHlwZSA9PT0gJ21lYW4nKSB7XG4gICAgICAgICAgICBwcm9ncmFtID0gaSA9PT0gMCA/XG4gICAgICAgICAgICAgICAgbmV3IE1lYW5Qcm9ncmFtKHsgd2luZG93U2l6ZTogd2luZG93U2l6ZSwgaW5TaXplOiBpblNpemUsIGJhdGNoU2l6ZTogeC5zaGFwZVswXSwgb3V0U2l6ZTogb3V0U2l6ZSB9LCBpblNpemUpIDpcbiAgICAgICAgICAgICAgICBuZXcgTWVhblByb2dyYW0oeyB3aW5kb3dTaXplOiB3aW5kb3dTaXplLCBpblNpemU6IGluU2l6ZSwgYmF0Y2hTaXplOiB4LnNoYXBlWzBdLCBvdXRTaXplOiBvdXRTaXplIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvZ3JhbSA9IG5ldyBSZWR1Y2VQcm9ncmFtKHsgd2luZG93U2l6ZTogd2luZG93U2l6ZSwgaW5TaXplOiBpblNpemUsIGJhdGNoU2l6ZTogeC5zaGFwZVswXSwgb3V0U2l6ZTogb3V0U2l6ZSB9LCByZWR1Y3Rpb25UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c1Jlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3Jlc3VsdF0sIGR0eXBlKTtcbiAgICAgICAgaWYgKHByZXZpb3VzUmVzdWx0LmRhdGFJZCAhPT0geC5kYXRhSWQpIHtcbiAgICAgICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocHJldmlvdXNSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBUcmFuc3Bvc2VQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9zZVByb2dyYW0oYVNoYXBlLCBuZXdEaW0pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IG5ldyBBcnJheShhU2hhcGUubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVbaV0gPSBhU2hhcGVbbmV3RGltW2ldXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMucmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIHN3aXRjaGVkID0gZ2V0U3dpdGNoZWRDb29yZHMobmV3RGltKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBcIiArIGR0eXBlICsgXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBzZXRPdXRwdXQoZ2V0QShcIiArIHN3aXRjaGVkICsgXCIpKTtcXG4gICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zcG9zZVByb2dyYW07XG59KCkpO1xuZnVuY3Rpb24gZ2V0U3dpdGNoZWRDb29yZHMobmV3RGltKSB7XG4gICAgdmFyIHJhbmsgPSBuZXdEaW0ubGVuZ3RoO1xuICAgIGlmIChyYW5rID4gNikge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRyYW5zcG9zZSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgdmFyIG9yaWdpbmFsT3JkZXIgPSBbJ3Jlc1JDLngnLCAncmVzUkMueScsICdyZXNSQy56JywgJ3Jlc1JDLncnLCAncmVzUkMudScsICdyZXNSQy52J107XG4gICAgdmFyIHN3aXRjaGVkQ29vcmRzID0gbmV3IEFycmF5KHJhbmspO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGltLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaGVkQ29vcmRzW25ld0RpbVtpXV0gPSBvcmlnaW5hbE9yZGVyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3dpdGNoZWRDb29yZHMuam9pbigpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgVHJhbnNwb3NlUGFja2VkUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc3Bvc2VQYWNrZWRQcm9ncmFtKGFTaGFwZSwgbmV3RGltKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLnBhY2tlZElucHV0cyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFja2VkT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGFTaGFwZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGFTaGFwZVtuZXdEaW1baV1dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy5yYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5yYW5rID4gNikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJQYWNrZWQgdHJhbnNwb3NlIGZvciByYW5rIFwiICsgdGhpcy5yYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayk7XG4gICAgICAgIHZhciBvdXRwdXRPcmRlciA9IGdldFZlY0NoYW5uZWxzKCdyYycsIHRoaXMucmFuayk7XG4gICAgICAgIHZhciBzd2l0Y2hlZE9yZGVyID0gbmV3IEFycmF5KHRoaXMucmFuayk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGltLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzd2l0Y2hlZE9yZGVyW25ld0RpbVtpXV0gPSBvdXRwdXRPcmRlcltpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5uZXJEaW1zID0gXCJ2ZWMyKFwiICsgc3dpdGNoZWRPcmRlci5zbGljZSgtMikuam9pbigpICsgXCIpXCI7XG4gICAgICAgIHZhciBuZXh0Q29sdW1uID0gXCIrK1wiICsgb3V0cHV0T3JkZXJbdGhpcy5yYW5rIC0gMV0gKyBcIiA8IFwiICsgb3V0cHV0U2hhcGVbdGhpcy5yYW5rIC0gMV07XG4gICAgICAgIHZhciBnZXRjID0gXCJnZXRDaGFubmVsKGdldEEoXCIgKyBzd2l0Y2hlZE9yZGVyLmpvaW4oKSArIFwiKSwgXCIgKyBpbm5lckRpbXMgKyBcIilcIjtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBcIiArIGR0eXBlICsgXCIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgIHJlc3VsdFswXSA9IFwiICsgZ2V0YyArIFwiO1xcbiAgICAgIGlmKFwiICsgbmV4dENvbHVtbiArIFwiKSB7XFxuICAgICAgICByZXN1bHRbMV0gPSBcIiArIGdldGMgKyBcIjtcXG4gICAgICB9XFxuICAgICAgLS1cIiArIG91dHB1dE9yZGVyW3RoaXMucmFuayAtIDFdICsgXCI7XFxuICAgICAgaWYoKytcIiArIG91dHB1dE9yZGVyW3RoaXMucmFuayAtIDJdICsgXCIgPCBcIiArIG91dHB1dFNoYXBlW3RoaXMucmFuayAtIDJdICsgXCIpIHtcXG4gICAgICAgIHJlc3VsdFsyXSA9IFwiICsgZ2V0YyArIFwiO1xcbiAgICAgICAgaWYoXCIgKyBuZXh0Q29sdW1uICsgXCIpIHtcXG4gICAgICAgICAgcmVzdWx0WzNdID0gXCIgKyBnZXRjICsgXCI7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNwb3NlUGFja2VkUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcG9zZUltcGwkMSh4LCBwZXJtLCBiYWNrZW5kKSB7XG4gICAgdmFyIHByb2dyYW0gPSB0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlMnKSA/XG4gICAgICAgIG5ldyBUcmFuc3Bvc2VQYWNrZWRQcm9ncmFtKHguc2hhcGUsIHBlcm0pIDpcbiAgICAgICAgbmV3IFRyYW5zcG9zZVByb2dyYW0oeC5zaGFwZSwgcGVybSk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt4XSwgeC5kdHlwZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHN1bUltcGwoeCwgYXhpcywga2VlcERpbXMsIGJhY2tlbmQpIHtcbiAgICB2YXIgcmVkdWN0aW9uSW5kaWNlcyA9IGF4aXM7XG4gICAgdmFyIHhSYW5rID0geC5zaGFwZS5sZW5ndGg7XG4gICAgdmFyIG9yaWdBeGVzID0gdGYudXRpbC5wYXJzZUF4aXNQYXJhbShyZWR1Y3Rpb25JbmRpY2VzLCB4LnNoYXBlKTtcbiAgICB2YXIgYXhlcyA9IG9yaWdBeGVzO1xuICAgIHZhciBwZXJtdXRlZEF4ZXMgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHhSYW5rKTtcbiAgICB2YXIgc3VtSW5wdXRJc1RyYW5zcG9zZWQgPSBwZXJtdXRlZEF4ZXMgIT0gbnVsbDtcbiAgICB2YXIgc3VtSW5wdXQgPSB4O1xuICAgIGlmIChzdW1JbnB1dElzVHJhbnNwb3NlZCkge1xuICAgICAgICBzdW1JbnB1dCA9IHRyYW5zcG9zZUltcGwkMSh4LCBwZXJtdXRlZEF4ZXMsIGJhY2tlbmQpO1xuICAgICAgICBheGVzID0gdGYuYmFja2VuZF91dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIHhSYW5rKTtcbiAgICB9XG4gICAgdGYuYmFja2VuZF91dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdzdW0nLCBheGVzLCB4UmFuayk7XG4gICAgdmFyIF9hID0gdGYuYmFja2VuZF91dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoc3VtSW5wdXQuc2hhcGUsIGF4ZXMpLCBzdW1PdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgIHZhciBvdXRTaGFwZSA9IHN1bU91dFNoYXBlO1xuICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAvLyByYXRoZXIgdGhhbiByZXNoYXBlIGF0IHRoZSBlbmQsIHNldCB0aGUgdGFyZ2V0IHNoYXBlIGhlcmUuXG4gICAgICAgIG91dFNoYXBlID0gdGYuYmFja2VuZF91dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKHN1bU91dFNoYXBlLCBvcmlnQXhlcyk7XG4gICAgfVxuICAgIHZhciBpblNpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgIHZhciB4U2l6ZSA9IHRmLnV0aWwuc2l6ZUZyb21TaGFwZSh4LnNoYXBlKTtcbiAgICB2YXIgYmF0Y2hTaXplID0geFNpemUgLyBpblNpemU7XG4gICAgdmFyIHJlc2hhcGVkSW5wdXQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHN1bUlucHV0IH0sIGF0dHJzOiB7IHNoYXBlOiBbYmF0Y2hTaXplLCBpblNpemVdIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgdmFyIG91dFR5cGUgPSB0Zi5zdW1PdXRUeXBlKHguZHR5cGUpO1xuICAgIHZhciByZWR1Y2VkID0gcmVkdWNlKHJlc2hhcGVkSW5wdXQsIG91dFR5cGUsICdzdW0nLCBiYWNrZW5kKTtcbiAgICB2YXIgb3V0ID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiByZWR1Y2VkIH0sIGF0dHJzOiB7IHNoYXBlOiBvdXRTaGFwZSB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzaGFwZWRJbnB1dCk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyZWR1Y2VkKTtcbiAgICBpZiAoc3VtSW5wdXRJc1RyYW5zcG9zZWQpIHtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhzdW1JbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHN1bShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgYXhpcyA9IGF0dHJzLmF4aXMsIGtlZXBEaW1zID0gYXR0cnMua2VlcERpbXM7XG4gICAgcmV0dXJuIHN1bUltcGwoeCwgYXhpcywga2VlcERpbXMsIGJhY2tlbmQpO1xufVxudmFyIHN1bUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5TdW0sXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogc3VtXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiB0cmFuc3Bvc2UoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIHBlcm0gPSBhdHRycy5wZXJtO1xuICAgIHZhciB3ZWJnbEJhY2tlbmQgPSBiYWNrZW5kO1xuICAgIHZhciB4UmFuayA9IHguc2hhcGUubGVuZ3RoO1xuICAgIHZhciBuZXdTaGFwZSA9IG5ldyBBcnJheSh4UmFuayk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdTaGFwZVtpXSA9IHguc2hhcGVbcGVybVtpXV07XG4gICAgfVxuICAgIHZhciBvdXQ7XG4gICAgaWYgKHdlYmdsQmFja2VuZC5zaG91bGRFeGVjdXRlT25DUFUoW3hdKSkge1xuICAgICAgICB2YXIgeFRleERhdGEgPSB3ZWJnbEJhY2tlbmQudGV4RGF0YS5nZXQoeC5kYXRhSWQpO1xuICAgICAgICB2YXIgdmFsdWVzID0geFRleERhdGEudmFsdWVzO1xuICAgICAgICB2YXIgb3V0VmFsdWVzID0gdHJhbnNwb3NlSW1wbENQVSh2YWx1ZXMsIHguc2hhcGUsIHguZHR5cGUsIHBlcm0sIG5ld1NoYXBlKTtcbiAgICAgICAgb3V0ID0gd2ViZ2xCYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG5ld1NoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIG91dERhdGEgPSB3ZWJnbEJhY2tlbmQudGV4RGF0YS5nZXQob3V0LmRhdGFJZCk7XG4gICAgICAgIG91dERhdGEudmFsdWVzID0gb3V0VmFsdWVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3V0ID0gdHJhbnNwb3NlSW1wbCQxKHgsIHBlcm0sIHdlYmdsQmFja2VuZCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG52YXIgdHJhbnNwb3NlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlRyYW5zcG9zZSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiB0cmFuc3Bvc2Vcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8vIEVtcGlyaWNhbGx5IGRldGVybWluZWQgbWluaW1hbCBzaGFyZWQgZGltZW5zaW9uIGluIG1hdG11bCBiZWZvcmUgd2UgZm9yd2FyZFxuLy8gdG8gYS5tdWwoYikuc3VtKCkgaW4gb3JkZXIgdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgR1BVIHBhcmFsbGVsaXNtLiBTZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMtY29yZS9wdWxsLzEzNzkgZm9yIGJlbmNobWFya3MuXG52YXIgTUFUTVVMX1NIQVJFRF9ESU1fVEhSRVNIT0xEID0gMTAwMDtcbmZ1bmN0aW9uIGJhdGNoTWF0TXVsSW1wbChfYSkge1xuICAgIHZhciBhID0gX2EuYSwgYiA9IF9hLmIsIHRyYW5zcG9zZUEgPSBfYS50cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCID0gX2EudHJhbnNwb3NlQiwgYmFja2VuZCA9IF9hLmJhY2tlbmQsIF9iID0gX2EuYmlhcywgYmlhcyA9IF9iID09PSB2b2lkIDAgPyBudWxsIDogX2IsIF9jID0gX2EucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cywgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IF9jID09PSB2b2lkIDAgPyBudWxsIDogX2MsIF9kID0gX2EubGVha3lyZWx1QWxwaGEsIGxlYWt5cmVsdUFscGhhID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCwgX2UgPSBfYS5hY3RpdmF0aW9uLCBhY3RpdmF0aW9uID0gX2UgPT09IHZvaWQgMCA/IG51bGwgOiBfZTtcbiAgICB2YXIgYVJhbmsgPSBhLnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgYlJhbmsgPSBiLnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgaW5uZXJTaGFwZUEgPSB0cmFuc3Bvc2VBID8gYS5zaGFwZVthUmFuayAtIDJdIDogYS5zaGFwZVthUmFuayAtIDFdO1xuICAgIHZhciBpbm5lclNoYXBlQiA9IHRyYW5zcG9zZUIgPyBiLnNoYXBlW2JSYW5rIC0gMV0gOiBiLnNoYXBlW2JSYW5rIC0gMl07XG4gICAgdmFyIG91dGVyU2hhcGVBID0gdHJhbnNwb3NlQSA/IGEuc2hhcGVbYVJhbmsgLSAxXSA6IGEuc2hhcGVbYVJhbmsgLSAyXTtcbiAgICB2YXIgb3V0ZXJTaGFwZUIgPSB0cmFuc3Bvc2VCID8gYi5zaGFwZVtiUmFuayAtIDJdIDogYi5zaGFwZVtiUmFuayAtIDFdO1xuICAgIHZhciBvdXRlckRpbXNBID0gYS5zaGFwZS5zbGljZSgwLCAtMik7XG4gICAgdmFyIG91dGVyRGltc0IgPSBiLnNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICB2YXIgYmF0Y2hEaW1BID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKG91dGVyRGltc0EpO1xuICAgIHZhciBiYXRjaERpbUIgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUob3V0ZXJEaW1zQik7XG4gICAgdmFyIGJhdGNoRGltc0NvbXBhdGlibGUgPSBiYXRjaERpbUEgPT09IGJhdGNoRGltQiB8fCBiYXRjaERpbUEgPT09IDEgfHwgYmF0Y2hEaW1CID09PSAxO1xuICAgIHRmLnV0aWwuYXNzZXJ0KGFSYW5rID49IDIgJiYgYlJhbmsgPj0gMiAmJiBiYXRjaERpbXNDb21wYXRpYmxlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkVycm9yIGluIG1hdE11bDogdGhlIGlucHV0IGJhdGNoIGRpbWVuc2lvbnMgbXVzdCBlaXRoZXIgYmUgdGhlIFwiICtcbiAgICAgICAgXCJzYW1lIG9yIGF0IGxlYXN0IG9uZSBpbnB1dCBiYXRjaCBkaW1lbnNpb24gbXVzdCBiZSAxLiBHb3QgaW5wdXQgXCIgK1xuICAgICAgICAoXCJiYXRjaCBkaW1lbnNpb25zIG9mIChcIiArIG91dGVyRGltc0EgKyBcIikgYW5kIChcIiArIG91dGVyRGltc0IgKyBcIikuXCIpOyB9KTtcbiAgICB2YXIgb3V0U2hhcGVPdXRlckRpbXMgPSBiYXRjaERpbUEgPiBiYXRjaERpbUIgPyBhLnNoYXBlLnNsaWNlKDAsIC0yKSA6IGIuc2hhcGUuc2xpY2UoMCwgLTIpO1xuICAgIHZhciBvdXRTaGFwZSA9IG91dFNoYXBlT3V0ZXJEaW1zLmNvbmNhdChbb3V0ZXJTaGFwZUEsIG91dGVyU2hhcGVCXSk7XG4gICAgdGYudXRpbC5hc3NlcnQoaW5uZXJTaGFwZUEgPT09IGlubmVyU2hhcGVCLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkVycm9yIGluIG1hdE11bDogaW5uZXIgc2hhcGVzIChcIiArIGlubmVyU2hhcGVBICsgXCIpIGFuZCAoXCIgK1xuICAgICAgICAoaW5uZXJTaGFwZUIgKyBcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIiArIGEuc2hhcGUgKyBcIiBhbmQgXCIpICtcbiAgICAgICAgKGIuc2hhcGUgKyBcIiBhbmQgdHJhbnNwb3NlQT1cIiArIHRyYW5zcG9zZUEpICtcbiAgICAgICAgKFwiIGFuZCB0cmFuc3Bvc2VCPVwiICsgdHJhbnNwb3NlQiArIFwiIG11c3QgbWF0Y2guXCIpOyB9KTtcbiAgICB2YXIgYTNkU2hhcGUgPSB0cmFuc3Bvc2VBID9cbiAgICAgICAgW2JhdGNoRGltQSwgaW5uZXJTaGFwZUEsIG91dGVyU2hhcGVBXSA6XG4gICAgICAgIFtiYXRjaERpbUEsIG91dGVyU2hhcGVBLCBpbm5lclNoYXBlQV07XG4gICAgdmFyIGIzZFNoYXBlID0gdHJhbnNwb3NlQiA/XG4gICAgICAgIFtiYXRjaERpbUIsIG91dGVyU2hhcGVCLCBpbm5lclNoYXBlQl0gOlxuICAgICAgICBbYmF0Y2hEaW1CLCBpbm5lclNoYXBlQiwgb3V0ZXJTaGFwZUJdO1xuICAgIC8vIFRoZSByZXN0IG9mIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBkZXNpZ25lZCB0byBvcGVyYXRlIG9uIHJhbmstMyB0ZW5zb3JzXG4gICAgdmFyIGEzZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogYSB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogYTNkU2hhcGUgfSB9KTtcbiAgICB2YXIgYjNkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiBiIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBiM2RTaGFwZSB9IH0pO1xuICAgIHZhciBpbnRlcm1lZGlhdGVzID0gW2EzZCwgYjNkXTtcbiAgICB2YXIgYmF0Y2hEaW0gPSBNYXRoLm1heChiYXRjaERpbUEsIGJhdGNoRGltQik7XG4gICAgdmFyIHNoYXJlZERpbSA9IHRyYW5zcG9zZUEgPyBhM2Quc2hhcGVbMV0gOiBhM2Quc2hhcGVbMl07XG4gICAgdmFyIGhhc0JpYXMgPSBiaWFzICE9IG51bGw7XG4gICAgdmFyIGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBwcmVsdUFjdGl2YXRpb25XZWlnaHRzICE9IG51bGw7XG4gICAgdmFyIGhhc0xlYWt5cmVsdUFscGhhID0gYWN0aXZhdGlvbiA9PT0gJ2xlYWt5cmVsdSc7XG4gICAgdmFyIGZ1c2VkQWN0aXZhdGlvbiA9IGFjdGl2YXRpb24gIT0gbnVsbCA/XG4gICAgICAgIG1hcEFjdGl2YXRpb25Ub1NoYWRlclByb2dyYW0oYWN0aXZhdGlvbiwgdHJ1ZSkgOlxuICAgICAgICBudWxsO1xuICAgIHZhciBjb250YWluc0Z1c2VkT3BzID0gaGFzQmlhcyB8fCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzIHx8XG4gICAgICAgIGhhc0xlYWt5cmVsdUFscGhhIHx8IGZ1c2VkQWN0aXZhdGlvbiAhPSBudWxsO1xuICAgIHZhciBvdXQ7XG4gICAgLy8gU2luY2UgdGhlIG1hdHJpY2VzIGFyZSB2ZWN0b3JzLCBpdCBpcyBmYXN0ZXIgdG8gY2FsbCBtdWwoKS5zdW0oKVxuICAgIC8vIGJlY2F1c2Ugc3VtKCkgaXMgTyhzcXJ0KE4pKSBkdWUgdG8gZGl2aWRlLWFuZC1jb25xdWVyLlxuICAgIGlmICgob3V0ZXJTaGFwZUEgPT09IDEgfHwgb3V0ZXJTaGFwZUIgPT09IDEpICYmXG4gICAgICAgIHNoYXJlZERpbSA+IE1BVE1VTF9TSEFSRURfRElNX1RIUkVTSE9MRCAmJiBjb250YWluc0Z1c2VkT3BzID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgYVZlYyA9IGEzZDtcbiAgICAgICAgdmFyIGJWZWMgPSBiM2Q7XG4gICAgICAgIGlmICh0cmFuc3Bvc2VBKSB7XG4gICAgICAgICAgICBhVmVjID0gdHJhbnNwb3NlKHsgaW5wdXRzOiB7IHg6IGEzZCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBwZXJtOiBbMCwgMiwgMV0gfSB9KTtcbiAgICAgICAgICAgIGludGVybWVkaWF0ZXMucHVzaChhVmVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNwb3NlQikge1xuICAgICAgICAgICAgYlZlYyA9IHRyYW5zcG9zZSh7IGlucHV0czogeyB4OiBiM2QgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgcGVybTogWzAsIDIsIDFdIH0gfSk7XG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVzLnB1c2goYlZlYyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZFJlc2hhcGVBID0gb3V0ZXJTaGFwZUIgIT09IDE7XG4gICAgICAgIHZhciBzaG91bGRSZXNoYXBlQiA9IG91dGVyU2hhcGVCID09PSAxO1xuICAgICAgICB2YXIgYVZlYzNkID0gYVZlYztcbiAgICAgICAgaWYgKHNob3VsZFJlc2hhcGVBKSB7XG4gICAgICAgICAgICBhVmVjM2QgPSByZXNoYXBlKHtcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHsgeDogYVZlYyB9LFxuICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGJhY2tlbmQsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgc2hhcGU6IFtiYXRjaERpbSwgc2hhcmVkRGltLCAxXSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGludGVybWVkaWF0ZXMucHVzaChhVmVjM2QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBheGlzID0gb3V0ZXJTaGFwZUIgPT09IDEgPyAyIDogMTtcbiAgICAgICAgdmFyIGJWZWMzZCA9IGJWZWM7XG4gICAgICAgIGlmIChzaG91bGRSZXNoYXBlQikge1xuICAgICAgICAgICAgYlZlYzNkID0gcmVzaGFwZSh7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiB7IHg6IGJWZWMgfSxcbiAgICAgICAgICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IHNoYXBlOiBbYmF0Y2hEaW0sIDEsIHNoYXJlZERpbV0gfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVzLnB1c2goYlZlYzNkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZHVjdCA9IG11bHRpcGx5KHsgaW5wdXRzOiB7IGE6IGFWZWMzZCwgYjogYlZlYzNkIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIG91dCA9IHN1bSh7IGlucHV0czogeyB4OiBwcm9kdWN0IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGF4aXM6IGF4aXMsIGtlZXBEaW1zOiB0cnVlIH0gfSk7XG4gICAgICAgIGludGVybWVkaWF0ZXMucHVzaChwcm9kdWN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBkdHlwZSA9IHRmLnVwY2FzdFR5cGUoYS5kdHlwZSwgYi5kdHlwZSk7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IE1hdE11bFBhY2tlZFByb2dyYW0oYTNkU2hhcGUsIGIzZFNoYXBlLCBbYmF0Y2hEaW0sIG91dGVyU2hhcGVBLCBvdXRlclNoYXBlQl0sIHRyYW5zcG9zZUEsIHRyYW5zcG9zZUIsIGhhc0JpYXMsIGZ1c2VkQWN0aXZhdGlvbiwgaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cywgaGFzTGVha3lyZWx1QWxwaGEpO1xuICAgICAgICB2YXIgaW5wdXRzID0gW2EzZCwgYjNkXTtcbiAgICAgICAgaWYgKGJpYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXRzLnB1c2goYmlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMpIHtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKHByZWx1QWN0aXZhdGlvbldlaWdodHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNMZWFreXJlbHVBbHBoYSkge1xuICAgICAgICAgICAgdmFyICRsZWFreXJlbHVBbHBoYSA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8oW10sICdmbG9hdDMyJywgdGYudXRpbC5jcmVhdGVTY2FsYXJWYWx1ZShsZWFreXJlbHVBbHBoYSwgJ2Zsb2F0MzInKSk7XG4gICAgICAgICAgICBpbnB1dHMucHVzaCgkbGVha3lyZWx1QWxwaGEpO1xuICAgICAgICAgICAgaW50ZXJtZWRpYXRlcy5wdXNoKCRsZWFreXJlbHVBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgaW5wdXRzLCBkdHlwZSk7XG4gICAgfVxuICAgIHZhciBvdXRSZXNoYXBlZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogb3V0IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBvdXRTaGFwZSB9IH0pO1xuICAgIGludGVybWVkaWF0ZXMucHVzaChvdXQpO1xuICAgIGZvciAodmFyIF9pID0gMCwgaW50ZXJtZWRpYXRlc18xID0gaW50ZXJtZWRpYXRlczsgX2kgPCBpbnRlcm1lZGlhdGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpID0gaW50ZXJtZWRpYXRlc18xW19pXTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dFJlc2hhcGVkO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gQVMgSVMgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gX2Z1c2VkTWF0TXVsKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgYSA9IGlucHV0cy5hLCBiID0gaW5wdXRzLmIsIGJpYXMgPSBpbnB1dHMuYmlhcywgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IGlucHV0cy5wcmVsdUFjdGl2YXRpb25XZWlnaHRzO1xuICAgIHZhciB0cmFuc3Bvc2VBID0gYXR0cnMudHJhbnNwb3NlQSwgdHJhbnNwb3NlQiA9IGF0dHJzLnRyYW5zcG9zZUIsIGFjdGl2YXRpb24gPSBhdHRycy5hY3RpdmF0aW9uLCBsZWFreXJlbHVBbHBoYSA9IGF0dHJzLmxlYWt5cmVsdUFscGhhO1xuICAgIHJldHVybiBiYXRjaE1hdE11bEltcGwoe1xuICAgICAgICBhOiBhLFxuICAgICAgICBiOiBiLFxuICAgICAgICB0cmFuc3Bvc2VBOiB0cmFuc3Bvc2VBLFxuICAgICAgICB0cmFuc3Bvc2VCOiB0cmFuc3Bvc2VCLFxuICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICBiaWFzOiBiaWFzLFxuICAgICAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzOiBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLFxuICAgICAgICBsZWFreXJlbHVBbHBoYTogbGVha3lyZWx1QWxwaGEsXG4gICAgICAgIGFjdGl2YXRpb246IGFjdGl2YXRpb25cbiAgICB9KTtcbn1cbnZhciBfZnVzZWRNYXRNdWxDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuX0Z1c2VkTWF0TXVsLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IF9mdXNlZE1hdE11bCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBBQlMkMSA9IFwicmV0dXJuIGFicyh4KTtcIjtcbmZ1bmN0aW9uIGFicyhhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgLy8gVE9ETzogaGFuZGxlIGNhc2VzIHdoZW4geCBpcyBjb21wbGV4LiBPbmNlIHRoZSBjcHUgaW1wbGVtZW50YXRpb25cbiAgICAvLyBjYW4gaGFuZGxlIGNvbXBsZXggdmFsdWVzLCByZWZhY3RvciB0byB1c2UgdW5hcnlLZXJuZWxGdW5jLlxuICAgIGlmIChiYWNrZW5kLnNob3VsZEV4ZWN1dGVPbkNQVShbeF0pICYmIHguZHR5cGUgIT09ICdjb21wbGV4NjQnKSB7XG4gICAgICAgIHZhciB4RGF0YSA9IGJhY2tlbmQudGV4RGF0YS5nZXQoeC5kYXRhSWQpO1xuICAgICAgICB2YXIgb3V0VmFsdWVzID0gc2ltcGxlQWJzSW1wbENQVSh4RGF0YS52YWx1ZXMpO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyh4LnNoYXBlLCB4LmR0eXBlLCBvdXRWYWx1ZXMpO1xuICAgIH1cbiAgICB2YXIgcHJvZ3JhbTtcbiAgICBpZiAodGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TJykpIHtcbiAgICAgICAgcHJvZ3JhbSA9IG5ldyBVbmFyeU9wUGFja2VkUHJvZ3JhbSh4LnNoYXBlLCBBQlMkMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm9ncmFtID0gbmV3IFVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIEFCUyQxKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt4XSwgeC5kdHlwZSk7XG59XG52YXIgYWJzQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkFicyxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBhYnNcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBBQ09TID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgaWYgKGFicyh4KSA+IDEuKSB7XFxuICAgIHJldHVybiBOQU47XFxuICB9XFxuICByZXR1cm4gYWNvcyh4KTtcXG5cIjtcbnZhciBhY29zID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBBQ09TIH0pO1xudmFyIGFjb3NDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQWNvcyxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBhY29zLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIEFDT1NIID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgaWYgKHggPCAxLjApIHJldHVybiBOQU47XFxucmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCAtIDEuMCkpO1wiO1xudmFyIGFjb3NoID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBBQ09TSCB9KTtcbnZhciBhY29zaENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5BY29zaCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBhY29zaCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBBREQgPSAncmV0dXJuIGEgKyBiOyc7XG52YXIgYWRkS2VybmVsRnVuYyA9IGJpbmFyeUtlcm5lbEZ1bmMoe1xuICAgIG9wU25pcHBldDogQURELFxuICAgIHBhY2tlZE9wU25pcHBldDogQURELFxuICAgIHN1cHBvcnRzQ29tcGxleDogdHJ1ZSxcbiAgICBjcHVLZXJuZWxJbXBsOiBhZGRJbXBsQ1BVXG59KTtcbnZhciBhZGRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQWRkLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGFkZEtlcm5lbEZ1bmNcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBBZGROUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBZGROUHJvZ3JhbShvdXRwdXRTaGFwZSwgc2hhcGVzKSB7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBzaGFwZXMubWFwKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBcIlRcIiArIGk7IH0pO1xuICAgICAgICB2YXIgc25pcHBldHMgPSBbXTtcbiAgICAgICAgLy8gR2V0IHRhcmdldCBlbGVtZW50cyBmcm9tIGV2ZXJ5IGlucHV0IHRlbnNvci5cbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICBzbmlwcGV0cy5wdXNoKFwiZmxvYXQgdlwiICsgdmFyaWFibGUgKyBcIiA9IGdldFwiICsgdmFyaWFibGUgKyBcIkF0T3V0Q29vcmRzKCk7XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzdW0gb2YgYWxsIGVsZW1lbnRzLlxuICAgICAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy52YXJpYWJsZU5hbWVzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwidlwiICsgdmFyaWFibGU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignICsgJyk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgc25pcHBldHMuam9pbignXFxuICAgICAgICAnKSArIFwiXFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSBcIiArIG9wZXJhdGlvbiArIFwiO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEFkZE5Qcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIEFkZE5QYWNrZWRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFkZE5QYWNrZWRQcm9ncmFtKG91dHB1dFNoYXBlLCBzaGFwZXMpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB0aGlzLnBhY2tlZElucHV0cyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFja2VkT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBzaGFwZXMubWFwKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBcIlRcIiArIGk7IH0pO1xuICAgICAgICB2YXIgc25pcHBldHMgPSBbXTtcbiAgICAgICAgLy8gR2V0IHRhcmdldCBlbGVtZW50cyBmcm9tIGV2ZXJ5IGlucHV0IHRlbnNvci5cbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICBzbmlwcGV0cy5wdXNoKFwidmVjNCB2XCIgKyB2YXJpYWJsZSArIFwiID0gZ2V0XCIgKyB2YXJpYWJsZSArIFwiQXRPdXRDb29yZHMoKTtcIik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHN1bSBvZiBhbGwgZWxlbWVudHMuXG4gICAgICAgIHZhciBvcGVyYXRpb24gPSB0aGlzLnZhcmlhYmxlTmFtZXNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ2XCIgKyB2YXJpYWJsZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcgKyAnKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBzbmlwcGV0cy5qb2luKCdcXG4gICAgICAgICcpICsgXCJcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gXCIgKyBvcGVyYXRpb24gKyBcIjtcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBBZGROUGFja2VkUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGFkZE4oYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgdGVuc29ycyA9IGlucHV0cztcbiAgICBpZiAodGVuc29ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KHsgaW5wdXRzOiB7IHg6IHRlbnNvcnNbMF0gfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB9XG4gICAgLy8gTGltaXQgdGhlIG51bWJlciBvZiB1cGxvYWRlZCB0ZXh0dXJlcyBmb3Igb3B0aW1pemF0aW9uLlxuICAgIGlmICh0ZW5zb3JzLmxlbmd0aCA+IHRmLmVudigpLmdldCgnV0VCR0xfTUFYX1RFWFRVUkVTX0lOX1NIQURFUicpKSB7XG4gICAgICAgIHZhciBtaWRJbmRleCA9IE1hdGguZmxvb3IodGVuc29ycy5sZW5ndGggLyAyKTtcbiAgICAgICAgdmFyIGxlZnRTaWRlID0gYWRkTih7IGlucHV0czogdGVuc29ycy5zbGljZSgwLCBtaWRJbmRleCksIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIHZhciByaWdodFNpZGUgPSBhZGROKHsgaW5wdXRzOiB0ZW5zb3JzLnNsaWNlKG1pZEluZGV4KSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgcmV0dXJuIGFkZE4oeyBpbnB1dHM6IFtsZWZ0U2lkZSwgcmlnaHRTaWRlXSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB9XG4gICAgdmFyIGR0eXBlID0gdGVuc29ycy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZHR5cGU7IH0pLnJlZHVjZShmdW5jdGlvbiAoZDEsIGQyKSB7IHJldHVybiB0Zi51cGNhc3RUeXBlKGQxLCBkMik7IH0pO1xuICAgIHZhciBzaGFwZXMgPSB0ZW5zb3JzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5zaGFwZTsgfSk7XG4gICAgLy8gV2UgY2FuIG1ha2Ugc3VyZSBzaGFwZXMgYXJlIGlkZW50aWNhbCBpbiBvcCBsZXZlbC5cbiAgICB2YXIgdXNlUGFja2VkT3AgPSB0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9QQUNLJyk7XG4gICAgdmFyIHByb2dyYW0gPSB1c2VQYWNrZWRPcCA/XG4gICAgICAgIG5ldyBBZGROUGFja2VkUHJvZ3JhbSh0ZW5zb3JzWzBdLnNoYXBlLCBzaGFwZXMpIDpcbiAgICAgICAgbmV3IEFkZE5Qcm9ncmFtKHRlbnNvcnNbMF0uc2hhcGUsIHNoYXBlcyk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIHRlbnNvcnMsIGR0eXBlKTtcbn1cbnZhciBhZGROQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkFkZE4sXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogYWRkTlxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gYWxsKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBheGlzID0gYXR0cnMuYXhpcywga2VlcERpbXMgPSBhdHRycy5rZWVwRGltcztcbiAgICB2YXIgeFJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgb3JpZ0F4ZXMgPSB0Zi51dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgIHZhciBheGVzID0gb3JpZ0F4ZXM7XG4gICAgdmFyIHBlcm11dGVkQXhlcyA9IHRmLmJhY2tlbmRfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeFJhbmspO1xuICAgIHZhciBwZXJtdXRlZFggPSB4O1xuICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICBwZXJtdXRlZFggPSB0cmFuc3Bvc2UoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBwZXJtOiBwZXJtdXRlZEF4ZXMgfSB9KTtcbiAgICAgICAgYXhlcyA9IHRmLmJhY2tlbmRfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCB4UmFuayk7XG4gICAgfVxuICAgIHRmLmJhY2tlbmRfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYWxsJywgYXhlcywgeFJhbmspO1xuICAgIHZhciBfYSA9IHRmLmJhY2tlbmRfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHBlcm11dGVkWC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgdmFyIGluU2l6ZSA9IHRmLnV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgdmFyIGEyRCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogcGVybXV0ZWRYIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBbLTEsIGluU2l6ZV0gfSB9KTtcbiAgICB2YXIgcmVkdWNlZCA9IHJlZHVjZShhMkQsIGEyRC5kdHlwZSwgJ2FsbCcsIGJhY2tlbmQpO1xuICAgIHZhciByZXM7XG4gICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IHRmLmJhY2tlbmRfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShvdXRTaGFwZSwgb3JpZ0F4ZXMpO1xuICAgICAgICByZXMgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHJlZHVjZWQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IG5ld1NoYXBlIH0gfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHJlZHVjZWQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IG91dFNoYXBlIH0gfSk7XG4gICAgfVxuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYTJEKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlZHVjZWQpO1xuICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHBlcm11dGVkWCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG52YXIgYWxsQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkFsbCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBhbGxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGFueShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgYXhpcyA9IGF0dHJzLmF4aXMsIGtlZXBEaW1zID0gYXR0cnMua2VlcERpbXM7XG4gICAgdmFyIHhSYW5rID0geC5zaGFwZS5sZW5ndGg7XG4gICAgdmFyIG9yaWdBeGVzID0gdGYudXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICB2YXIgYXhlcyA9IG9yaWdBeGVzO1xuICAgIHZhciBwZXJtdXRlZEF4ZXMgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHhSYW5rKTtcbiAgICB2YXIgcGVybXV0ZWRYID0geDtcbiAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgcGVybXV0ZWRYID0gdHJhbnNwb3NlKHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgcGVybTogcGVybXV0ZWRBeGVzIH0gfSk7XG4gICAgICAgIGF4ZXMgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeFJhbmspO1xuICAgIH1cbiAgICB0Zi5iYWNrZW5kX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ2FueScsIGF4ZXMsIHhSYW5rKTtcbiAgICB2YXIgX2EgPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhwZXJtdXRlZFguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgIHZhciBpblNpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgIHZhciBhMkQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHBlcm11dGVkWCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogWy0xLCBpblNpemVdIH0gfSk7XG4gICAgdmFyIHJlZHVjZWQgPSByZWR1Y2UoYTJELCBhMkQuZHR5cGUsICdhbnknLCBiYWNrZW5kKTtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSB0Zi5iYWNrZW5kX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ob3V0U2hhcGUsIG9yaWdBeGVzKTtcbiAgICAgICAgcmVzID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiByZWR1Y2VkIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBuZXdTaGFwZSB9IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiByZWR1Y2VkIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBvdXRTaGFwZSB9IH0pO1xuICAgIH1cbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGEyRCk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyZWR1Y2VkKTtcbiAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwZXJtdXRlZFgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxudmFyIGFueUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5BbnksXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogYW55XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgQXJnTWluTWF4UHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcmdNaW5NYXhQcm9ncmFtKHJlZHVjZUluZm8sIG9wLCBmaXJzdFBhc3MpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gcmVkdWNlSW5mby53aW5kb3dTaXplLCBiYXRjaFNpemUgPSByZWR1Y2VJbmZvLmJhdGNoU2l6ZSwgb3V0U2l6ZSA9IHJlZHVjZUluZm8ub3V0U2l6ZTtcbiAgICAgICAgaWYgKCFmaXJzdFBhc3MpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdiZXN0SW5kaWNlc0EnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0U2l6ZV07XG4gICAgICAgIHZhciBjb21wT3AgPSAob3AgPT09ICdtYXgnKSA/ICc+JyA6ICc8JztcbiAgICAgICAgdmFyIGluZGV4U25pcHBldCA9IGZpcnN0UGFzcyA/XG4gICAgICAgICAgICAnaW5PZmZzZXQgKyBpOycgOlxuICAgICAgICAgICAgJ3JvdW5kKGdldEJlc3RJbmRpY2VzQShiYXRjaCwgaW5PZmZzZXQgKyBpKSk7JztcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIgKyB3aW5kb3dTaXplICsgXCI7XFxuXFxuICAgICAgICBpbnQgYmVzdEluZGV4ID0gaW5PZmZzZXQ7XFxuICAgICAgICBmbG9hdCBiZXN0VmFsdWUgPSBnZXRBKGJhdGNoLCBiZXN0SW5kZXgpO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIHdpbmRvd1NpemUgKyBcIjsgaSsrKSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IFwiICsgaW5kZXhTbmlwcGV0ICsgXCI7XFxuICAgICAgICAgIGZsb2F0IGNhbmRpZGF0ZSA9IGdldEEoYmF0Y2gsIGluSWR4KTtcXG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSBcIiArIGNvbXBPcCArIFwiIGJlc3RWYWx1ZSkge1xcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IGNhbmRpZGF0ZTtcXG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpbklkeDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGJlc3RJbmRleCkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBBcmdNaW5NYXhQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIEFyZ01pbk1heFBhY2tlZFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJnTWluTWF4UGFja2VkUHJvZ3JhbShzaGFwZSwgd2luZG93U2l6ZSwgb3AsIGZpcnN0UGFzcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5wYWNrZWRJbnB1dHMgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhY2tlZE91dHB1dCA9IHRydWU7XG4gICAgICAgIHRmLnV0aWwuYXNzZXJ0KHNoYXBlLmxlbmd0aCA+IDIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiUGFja2VkIGFyZ1wiICsgKG9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgIG9wLnNsaWNlKDEpKSArIFwiIHN1cHBvcnRzIG9ubHkgaW5wdXRzIHdpdGggcmFuayBhYm92ZSAyLlwiOyB9KTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHNoYXBlW3NoYXBlLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgb3V0U2l6ZSA9IE1hdGguY2VpbChpblNpemUgLyB3aW5kb3dTaXplKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHNoYXBlLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgaWYgKG91dFNpemUgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFNoYXBlLnB1c2gob3V0U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaXJzdFBhc3MpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdiZXN0SW5kaWNlc0EnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0U2hhcGUgPSB0aGlzLm91dHB1dFNoYXBlO1xuICAgICAgICB2YXIgcmFuayA9IG91dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgICAgIHZhciBjb29yZHMgPSBnZXRDaGFubmVscygnY29vcmRzJywgcmFuayk7XG4gICAgICAgIHZhciBzb3VyY2VMb2NTZXR1cDtcbiAgICAgICAgdmFyIHNvdXJjZVJhbms7XG4gICAgICAgIGlmIChvdXRTaXplID09PSAxKSB7XG4gICAgICAgICAgICBzb3VyY2VSYW5rID0gcmFuayArIDE7XG4gICAgICAgICAgICB2YXIgc291cmNlTG9jRFR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShzb3VyY2VSYW5rKTtcbiAgICAgICAgICAgIHNvdXJjZUxvY1NldHVwID0gXCJcXG4gICAgICAgIFwiICsgc291cmNlTG9jRFR5cGUgKyBcIiBzb3VyY2VMb2NSID0gXCIgKyBzb3VyY2VMb2NEVHlwZSArIFwiKFwiICsgY29vcmRzLmpvaW4oKSArIFwiLCAwKTtcXG4gICAgICAgICsrXCIgKyBjb29yZHNbcmFuayAtIDFdICsgXCI7XFxuICAgICAgICBcIiArIHNvdXJjZUxvY0RUeXBlICsgXCIgc291cmNlTG9jRyA9IFwiICsgc291cmNlTG9jRFR5cGUgKyBcIihcIiArIGNvb3Jkcy5qb2luKCkgKyBcIiwgMCk7XFxuICAgICAgICArK1wiICsgY29vcmRzW3JhbmsgLSAyXSArIFwiO1xcbiAgICAgICAgXCIgKyBzb3VyY2VMb2NEVHlwZSArIFwiIHNvdXJjZUxvY0EgPSBcIiArIHNvdXJjZUxvY0RUeXBlICsgXCIoXCIgKyBjb29yZHMuam9pbigpICsgXCIsIDApO1xcbiAgICAgICAgLS1cIiArIGNvb3Jkc1tyYW5rIC0gMV0gKyBcIjtcXG4gICAgICAgIFwiICsgc291cmNlTG9jRFR5cGUgKyBcIiBzb3VyY2VMb2NCID0gXCIgKyBzb3VyY2VMb2NEVHlwZSArIFwiKFwiICsgY29vcmRzLmpvaW4oKSArIFwiLCAwKTtcXG4gICAgICAgIC0tXCIgKyBjb29yZHNbcmFuayAtIDJdICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VSYW5rID0gcmFuaztcbiAgICAgICAgICAgIHNvdXJjZUxvY1NldHVwID0gXCJcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBzb3VyY2VMb2NSID0gY29vcmRzO1xcbiAgICAgICAgKytcIiArIGNvb3Jkc1tyYW5rIC0gMV0gKyBcIjtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBzb3VyY2VMb2NHID0gY29vcmRzO1xcbiAgICAgICAgKytcIiArIGNvb3Jkc1tyYW5rIC0gMl0gKyBcIjtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBzb3VyY2VMb2NBID0gY29vcmRzO1xcbiAgICAgICAgLS1cIiArIGNvb3Jkc1tyYW5rIC0gMV0gKyBcIjtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBzb3VyY2VMb2NCID0gY29vcmRzO1xcbiAgICAgICAgLS1cIiArIGNvb3Jkc1tyYW5rIC0gMl0gKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbm5lbHMgPSBbJ3gnLCAneScsICd6JywgJ3cnLCAndScsICd2J10uc2xpY2UoMCwgc291cmNlUmFuayk7XG4gICAgICAgIHZhciBpbkNoYW5uZWwgPSAnLicgKyBjaGFubmVsc1tzb3VyY2VSYW5rIC0gMV07IC8vIGUuZy4gXCIuYlwiIGZvciByYW5rIDMuXG4gICAgICAgIHZhciBpbnRDaGFubmVscyA9IGNoYW5uZWxzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gJ2ludCAnICsgeDsgfSk7XG4gICAgICAgIHZhciBzcmNSQ29vcmRzID0gZ2V0Q2hhbm5lbHMoJ3NvdXJjZUxvY1InLCBzb3VyY2VSYW5rIC0gMSkuY29uY2F0KCdpbklkeC5yJyk7XG4gICAgICAgIHZhciBzcmNHQ29vcmRzID0gZ2V0Q2hhbm5lbHMoJ3NvdXJjZUxvY0cnLCBzb3VyY2VSYW5rIC0gMSkuY29uY2F0KCdpbklkeC5nJyk7XG4gICAgICAgIHZhciBzcmNCQ29vcmRzID0gZ2V0Q2hhbm5lbHMoJ3NvdXJjZUxvY0InLCBzb3VyY2VSYW5rIC0gMSkuY29uY2F0KCdpbklkeC5iJyk7XG4gICAgICAgIHZhciBzcmNBQ29vcmRzID0gZ2V0Q2hhbm5lbHMoJ3NvdXJjZUxvY0EnLCBzb3VyY2VSYW5rIC0gMSkuY29uY2F0KCdpbklkeC5hJyk7XG4gICAgICAgIHZhciBjb21wT3AgPSAob3AgPT09ICdtYXgnKSA/ICdncmVhdGVyVGhhbicgOiAnbGVzc1RoYW4nO1xuICAgICAgICB2YXIgZmV0Y2hDYW5kaWRhdGVJZHggPSBmaXJzdFBhc3MgPyAnJyA6IFwiXFxuICAgICAgICAgIGluSWR4ID0gcm91bmQodmVjNChnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiICsgc3JjUkNvb3Jkcy5qb2luKCkgKyBcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiICsgc3JjR0Nvb3Jkcy5qb2luKCkgKyBcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiICsgc3JjQkNvb3Jkcy5qb2luKCkgKyBcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiICsgc3JjQUNvb3Jkcy5qb2luKCkgKyBcIikpKTtcIjtcbiAgICAgICAgdmFyIGZldGNoVmFsdWUgPSBcInZlYzQoXFxuICAgICAgICAgICAgZ2V0QUNoYW5uZWwoXCIgKyBzcmNSQ29vcmRzLmpvaW4oKSArIFwiKSxcXG4gICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QUNoYW5uZWwoXCIgKyBzcmNHQ29vcmRzLmpvaW4oKSArIFwiKSA6IDAuLFxcbiAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBQ2hhbm5lbChcIiArIHNyY0JDb29yZHMuam9pbigpICsgXCIpIDogMC4sXFxuICAgICAgICAgICAgaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sID8gZ2V0QUNoYW5uZWwoXCIgKyBzcmNBQ29vcmRzLmpvaW4oKSArIFwiKSA6IDAuKVwiO1xuICAgICAgICB2YXIgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbFNuaXBwZXQgPSBmaXJzdFBhc3MgPyAnJyA6IFwiXFxuICAgICAgZmxvYXQgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIiArIGludENoYW5uZWxzLmpvaW4oKSArIFwiKSB7XFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRCZXN0SW5kaWNlc0EoXCIgKyBjaGFubmVscy5qb2luKCkgKyBcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIGNoYW5uZWxzLnNsaWNlKC0yKS5qb2luKCkgKyBcIikpO1xcbiAgICAgIH1cIjtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgZmxvYXQgZ2V0QUNoYW5uZWwoXCIgKyBpbnRDaGFubmVscy5qb2luKCkgKyBcIikge1xcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QShcIiArIGNoYW5uZWxzLmpvaW4oKSArIFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIGNoYW5uZWxzLnNsaWNlKC0yKS5qb2luKCkgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgICBcIiArIGdldEJlc3RJbmRpY2VzQUNoYW5uZWxTbmlwcGV0ICsgXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBcIiArIGNvb3Jkc1tyYW5rIC0gMV0gKyBcIiA8IFwiICsgKG91dFNoYXBlW3JhbmsgLSAxXSAtIDEpICsgXCI7XFxuICAgICAgICBib29sIGhhc05leHRSb3cgPSBcIiArIGNvb3Jkc1tyYW5rIC0gMl0gKyBcIiA8IFwiICsgKG91dFNoYXBlW3JhbmsgLSAyXSAtIDEpICsgXCI7XFxuICAgICAgICBcIiArIHNvdXJjZUxvY1NldHVwICsgXCJcXG4gICAgICAgIGl2ZWM0IHNyY0lkeCA9IGl2ZWM0KHNvdXJjZUxvY1JcIiArIGluQ2hhbm5lbCArIFwiLCBzb3VyY2VMb2NHXCIgKyBpbkNoYW5uZWwgKyBcIixcXG4gICAgICAgICAgc291cmNlTG9jQlwiICsgaW5DaGFubmVsICsgXCIsIHNvdXJjZUxvY0FcIiArIGluQ2hhbm5lbCArIFwiKSAqIFwiICsgd2luZG93U2l6ZSArIFwiO1xcbiAgICAgICAgaXZlYzQgaW5JZHggPSBzcmNJZHg7XFxuICAgICAgICB2ZWM0IGJlc3RJbmRleCA9IHZlYzQoaW5JZHgpO1xcbiAgICAgICAgdmVjNCBiZXN0VmFsdWUgPSBcIiArIGZldGNoVmFsdWUgKyBcIjtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyB3aW5kb3dTaXplICsgXCI7IGkrKykge1xcbiAgICAgICAgICBpbklkeCA9IHNyY0lkeDtcXG4gICAgICAgICAgXCIgKyBmZXRjaENhbmRpZGF0ZUlkeCArIFwiXFxuICAgICAgICAgIHZlYzQgY2FuZGlkYXRlID0gXCIgKyBmZXRjaFZhbHVlICsgXCI7XFxuICAgICAgICAgIGJ2ZWM0IG5hbiA9IGlzbmFuKGNhbmRpZGF0ZSk7XFxuICAgICAgICAgIGJ2ZWM0IHJlcGxhY2UgPSBidmVjNChcXG4gICAgICAgICAgICB2ZWM0KFwiICsgY29tcE9wICsgXCIoY2FuZGlkYXRlLCBiZXN0VmFsdWUpKSAqICh2ZWM0KDEuMCkgLSB2ZWM0KG5hbikpKTtcXG5cXG4gICAgICAgICAgYmVzdFZhbHVlID0gdmVjNChyZXBsYWNlLnggID8gY2FuZGlkYXRlLnggOiBiZXN0VmFsdWUueCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLnkgID8gY2FuZGlkYXRlLnkgOiBiZXN0VmFsdWUueSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLnogID8gY2FuZGlkYXRlLnogOiBiZXN0VmFsdWUueixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLncgID8gY2FuZGlkYXRlLncgOiBiZXN0VmFsdWUudyk7XFxuICAgICAgICAgIGJlc3RJbmRleCA9IG1peChiZXN0SW5kZXgsIHZlYzQoaW5JZHgpLCB2ZWM0KHJlcGxhY2UpKTtcXG4gICAgICAgICAgc3JjSWR4Kys7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoYmVzdEluZGV4KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQXJnTWluTWF4UGFja2VkUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGFyZ1JlZHVjZShiYWNrZW5kLCB4LCByZWR1Y2VUeXBlLCBiZXN0SW5kaWNlc0EpIHtcbiAgICBpZiAoYmVzdEluZGljZXNBID09PSB2b2lkIDApIHsgYmVzdEluZGljZXNBID0gbnVsbDsgfVxuICAgIHZhciBiYXRjaFNpemUgPSB4LnNoYXBlWzBdO1xuICAgIHZhciBpblNpemUgPSB4LnNoYXBlWzFdO1xuICAgIGlmIChiZXN0SW5kaWNlc0EgIT0gbnVsbCkge1xuICAgICAgICBiYXRjaFNpemUgPSBiZXN0SW5kaWNlc0Euc2hhcGVbMF07XG4gICAgICAgIGluU2l6ZSA9IGJlc3RJbmRpY2VzQS5zaGFwZVsxXTtcbiAgICB9XG4gICAgdmFyIHdpbmRvd1NpemUgPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKGluU2l6ZSk7XG4gICAgdmFyIHJlZHVjZUluZm8gPSB7IHdpbmRvd1NpemU6IHdpbmRvd1NpemUsIGluU2l6ZTogaW5TaXplLCBiYXRjaFNpemU6IGJhdGNoU2l6ZSwgb3V0U2l6ZTogTWF0aC5jZWlsKGluU2l6ZSAvIHdpbmRvd1NpemUpIH07XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgQXJnTWluTWF4UHJvZ3JhbShyZWR1Y2VJbmZvLCByZWR1Y2VUeXBlLCBiZXN0SW5kaWNlc0EgPT0gbnVsbCk7XG4gICAgdmFyIGlucHV0cyA9IFt4XTtcbiAgICBpZiAoYmVzdEluZGljZXNBICE9IG51bGwpIHtcbiAgICAgICAgaW5wdXRzLnB1c2goYmVzdEluZGljZXNBKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIGlucHV0cywgJ2ludDMyJyk7XG4gICAgLy8gTm8gbmVlZCB0byBydW4gYW5vdGhlciBHUEdQVSBwcm9ncmFtLlxuICAgIGlmIChvdXRwdXQuc2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGFyZ1JlZHVjZShiYWNrZW5kLCB4LCByZWR1Y2VUeXBlLCBvdXRwdXQpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ob3V0cHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXJnUmVkdWNlUGFja2VkKGJhY2tlbmQsIHgsIHJlZHVjZVR5cGUsIGJlc3RJbmRpY2VzQSkge1xuICAgIGlmIChiZXN0SW5kaWNlc0EgPT09IHZvaWQgMCkgeyBiZXN0SW5kaWNlc0EgPSBudWxsOyB9XG4gICAgdmFyIGluU2hhcGUgPSBiZXN0SW5kaWNlc0EgIT0gbnVsbCA/IGJlc3RJbmRpY2VzQS5zaGFwZSA6IHguc2hhcGU7XG4gICAgdmFyIGluU2l6ZSA9IGluU2hhcGVbaW5TaGFwZS5sZW5ndGggLSAxXTtcbiAgICB2YXIgd2luZG93U2l6ZSA9IHRmLmJhY2tlbmRfdXRpbC5jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUoaW5TaXplKTtcbiAgICB2YXIgcHJvZ3JhbSA9IG5ldyBBcmdNaW5NYXhQYWNrZWRQcm9ncmFtKGluU2hhcGUsIHdpbmRvd1NpemUsIHJlZHVjZVR5cGUsIGJlc3RJbmRpY2VzQSA9PSBudWxsKTtcbiAgICB2YXIgaW5wdXRzID0gYmVzdEluZGljZXNBID09IG51bGwgPyBbeF0gOiBbeCwgYmVzdEluZGljZXNBXTtcbiAgICB2YXIgb3V0cHV0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgaW5wdXRzLCAnaW50MzInKTtcbiAgICBpZiAob3V0cHV0LnNoYXBlLmxlbmd0aCA9PT0geC5zaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFyZ1JlZHVjZVBhY2tlZChiYWNrZW5kLCB4LCByZWR1Y2VUeXBlLCBvdXRwdXQpO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG91dHB1dCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBhcmdNaW5NYXhSZWR1Y2UoYmFja2VuZCwgeCwgYXhpcywgcmVkdWNlVHlwZSkge1xuICAgIHZhciBheGVzID0gW2F4aXNdO1xuICAgIHRmLmJhY2tlbmRfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnJyArIHJlZHVjZVR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyByZWR1Y2VUeXBlLnNsaWNlKDEpLCBheGVzLCB4LnNoYXBlLmxlbmd0aCk7XG4gICAgaWYgKCF0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9QQUNLX1JFRFVDRScpIHx8IHguc2hhcGUubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgdmFyIGludGVybWVkaWF0ZVRlbnNvckluZm9zID0gW107XG4gICAgICAgIHZhciBfYSA9IHRmLmJhY2tlbmRfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogWy0xLCBpblNpemVdIH0gfSk7XG4gICAgICAgIGludGVybWVkaWF0ZVRlbnNvckluZm9zLnB1c2goYTJEKTtcbiAgICAgICAgdmFyIHJlZHVjZWQgPSBhcmdSZWR1Y2UoYmFja2VuZCwgYTJELCByZWR1Y2VUeXBlKTtcbiAgICAgICAgaW50ZXJtZWRpYXRlVGVuc29ySW5mb3MucHVzaChyZWR1Y2VkKTtcbiAgICAgICAgdmFyIHJlc2hhcGVkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiByZWR1Y2VkIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBvdXRTaGFwZSB9IH0pO1xuICAgICAgICBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IHJldHVybiBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc2hhcGVkO1xuICAgIH1cbiAgICByZXR1cm4gYXJnUmVkdWNlUGFja2VkKGJhY2tlbmQsIHgsIHJlZHVjZVR5cGUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBhcmdNYXgoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGF4aXMgPSBhdHRycy5heGlzO1xuICAgIHZhciBheGVzID0gdGYudXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICB2YXIgcGVybXV0ZWRBeGVzID0gdGYuYmFja2VuZF91dGlsLmdldEF4ZXNQZXJtdXRhdGlvbihheGVzLCB4LnNoYXBlLmxlbmd0aCk7XG4gICAgdmFyICR4ID0geDtcbiAgICB2YXIgaW50ZXJtZWRpYXRlVGVuc29ySW5mb3MgPSBbXTtcbiAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgJHggPSB0cmFuc3Bvc2UoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBwZXJtOiBwZXJtdXRlZEF4ZXMgfSB9KTtcbiAgICAgICAgaW50ZXJtZWRpYXRlVGVuc29ySW5mb3MucHVzaCgkeCk7XG4gICAgICAgIGF4ZXMgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgJHguc2hhcGUubGVuZ3RoKTtcbiAgICB9XG4gICAgdGYuYmFja2VuZF91dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdhcmdNYXgnLCBbYXhlc1swXV0sICR4LnNoYXBlLmxlbmd0aCk7XG4gICAgdmFyIG91dCA9IGFyZ01pbk1heFJlZHVjZShiYWNrZW5kLCAkeCwgYXhlc1swXSwgJ21heCcpO1xuICAgIGludGVybWVkaWF0ZVRlbnNvckluZm9zLmZvckVhY2goZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odCk7IH0pO1xuICAgIHJldHVybiBvdXQ7XG59XG52YXIgYXJnTWF4Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkFyZ01heCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBhcmdNYXhcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGFyZ01pbihhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgYXhpcyA9IGF0dHJzLmF4aXM7XG4gICAgdmFyIGF4ZXMgPSB0Zi51dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgIHZhciBwZXJtdXRlZEF4ZXMgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHguc2hhcGUubGVuZ3RoKTtcbiAgICB2YXIgJHggPSB4O1xuICAgIHZhciBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcyA9IFtdO1xuICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAkeCA9IHRyYW5zcG9zZSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHBlcm06IHBlcm11dGVkQXhlcyB9IH0pO1xuICAgICAgICBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcy5wdXNoKCR4KTtcbiAgICAgICAgYXhlcyA9IHRmLmJhY2tlbmRfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCAkeC5zaGFwZS5sZW5ndGgpO1xuICAgIH1cbiAgICB0Zi5iYWNrZW5kX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ2FyZ01pbicsIFtheGVzWzBdXSwgJHguc2hhcGUubGVuZ3RoKTtcbiAgICB2YXIgb3V0ID0gYXJnTWluTWF4UmVkdWNlKGJhY2tlbmQsICR4LCBheGVzWzBdLCAnbWluJyk7XG4gICAgaW50ZXJtZWRpYXRlVGVuc29ySW5mb3MuZm9yRWFjaChmdW5jdGlvbiAodCkgeyByZXR1cm4gYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh0KTsgfSk7XG4gICAgcmV0dXJuIG91dDtcbn1cbnZhciBhcmdNaW5Db25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQXJnTWluLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGFyZ01pblxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIEFTSU4gPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICBpZiAoYWJzKHgpID4gMS4pIHtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG4gIHJldHVybiBhc2luKHgpO1xcblwiO1xudmFyIGFzaW4gPSB1bmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IEFTSU4gfSk7XG52YXIgYXNpbkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5Bc2luLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGFzaW4sXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgQVNJTkggPSBDSEVDS19OQU5fU05JUFBFVCArIFwicmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEuMCkpO1wiO1xudmFyIGFzaW5oID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBBU0lOSCB9KTtcbnZhciBhc2luaENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5Bc2luaCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBhc2luaCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBBVEFOID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGF0YW4oeCk7XFxuXCI7XG52YXIgYXRhbiA9IHVuYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogQVRBTiB9KTtcbnZhciBhdGFuQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkF0YW4sXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogYXRhbixcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBBVEFOMiA9IENIRUNLX05BTl9TTklQUEVUX0JJTkFSWSArIFwiXFxuICByZXR1cm4gYXRhbihhLCBiKTtcXG5cIjtcbnZhciBBVEFOMl9QQUNLRUQgPSBcIlxcbiAgdmVjNCByZXN1bHQgPSBhdGFuKGEsIGIpO1xcbiAgdmVjNCBpc05hTiA9IG1pbih2ZWM0KGlzbmFuKGEpKSArIHZlYzQoaXNuYW4oYikpLCB2ZWM0KDEuMCkpO1xcbiAgXCIgK1xuICAgIENIRUNLX05BTl9TTklQUEVUX0JJTkFSWV9QQUNLRUQgKyBcIlxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIjtcbnZhciBhdGFuMiA9IGJpbmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IEFUQU4yLCBwYWNrZWRPcFNuaXBwZXQ6IEFUQU4yX1BBQ0tFRCB9KTtcbnZhciBhdGFuMkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5BdGFuMixcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBhdGFuMixcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBBVEFOSCA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIGlmICgoeCA8IC0xLjApIHx8ICh4ID4gMS4wKSkgcmV0dXJuIE5BTjtcXG5yZXR1cm4gKGxvZygxLjAgKyB4KSAtIGxvZygxLjAgLSB4KSkgLyAyLjA7XCI7XG52YXIgYXRhbmggPSB1bmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IEFUQU5IIH0pO1xudmFyIGF0YW5oQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkF0YW5oLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGF0YW5oLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFBvb2wyRFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9vbDJEUHJvZ3JhbShjb252SW5mbywgcG9vbFR5cGUsIGNvbXB1dGVQb3NpdGlvbnMsIGZsYXR0ZW5Qb3NpdGlvbnMsIGluY2x1ZGVCYXRjaEluSW5kZXgpIHtcbiAgICAgICAgaWYgKGZsYXR0ZW5Qb3NpdGlvbnMgPT09IHZvaWQgMCkgeyBmbGF0dGVuUG9zaXRpb25zID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGluY2x1ZGVCYXRjaEluSW5kZXggPT09IHZvaWQgMCkgeyBpbmNsdWRlQmF0Y2hJbkluZGV4ID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycgJiYgY29tcHV0ZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBwb3NpdGlvbnMgZm9yIGF2ZXJhZ2UgcG9vbC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgICAgIHZhciBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBlZmZlY3RpdmVGaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgICAgIHZhciBpc0F2Z1Bvb2wgPSBwb29sVHlwZSA9PT0gJ2F2Zyc7XG4gICAgICAgIHZhciBiYXRjaEZsYXR0ZW5Qb3NpdGlvblN0ciA9IFwiKChiYXRjaCAgKiBcIiArIGNvbnZJbmZvLmluSGVpZ2h0ICsgXCIgKyB4UikgKiBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIiArIHhDKSAqIFwiICsgY29udkluZm8uaW5DaGFubmVscyArIFwiICsgZFwiO1xuICAgICAgICB2YXIgZmxhdHRlblBvc2l0aW9uU3RyID0gXCIoeFIgKiBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIiArIHhDKSAqIFwiICsgY29udkluZm8uaW5DaGFubmVscyArIFwiICsgZFwiO1xuICAgICAgICB2YXIgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICcwLjAnO1xuICAgICAgICBpZiAoIWlzQXZnUG9vbCkge1xuICAgICAgICAgICAgLy8gV2ViR0wgb24gRmlyZWZveCBMaW51eCBjYW4ndCBjb21waWxlIDEvMCBzbyB3ZSBkbyAxL2Vwcy5cbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnLTEuMCAvIDFlLTIwJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHV0ZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgdmFyIGNvbXBhcmVPcF8xID0gJz49JztcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xcbiAgICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ICsgXCI7XFxuICAgICAgICAgICAgICB3UiArPSBcIiArIGRpbGF0aW9uSGVpZ2h0ICsgXCIpIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyBjb252SW5mby5pbkhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZWZmZWN0aXZlRmlsdGVyV2lkdGggKyBcIjtcXG4gICAgICAgICAgICAgICAgd0MgKz0gXCIgKyBkaWxhdGlvbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgY29udkluZm8uaW5XaWR0aCArIFwiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcblxcbiAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXFxuICAgICAgICAgICAgICAvLyB1c2UgdGhlIGN1cnJlbnQgdmFsdWUuXFxuICAgICAgICAgICAgICBmbG9hdCBjdXJyTWluTWF4VmFsdWUgPSBtaXgoXFxuICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSBcIiArIGNvbXBhcmVPcF8xICsgXCIgY3Vyck1pbk1heFZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlRm91bmQgPSAxLjA7XFxuICAgICAgICAgICAgICAgIG1pbk1heFBvc2l0aW9uID0gXCIgKyAoZmxhdHRlblBvc2l0aW9ucyA/IChpbmNsdWRlQmF0Y2hJbkluZGV4ID8gYmF0Y2hGbGF0dGVuUG9zaXRpb25TdHIgOlxuICAgICAgICAgICAgICAgIGZsYXR0ZW5Qb3NpdGlvblN0cikgOlxuICAgICAgICAgICAgICAgIFwid1IgKiBcIiArIGVmZmVjdGl2ZUZpbHRlcldpZHRoICsgXCIgKyB3Q1wiKSArIFwiO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQobWluTWF4UG9zaXRpb24pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGFyZU9wID0gJ21heCc7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHBvb2xUeXBlICsgXCIoXCIgKyBwb29sVHlwZSArIFwiKFwiICsgcG9vbFR5cGUgKyBcIihcIiArXG4gICAgICAgICAgICAnbWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSknO1xuICAgICAgICBpZiAocG9vbFR5cGUgPT09ICdhdmcnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IFwiYXZnVmFsdWUgLyBjb3VudFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aE5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihmaWx0ZXJXaWR0aCAvIDQpICogNDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9IGZpbHRlcldpZHRoICUgNDtcbiAgICAgICAgdmFyIHVwZGF0ZVNuaXBwZXQgPSBcIlxcbiAgICAgIGlmIChcIiArIGlzQXZnUG9vbCArIFwiKSB7XFxuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBcIiArIGNvbXBhcmVPcCArIFwiKHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBjb3VudCA9IDAuMDtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCB4UiwgaW50IHhDLCBpbnQgZCkge1xcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvdW50ICs9IDEuMDtcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCIpO1xcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuICAgICAgICBjb3VudCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGVmZmVjdGl2ZUZpbHRlckhlaWdodCArIFwiO1xcbiAgICAgICAgICAgIHdSICs9IFwiICsgZGlsYXRpb25IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoTmVhcmVzdFZlYzQgKyBcIjsgd0MgKz0gNCkge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIiArIGRpbGF0aW9uV2lkdGggKyBcIjtcXG5cXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyBcIiArIGRpbGF0aW9uV2lkdGggKyBcIiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiAqIFwiICsgZGlsYXRpb25XaWR0aCArIFwiLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAzICogXCIgKyBkaWxhdGlvbldpZHRoICsgXCIsIGQpXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgXCIgKyBmaWx0ZXJXaWR0aE5lYXJlc3RWZWM0ICsgXCI7XFxuICAgICAgICAgIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyBcIiArIGRpbGF0aW9uV2lkdGggKyBcIiwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyBcIiArIGRpbGF0aW9uV2lkdGggKyBcIiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiAqIFwiICsgZGlsYXRpb25XaWR0aCArIFwiLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIiArIHJldHVyblZhbHVlICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBQb29sMkRQcm9ncmFtO1xufSgpKTtcbnZhciBQb29sM0RQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvb2wzRFByb2dyYW0oY29udkluZm8sIHBvb2xUeXBlLCBjb21wdXRlUG9zaXRpb25zLCBmbGF0dGVuUG9zaXRpb25zLCBpbmNsdWRlQmF0Y2hJbkluZGV4KSB7XG4gICAgICAgIGlmIChmbGF0dGVuUG9zaXRpb25zID09PSB2b2lkIDApIHsgZmxhdHRlblBvc2l0aW9ucyA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChpbmNsdWRlQmF0Y2hJbkluZGV4ID09PSB2b2lkIDApIHsgaW5jbHVkZUJhdGNoSW5JbmRleCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICBpZiAocG9vbFR5cGUgPT09ICdhdmcnICYmIGNvbXB1dGVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVEZXB0aCA9IGNvbnZJbmZvLnN0cmlkZURlcHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGRpbGF0aW9uRGVwdGggPSBjb252SW5mby5kaWxhdGlvbkRlcHRoO1xuICAgICAgICB2YXIgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodDtcbiAgICAgICAgdmFyIGRpbGF0aW9uV2lkdGggPSBjb252SW5mby5kaWxhdGlvbldpZHRoO1xuICAgICAgICB2YXIgZWZmZWN0aXZlRmlsdGVyRGVwdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJEZXB0aDtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUZpbHRlcldpZHRoID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBwYWRGcm9udCA9IGNvbnZJbmZvLnBhZEluZm8uZnJvbnQ7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIGlzQXZnUG9vbCA9IHBvb2xUeXBlID09PSAnYXZnJztcbiAgICAgICAgdmFyIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMC4wJztcbiAgICAgICAgaWYgKCFpc0F2Z1Bvb2wpIHtcbiAgICAgICAgICAgIC8vIFdlYkdMIG9uIEZpcmVmb3ggTGludXggY2FuJ3QgY29tcGlsZSAxLzAgc28gd2UgZG8gMS9lcHMuXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJy0xLjAgLyAxZS0yMCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXB1dGVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBjb21wYXJlT3BfMiA9ICc+PSc7XG4gICAgICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICAgIGNvbnN0IGl2ZWMzIHN0cmlkZXMgPVxcbiAgICAgICAgICAgIGl2ZWMzKFwiICsgc3RyaWRlRGVwdGggKyBcIiwgXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiwgXCIgKyBzdHJpZGVXaWR0aCArIFwiKTtcXG4gICAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIiArIHBhZEZyb250ICsgXCIsIFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgICBpbnQgY2ggPSBjb29yZHMudTtcXG5cXG4gICAgICAgICAgaXZlYzMgeENvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4RENvcm5lciA9IHhDb3JuZXIueDtcXG4gICAgICAgICAgaW50IHhSQ29ybmVyID0geENvcm5lci55O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4Q29ybmVyLno7XFxuXFxuICAgICAgICAgIC8vIG1heC9taW4geCg/LCA/LCA/LCBjaCkgdG8gZ2V0IHkoeUQsIHlSLCB5QywgY2gpLlxcbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZSA9IDAuMDtcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWVGb3VuZCA9IDAuMDtcXG4gICAgICAgICAgaW50IG1pbk1heFBvc2l0aW9uID0gMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0QgPSAwOyB3RCA8IFwiICsgZWZmZWN0aXZlRmlsdGVyRGVwdGggKyBcIjtcXG4gICAgICAgICAgICAgIHdEICs9IFwiICsgZGlsYXRpb25EZXB0aCArIFwiKSB7XFxuICAgICAgICAgICAgaW50IHhEID0geERDb3JuZXIgKyB3RDtcXG5cXG4gICAgICAgICAgICBpZiAoeEQgPCAwIHx8IHhEID49IFwiICsgY29udkluZm8uaW5EZXB0aCArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ICsgXCI7XFxuICAgICAgICAgICAgICAgIHdSICs9IFwiICsgZGlsYXRpb25IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyBjb252SW5mby5pbkhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZWZmZWN0aXZlRmlsdGVyV2lkdGggKyBcIjtcXG4gICAgICAgICAgICAgICAgICB3QyArPSBcIiArIGRpbGF0aW9uV2lkdGggKyBcIikge1xcbiAgICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgY29udkluZm8uaW5XaWR0aCArIFwiKSB7XFxuICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRYKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIGN1cnJlbnQgdmFsdWUuXFxuICAgICAgICAgICAgICAgIGZsb2F0IGN1cnJNaW5NYXhWYWx1ZSA9IG1peChcXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBcIiArIGNvbXBhcmVPcF8yICsgXCIgY3Vyck1pbk1heFZhbHVlKSB7XFxuICAgICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZUZvdW5kID0gMS4wO1xcbiAgICAgICAgICAgICAgICAgIG1pbk1heFBvc2l0aW9uID0gXCIgKyAoZmxhdHRlblBvc2l0aW9ucyA/XG4gICAgICAgICAgICAgICAgKGluY2x1ZGVCYXRjaEluSW5kZXggP1xuICAgICAgICAgICAgICAgICAgICBcIigoKGJhdGNoICogXCIgKyBjb252SW5mby5pbkRlcHRoICsgXCIgKyB4RCkgKiBcIiArIGNvbnZJbmZvLmluSGVpZ2h0ICsgXCIgKyB4UikgKiBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIiArIHhDKSAqIFwiICsgY29udkluZm8uaW5DaGFubmVscyArIFwiICsgY2hcIiA6XG4gICAgICAgICAgICAgICAgICAgIFwiKCh4RCAqIFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIiArIHhSKSAqIFwiICsgY29udkluZm8uaW5XaWR0aCArIFwiICsgeEMpICogXCIgKyBjb252SW5mby5pbkNoYW5uZWxzICsgXCIgKyBjaFwiKSA6XG4gICAgICAgICAgICAgICAgXCJ3RCAqIFwiICsgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ICsgXCIgKiBcIiArIGVmZmVjdGl2ZUZpbHRlcldpZHRoICsgXCIgK1xcbiAgICAgICAgICAgICAgICAgICAgICB3UiAqIFwiICsgZWZmZWN0aXZlRmlsdGVyV2lkdGggKyBcIiArIHdDXCIpICsgXCI7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KG1pbk1heFBvc2l0aW9uKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBhcmVPcCA9ICdtYXgnO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBwb29sVHlwZSArIFwiKFwiICsgcG9vbFR5cGUgKyBcIihcIiArIHBvb2xUeXBlICsgXCIoXCIgK1xuICAgICAgICAgICAgJ21pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pJztcbiAgICAgICAgaWYgKHBvb2xUeXBlID09PSAnYXZnJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBcImF2Z1ZhbHVlIC8gY291bnRcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3IoZmlsdGVyV2lkdGggLyA0KSAqIDQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPSBmaWx0ZXJXaWR0aCAlIDQ7XG4gICAgICAgIHZhciB1cGRhdGVTbmlwcGV0ID0gXCJcXG4gICAgICBpZiAoXCIgKyBpc0F2Z1Bvb2wgKyBcIikge1xcbiAgICAgICAgYXZnVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1pbk1heFZhbHVlID0gXCIgKyBjb21wYXJlT3AgKyBcIih2YWx1ZXMsIG1pbk1heFZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMyBzdHJpZGVzID1cXG4gICAgICAgIGl2ZWMzKFwiICsgc3RyaWRlRGVwdGggKyBcIiwgXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiwgXCIgKyBzdHJpZGVXaWR0aCArIFwiKTtcXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIgKyBwYWRGcm9udCArIFwiLCBcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBjb3VudCA9IDAuMDtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCB4RCwgaW50IHhSLCBpbnQgeEMsIGludCBjaCkge1xcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvdW50ICs9IDEuMDtcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgY2ggPSBjb29yZHMudTtcXG5cXG4gICAgICAgIGl2ZWMzIHhDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhEQ29ybmVyID0geENvcm5lci54O1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geENvcm5lci55O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geENvcm5lci56O1xcblxcbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sID8sIGQpIHRvIGdldCB5KHlELCB5UiwgeUMsIGNoKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIiArIGluaXRpYWxpemF0aW9uVmFsdWUgKyBcIik7XFxuICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG4gICAgICAgIGNvdW50ID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd0QgPSAwOyB3RCA8IFwiICsgZWZmZWN0aXZlRmlsdGVyRGVwdGggKyBcIjtcXG4gICAgICAgICAgICB3RCArPSBcIiArIGRpbGF0aW9uRGVwdGggKyBcIikge1xcbiAgICAgICAgICBpbnQgeEQgPSB4RENvcm5lciArIHdEO1xcblxcbiAgICAgICAgICBpZiAoeEQgPCAwIHx8IHhEID49IFwiICsgY29udkluZm8uaW5EZXB0aCArIFwiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ICsgXCI7XFxuICAgICAgICAgICAgd1IgKz0gXCIgKyBkaWxhdGlvbkhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoTmVhcmVzdFZlYzQgKyBcIjsgd0MgKz0gNCkge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiICsgZGlsYXRpb25XaWR0aCArIFwiO1xcblxcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QywgY2gpLFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIFwiICsgZGlsYXRpb25XaWR0aCArIFwiLCBjaCksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgMiAqIFwiICsgZGlsYXRpb25XaWR0aCArIFwiLCBjaCksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgMyAqIFwiICsgZGlsYXRpb25XaWR0aCArIFwiLCBjaClcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIFwiICsgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCArIFwiO1xcbiAgICAgICAgICAgIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyBcIiArIGRpbGF0aW9uV2lkdGggKyBcIiwgY2gpLFxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiICsgKGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QywgY2gpLFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIFwiICsgZGlsYXRpb25XaWR0aCArIFwiLCBjaCksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgMiAqIFwiICsgZGlsYXRpb25XaWR0aCArIFwiLCBjaCksXFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoXCIgKyByZXR1cm5WYWx1ZSArIFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUG9vbDNEUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGF2Z1Bvb2woYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgYXNzZXJ0Tm90Q29tcGxleCh4LCAnYXZnUG9vbCcpO1xuICAgIHZhciBmaWx0ZXJTaXplID0gYXR0cnMuZmlsdGVyU2l6ZSwgc3RyaWRlcyA9IGF0dHJzLnN0cmlkZXMsIHBhZCA9IGF0dHJzLnBhZCwgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlO1xuICAgIHZhciBkaWxhdGlvbnMgPSAxO1xuICAgIHRmLnV0aWwuYXNzZXJ0KHRmLmJhY2tlbmRfdXRpbC5laXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUoc3RyaWRlcywgZGlsYXRpb25zKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Vycm9yIGluIGF2Z1Bvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuICcgK1xuICAgICAgICAoXCJHb3Qgc3RyaWRlcyBcIiArIHN0cmlkZXMgKyBcIiBhbmQgZGlsYXRpb25zICdcIiArIGRpbGF0aW9ucyArIFwiJ1wiKTsgfSk7XG4gICAgdmFyIGNvbnZJbmZvID0gdGYuYmFja2VuZF91dGlsLmNvbXB1dGVQb29sMkRJbmZvKHguc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIGlmIChjb252SW5mby5maWx0ZXJXaWR0aCA9PT0gMSAmJiBjb252SW5mby5maWx0ZXJIZWlnaHQgPT09IDEgJiZcbiAgICAgICAgdGYudXRpbC5hcnJheXNFcXVhbChjb252SW5mby5pblNoYXBlLCBjb252SW5mby5vdXRTaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB9XG4gICAgdmFyIGF2Z1Bvb2xQcm9ncmFtID0gbmV3IFBvb2wyRFByb2dyYW0oY29udkluZm8sICdhdmcnLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKGF2Z1Bvb2xQcm9ncmFtLCBbeF0sICdmbG9hdDMyJyk7XG59XG52YXIgYXZnUG9vbENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5BdmdQb29sLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGF2Z1Bvb2xcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGF2Z1Bvb2wzRChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGF0dHJzLmZpbHRlclNpemUsIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZSwgZGF0YUZvcm1hdCA9IGF0dHJzLmRhdGFGb3JtYXQ7XG4gICAgdmFyIGRpbGF0aW9ucyA9IFsxLCAxLCAxXTtcbiAgICB2YXIgY29udkluZm8gPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZVBvb2wzREluZm8oeC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSwgZGF0YUZvcm1hdCk7XG4gICAgdmFyIGF2Z1Bvb2xQcm9ncmFtID0gbmV3IFBvb2wzRFByb2dyYW0oY29udkluZm8sICdhdmcnLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKGF2Z1Bvb2xQcm9ncmFtLCBbeF0sICdmbG9hdDMyJyk7XG59XG52YXIgYXZnUG9vbDNEQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkF2Z1Bvb2wzRCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBhdmdQb29sM0Rcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBBdmdQb29sMkRCYWNrcHJvcFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXZnUG9vbDJEQmFja3Byb3BQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGRpbGF0aW9uSGVpZ2h0ID0gY29udkluZm8uZGlsYXRpb25IZWlnaHQ7XG4gICAgICAgIHZhciBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUZpbHRlcldpZHRoID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZWZmZWN0aXZlRmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgYXZnTXVsdGlwbGllciA9IDEgLyAoZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGgpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGF2Z011bHRpcGxpZXIgPSBmbG9hdChcIiArIGF2Z011bHRpcGxpZXIgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgKyBcIjtcXG4gICAgICAgICAgICB3UiArPSBcIiArIGRpbGF0aW9uSGVpZ2h0ICsgXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIgKyBzdHJpZGVIZWlnaHQgKyBcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIiArIGNvbnZJbmZvLm91dEhlaWdodCArIFwiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGVmZmVjdGl2ZUZpbHRlcldpZHRoICsgXCI7XFxuICAgICAgICAgICAgd0MrPSBcIiArIGRpbGF0aW9uV2lkdGggKyBcIikge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgY29udkluZm8ub3V0V2lkdGggKyBcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBhdmdNdWx0aXBsaWVyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbTtcbn0oKSk7XG52YXIgQXZnUG9vbDNEQmFja3Byb3BQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF2Z1Bvb2wzREJhY2twcm9wUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5pblNoYXBlO1xuICAgICAgICB2YXIgZmlsdGVyRGVwdGggPSBjb252SW5mby5maWx0ZXJEZXB0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVEZXB0aCA9IGNvbnZJbmZvLnN0cmlkZURlcHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGRpbGF0aW9uRGVwdGggPSBjb252SW5mby5kaWxhdGlvbkRlcHRoO1xuICAgICAgICB2YXIgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodDtcbiAgICAgICAgdmFyIGRpbGF0aW9uV2lkdGggPSBjb252SW5mby5kaWxhdGlvbldpZHRoO1xuICAgICAgICB2YXIgZWZmZWN0aXZlRmlsdGVyRGVwdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJEZXB0aDtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUZpbHRlcldpZHRoID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBwYWRGcm9udCA9IGVmZmVjdGl2ZUZpbHRlckRlcHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8uZnJvbnQ7XG4gICAgICAgIHZhciBwYWRUb3AgPSBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZWZmZWN0aXZlRmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgYXZnTXVsdGlwbGllciA9IDEgLyAoZmlsdGVyRGVwdGggKiBmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIiArIHBhZEZyb250ICsgXCIsIFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG4gICAgICBjb25zdCBmbG9hdCBhdmdNdWx0aXBsaWVyID0gZmxvYXQoXCIgKyBhdmdNdWx0aXBsaWVyICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgY2ggPSBjb29yZHMudTtcXG5cXG4gICAgICAgIGl2ZWMzIGR5Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgLSBwYWRzO1xcbiAgICAgICAgaW50IGR5RENvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueTtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci56O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCA6LCBjaCkgdG8gZ2V0XFxuICAgICAgICAvLyBkeCh4RCwgeFIsIHhDLCBjaCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3RCA9IDA7IHdEIDwgXCIgKyBlZmZlY3RpdmVGaWx0ZXJEZXB0aCArIFwiO1xcbiAgICAgICAgICAgIHdEICs9IFwiICsgZGlsYXRpb25EZXB0aCArIFwiKSB7XFxuICAgICAgICAgIGZsb2F0IGR5RCA9IGZsb2F0KGR5RENvcm5lciArIHdEKSAvIFwiICsgc3RyaWRlRGVwdGggKyBcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlEIDwgMC4wIHx8IGR5RCA+PSBcIiArIGNvbnZJbmZvLm91dERlcHRoICsgXCIuMCB8fCBmcmFjdChkeUQpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeUQgPSBpbnQoZHlEKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ICsgXCI7XFxuICAgICAgICAgICAgICB3UiArPSBcIiArIGRpbGF0aW9uSGVpZ2h0ICsgXCIpIHtcXG4gICAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIgKyBjb252SW5mby5vdXRIZWlnaHQgKyBcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGVmZmVjdGl2ZUZpbHRlcldpZHRoICsgXCI7XFxuICAgICAgICAgICAgICAgIHdDICs9IFwiICsgZGlsYXRpb25XaWR0aCArIFwiKSB7XFxuICAgICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIiArIHN0cmlkZVdpZHRoICsgXCIuMDtcXG5cXG4gICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgY29udkluZm8ub3V0V2lkdGggKyBcIi4wIHx8XFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeUQsIGlkeVIsIGlkeUMsIGNoKTtcXG5cXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIGF2Z011bHRpcGxpZXI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEF2Z1Bvb2wzREJhY2twcm9wUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGF2Z1Bvb2wzREdyYWQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBkeSA9IGlucHV0cy5keSwgaW5wdXQgPSBpbnB1dHMuaW5wdXQ7XG4gICAgdmFyIHggPSBpbnB1dDtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGF0dHJzLmZpbHRlclNpemUsIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZTtcbiAgICB2YXIgZGlsYXRpb25zID0gWzEsIDEsIDFdO1xuICAgIHZhciBjb252SW5mbyA9IHRmLmJhY2tlbmRfdXRpbC5jb21wdXRlUG9vbDNESW5mbyh4LnNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB2YXIgYXZnUG9vbEJhY2twcm9wUHJvZ3JhbSA9IG5ldyBBdmdQb29sM0RCYWNrcHJvcFByb2dyYW0oY29udkluZm8pO1xuICAgIHJldHVybiBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShhdmdQb29sQmFja3Byb3BQcm9ncmFtLCBbZHldLCB4LmR0eXBlKTtcbn1cbnZhciBhdmdQb29sR3JhZDNEQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkF2Z1Bvb2wzREdyYWQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogYXZnUG9vbDNER3JhZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gYXZnUG9vbEdyYWQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBkeSA9IGlucHV0cy5keSwgaW5wdXQgPSBpbnB1dHMuaW5wdXQ7XG4gICAgdmFyIHggPSBpbnB1dDtcbiAgICBhc3NlcnROb3RDb21wbGV4KFtkeSwgaW5wdXRdLCAnYXZnUG9vbEdyYWQnKTtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGF0dHJzLmZpbHRlclNpemUsIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQ7XG4gICAgdmFyIGNvbnZJbmZvID0gdGYuYmFja2VuZF91dGlsLmNvbXB1dGVQb29sMkRJbmZvKHguc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIDEgLyogZGlsYXRpb25zICovLCBwYWQpO1xuICAgIHZhciBhdmdQb29sQmFja3Byb3BQcm9ncmFtID0gbmV3IEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbyk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKGF2Z1Bvb2xCYWNrcHJvcFByb2dyYW0sIFtkeV0sIHguZHR5cGUpO1xufVxudmFyIGF2Z1Bvb2xHcmFkQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkF2Z1Bvb2xHcmFkLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGF2Z1Bvb2xHcmFkXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBiYXRjaE1hdE11bChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGEgPSBpbnB1dHMuYSwgYiA9IGlucHV0cy5iO1xuICAgIHZhciB0cmFuc3Bvc2VBID0gYXR0cnMudHJhbnNwb3NlQSwgdHJhbnNwb3NlQiA9IGF0dHJzLnRyYW5zcG9zZUI7XG4gICAgcmV0dXJuIGJhdGNoTWF0TXVsSW1wbCh7IGE6IGEsIGI6IGIsIHRyYW5zcG9zZUE6IHRyYW5zcG9zZUEsIHRyYW5zcG9zZUI6IHRyYW5zcG9zZUIsIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG59XG52YXIgYmF0Y2hNYXRNdWxDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQmF0Y2hNYXRNdWwsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogYmF0Y2hNYXRNdWwsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgQmF0Y2hOb3JtUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXRjaE5vcm1Qcm9ncmFtKHhTaGFwZSwgbWVhblNoYXBlLCB2YXJpYW5jZVNoYXBlLCBvZmZzZXRTaGFwZSwgc2NhbGVTaGFwZSwgdmFyaWFuY2VFcHNpbG9uKSB7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ21lYW4nLCAndmFyaWFuY2UnXTtcbiAgICAgICAgdGYuYmFja2VuZF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgbWVhblNoYXBlKTtcbiAgICAgICAgdGYuYmFja2VuZF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgdmFyaWFuY2VTaGFwZSk7XG4gICAgICAgIHZhciBvZmZzZXRTbmlwcGV0ID0gJzAuMCc7XG4gICAgICAgIGlmIChvZmZzZXRTaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0Zi5iYWNrZW5kX3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoeFNoYXBlLCBvZmZzZXRTaGFwZSk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnb2Zmc2V0Jyk7XG4gICAgICAgICAgICBvZmZzZXRTbmlwcGV0ID0gJ2dldE9mZnNldEF0T3V0Q29vcmRzKCknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsZVNuaXBwZXQgPSAnMS4wJztcbiAgICAgICAgaWYgKHNjYWxlU2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGYuYmFja2VuZF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgc2NhbGVTaGFwZSk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnc2NhbGUnKTtcbiAgICAgICAgICAgIHNjYWxlU25pcHBldCA9ICdnZXRTY2FsZUF0T3V0Q29vcmRzKCknO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG1lYW4gPSBnZXRNZWFuQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHZhcmlhbmNlID0gZ2V0VmFyaWFuY2VBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgb2Zmc2V0ID0gXCIgKyBvZmZzZXRTbmlwcGV0ICsgXCI7XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IFwiICsgc2NhbGVTbmlwcGV0ICsgXCI7XFxuICAgICAgICBmbG9hdCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgZmxvYXQoXCIgKyB2YXJpYW5jZUVwc2lsb24gKyBcIikpO1xcbiAgICAgICAgc2V0T3V0cHV0KGRvdCh2ZWMzKHgsIC1tZWFuLCBvZmZzZXQpLCB2ZWMzKGludiwgaW52LCAxKSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBCYXRjaE5vcm1Qcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIEJhdGNoTm9ybVBhY2tlZFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmF0Y2hOb3JtUGFja2VkUHJvZ3JhbSh4U2hhcGUsIG1lYW5TaGFwZSwgdmFyaWFuY2VTaGFwZSwgb2Zmc2V0U2hhcGUsIHNjYWxlU2hhcGUsIHZhcmlhbmNlRXBzaWxvbikge1xuICAgICAgICB0aGlzLnBhY2tlZElucHV0cyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFja2VkT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ21lYW4nLCAndmFyaWFuY2UnXTtcbiAgICAgICAgdGYuYmFja2VuZF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgbWVhblNoYXBlKTtcbiAgICAgICAgdGYuYmFja2VuZF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgdmFyaWFuY2VTaGFwZSk7XG4gICAgICAgIHZhciBvZmZzZXRTbmlwcGV0ID0gJ3ZlYzQoMC4wKSc7XG4gICAgICAgIGlmIChvZmZzZXRTaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0Zi5iYWNrZW5kX3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoeFNoYXBlLCBvZmZzZXRTaGFwZSk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnb2Zmc2V0Jyk7XG4gICAgICAgICAgICBvZmZzZXRTbmlwcGV0ID0gJ2dldE9mZnNldEF0T3V0Q29vcmRzKCknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsZVNuaXBwZXQgPSAndmVjNCgxLjApJztcbiAgICAgICAgaWYgKHNjYWxlU2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGYuYmFja2VuZF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgc2NhbGVTaGFwZSk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnc2NhbGUnKTtcbiAgICAgICAgICAgIHNjYWxlU25pcHBldCA9ICdnZXRTY2FsZUF0T3V0Q29vcmRzKCknO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgb2Zmc2V0ID0gXCIgKyBvZmZzZXRTbmlwcGV0ICsgXCI7XFxuICAgICAgICB2ZWM0IHNjYWxlID0gXCIgKyBzY2FsZVNuaXBwZXQgKyBcIjtcXG5cXG4gICAgICAgIHZlYzQgeCA9IGdldFhBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCBtZWFuID0gZ2V0TWVhbkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHZhcmlhbmNlID0gZ2V0VmFyaWFuY2VBdE91dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgdmVjNChcIiArIHZhcmlhbmNlRXBzaWxvbiArIFwiKSk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEJhdGNoTm9ybVBhY2tlZFByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgYmF0Y2hOb3JtID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGlucHV0cyA9IF9hLmlucHV0cywgYmFja2VuZCA9IF9hLmJhY2tlbmQsIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueCwgbWVhbiA9IGlucHV0cy5tZWFuLCB2YXJpYW5jZSA9IGlucHV0cy52YXJpYW5jZSwgb2Zmc2V0ID0gaW5wdXRzLm9mZnNldCwgc2NhbGUgPSBpbnB1dHMuc2NhbGU7XG4gICAgdGYudXRpbC5hc3NlcnQobWVhbi5zaGFwZS5sZW5ndGggPT09IHZhcmlhbmNlLnNoYXBlLmxlbmd0aCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0JhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgdmFyaWFuY2UgdG8gaGF2ZSAnICtcbiAgICAgICAgJ2VxdWFsIHJhbmtzLic7IH0pO1xuICAgIHRmLnV0aWwuYXNzZXJ0KG9mZnNldCA9PSBudWxsIHx8IG1lYW4uc2hhcGUubGVuZ3RoID09PSBvZmZzZXQuc2hhcGUubGVuZ3RoLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBvZmZzZXQgdG8gaGF2ZSAnICtcbiAgICAgICAgJ2VxdWFsIHJhbmtzLic7IH0pO1xuICAgIHRmLnV0aWwuYXNzZXJ0KHNjYWxlID09IG51bGwgfHwgbWVhbi5zaGFwZS5sZW5ndGggPT09IHNjYWxlLnNoYXBlLmxlbmd0aCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0JhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgc2NhbGUgdG8gaGF2ZSAnICtcbiAgICAgICAgJ2VxdWFsIHJhbmtzLic7IH0pO1xuICAgIHZhciB2YXJpYW5jZUVwc2lsb24gPSBhdHRycy52YXJpYW5jZUVwc2lsb247XG4gICAgaWYgKHZhcmlhbmNlRXBzaWxvbiA9PSBudWxsKSB7XG4gICAgICAgIHZhcmlhbmNlRXBzaWxvbiA9IDAuMDAxO1xuICAgIH1cbiAgICB2YXIgZmluYWxJbnB1dHMgPSBbeCwgbWVhbiwgdmFyaWFuY2VdO1xuICAgIHZhciBvZmZzZXRTaGFwZSA9IG51bGw7XG4gICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIG9mZnNldFNoYXBlID0gb2Zmc2V0LnNoYXBlO1xuICAgICAgICBmaW5hbElucHV0cy5wdXNoKG9mZnNldCk7XG4gICAgfVxuICAgIHZhciBzY2FsZVNoYXBlID0gbnVsbDtcbiAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzY2FsZVNoYXBlID0gc2NhbGUuc2hhcGU7XG4gICAgICAgIGZpbmFsSW5wdXRzLnB1c2goc2NhbGUpO1xuICAgIH1cbiAgICB2YXIgcHJvZ3JhbSA9IHRmLmVudigpLmdldEJvb2woJ1dFQkdMX1BBQ0tfTk9STUFMSVpBVElPTicpID9cbiAgICAgICAgbmV3IEJhdGNoTm9ybVBhY2tlZFByb2dyYW0oeC5zaGFwZSwgbWVhbi5zaGFwZSwgdmFyaWFuY2Uuc2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pIDpcbiAgICAgICAgbmV3IEJhdGNoTm9ybVByb2dyYW0oeC5zaGFwZSwgbWVhbi5zaGFwZSwgdmFyaWFuY2Uuc2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pO1xuICAgIHZhciBvdXRwdXQgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBmaW5hbElucHV0cywgZmluYWxJbnB1dHNbMF0uZHR5cGUpO1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xudmFyIGJhdGNoTm9ybUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5GdXNlZEJhdGNoTm9ybSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBiYXRjaE5vcm0sXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgU2xpY2VQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsaWNlUHJvZ3JhbShkZXN0U2l6ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3NvdXJjZSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gZGVzdFNpemU7XG4gICAgICAgIHRoaXMucmFuayA9IGRlc3RTaXplLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIHVuaWZvcm1QYXJ0ID0gXCJ1bmlmb3JtIGludCBzdGFydFtcIiArIHRoaXMucmFuayArIFwiXTtcIjtcbiAgICAgICAgdmFyIHNvdXJjZUNvb3JkcyA9IGdldENvb3Jkcyh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgYm9keTtcbiAgICAgICAgdmFyIGNvb3JkU3VtID0gZGVzdFNpemUubWFwKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJzb3VyY2VMb2MuXCIgKyBjb29yZHNbaV0gKyBcIiA9IHN0YXJ0W1wiICsgaSArIFwiXSArIGNvb3Jkcy5cIiArIGNvb3Jkc1tpXSArIFwiO1wiO1xuICAgICAgICB9KTtcbiAgICAgICAgYm9keSA9IFwiXFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgc291cmNlTG9jO1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgXCIgKyBjb29yZFN1bS5qb2luKCdcXG4nKSArIFwiXFxuICAgICAgXCI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIFwiICsgdW5pZm9ybVBhcnQgKyBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgYm9keSArIFwiXFxuICAgICAgICBzZXRPdXRwdXQoZ2V0U291cmNlKFwiICsgc291cmNlQ29vcmRzICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBTbGljZVByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc3RhcnQubGVuZ3RoICE9PSB0aGlzLnJhbmspIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIHJhbmsgKFwiICsgdGhpcy5yYW5rICsgXCIpIG9mIHRoZSBwcm9ncmFtIG11c3QgbWF0Y2ggdGhlIFwiICtcbiAgICAgICAgICAgICAgICAoXCJsZW5ndGggb2Ygc3RhcnQgKFwiICsgc3RhcnQubGVuZ3RoICsgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydExvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHdlYkdMUHJvZ3JhbSwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXJ0TG9jID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGUgY29tcGlsZXIgaGFzIG9wdGltaXplZCBhbmQgcmVhbGl6ZWQgaXQgZG9lc24ndCBuZWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB1bmlmb3JtLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFpdihfdGhpcy5zdGFydExvYywgc3RhcnQpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNsaWNlUHJvZ3JhbTtcbn0oKSk7XG52YXIgY29vcmRzID0gWyd4JywgJ3knLCAneicsICd3JywgJ3UnLCAndiddO1xuZnVuY3Rpb24gZ2V0Q29vcmRzKHJhbmspIHtcbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZUxvYyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPD0gNikge1xuICAgICAgICByZXR1cm4gY29vcmRzLnNsaWNlKDAsIHJhbmspLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gJ3NvdXJjZUxvYy4nICsgeDsgfSkuam9pbignLCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJTbGljaW5nIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFNsaWNlUGFja2VkUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbGljZVBhY2tlZFByb2dyYW0oZGVzdFNpemUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydzb3VyY2UnXTtcbiAgICAgICAgdGhpcy5wYWNrZWRJbnB1dHMgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhY2tlZE91dHB1dCA9IHRydWU7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBkZXN0U2l6ZTtcbiAgICAgICAgdGhpcy5yYW5rID0gZGVzdFNpemUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgY29vcmRzID0gZ2V0Q2hhbm5lbHMoJ2Nvb3JkcycsIHRoaXMucmFuayk7XG4gICAgICAgIHZhciBzb3VyY2VMb2MgPSBnZXRDaGFubmVscygnc291cmNlTG9jJywgdGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIGlubmVyRGltcyA9IHRoaXMucmFuayA9PT0gMSA/ICdzb3VyY2VMb2MnIDogXCJ2ZWMyKFwiICsgc291cmNlTG9jLnNsaWNlKC0yKS5qb2luKCkgKyBcIilcIjtcbiAgICAgICAgdmFyIGdldENoYW5uZWwgPSBcImdldENoYW5uZWwoZ2V0U291cmNlKFwiICsgc291cmNlTG9jLmpvaW4oKSArIFwiKSwgXCIgKyBpbm5lckRpbXMgKyBcIilcIjtcbiAgICAgICAgdmFyIHVwcGVyUm93ID0gXCJcXG4gICAgICByZXN1bHQueCA9IFwiICsgZ2V0Q2hhbm5lbCArIFwiO1xcbiAgICAgIGlmICgrK1wiICsgY29vcmRzW3RoaXMucmFuayAtIDFdICsgXCIgPCBcIiArIGRlc3RTaXplW3RoaXMucmFuayAtIDFdICsgXCIpIHtcXG4gICAgICAgICsrXCIgKyBzb3VyY2VMb2NbdGhpcy5yYW5rIC0gMV0gKyBcIjtcXG4gICAgICAgIHJlc3VsdC55ID0gXCIgKyBnZXRDaGFubmVsICsgXCI7XFxuICAgICAgICAtLVwiICsgc291cmNlTG9jW3RoaXMucmFuayAtIDFdICsgXCI7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICAgICAgdmFyIGxvd2VyUm93ID0gdGhpcy5yYW5rID09PSAxID8gJycgOiBcIlxcbiAgICAgIC0tXCIgKyBjb29yZHNbdGhpcy5yYW5rIC0gMV0gKyBcIjtcXG4gICAgICBpZiAoKytcIiArIGNvb3Jkc1t0aGlzLnJhbmsgLSAyXSArIFwiIDwgXCIgKyBkZXN0U2l6ZVt0aGlzLnJhbmsgLSAyXSArIFwiKSB7XFxuICAgICAgICArK1wiICsgc291cmNlTG9jW3RoaXMucmFuayAtIDJdICsgXCI7XFxuICAgICAgICByZXN1bHQueiA9IFwiICsgZ2V0Q2hhbm5lbCArIFwiO1xcbiAgICAgICAgaWYgKCsrXCIgKyBjb29yZHNbdGhpcy5yYW5rIC0gMV0gKyBcIiA8IFwiICsgZGVzdFNpemVbdGhpcy5yYW5rIC0gMV0gKyBcIikge1xcbiAgICAgICAgICArK1wiICsgc291cmNlTG9jW3RoaXMucmFuayAtIDFdICsgXCI7XFxuICAgICAgICAgIHJlc3VsdC53ID0gXCIgKyBnZXRDaGFubmVsICsgXCI7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICAgICAgdmFyIHNvdXJjZUxvY1NldHVwID0gdGhpcy5yYW5rIDw9IDQgP1xuICAgICAgICAgICAgXCJzb3VyY2VMb2MgPSBjb29yZHMgK1xcbiAgICAgICAgICAgIFwiICsgZHR5cGUgKyBcIihcIiArIGRlc3RTaXplLm1hcChmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gXCJzdGFydFtcIiArIGkgKyBcIl1cIjsgfSkuam9pbigpICsgXCIpO1wiIDpcbiAgICAgICAgICAgIGRlc3RTaXplLm1hcChmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gc291cmNlTG9jW2ldICsgXCIgPSBcIiArIGNvb3Jkc1tpXSArIFwiICsgc3RhcnRbXCIgKyBpICsgXCJdO1wiOyB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdW5pZm9ybSBpbnQgc3RhcnRbXCIgKyB0aGlzLnJhbmsgKyBcIl07XFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIHNvdXJjZUxvYztcXG4gICAgICAgIFwiICsgc291cmNlTG9jU2V0dXAgKyBcIlxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgIFwiICsgdXBwZXJSb3cgKyBcIlxcbiAgICAgICAgXCIgKyBsb3dlclJvdyArIFwiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBTbGljZVBhY2tlZFByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc3RhcnQubGVuZ3RoICE9PSB0aGlzLnJhbmspIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIHJhbmsgKFwiICsgdGhpcy5yYW5rICsgXCIpIG9mIHRoZSBwcm9ncmFtIG11c3QgbWF0Y2ggdGhlIFwiICtcbiAgICAgICAgICAgICAgICAoXCJsZW5ndGggb2Ygc3RhcnQgKFwiICsgc3RhcnQubGVuZ3RoICsgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydExvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHdlYkdMUHJvZ3JhbSwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXJ0TG9jID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGUgY29tcGlsZXIgaGFzIG9wdGltaXplZCBhbmQgcmVhbGl6ZWQgaXQgZG9lc24ndCBuZWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB1bmlmb3JtLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFpdihfdGhpcy5zdGFydExvYywgc3RhcnQpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNsaWNlUGFja2VkUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dTbGljZSh4LCBiZWdpbiwgc2l6ZSwgYmFja2VuZCkge1xuICAgIHZhciB4VGV4RGF0YSA9IGJhY2tlbmQudGV4RGF0YS5nZXQoeC5kYXRhSWQpO1xuICAgIHZhciB0ID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhzaXplLCB4LmR0eXBlKTtcbiAgICB2YXIgbmV3VGV4RGF0YSA9IGJhY2tlbmQudGV4RGF0YS5nZXQodC5kYXRhSWQpO1xuICAgIC8vIENvcHkgdGV4dHVyZSBkYXRhIGZyb20gdGhlIG9yaWdpbmFsIHRlbnNvci5cbiAgICBPYmplY3QuYXNzaWduKG5ld1RleERhdGEsIHhUZXhEYXRhKTtcbiAgICBuZXdUZXhEYXRhLmNvbXBsZXhQYXJlbnRSZWZDb3VudCA9IDA7XG4gICAgbmV3VGV4RGF0YS5yZWZDb3VudCA9IDE7XG4gICAgbmV3VGV4RGF0YS5zaGFwZSA9IHNpemU7XG4gICAgbmV3VGV4RGF0YS5kdHlwZSA9IHguZHR5cGU7XG4gICAgdmFyIGZsYXRPZmZzZXQgPSB0Zi5zbGljZV91dGlsLmNvbXB1dGVGbGF0T2Zmc2V0KGJlZ2luLCB0Zi51dGlsLmNvbXB1dGVTdHJpZGVzKHguc2hhcGUpKTtcbiAgICBpZiAoeFRleERhdGEuc2xpY2UpIHtcbiAgICAgICAgLy8gV2UgYXJlIHNsaWNpbmcgYW4gYWxyZWFkeSBzbGljZWQgdGVuc29yLCBzbyB3ZSBoYXZlIHRvIGFjY3VtdWxhdGVcbiAgICAgICAgLy8gdGhlIG9mZnNldC5cbiAgICAgICAgZmxhdE9mZnNldCArPSB4VGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0O1xuICAgIH1cbiAgICBuZXdUZXhEYXRhLnNsaWNlID0ge1xuICAgICAgICBmbGF0T2Zmc2V0OiBmbGF0T2Zmc2V0LFxuICAgICAgICAvLyBQb2ludCB0byB0aGUgb3JpZ2luYWwgZGF0YUlkLCB3aGljaCBpcyB1c2VkIHRvIGRvIHJlZiBjb3VudGluZy5cbiAgICAgICAgb3JpZ0RhdGFJZDogeFRleERhdGEuc2xpY2UgJiYgeFRleERhdGEuc2xpY2Uub3JpZ0RhdGFJZCB8fCB4LmRhdGFJZFxuICAgIH07XG4gICAgLy8gSW5jcmVhc2UgdGhlIHJlZiBjb3VudCBmb3IgdGhhdCBkYXRhIGJ1Y2tldC5cbiAgICB2YXIgcmVmQ291bnQgPSBiYWNrZW5kLmRhdGFSZWZDb3VudC5nZXQobmV3VGV4RGF0YS5zbGljZS5vcmlnRGF0YUlkKSB8fCAxO1xuICAgIGJhY2tlbmQuZGF0YVJlZkNvdW50LnNldChuZXdUZXhEYXRhLnNsaWNlLm9yaWdEYXRhSWQsIHJlZkNvdW50ICsgMSk7XG4gICAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBzbGljZShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgYmVnaW4gPSBhdHRycy5iZWdpbiwgc2l6ZSA9IGF0dHJzLnNpemU7XG4gICAgdmFyIF9hID0gdGYuc2xpY2VfdXRpbC5wYXJzZVNsaWNlUGFyYW1zKHgsIGJlZ2luLCBzaXplKSwgJGJlZ2luID0gX2FbMF0sICRzaXplID0gX2FbMV07XG4gICAgdGYuc2xpY2VfdXRpbC5hc3NlcnRQYXJhbXNWYWxpZCh4LCAkYmVnaW4sICRzaXplKTtcbiAgICBpZiAodGYudXRpbC5zaXplRnJvbVNoYXBlKCRzaXplKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbygkc2l6ZSwgeC5kdHlwZSwgW10pO1xuICAgIH1cbiAgICAvLyBSdW4gb24gY3B1IGlmIGR0eXBlIGlzIHN0cmluZy4gRm9yIHN0cmluZywgdGhlIGJhY2tlbmQgcmVwcmVzZW50cyBpdFxuICAgIC8vIGFzIFVpbnQ4QXJyYXlbXSwgd2hlcmUgZWFjaCBVaW50OEFycmF5IGlzIGEgY2hhcmFjdGVyLiBHaXZlbiB0aGF0IHRoZVxuICAgIC8vIGNvbXB1dGF0aW9uIGlzIG9ubHkgb24gdGhlIG91dGVyIGFycmF5LCB1cGxvYWRpbmcgdGhlIHdob2xlIGRhdGEgb250b1xuICAgIC8vIGdwdSBpcyB3YXN0ZWZ1bC4gQWxzbywgY3VycmVudGx5IHdlYmdsIGRvZXNuJ3QgaGF2ZSBhIGRlc2lnbiB0b1xuICAgIC8vIHVwbG9hZCBhbmQgcmV0cmlldmUgVWludDhBcnJheVtdIGJldHdlZW4gY3B1IGFuZCBncHUuIFRoZXJlZm9yZSwgd2VcbiAgICAvLyBqdXN0IHJ1biB0aGUga2VybmVsIG9uIGNwdSBpZiBkdHlwZSBpcyBzdHJpbmcuXG4gICAgaWYgKGJhY2tlbmQuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt4XSkgfHwgeC5kdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHhUZXhEYXRhID0gYmFja2VuZC50ZXhEYXRhLmdldCh4LmRhdGFJZCk7XG4gICAgICAgIHZhciBvdXRWYWx1ZXMgPSBzbGljZUltcGxDUFUoeFRleERhdGEudmFsdWVzLCAkYmVnaW4sICRzaXplLCB4LnNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oJHNpemUsIHguZHR5cGUsIG91dFZhbHVlcyk7XG4gICAgfVxuICAgIHZhciBpc1BhY2tlZCA9IGJhY2tlbmQudGV4RGF0YS5nZXQoeC5kYXRhSWQpLmlzUGFja2VkO1xuICAgIHZhciBpc0NvbnRpbm91cyA9IHRmLnNsaWNlX3V0aWwuaXNTbGljZUNvbnRpbm91cyh4LnNoYXBlLCAkYmVnaW4sICRzaXplKTtcbiAgICBpZiAoaXNQYWNrZWQgfHwgIWlzQ29udGlub3VzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gdGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TJykgP1xuICAgICAgICAgICAgbmV3IFNsaWNlUGFja2VkUHJvZ3JhbSgkc2l6ZSkgOlxuICAgICAgICAgICAgbmV3IFNsaWNlUHJvZ3JhbSgkc2l6ZSk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKCRiZWdpbik7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbeF0sIHguZHR5cGUsIGN1c3RvbVNldHVwKTtcbiAgICB9XG4gICAgYmFja2VuZC51cGxvYWRUb0dQVSh4LmRhdGFJZCk7XG4gICAgcmV0dXJuIHNoYWxsb3dTbGljZSh4LCAkYmVnaW4sICRzaXplLCBiYWNrZW5kKTtcbn1cbnZhciBzbGljZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5TbGljZSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBzbGljZVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGJhdGNoVG9TcGFjZU5EID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBibG9ja1NoYXBlID0gYXR0cnMuYmxvY2tTaGFwZSwgY3JvcHMgPSBhdHRycy5jcm9wcztcbiAgICB0Zi51dGlsLmFzc2VydCh4LnNoYXBlLmxlbmd0aCA8PSA0LCBmdW5jdGlvbiAoKSB7IHJldHVybiAnYmF0Y2hUb1NwYWNlTkQgZm9yIHJhbmsgPiA0IHdpdGggYSBXZWJHTCBiYWNrZW5kIG5vdCAnICtcbiAgICAgICAgJ2ltcGxlbWVudGVkIHlldCc7IH0pO1xuICAgIHZhciBwcm9kID0gYmxvY2tTaGFwZS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKiBiOyB9KTtcbiAgICB2YXIgcmVzaGFwZWQgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0UmVzaGFwZWQoeC5zaGFwZSwgYmxvY2tTaGFwZSwgcHJvZCk7XG4gICAgdmFyIHBlcm11dGVkID0gdGYuYmFja2VuZF91dGlsLmdldFBlcm11dGVkKHJlc2hhcGVkLmxlbmd0aCwgYmxvY2tTaGFwZS5sZW5ndGgpO1xuICAgIHZhciByZXNoYXBlZFBlcm11dGVkID0gdGYuYmFja2VuZF91dGlsLmdldFJlc2hhcGVkUGVybXV0ZWQoeC5zaGFwZSwgYmxvY2tTaGFwZSwgcHJvZCk7XG4gICAgdmFyIHNsaWNlQmVnaW5Db29yZHMgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0U2xpY2VCZWdpbkNvb3Jkcyhjcm9wcywgYmxvY2tTaGFwZS5sZW5ndGgpO1xuICAgIHZhciBzbGljZVNpemUgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0U2xpY2VTaXplKHJlc2hhcGVkUGVybXV0ZWQsIGNyb3BzLCBibG9ja1NoYXBlLmxlbmd0aCk7XG4gICAgdmFyIHRvRGlzcG9zZSA9IFtdO1xuICAgIHZhciByZXNoYXBlZEludGVybWVkaWF0ZSA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogcmVzaGFwZWQgfSB9KTtcbiAgICB2YXIgdHJhbnNwb3NlZEludGVybWVkaWF0ZSA9IHRyYW5zcG9zZSh7IGlucHV0czogeyB4OiByZXNoYXBlZEludGVybWVkaWF0ZSB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBwZXJtOiBwZXJtdXRlZCB9IH0pO1xuICAgIHZhciByZXNoYXBlZEludGVybWVkaWF0ZTIgPSByZXNoYXBlKHtcbiAgICAgICAgaW5wdXRzOiB7IHg6IHRyYW5zcG9zZWRJbnRlcm1lZGlhdGUgfSxcbiAgICAgICAgYmFja2VuZDogYmFja2VuZCxcbiAgICAgICAgYXR0cnM6IHsgc2hhcGU6IHJlc2hhcGVkUGVybXV0ZWQgfVxuICAgIH0pO1xuICAgIHZhciBzbGljZWQgPSBzbGljZSh7XG4gICAgICAgIGlucHV0czogeyB4OiByZXNoYXBlZEludGVybWVkaWF0ZTIgfSxcbiAgICAgICAgYmFja2VuZDogYmFja2VuZCxcbiAgICAgICAgYXR0cnM6IHsgYmVnaW46IHNsaWNlQmVnaW5Db29yZHMsIHNpemU6IHNsaWNlU2l6ZSB9XG4gICAgfSk7XG4gICAgdG9EaXNwb3NlLnB1c2gocmVzaGFwZWRJbnRlcm1lZGlhdGUpO1xuICAgIHRvRGlzcG9zZS5wdXNoKHRyYW5zcG9zZWRJbnRlcm1lZGlhdGUpO1xuICAgIHRvRGlzcG9zZS5wdXNoKHJlc2hhcGVkSW50ZXJtZWRpYXRlMik7XG4gICAgdG9EaXNwb3NlLmZvckVhY2goZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odCk7IH0pO1xuICAgIHJldHVybiBzbGljZWQ7XG59O1xudmFyIGJhdGNoVG9TcGFjZU5EQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkJhdGNoVG9TcGFjZU5ELFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGJhdGNoVG9TcGFjZU5EXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBiaW5jb3VudChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueCwgd2VpZ2h0cyA9IGlucHV0cy53ZWlnaHRzO1xuICAgIHZhciBzaXplID0gYXR0cnMuc2l6ZTtcbiAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLnJlYWRTeW5jKHguZGF0YUlkKTtcbiAgICB2YXIgd2VpZ2h0c1ZhbHMgPSBiYWNrZW5kLnJlYWRTeW5jKHdlaWdodHMuZGF0YUlkKTtcbiAgICB2YXIgb3V0VmFscyA9IGJpbmNvdW50SW1wbENQVSh4VmFscywgd2VpZ2h0c1ZhbHMsIHdlaWdodHMuZHR5cGUsIHdlaWdodHMuc2hhcGUsIHNpemUpO1xuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtzaXplXSwgd2VpZ2h0cy5kdHlwZSwgb3V0VmFscyk7XG59XG52YXIgYmluY291bnRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQmluY291bnQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogYmluY291bnRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBOT1RfRVFVQUwgPSBcInJldHVybiBmbG9hdChhICE9IGIpO1wiO1xudmFyIG5vdEVxdWFsID0gYmluYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogTk9UX0VRVUFMLCBkdHlwZTogJ2Jvb2wnIH0pO1xudmFyIG5vdEVxdWFsQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLk5vdEVxdWFsLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IG5vdEVxdWFsLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gcmVhbChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciBpbnB1dCA9IGlucHV0cy5pbnB1dDtcbiAgICB2YXIgaW5wdXREYXRhID0gYmFja2VuZC50ZXhEYXRhLmdldChpbnB1dC5kYXRhSWQpO1xuICAgIHJldHVybiBpZGVudGl0eSh7IGlucHV0czogeyB4OiBpbnB1dERhdGEuY29tcGxleFRlbnNvckluZm9zLnJlYWwgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbn1cbnZhciByZWFsQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlJlYWwsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogcmVhbFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFRPX0lOVCA9IFwicmV0dXJuIGZsb2F0KGludCh4KSk7XCI7XG5mdW5jdGlvbiBpbnQoaW5wdXQsIGJhY2tlbmQpIHtcbiAgICB2YXIgcHJvZ3JhbSA9IG5ldyBVbmFyeU9wUHJvZ3JhbShpbnB1dC5zaGFwZSwgVE9fSU5UKTtcbiAgICB2YXIgb3V0cHV0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2lucHV0XSwgJ2ludDMyJyk7XG4gICAgcmV0dXJuIHsgZGF0YUlkOiBvdXRwdXQuZGF0YUlkLCBzaGFwZTogb3V0cHV0LnNoYXBlLCBkdHlwZTogb3V0cHV0LmR0eXBlIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGNhc3QoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGR0eXBlID0gYXR0cnMuZHR5cGU7XG4gICAgLy8gQ2FzdGluZyB0byBjb21wbGV4NjQuXG4gICAgaWYgKGR0eXBlID09PSAnY29tcGxleDY0Jykge1xuICAgICAgICBpZiAoeC5kdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGl0eSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhhbm54aW5neXVhbik6IEltcG9ydCBrZXJuZWwgZnVuY3Rpb24gb25jZSB6ZXJvcyBpcyBtb2R1bGFyaXplZC5cbiAgICAgICAgdmFyIHplcm9zVGVuc29yID0gdGYuemVyb3MoeC5zaGFwZSk7XG4gICAgICAgIHZhciBmbG9hdFggPSBjYXN0KHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgZHR5cGU6ICdmbG9hdDMyJyB9IH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGxleCh7IGlucHV0czogeyByZWFsOiBmbG9hdFgsIGltYWc6IHplcm9zVGVuc29yIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIHplcm9zVGVuc29yLmRpc3Bvc2UoKTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmbG9hdFgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBDYXN0aW5nIGZyb20gY29tcGxleDY0XG4gICAgaWYgKHguZHR5cGUgPT09ICdjb21wbGV4NjQnKSB7XG4gICAgICAgIHZhciByZWFsUGFydCA9IHJlYWwoeyBpbnB1dHM6IHsgaW5wdXQ6IHggfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhc3QoeyBpbnB1dHM6IHsgeDogcmVhbFBhcnQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgZHR5cGU6IGR0eXBlIH0gfSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVhbFBhcnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoIXRmLnV0aWwuaGFzRW5jb2RpbmdMb3NzKHguZHR5cGUsIGR0eXBlKSkge1xuICAgICAgICAvLyBXZSBkb24ndCBjaGFuZ2UgdGhlIHVuZGVybHlpbmcgZGF0YSwgc2luY2Ugd2UgY2FzdCB0byBoaWdoZXJcbiAgICAgICAgLy8gcHJlY2lzaW9uLlxuICAgICAgICB2YXIgcmVzdWx0ID0gaWRlbnRpdHkoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICByZXR1cm4geyBkYXRhSWQ6IHJlc3VsdC5kYXRhSWQsIHNoYXBlOiByZXN1bHQuc2hhcGUsIGR0eXBlOiBkdHlwZSB9O1xuICAgIH1cbiAgICBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgcmV0dXJuIGludCh4LCBiYWNrZW5kKTtcbiAgICB9XG4gICAgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgdmFyIHplcm9zVGVuc29ySW5mbyA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8oW10sICdib29sJywgdGYudXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKCdib29sJywgMSkpO1xuICAgICAgICB2YXIgYmluYXJ5SW5wdXRzID0geyBhOiB4LCBiOiB6ZXJvc1RlbnNvckluZm8gfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5vdEVxdWFsKHsgaW5wdXRzOiBiaW5hcnlJbnB1dHMsIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oemVyb3NUZW5zb3JJbmZvKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gQ2FzdDogZmFpbGVkIHRvIGNhc3QgXCIgKyB4LmR0eXBlICsgXCIgdG8gXCIgKyBkdHlwZSk7XG59XG52YXIgY2FzdENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5DYXN0LFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGNhc3Rcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBDRUlMID0gXCJyZXR1cm4gY2VpbCh4KTtcIjtcbnZhciBjZWlsID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBDRUlMLCBwYWNrZWRPcFNuaXBwZXQ6IENFSUwsIGNwdUtlcm5lbEltcGw6IGNlaWxJbXBsQ1BVIH0pO1xudmFyIGNlaWxDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQ2VpbCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBjZWlsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgQ2xpcFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xpcFByb2dyYW0oYVNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gYVNoYXBlO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1pblZhbDtcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1heFZhbDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgaWYgKGlzbmFuKHZhbHVlKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoY2xhbXAodmFsdWUsIG1pblZhbCwgbWF4VmFsKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgQ2xpcFByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5taW5Mb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm1pbkxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cod2ViR0xQcm9ncmFtLCAnbWluVmFsJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMubWF4TG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyh3ZWJHTFByb2dyYW0sICdtYXhWYWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihfdGhpcy5taW5Mb2MsIG1pbik7XG4gICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMWYoX3RoaXMubWF4TG9jLCBtYXgpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENsaXBQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIENsaXBQYWNrZWRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsaXBQYWNrZWRQcm9ncmFtKGFTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5wYWNrZWRJbnB1dHMgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhY2tlZE91dHB1dCA9IHRydWU7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBhU2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWluVmFsO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWF4VmFsO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgdmFsdWUgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIGlmIChhbnkoaXNuYW4odmFsdWUpKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoY2xhbXAodmFsdWUsIHZlYzQobWluVmFsKSwgdmVjNChtYXhWYWwpKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgQ2xpcFBhY2tlZFByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5taW5Mb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm1pbkxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cod2ViR0xQcm9ncmFtLCAnbWluVmFsJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMubWF4TG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyh3ZWJHTFByb2dyYW0sICdtYXhWYWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihfdGhpcy5taW5Mb2MsIG1pbik7XG4gICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMWYoX3RoaXMubWF4TG9jLCBtYXgpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENsaXBQYWNrZWRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY2xpcEJ5VmFsdWUoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGNsaXBWYWx1ZU1pbiA9IGF0dHJzLmNsaXBWYWx1ZU1pbiwgY2xpcFZhbHVlTWF4ID0gYXR0cnMuY2xpcFZhbHVlTWF4O1xuICAgIHZhciBwcm9ncmFtO1xuICAgIGlmICh0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9QQUNLX0NMSVAnKSkge1xuICAgICAgICBwcm9ncmFtID0gbmV3IENsaXBQYWNrZWRQcm9ncmFtKHguc2hhcGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvZ3JhbSA9IG5ldyBDbGlwUHJvZ3JhbSh4LnNoYXBlKTtcbiAgICB9XG4gICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoY2xpcFZhbHVlTWluLCBjbGlwVmFsdWVNYXgpO1xuICAgIHJldHVybiBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbeF0sIHguZHR5cGUsIGN1c3RvbVNldHVwKTtcbn1cbnZhciBjbGlwQnlWYWx1ZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5DbGlwQnlWYWx1ZSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBjbGlwQnlWYWx1ZVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIENvbXBsZXhBYnNQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBsZXhBYnNQcm9ncmFtKHNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsncmVhbCcsICdpbWFnJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgcmUgPSBhYnMoZ2V0UmVhbEF0T3V0Q29vcmRzKCkpO1xcbiAgICAgICAgZmxvYXQgaW0gPSBhYnMoZ2V0SW1hZ0F0T3V0Q29vcmRzKCkpO1xcbiAgICAgICAgZmxvYXQgbXggPSBtYXgocmUsIGltKTtcXG5cXG4gICAgICAgIC8vIHNhZGx5IHRoZSBsZW5ndGggZnVuY3Rpb24gaW4gZ2xzbCBpcyBub3QgdW5kZXJmbG93LXNhZmVcXG4gICAgICAgIC8vIChhdCBsZWFzdCBub3Qgb24gSW50ZWwgR1BVcykuIFNvIHRoZSBzYWZlIHNvbHV0aW9uIGlzXFxuICAgICAgICAvLyB0byBlbnN1cmUgdW5kZXJmbG93LXNhZmV0eSBpbiBhbGwgY2FzZXMuXFxuICAgICAgICBzZXRPdXRwdXQoXFxuICAgICAgICAgIG14ID09IDAuMCA/IDAuMCA6IG14ICogbGVuZ3RoKHZlYzIoMSwgbWluKHJlLCBpbSkvbXgpKVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGxleEFic1Byb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vLyBSZXR1cm5zIGEgVGVuc29ySW5mbyB3aXRoIHRoZSBjb21wbGV4IHNoYXBlIGFuZCB0aGUgZGF0YUlkIG9mIHRoZVxuLy8gdW5kZXJseWluZyBwYXJ0LiBXZSBuZWVkIHRvIGRvIHRoaXMgYmVjYXVzZSBhIHJlc2hhcGVkIGNvbXBsZXggdGVuc29yIGlzXG4vLyBub3QgcmVmbGVjdGVkIGluIGl0cyBwYXJ0cy5cbmZ1bmN0aW9uIG1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyhjb21wbGV4VGVuc29yLCBjb21wbGV4UGFydCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFJZDogY29tcGxleFBhcnQuZGF0YUlkLFxuICAgICAgICBkdHlwZTogY29tcGxleFBhcnQuZHR5cGUsXG4gICAgICAgIHNoYXBlOiBjb21wbGV4VGVuc29yLnNoYXBlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXhBYnMoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciB4RGF0YSA9IGJhY2tlbmQudGV4RGF0YS5nZXQoeC5kYXRhSWQpO1xuICAgIHZhciBwcm9ncmFtID0gbmV3IENvbXBsZXhBYnNQcm9ncmFtKHguc2hhcGUpO1xuICAgIHZhciBwcm9ncmFtSW5wdXRzID0gW1xuICAgICAgICBtYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8oeCwgeERhdGEuY29tcGxleFRlbnNvckluZm9zLnJlYWwpLFxuICAgICAgICBtYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8oeCwgeERhdGEuY29tcGxleFRlbnNvckluZm9zLmltYWcpLFxuICAgIF07XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIHByb2dyYW1JbnB1dHMsIHByb2dyYW1JbnB1dHNbMF0uZHR5cGUpO1xufVxudmFyIGNvbXBsZXhBYnNDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQ29tcGxleEFicyxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBjb21wbGV4QWJzXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgQ29uY2F0UHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDb25jYXRzIDJkIHRlbnNvcnMgYWxvbmcgYXhpcz0xLiBTZWUgY29tbWVudHMgaW4gTWF0aEJhY2tlbmRXZWJHTC5jb25jYXQoKS5cbiAgICBmdW5jdGlvbiBDb25jYXRQcm9ncmFtKHNoYXBlcykge1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZU91dFNoYXBlKHNoYXBlcywgMSAvKiBheGlzICovKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gc2hhcGVzLm1hcChmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gXCJUXCIgKyBpOyB9KTtcbiAgICAgICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoc2hhcGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICBvZmZzZXRzWzBdID0gc2hhcGVzWzBdWzFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9mZnNldHNbaV0gPSBvZmZzZXRzW2kgLSAxXSArIHNoYXBlc1tpXVsxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc25pcHBldHMgPSBbXCJpZiAoeUMgPCBcIiArIG9mZnNldHNbMF0gKyBcIikgc2V0T3V0cHV0KGdldFQwKHlSLCB5QykpO1wiXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBvZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2hpZnQgPSBvZmZzZXRzW2kgLSAxXTtcbiAgICAgICAgICAgIHNuaXBwZXRzLnB1c2goXCJlbHNlIGlmICh5QyA8IFwiICsgb2Zmc2V0c1tpXSArIFwiKSBcIiArXG4gICAgICAgICAgICAgICAgKFwic2V0T3V0cHV0KGdldFRcIiArIGkgKyBcIih5UiwgeUMtXCIgKyBzaGlmdCArIFwiKSk7XCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gb2Zmc2V0cy5sZW5ndGg7XG4gICAgICAgIHZhciBsYXN0U2hpZnQgPSBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHNuaXBwZXRzLnB1c2goXCJlbHNlIHNldE91dHB1dChnZXRUXCIgKyBsYXN0SW5kZXggKyBcIih5UiwgeUMtXCIgKyBsYXN0U2hpZnQgKyBcIikpO1wiKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgeVIgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB5QyA9IGNvb3Jkcy55O1xcblxcbiAgICAgICAgXCIgKyBzbmlwcGV0cy5qb2luKCdcXG4gICAgICAgICcpICsgXCJcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29uY2F0UHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBDb25jYXRQYWNrZWRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmNhdFBhY2tlZFByb2dyYW0oc2hhcGVzLCBheGlzKSB7XG4gICAgICAgIHRoaXMucGFja2VkSW5wdXRzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWNrZWRPdXRwdXQgPSB0cnVlO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZU91dFNoYXBlKHNoYXBlcywgYXhpcyk7XG4gICAgICAgIHZhciBzaGFwZSA9IHRoaXMub3V0cHV0U2hhcGU7XG4gICAgICAgIHZhciByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IGdldENoYW5uZWxzKCdjb29yZHMnLCByYW5rKTtcbiAgICAgICAgdmFyIGNoYW5uZWxzID0gWyd4JywgJ3knLCAneicsICd3JywgJ3UnLCAndiddLnNsaWNlKDAsIHJhbmspO1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBzaGFwZXMubWFwKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBcIlRcIiArIGk7IH0pO1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShzaGFwZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIG9mZnNldHNbMF0gPSBzaGFwZXNbMF1bYXhpc107XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2Zmc2V0c1tpXSA9IG9mZnNldHNbaSAtIDFdICsgc2hhcGVzW2ldW2F4aXNdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFubmVsID0gY2hhbm5lbHNbYXhpc107XG4gICAgICAgIHZhciBsYXN0Q2hhbm5lbHMgPSBjaGFubmVscy5zbGljZSgtMik7XG4gICAgICAgIHZhciBhbGxDaGFubmVscyA9IGNoYW5uZWxzLmpvaW4oKTtcbiAgICAgICAgdmFyIGdldFZhbHVlU25pcHBldCA9IFwiaWYgKFwiICsgY2hhbm5lbCArIFwiIDwgXCIgKyBvZmZzZXRzWzBdICsgXCIpIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgIGdldFQwKFwiICsgYWxsQ2hhbm5lbHMgKyBcIiksIHZlYzIoXCIgKyBsYXN0Q2hhbm5lbHMuam9pbigpICsgXCIpKTtcXG4gICAgICAgIH1cIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBvZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2hpZnRfMSA9IG9mZnNldHNbaSAtIDFdO1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlID49IGNvbXBhcmlzb24gYmVsb3cgbWF5IHNlZW0gdW5uZWNlc3NhcnkgZ2l2ZW4gdGhlIGNoZWNrXG4gICAgICAgICAgICAvLyBhYm92ZSBidXQgaXMgbmVlZGVkIHRvIHdvcmthcm91bmQgYnJhbmNoIGV4ZWN1dGlvbiBpc3N1ZXMgb24gc29tZVxuICAgICAgICAgICAgLy8gZGV2aWNlcy4gSXQgbWFrZXMgYWxsIHRoZSBjb25kaXRpb25zIGV4Y2x1c2l2ZSB3aXRob3V0IHJlbHlpbmcgb25cbiAgICAgICAgICAgIC8vIGV4ZWN1dGlvbiBvcmRlci5cbiAgICAgICAgICAgIGdldFZhbHVlU25pcHBldCArPSBcIlxcbiAgICAgICAgaWYgKFwiICsgY2hhbm5lbCArIFwiIDwgXCIgKyBvZmZzZXRzW2ldICsgXCIgICYmIFwiICsgY2hhbm5lbCArIFwiID49IFwiICsgb2Zmc2V0c1tpIC0gMV0gKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICBnZXRUXCIgKyBpICsgXCIoXCIgKyBzaGlmdGVkQ2hhbm5lbHMoY2hhbm5lbHMsIGNoYW5uZWwsIHNoaWZ0XzEpICsgXCIpLFxcbiAgICAgICAgICAgIHZlYzIoXCIgKyBzaGlmdGVkQ2hhbm5lbHMobGFzdENoYW5uZWxzLCBjaGFubmVsLCBzaGlmdF8xKSArIFwiKSk7XFxuICAgICAgICB9XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IG9mZnNldHMubGVuZ3RoO1xuICAgICAgICB2YXIgc2hpZnQgPSBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGdldFZhbHVlU25pcHBldCArPSBcIlxcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgIGdldFRcIiArIGxhc3RJbmRleCArIFwiKFwiICsgc2hpZnRlZENoYW5uZWxzKGNoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCkgKyBcIiksXFxuICAgICAgICAgIHZlYzIoXCIgKyBzaGlmdGVkQ2hhbm5lbHMobGFzdENoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCkgKyBcIikpO1wiO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBmbG9hdCBnZXRWYWx1ZShcIiArIGNoYW5uZWxzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gJ2ludCAnICsgeDsgfSkgKyBcIikge1xcbiAgICAgICAgXCIgKyBnZXRWYWx1ZVNuaXBwZXQgKyBcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoZ2V0VmFsdWUoXCIgKyBjb29yZHMgKyBcIiksIDAuLCAwLiwgMC4pO1xcblxcbiAgICAgICAgXCIgKyBjb29yZHNbcmFuayAtIDFdICsgXCIgPSBcIiArIGNvb3Jkc1tyYW5rIC0gMV0gKyBcIiArIDE7XFxuICAgICAgICBpZiAoXCIgKyBjb29yZHNbcmFuayAtIDFdICsgXCIgPCBcIiArIHNoYXBlW3JhbmsgLSAxXSArIFwiKSB7XFxuICAgICAgICAgIHJlc3VsdC5nID0gZ2V0VmFsdWUoXCIgKyBjb29yZHMgKyBcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIiArIGNvb3Jkc1tyYW5rIC0gMl0gKyBcIiA9IFwiICsgY29vcmRzW3JhbmsgLSAyXSArIFwiICsgMTtcXG4gICAgICAgIGlmIChcIiArIGNvb3Jkc1tyYW5rIC0gMl0gKyBcIiA8IFwiICsgc2hhcGVbcmFuayAtIDJdICsgXCIpIHtcXG4gICAgICAgICAgcmVzdWx0LmEgPSBnZXRWYWx1ZShcIiArIGNvb3JkcyArIFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiICsgY29vcmRzW3JhbmsgLSAxXSArIFwiID0gXCIgKyBjb29yZHNbcmFuayAtIDFdICsgXCIgLSAxO1xcbiAgICAgICAgaWYgKFwiICsgY29vcmRzW3JhbmsgLSAyXSArIFwiIDwgXCIgKyBzaGFwZVtyYW5rIC0gMl0gKyBcIiAmJlxcbiAgICAgICAgICAgIFwiICsgY29vcmRzW3JhbmsgLSAxXSArIFwiIDwgXCIgKyBzaGFwZVtyYW5rIC0gMV0gKyBcIikge1xcbiAgICAgICAgICByZXN1bHQuYiA9IGdldFZhbHVlKFwiICsgY29vcmRzICsgXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbmNhdFBhY2tlZFByb2dyYW07XG59KCkpO1xuLyoqXG4gKiBSZXR1cm4gYW4gZXhwcmVzc2lvbiBmb3IgY29vcmRpbmF0ZXMgaW50byBhIHZlY3RvciB3aGVyZSBhIGdpdmVuIGNoYW5uZWxcbiAqIHdpbGwgYmUgb2Zmc2V0IGJ5IFtzaGlmdF0uXG4gKlxuICogQHBhcmFtIGNoYW5uZWxzIHRoZSBjaGFubmVscyB0byBjb25zaWRlclxuICogQHBhcmFtIGNoYW5uZWwgdGhlIGNoYW5uZWwgd2Ugd2FudCBzaGlmdGVkXG4gKiBAcGFyYW0gc2hpZnQgIHRoZSBhbW91bnQgdG8gc3VidHJhY3QgZnJvbSB0aGUgY2hhbm5lbC5cbiAqXG4gKiBAcmV0dXJucyBhIHN0cmluZyBvZiB0aGUgZm9ybSAneCwgeS1bc2hpZnRdLCB6JyB3aGVyZSBhbnkgb25lIGNoYW5uZWwgY2FuXG4gKiBoYXZlIHRoZSBzaGlmdCBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBzaGlmdGVkQ2hhbm5lbHMoY2hhbm5lbHMsIGNoYW5uZWwsIHNoaWZ0KSB7XG4gICAgdmFyIGNoYW5uZWxJZHggPSBjaGFubmVscy5pbmRleE9mKGNoYW5uZWwpO1xuICAgIHZhciByZXMgPSBjaGFubmVscy5tYXAoZnVuY3Rpb24gKGMsIGlkeCkge1xuICAgICAgICBpZiAoaWR4ID09PSBjaGFubmVsSWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gYyArIFwiIC0gXCIgKyBzaGlmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcy5qb2luKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGltYWcoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgaW5wdXQgPSBpbnB1dHMuaW5wdXQ7XG4gICAgdmFyIGlucHV0RGF0YSA9IGJhY2tlbmQudGV4RGF0YS5nZXQoaW5wdXQuZGF0YUlkKTtcbiAgICByZXR1cm4gaWRlbnRpdHkoeyBpbnB1dHM6IHsgeDogaW5wdXREYXRhLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG59XG52YXIgaW1hZ0NvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5JbWFnLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGltYWdcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEltcGwkMShpbnB1dHMsIGF4aXMsIGJhY2tlbmQpIHtcbiAgICB2YXIgZHR5cGUgPSBpbnB1dHNbMF0uZHR5cGU7XG4gICAgaWYgKGR0eXBlID09PSAnY29tcGxleDY0Jykge1xuICAgICAgICB2YXIgcmVhbHMgPSBpbnB1dHMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiByZWFsKHsgaW5wdXRzOiB7IGlucHV0OiB0IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7IH0pO1xuICAgICAgICB2YXIgaW1hZ3MgPSBpbnB1dHMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBpbWFnKHsgaW5wdXRzOiB7IGlucHV0OiB0IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7IH0pO1xuICAgICAgICB2YXIgcmVhbENvbmNhdGVkID0gY29uY2F0SW1wbCQxKHJlYWxzLCBheGlzLCBiYWNrZW5kKTtcbiAgICAgICAgdmFyIGltYWdDb25jYXRlZCA9IGNvbmNhdEltcGwkMShpbWFncywgYXhpcywgYmFja2VuZCk7XG4gICAgICAgIHZhciByZXN1bHRfMSA9IGNvbXBsZXgoeyBpbnB1dHM6IHsgcmVhbDogcmVhbENvbmNhdGVkLCBpbWFnOiBpbWFnQ29uY2F0ZWQgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgcmVhbHMuZm9yRWFjaChmdW5jdGlvbiAocikgeyByZXR1cm4gYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyKTsgfSk7XG4gICAgICAgIGltYWdzLmZvckVhY2goZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSk7IH0pO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlYWxDb25jYXRlZCk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaW1hZ0NvbmNhdGVkKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdF8xO1xuICAgIH1cbiAgICAvLyBSdW4gb24gY3B1IGlmIGR0eXBlIGlzIHN0cmluZy4gRm9yIHN0cmluZywgdGhlIGJhY2tlbmQgcmVwcmVzZW50cyBpdFxuICAgIC8vIGFzIFVpbnQ4QXJyYXlbXSwgd2hlcmUgZWFjaCBVaW50OEFycmF5IGlzIGEgY2hhcmFjdGVyLiBHaXZlbiB0aGF0IHRoZVxuICAgIC8vIGNvbXB1dGF0aW9uIGlzIG9ubHkgb24gdGhlIG91dGVyIGFycmF5LCB1cGxvYWRpbmcgdGhlIHdob2xlIGRhdGEgb250b1xuICAgIC8vIGdwdSBpcyB3YXN0ZWZ1bC4gQWxzbywgY3VycmVudGx5IHdlYmdsIGRvZXNuJ3QgaGF2ZSBhIGRlc2lnbiB0b1xuICAgIC8vIHVwbG9hZCBhbmQgcmV0cmlldmUgVWludDhBcnJheVtdIGJldHdlZW4gY3B1IGFuZCBncHUuIFRoZXJlZm9yZSwgd2VcbiAgICAvLyBqdXN0IHJ1biB0aGUga2VybmVsIG9uIGNwdSBpZiBkdHlwZSBpcyBzdHJpbmcuXG4gICAgaWYgKGR0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgX2EgPSBjb21wdXRlVGVuc29yczJEKGlucHV0cywgYXhpcywgYmFja2VuZCksIHRlbnNvcnMyRF8xID0gX2EudGVuc29yczJELCBvdXRTaGFwZV8xID0gX2Eub3V0U2hhcGU7XG4gICAgICAgIHZhciBpbnB1dHNWYWxTaGFwZXMgPSB0ZW5zb3JzMkRfMS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHM6IGJhY2tlbmQucmVhZFN5bmModC5kYXRhSWQpLCBzaGFwZTogdC5zaGFwZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNpbXBseUNvbmNhdCA9IHRlbnNvcnMyRF8xWzBdLnNoYXBlWzBdID09PSAxO1xuICAgICAgICB2YXIgb3V0VmFscyA9IGNvbmNhdEltcGxDUFUoaW5wdXRzVmFsU2hhcGVzLCBvdXRTaGFwZV8xLCBkdHlwZSwgc2ltcGx5Q29uY2F0KTtcbiAgICAgICAgdmFyIGZpbmFsT3V0U2hhcGUgPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZU91dFNoYXBlKGlucHV0cy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuc2hhcGU7IH0pLCBheGlzKTtcbiAgICAgICAgdmFyIG91dEluZm8gPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKGZpbmFsT3V0U2hhcGUsIGR0eXBlLCBvdXRWYWxzKTtcbiAgICAgICAgdGVuc29yczJEXzEuZm9yRWFjaChmdW5jdGlvbiAodCkgeyByZXR1cm4gYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh0KTsgfSk7XG4gICAgICAgIHJldHVybiBvdXRJbmZvO1xuICAgIH1cbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA+IHRmLmVudigpLmdldE51bWJlcignV0VCR0xfTUFYX1RFWFRVUkVTX0lOX1NIQURFUicpKSB7XG4gICAgICAgIHZhciBtaWRJbmRleCA9IE1hdGguZmxvb3IoaW5wdXRzLmxlbmd0aCAvIDIpO1xuICAgICAgICB2YXIgbGVmdFNpZGUgPSBjb25jYXRJbXBsJDEoaW5wdXRzLnNsaWNlKDAsIG1pZEluZGV4KSwgYXhpcywgYmFja2VuZCk7XG4gICAgICAgIHZhciByaWdodFNpZGUgPSBjb25jYXRJbXBsJDEoaW5wdXRzLnNsaWNlKG1pZEluZGV4KSwgYXhpcywgYmFja2VuZCk7XG4gICAgICAgIHZhciByZXN1bHRfMiA9IGNvbmNhdEltcGwkMShbbGVmdFNpZGUsIHJpZ2h0U2lkZV0sIGF4aXMsIGJhY2tlbmQpO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGxlZnRTaWRlKTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyaWdodFNpZGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0XzI7XG4gICAgfVxuICAgIGlmICh0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlMnKSAmJlxuICAgICAgICBpbnB1dHNbMF0uc2hhcGUubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgcHJvZ3JhbV8xID0gbmV3IENvbmNhdFBhY2tlZFByb2dyYW0oaW5wdXRzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5zaGFwZTsgfSksIGF4aXMpO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbV8xLCBpbnB1dHMsIGR0eXBlKTtcbiAgICB9XG4gICAgdmFyIF9iID0gY29tcHV0ZVRlbnNvcnMyRChpbnB1dHMsIGF4aXMsIGJhY2tlbmQpLCB0ZW5zb3JzMkQgPSBfYi50ZW5zb3JzMkQsIG91dFNoYXBlID0gX2Iub3V0U2hhcGU7XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgQ29uY2F0UHJvZ3JhbSh0ZW5zb3JzMkQubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnNoYXBlOyB9KSk7XG4gICAgdmFyIHJlc3VsdCA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIHRlbnNvcnMyRCwgZHR5cGUpO1xuICAgIHRlbnNvcnMyRC5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IHJldHVybiBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHIpOyB9KTtcbiAgICB2YXIgcmVzaGFwZWRSZXN1bHQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHJlc3VsdCB9LCBhdHRyczogeyBzaGFwZTogb3V0U2hhcGUgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc2hhcGVkUmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVRlbnNvcnMyRChpbnB1dHMsIGF4aXMsIGJhY2tlbmQpIHtcbiAgICAvLyBBbnkgY29uY2F0IG9mIG4tZGltZW5zaW9uYWwgdGVuc29ycyBhY3Jvc3MgYW55IGF4aXMgY2FuIGJlIHJlZHVjZWQgdG9cbiAgICAvLyBhIGNvbmNhdGVuYXRpb24gb2YgdHdvLWRpbWVuc2lvbmFsIHRlbnNvcnMgYWNyb3NzIHRoZSBheGlzIDEgYnkgZmlyc3RcbiAgICAvLyBwYXJ0aXRpb25pbmcgdGhlIGF4ZXMgb2YgdGhlIG9yaWdpbmFsIHRlbnNvcnMgaW50byB0aG9zZSBsZXNzIHRoYW4gdGhlXG4gICAgLy8gYXhpcyB0byBiZSBjb25jYXRlbmF0ZWQgYW5kIHRoZSByZXN0LiBUaGVuIHJlc2hhcGUgdGhlIHRlbnNvcnNcbiAgICAvLyBpbnRvIGEgdHdvLWRpbWVuc2lvbmFsIHRlbnNvciBieSBjb2xsYXBzaW5nIHRoZXNlIHR3byBzZXRzIG9mIGF4ZXMgYW5kXG4gICAgLy8gY29uY2F0ZW5hdGUgdGhlIHJlc3VsdGluZyBtYXRyaWNlcyBhY3Jvc3MgdGhlIGF4aXMgMSwgZmluYWxseSByZXNoYXBpbmdcbiAgICAvLyB0aGUgcmVzdWx0IHRvIGhhdmUgdGhlIHByb3BlciBzaGFwZS5cbiAgICB2YXIgb3V0U2hhcGUgPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZU91dFNoYXBlKGlucHV0cy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuc2hhcGU7IH0pLCBheGlzKTtcbiAgICB2YXIgdGVuc29yczJEID0gaW5wdXRzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcmVzaGFwZSh7XG4gICAgICAgIGlucHV0czogeyB4OiB4IH0sXG4gICAgICAgIGF0dHJzOiB7IHNoYXBlOiBbLTEsIHRmLnV0aWwuc2l6ZUZyb21TaGFwZSh4LnNoYXBlLnNsaWNlKGF4aXMpKV0gfSxcbiAgICAgICAgYmFja2VuZDogYmFja2VuZFxuICAgIH0pOyB9KTtcbiAgICByZXR1cm4geyB0ZW5zb3JzMkQ6IHRlbnNvcnMyRCwgb3V0U2hhcGU6IG91dFNoYXBlIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGF4aXMgPSBhdHRycy5heGlzO1xuICAgIHZhciAkYXhpcyA9IHRmLnV0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgaW5wdXRzWzBdLnNoYXBlKVswXTtcbiAgICB2YXIgb3V0U2hhcGUgPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZU91dFNoYXBlKGlucHV0cy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuc2hhcGU7IH0pLCAkYXhpcyk7XG4gICAgaWYgKHRmLnV0aWwuc2l6ZUZyb21TaGFwZShvdXRTaGFwZSkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8ob3V0U2hhcGUsIGlucHV0c1swXS5kdHlwZSwgW10pO1xuICAgIH1cbiAgICAvLyBLZWVwIG9ubHkgbm9uLWVtcHR5IHRlbnNvcnMgKGlnbm9yZSB0ZW5zb3JzIHdpdGggMCBpbiB0aGVpciBzaGFwZSkuXG4gICAgdmFyICRpbnB1dHMgPSBpbnB1dHMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0Zi51dGlsLnNpemVGcm9tU2hhcGUodC5zaGFwZSkgPiAwOyB9KTtcbiAgICBpZiAoJGlucHV0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KHsgaW5wdXRzOiB7IHg6ICRpbnB1dHNbMF0gfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB9XG4gICAgdmFyIHNoYXBlcyA9ICRpbnB1dHMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnNoYXBlOyB9KTtcbiAgICB0Zi5iYWNrZW5kX3V0aWwuYXNzZXJ0UGFyYW1zQ29uc2lzdGVudChzaGFwZXMsICRheGlzKTtcbiAgICByZXR1cm4gY29uY2F0SW1wbCQxKCRpbnB1dHMsICRheGlzLCBiYWNrZW5kKTtcbn1cbnZhciBjb25jYXRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQ29uY2F0LFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGNvbmNhdFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIENvbnYyRFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJEUHJvZ3JhbShjb252SW5mbywgYWRkQmlhcywgYWN0aXZhdGlvbiwgaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cywgaGFzTGVha3lyZWx1QWxwaGEpIHtcbiAgICAgICAgaWYgKGFkZEJpYXMgPT09IHZvaWQgMCkgeyBhZGRCaWFzID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGFjdGl2YXRpb24gPT09IHZvaWQgMCkgeyBhY3RpdmF0aW9uID0gbnVsbDsgfVxuICAgICAgICBpZiAoaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9PT0gdm9pZCAwKSB7IGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaGFzTGVha3lyZWx1QWxwaGEgPT09IHZvaWQgMCkgeyBoYXNMZWFreXJlbHVBbHBoYSA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihjb252SW5mby5pbkNoYW5uZWxzIC8gNCkgKiA0O1xuICAgICAgICB2YXIgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSBjb252SW5mby5pbkNoYW5uZWxzICUgNDtcbiAgICAgICAgdmFyIGlzQ2hhbm5lbHNMYXN0ID0gY29udkluZm8uZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gICAgICAgIHZhciByb3dEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDEgOiAyO1xuICAgICAgICB2YXIgY29sRGltID0gaXNDaGFubmVsc0xhc3QgPyAyIDogMztcbiAgICAgICAgdmFyIGNoYW5uZWxEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDMgOiAxO1xuICAgICAgICB2YXIgYWN0aXZhdGlvblNuaXBwZXQgPSAnJywgYXBwbHlBY3RpdmF0aW9uU25pcHBldCA9ICcnO1xuICAgICAgICBpZiAoYWN0aXZhdGlvbikge1xuICAgICAgICAgICAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uU25pcHBldCA9IFwiZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XFxuICAgICAgICAgIGZsb2F0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcXG4gICAgICAgICAgXCIgKyBhY3RpdmF0aW9uICsgXCJcXG4gICAgICAgIH1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0xlYWt5cmVsdUFscGhhKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBcImZsb2F0IGFjdGl2YXRpb24oZmxvYXQgYSkge1xcbiAgICAgICAgICBmbG9hdCBiID0gZ2V0TGVha3lyZWx1QWxwaGFBdE91dENvb3JkcygpO1xcbiAgICAgICAgICBcIiArIGFjdGl2YXRpb24gKyBcIlxcbiAgICAgICAgfVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBcIlxcbiAgICAgICAgICBmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IHgpIHtcXG4gICAgICAgICAgICBcIiArIGFjdGl2YXRpb24gKyBcIlxcbiAgICAgICAgICB9XFxuICAgICAgICBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwcGx5QWN0aXZhdGlvblNuaXBwZXQgPSBcInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRkQmlhc1NuaXBwZXQgPSBhZGRCaWFzID8gJ3Jlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTsnIDogJyc7XG4gICAgICAgIGlmIChhZGRCaWFzKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgncHJlbHVBY3RpdmF0aW9uV2VpZ2h0cycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNMZWFreXJlbHVBbHBoYSkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2xlYWt5cmVsdUFscGhhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgXCIgKyBhY3RpdmF0aW9uU25pcHBldCArIFwiXFxuXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkc1tcIiArIGNoYW5uZWxEaW0gKyBcIl07XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPVxcbiAgICAgICAgICAgIGl2ZWMyKGNvb3Jkc1tcIiArIHJvd0RpbSArIFwiXSwgY29vcmRzW1wiICsgY29sRGltICsgXCJdKSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiICsgZGlsYXRpb25IZWlnaHQgKyBcIjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIGNvbnZJbmZvLmluSGVpZ2h0ICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiICsgZGlsYXRpb25XaWR0aCArIFwiO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyBjb252SW5mby5pbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIjsgZDEgKz0gNCkge1xcbiAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAzLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBpZiAoXCIgKyBpc0NoYW5uZWxzTGFzdCArIFwiKSB7XFxuICAgICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMylcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxLCB4UiwgeEMpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeFIsIHhDKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDIsIHhSLCB4QyksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAzLCB4UiwgeEMpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoXCIgKyAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG5cXG4gICAgICAgICAgICAgIGlmIChcIiArIGlzQ2hhbm5lbHNMYXN0ICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiKSAqXFxuICAgICAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgZDIpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgeFIsIHhDKSAqXFxuICAgICAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgZDIpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSwgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgaWYgKFwiICsgaXNDaGFubmVsc0xhc3QgKyBcIikge1xcbiAgICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSlcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIHhSLCB4QyksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEsIHhSLCB4QylcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMiwgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgaWYgKFwiICsgaXNDaGFubmVsc0xhc3QgKyBcIikge1xcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMilcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIHhSLCB4QyksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEsIHhSLCB4QyksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDIsIHhSLCB4QylcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSBkb3RQcm9kO1xcbiAgICAgICAgXCIgKyBhZGRCaWFzU25pcHBldCArIFwiXFxuICAgICAgICBcIiArIGFwcGx5QWN0aXZhdGlvblNuaXBwZXQgKyBcIlxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRFByb2dyYW07XG59KCkpO1xudmFyIENvbnYzRFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjNEUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnVyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgICAgIHZhciBwYWRGcm9udCA9IGNvbnZJbmZvLnBhZEluZm8uZnJvbnQ7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBzdHJpZGVEZXB0aCA9IGNvbnZJbmZvLnN0cmlkZURlcHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGRpbGF0aW9uRGVwdGggPSBjb252SW5mby5kaWxhdGlvbkRlcHRoO1xuICAgICAgICB2YXIgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodDtcbiAgICAgICAgdmFyIGRpbGF0aW9uV2lkdGggPSBjb252SW5mby5kaWxhdGlvbldpZHRoO1xuICAgICAgICB2YXIgZmlsdGVyRGVwdGggPSBjb252SW5mby5maWx0ZXJEZXB0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBpbnB1dERlcHRoTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKGNvbnZJbmZvLmluQ2hhbm5lbHMgLyA0KSAqIDQ7XG4gICAgICAgIHZhciBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IGNvbnZJbmZvLmluQ2hhbm5lbHMgJSA0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMyBzdHJpZGVzID0gaXZlYzMoXCIgKyBzdHJpZGVEZXB0aCArIFwiLCBcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIiArIHBhZEZyb250ICsgXCIsIFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnU7XFxuXFxuICAgICAgICBpdmVjMyB4RlJDQ29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhGUkNDb3JuZXIueTtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhGUkNDb3JuZXIuejtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgPywgZDEpIHdpdGggdyg6LCA6LCA6LCBkMSwgZDIpIHRvIGdldFxcbiAgICAgICAgLy8geSh5RiwgeVIsIHlDLCBkMikuID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbFxcbiAgICAgICAgLy8gdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3RiA9IDA7IHdGIDwgXCIgKyBmaWx0ZXJEZXB0aCArIFwiOyB3RisrKSB7XFxuICAgICAgICAgIGludCB4RiA9IHhGQ29ybmVyICsgd0YgKiBcIiArIGRpbGF0aW9uRGVwdGggKyBcIjtcXG5cXG4gICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSBcIiArIGNvbnZJbmZvLmluRGVwdGggKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiICsgZGlsYXRpb25IZWlnaHQgKyBcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIiArIGRpbGF0aW9uV2lkdGggKyBcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyBjb252SW5mby5pbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIjsgZDEgKz0gNCkge1xcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAzKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAyLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDMsIGQyKVxcbiAgICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9XFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIikgKlxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgZDIpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEsIGQyKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDIpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDIsIGQyKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjNEUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBJbTJDb2xQYWNrZWRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEltMkNvbFBhY2tlZFByb2dyYW0ob3V0cHV0U2hhcGUsIGlucHV0U2hhcGUsIGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLnBhY2tlZElucHV0cyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFja2VkT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aCwgaW5DaGFubmVscyA9IGNvbnZJbmZvLmluQ2hhbm5lbHMsIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGgsIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodCwgcGFkSW5mbyA9IGNvbnZJbmZvLnBhZEluZm8sIG91dFdpZHRoID0gY29udkluZm8ub3V0V2lkdGgsIGRpbGF0aW9uV2lkdGggPSBjb252SW5mby5kaWxhdGlvbldpZHRoLCBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0LCBkYXRhRm9ybWF0ID0gY29udkluZm8uZGF0YUZvcm1hdDtcbiAgICAgICAgdmFyIGxlZnQgPSBwYWRJbmZvLmxlZnQsIHRvcCA9IHBhZEluZm8udG9wO1xuICAgICAgICB2YXIgaXRlbXNQZXJCbG9ja1JvdyA9IGluQ2hhbm5lbHMgKiBmaWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIGdsc2wgPSBnZXRHbHNsRGlmZmVyZW5jZXMoKTtcbiAgICAgICAgdmFyIGlzQ2hhbm5lbHNMYXN0ID0gZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gICAgICAgIHZhciByb3dEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDAgOiAxO1xuICAgICAgICB2YXIgY29sRGltID0gaXNDaGFubmVsc0xhc3QgPyAxIDogMjtcbiAgICAgICAgdmFyIHVucm9sbGVkID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDw9IDE7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPD0gMTsgY29sKyspIHtcbiAgICAgICAgICAgICAgICB1bnJvbGxlZCArPSBcIlxcbiAgICAgICAgICBibG9ja0luZGV4ID0gcmMueSArIFwiICsgY29sICsgXCI7XFxuICAgICAgICAgIHBvcyA9IHJjLnggKyBcIiArIHJvdyArIFwiO1xcblxcbiAgICAgICAgICBpZihibG9ja0luZGV4IDwgXCIgKyBvdXRwdXRTaGFwZVsxXSArIFwiICYmIHBvcyA8IFwiICsgb3V0cHV0U2hhcGVbMF0gKyBcIikge1xcbiAgICAgICAgICAgIG9mZnNldFkgPSBpbnQoYmxvY2tJbmRleCAvIChcIiArIG91dFdpZHRoICsgXCIpKSAqIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIgLSBcIiArIHRvcCArIFwiO1xcbiAgICAgICAgICAgIGQwID0gb2Zmc2V0WSArIFwiICsgZGlsYXRpb25IZWlnaHQgKyBcIiAqIChwb3MgLyBcIiArIGl0ZW1zUGVyQmxvY2tSb3cgKyBcIik7XFxuXFxuICAgICAgICAgICAgaWYoZDAgPCBcIiArIGlucHV0U2hhcGVbcm93RGltXSArIFwiICYmIGQwID49IDApIHtcXG5cXG4gICAgICAgICAgICAgIG9mZnNldFggPSBpbnQobW9kKGZsb2F0KGJsb2NrSW5kZXgpLCBcIiArIG91dFdpZHRoICsgXCIuKSAqIFwiICsgc3RyaWRlV2lkdGggKyBcIi4gLSBcIiArIGxlZnQgKyBcIi4pO1xcbiAgICAgICAgICAgICAgZDEgPSBvZmZzZXRYICsgXCIgKyBkaWxhdGlvbldpZHRoICsgXCIgKiAoaW50KG1vZChmbG9hdChwb3MpLCBcIiArIGl0ZW1zUGVyQmxvY2tSb3cgKyBcIi4pIC8gXCIgKyBpbkNoYW5uZWxzICsgXCIuKSk7XFxuXFxuICAgICAgICAgICAgICBpZihkMSA8IFwiICsgaW5wdXRTaGFwZVtjb2xEaW1dICsgXCIgJiYgZDEgPj0gMCkge1xcblxcbiAgICAgICAgICAgICAgICBjaCA9IGludChtb2QoZmxvYXQocG9zKSwgXCIgKyBpbkNoYW5uZWxzICsgXCIuKSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChcIiArIGlzQ2hhbm5lbHNMYXN0ICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQxLCBjaCk7XFxuICAgICAgICAgICAgICAgICAgcmVzdWx0W1wiICsgKHJvdyAqIDIgKyBjb2wpICsgXCJdID0gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgICAgICAgIGdldEEoZDAsIGludChpbm5lckRpbXMueCksXFxuICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQwLCBkMSk7XFxuICAgICAgICAgICAgICAgICAgcmVzdWx0W1wiICsgKHJvdyAqIDIgKyBjb2wpICsgXCJdID0gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgICAgICAgIGdldEEoY2gsIGludChpbm5lckRpbXMueCksXFxuICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwKTtcXG5cXG4gICAgICAgIGludCBibG9ja0luZGV4LCBwb3MsIG9mZnNldFksIGQwLCBvZmZzZXRYLCBkMSwgY2g7XFxuICAgICAgICB2ZWMyIGlubmVyRGltcztcXG5cXG4gICAgICAgIFwiICsgdW5yb2xsZWQgKyBcIlxcblxcbiAgICAgICAgXCIgKyBnbHNsLm91dHB1dCArIFwiID0gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBJbTJDb2xQYWNrZWRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLy8gRm9yIDF4MSBrZXJuZWxzIHRoYXQgaXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IHBvaW50IGluIHRoZSBpbnB1dCwgY29udm9sdXRpb25cbi8vIGNhbiBiZSBleHByZXNzZWQgYXMgbWF0cml4IG11bHRpcGxpY2F0aW9uICh3aXRob3V0IG5lZWQgZm9yIG1lbW9yeVxuLy8gcmVtYXBwaW5nKS5cbmZ1bmN0aW9uIGNvbnYyZEJ5TWF0TXVsKF9hKSB7XG4gICAgdmFyIHggPSBfYS54LCBmaWx0ZXIgPSBfYS5maWx0ZXIsIGNvbnZJbmZvID0gX2EuY29udkluZm8sIGJhY2tlbmQgPSBfYS5iYWNrZW5kLCBfYiA9IF9hLmJpYXMsIGJpYXMgPSBfYiA9PT0gdm9pZCAwID8gbnVsbCA6IF9iLCBfYyA9IF9hLnByZWx1QWN0aXZhdGlvbldlaWdodHMsIHByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBfYyA9PT0gdm9pZCAwID8gbnVsbCA6IF9jLCBfZCA9IF9hLmxlYWt5cmVsdUFscGhhLCBsZWFreXJlbHVBbHBoYSA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsIF9lID0gX2EuYWN0aXZhdGlvbiwgYWN0aXZhdGlvbiA9IF9lID09PSB2b2lkIDAgPyBudWxsIDogX2U7XG4gICAgLy8gUmVzaGFwZXMgY29udjJEIGlucHV0IHRvIDJEIHRlbnNvcnMsIHVzZXMgbWF0TXVsIGFuZCB0aGVuIHJlc2hhcGUgdGhlXG4gICAgLy8gcmVzdWx0IGZyb20gMkQgdG8gNEQuXG4gICAgdmFyIHhTaGFwZSA9IHguc2hhcGU7XG4gICAgdmFyIHhUZXhEYXRhID0gYmFja2VuZC50ZXhEYXRhLmdldCh4LmRhdGFJZCk7XG4gICAgdmFyIHNoYXJlZE1hdE11bERpbSA9IGNvbnZJbmZvLmluQ2hhbm5lbHM7XG4gICAgdmFyIG91dGVyU2hhcGVYID0geFNoYXBlWzBdICogeFNoYXBlWzFdICogeFNoYXBlWzJdO1xuICAgIHZhciBvdXRlclNoYXBlRmlsdGVyID0gY29udkluZm8ub3V0Q2hhbm5lbHM7XG4gICAgdmFyIGlzQ2hhbm5lbHNMYXN0ID0gY29udkluZm8uZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gICAgdmFyIHRyYW5zcG9zZUEgPSBmYWxzZTtcbiAgICB2YXIgdHJhbnNwb3NlQiA9IGZhbHNlO1xuICAgIHZhciBvdXQ7XG4gICAgdmFyIGludGVybWVkaWF0ZXMgPSBbXTtcbiAgICAvLyBUT0RPOiBPbmNlIHJlZHVjdGlvbiBvcHMgYXJlIHBhY2tlZCwgYmF0Y2hNYXRNdWwgd2lsbCBhbHdheXMgYmUgcGFja2VkXG4gICAgLy8gYW5kIHdlIGNhbiByZW1vdmUgdGhpcyBjb25kaXRpb24uXG4gICAgdmFyIGJhdGNoTWF0TXVsV2lsbEJlVW5wYWNrZWQgPSAob3V0ZXJTaGFwZVggPT09IDEgfHwgb3V0ZXJTaGFwZUZpbHRlciA9PT0gMSkgJiZcbiAgICAgICAgc2hhcmVkTWF0TXVsRGltID4gTUFUTVVMX1NIQVJFRF9ESU1fVEhSRVNIT0xEO1xuICAgIHZhciByZXNoYXBlV2lsbEJlRXhwZW5zaXZlID0geFNoYXBlWzJdICUgMiAhPT0gMCAmJiAhIXhUZXhEYXRhLmlzUGFja2VkO1xuICAgIGlmIChiYXRjaE1hdE11bFdpbGxCZVVucGFja2VkIHx8ICF0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9MQVpJTFlfVU5QQUNLJykgfHxcbiAgICAgICAgIXRmLmVudigpLmdldEJvb2woJ1dFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlMnKSB8fFxuICAgICAgICAhcmVzaGFwZVdpbGxCZUV4cGVuc2l2ZSkge1xuICAgICAgICB2YXIgdGFyZ2V0U2hhcGUgPSBpc0NoYW5uZWxzTGFzdCA/IHhTaGFwZVswXSAqIHhTaGFwZVsxXSAqIHhTaGFwZVsyXSA6XG4gICAgICAgICAgICB4U2hhcGVbMF0gKiB4U2hhcGVbMl0gKiB4U2hhcGVbM107XG4gICAgICAgIHZhciB4UmVzaGFwZWQgPSByZXNoYXBlKHtcbiAgICAgICAgICAgIGlucHV0czogeyB4OiB4IH0sXG4gICAgICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICAgICAgYXR0cnM6IHsgc2hhcGU6IFsxLCB0YXJnZXRTaGFwZSwgY29udkluZm8uaW5DaGFubmVsc10gfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZpbHRlclJlc2hhcGVkID0gcmVzaGFwZSh7XG4gICAgICAgICAgICBpbnB1dHM6IHsgeDogZmlsdGVyIH0sXG4gICAgICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICAgICAgYXR0cnM6IHsgc2hhcGU6IFsxLCBjb252SW5mby5pbkNoYW5uZWxzLCBjb252SW5mby5vdXRDaGFubmVsc10gfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhdGNoTWF0TXVsSW1wbCh7XG4gICAgICAgICAgICBhOiB4UmVzaGFwZWQsXG4gICAgICAgICAgICBiOiBmaWx0ZXJSZXNoYXBlZCxcbiAgICAgICAgICAgIHRyYW5zcG9zZUE6IHRyYW5zcG9zZUEsXG4gICAgICAgICAgICB0cmFuc3Bvc2VCOiB0cmFuc3Bvc2VCLFxuICAgICAgICAgICAgYmFja2VuZDogYmFja2VuZCxcbiAgICAgICAgICAgIGJpYXM6IGJpYXMsXG4gICAgICAgICAgICBhY3RpdmF0aW9uOiBhY3RpdmF0aW9uLFxuICAgICAgICAgICAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0czogcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyxcbiAgICAgICAgICAgIGxlYWt5cmVsdUFscGhhOiBsZWFreXJlbHVBbHBoYVxuICAgICAgICB9KTtcbiAgICAgICAgb3V0ID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiByZXN1bHQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IGNvbnZJbmZvLm91dFNoYXBlIH0gfSk7XG4gICAgICAgIGludGVybWVkaWF0ZXMucHVzaCh4UmVzaGFwZWQpO1xuICAgICAgICBpbnRlcm1lZGlhdGVzLnB1c2goZmlsdGVyUmVzaGFwZWQpO1xuICAgICAgICBpbnRlcm1lZGlhdGVzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEZvbGxvd2luZyBvcHRpbWl6YXRpb24gaXMgc3BlY2lmaWMgdG8gcGFja2VkIHx4fCB3aXRoIG9kZCByb3cgY291bnRcbiAgICAgICAgLy8gKEZvciBleGFtcGxlLCBpbiBjaGFubmVsTGFzdCBtb2RlLCAncm93IGNvdW50JyByZWZlcnMgdG8geC5zaGFwZVsyXSk6XG4gICAgICAgIC8vIHdlIGF2b2lkIGV4cGVuc2l2ZSBwYWNrZWQgMngyIHJlc2hhcGUgYnkgcGFkZGluZyByb3cgY291bnQgdG8gbmV4dCxcbiAgICAgICAgLy8gZXZlbiBudW1iZXIuIFdoZW4geC5zaGFwZVsyXSBpcyBvZGQsIHRoZSByZXN1bHQgb2YgcGFja2VkIGJhdGNoTWF0TXVsIGlzXG4gICAgICAgIC8vIHRoZSBzYW1lIChoYXMgdGhlIHNhbWUgdGV4dHVyZSBsYXlvdXQgYW5kIGFuZCB2YWx1ZXMgaW4gdGhlIHRleHR1cmUpIGFzXG4gICAgICAgIC8vIGl0IGlzIGZvciBldmVuIHguc2hhcGVbMl0gKyAxLiBXZSBtYWtlIHRoZSBvZGQtcm93cyB0ZW5zb3IgdG8gbG9vayBsaWtlXG4gICAgICAgIC8vIGV2ZW4tcm93cyB0ZW5zb3IgYmVmb3JlIHRoZSBvcGVyYXRpb24gYW5kLCBhZnRlciB0aGUgYmF0Y2hNYXRNdWwsXG4gICAgICAgIC8vIGZpeCB0aGUgZXZlbi1yb3dzIHJlc3VsdCB0byBoYXZlIG9kZCBudW1iZXIgb2Ygcm93cy5cbiAgICAgICAgdmFyIHRhcmdldFNoYXBlID0gaXNDaGFubmVsc0xhc3QgP1xuICAgICAgICAgICAgeFNoYXBlWzBdICogeFNoYXBlWzFdICogKHhTaGFwZVsyXSArIDEpIDpcbiAgICAgICAgICAgIHhTaGFwZVswXSAqIHhTaGFwZVsyXSAqICh4U2hhcGVbM10gKyAxKTtcbiAgICAgICAgdmFyIHhSZXNoYXBlZF8xID0ge1xuICAgICAgICAgICAgZGF0YUlkOiB4LmRhdGFJZCxcbiAgICAgICAgICAgIHNoYXBlOiBbMSwgdGFyZ2V0U2hhcGUsIGNvbnZJbmZvLmluQ2hhbm5lbHNdLFxuICAgICAgICAgICAgZHR5cGU6IHguZHR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgLy8geFRleERhdGEuc2hhcGUgZ2V0cyByZWZlcmVuY2VkIGZyb20gR1BHUFVCaW5hcnkuaW5TaGFwZUluZm9zLlxuICAgICAgICAvLyBEZWNyZW1lbnRpbmcgcm93IGNvdW50LCBhZnRlciBiYXRjaE1hdE11bC0+Li4uLT5jb21waWxlUHJvZ3JhbSBsZWFkcyB0b1xuICAgICAgICAvLyBpbnZhbGlkIHJvdyBjb3VudCB3aXRoaW4gdGhlIHJlZmVyZW5jZSBpbiBHUEdQVUJpbmFyeS5pblNoYXBlSW5mb3MuXG4gICAgICAgIC8vIEFsdGVybmF0aXZlIGZpeCB3b3VsZCBiZSB0byBwcm92aWRlIGEgY29weSB0byBHUEdQVUJpbmFyeS5pblNoYXBlSW5mb3NcbiAgICAgICAgLy8gaW4gY29tcGlsZVByb2dyYW0gbWV0aG9kLCBidXQgdGhhdCB3b3VsZCBhZmZlY3QgY29tcGlsYXRpb24gb2YgYWxsXG4gICAgICAgIC8vIHByb2dyYW1zIC0gaW5zdGVhZCwgcHJvdmlkZSBhIGNvcHkgaGVyZSwgd2l0aCBldmVuIHJvdyBjb3VudCwgYmVmb3JlXG4gICAgICAgIC8vIGNhbGxpbmcgYmF0Y2hNYXRNdWwtPi4uLi0+Y29tcGlsZVByb2dyYW0gYW5kIGFmdGVyIHRoYXQsIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyB4VGV4RGF0YS5zaGFwZSBpcyByZXN0b3JlZC5cbiAgICAgICAgdmFyIG9yaWdpbmFsWFRleERhdGFTaGFwZSA9IHhUZXhEYXRhLnNoYXBlO1xuICAgICAgICB4VGV4RGF0YS5zaGFwZSA9IHhUZXhEYXRhLnNoYXBlLnNsaWNlKCk7XG4gICAgICAgIHhUZXhEYXRhLnNoYXBlW3hUZXhEYXRhLnNoYXBlLmxlbmd0aCAtIDJdKys7XG4gICAgICAgIHRmLnV0aWwuYXNzZXJ0KGlzUmVzaGFwZUZyZWUoeFRleERhdGEuc2hhcGUsIHhSZXNoYXBlZF8xLnNoYXBlKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJwYWNrZWQgcmVzaGFwZSBcIiArIHhUZXhEYXRhLnNoYXBlICsgXCIgdG8gXCIgKyB4UmVzaGFwZWRfMS5zaGFwZSArIFwiIGlzbid0IGZyZWVcIjsgfSk7XG4gICAgICAgIHZhciBmaWx0ZXJSZXNoYXBlZCA9IHJlc2hhcGUoe1xuICAgICAgICAgICAgaW5wdXRzOiB7IHg6IGZpbHRlciB9LFxuICAgICAgICAgICAgYmFja2VuZDogYmFja2VuZCxcbiAgICAgICAgICAgIGF0dHJzOiB7IHNoYXBlOiBbMSwgY29udkluZm8uaW5DaGFubmVscywgY29udkluZm8ub3V0Q2hhbm5lbHNdIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGludGVybWVkaWF0ZXMucHVzaChmaWx0ZXJSZXNoYXBlZCk7XG4gICAgICAgIHZhciBwb2ludHdpc2VDb252ID0gYmF0Y2hNYXRNdWxJbXBsKHtcbiAgICAgICAgICAgIGE6IHhSZXNoYXBlZF8xLFxuICAgICAgICAgICAgYjogZmlsdGVyUmVzaGFwZWQsXG4gICAgICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICAgICAgdHJhbnNwb3NlQTogdHJhbnNwb3NlQSxcbiAgICAgICAgICAgIHRyYW5zcG9zZUI6IHRyYW5zcG9zZUIsXG4gICAgICAgICAgICBiaWFzOiBiaWFzLFxuICAgICAgICAgICAgYWN0aXZhdGlvbjogYWN0aXZhdGlvbixcbiAgICAgICAgICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHM6IHByZWx1QWN0aXZhdGlvbldlaWdodHMsXG4gICAgICAgICAgICBsZWFreXJlbHVBbHBoYTogbGVha3lyZWx1QWxwaGFcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwb2ludHdpc2VDb252VGV4RGF0YSA9IGJhY2tlbmQudGV4RGF0YS5nZXQocG9pbnR3aXNlQ29udi5kYXRhSWQpO1xuICAgICAgICB0Zi51dGlsLmFzc2VydChwb2ludHdpc2VDb252VGV4RGF0YS5pc1BhY2tlZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2JhdGNoTWF0TXVsIHJlc3VsdCBpcyBleHBlY3RlZCB0byBiZSBwYWNrZWQnOyB9KTtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgaW5wdXQgc2hhcGUgdG8gb3JpZ2luYWwuXG4gICAgICAgIHhUZXhEYXRhLnNoYXBlID0gb3JpZ2luYWxYVGV4RGF0YVNoYXBlO1xuICAgICAgICAvLyBTZXQgdGhlIG91dHB1dCBzaGFwZSAtIHRoZXJlIGlzIG5vIG5lZWQgZm9yIGV4cGVuc2l2ZSByZXNoYXBlIGFzIGRhdGFcbiAgICAgICAgLy8gbGF5b3V0IGlzIGFscmVhZHkgY29ycmVjdC5cbiAgICAgICAgcG9pbnR3aXNlQ29udlRleERhdGEuc2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgb3V0ID0gaWRlbnRpdHkoeyBpbnB1dHM6IHsgeDogcG9pbnR3aXNlQ29udiB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICBvdXQuc2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgaW50ZXJtZWRpYXRlcy5wdXNoKHBvaW50d2lzZUNvbnYpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIGludGVybWVkaWF0ZXNfMSA9IGludGVybWVkaWF0ZXM7IF9pIDwgaW50ZXJtZWRpYXRlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaSA9IGludGVybWVkaWF0ZXNfMVtfaV07XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG4vLyBJbXBsZW1lbnRzIHRoZSBpbTJyb3cgYWxnb3JpdGhtIGFzIG91dGxpbmVkIGluIFwiSGlnaCBQZXJmb3JtYW5jZVxuLy8gQ29udm9sdXRpb25hbCBOZXVyYWwgTmV0d29ya3MgZm9yIERvY3VtZW50IFByb2Nlc3NpbmdcIiAoU3V2aXNvZnQsIDIwMDYpXG5mdW5jdGlvbiBjb252MmRXaXRoSW0yUm93KF9hKSB7XG4gICAgdmFyIHggPSBfYS54LCBmaWx0ZXIgPSBfYS5maWx0ZXIsIGNvbnZJbmZvID0gX2EuY29udkluZm8sIGJhY2tlbmQgPSBfYS5iYWNrZW5kLCBfYiA9IF9hLmJpYXMsIGJpYXMgPSBfYiA9PT0gdm9pZCAwID8gbnVsbCA6IF9iLCBfYyA9IF9hLnByZWx1QWN0aXZhdGlvbldlaWdodHMsIHByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBfYyA9PT0gdm9pZCAwID8gbnVsbCA6IF9jLCBfZCA9IF9hLmxlYWt5cmVsdUFscGhhLCBsZWFreXJlbHVBbHBoYSA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsIF9lID0gX2EuYWN0aXZhdGlvbiwgYWN0aXZhdGlvbiA9IF9lID09PSB2b2lkIDAgPyBudWxsIDogX2U7XG4gICAgLy8gUmVhcnJhbmdlcyBjb252MmQgaW5wdXQgc28gZWFjaCBibG9jayB0byBiZSBjb252b2x2ZWQgb3ZlciBmb3JtcyB0aGVcbiAgICAvLyBjb2x1bW4gb2YgYSBuZXcgbWF0cml4IHdpdGggc2hhcGUgW2ZpbHRlcldpZHRoICogZmlsdGVySGVpZ2h0ICpcbiAgICAvLyBpbkNoYW5uZWxzLCBvdXRIZWlnaHQgKiBvdXRXaWR0aF0uIFRoZSBmaWx0ZXIgaXMgYWxzbyByZWFycmFuZ2VkIHNvIGVhY2hcbiAgICAvLyBvdXRwdXQgY2hhbm5lbCBmb3JtcyBhIHJvdyBvZiBhIG5ldyBtYXRyaXggd2l0aCBzaGFwZSBbb3V0Q2hhbm5lbHMsXG4gICAgLy8gZmlsdGVyV2lkdGggKiBmaWx0ZXJIZWlnaHQgKiBpbkNoYW5uZWxzXS4gVGhlIGNvbnZvbHV0aW9uIGlzIHRoZW5cbiAgICAvLyBjb21wdXRlZCBieSBtdWx0aXBseWluZyB0aGVzZSBtYXRyaWNlcyBhbmQgcmVzaGFwaW5nIHRoZSByZXN1bHQuXG4gICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGgsIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodCwgaW5DaGFubmVscyA9IGNvbnZJbmZvLmluQ2hhbm5lbHMsIG91dFdpZHRoID0gY29udkluZm8ub3V0V2lkdGgsIG91dEhlaWdodCA9IGNvbnZJbmZvLm91dEhlaWdodCwgZGF0YUZvcm1hdCA9IGNvbnZJbmZvLmRhdGFGb3JtYXQ7XG4gICAgdmFyIGlzQ2hhbm5lbHNMYXN0ID0gZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gICAgdmFyIHNoYXJlZERpbSA9IGZpbHRlcldpZHRoICogZmlsdGVySGVpZ2h0ICogaW5DaGFubmVscztcbiAgICB2YXIgbnVtQ29scyA9IG91dEhlaWdodCAqIG91dFdpZHRoO1xuICAgIHZhciB4MkNvbFNoYXBlID0gW3NoYXJlZERpbSwgbnVtQ29sc107XG4gICAgdmFyIHRyYW5zcG9zZUEgPSB0cnVlO1xuICAgIHZhciB0cmFuc3Bvc2VCID0gZmFsc2U7XG4gICAgdmFyIGludGVybWVkaWF0ZXMgPSBbXTtcbiAgICB2YXIgeFNxdWVlemVkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiB4LnNoYXBlLnNsaWNlKDEpIH0gfSk7XG4gICAgdmFyIHcyUm93ID0gcmVzaGFwZSh7XG4gICAgICAgIGlucHV0czogeyB4OiBmaWx0ZXIgfSxcbiAgICAgICAgYmFja2VuZDogYmFja2VuZCxcbiAgICAgICAgYXR0cnM6IHsgc2hhcGU6IFsxLCBzaGFyZWREaW0sIHRmLnV0aWwuc2l6ZUZyb21TaGFwZShmaWx0ZXIuc2hhcGUpIC8gc2hhcmVkRGltXSB9XG4gICAgfSk7XG4gICAgaW50ZXJtZWRpYXRlcy5wdXNoKHhTcXVlZXplZCk7XG4gICAgaW50ZXJtZWRpYXRlcy5wdXNoKHcyUm93KTtcbiAgICB2YXIgaW0yQ29sUHJvZ3JhbSA9IG5ldyBJbTJDb2xQYWNrZWRQcm9ncmFtKHgyQ29sU2hhcGUsIHhTcXVlZXplZC5zaGFwZSwgY29udkluZm8pO1xuICAgIHZhciBpbTJDb2wgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShpbTJDb2xQcm9ncmFtLCBbeFNxdWVlemVkXSwgJ2Zsb2F0MzInKTtcbiAgICB2YXIgaW0yQ29sUmVzaGFwZWQgPSByZXNoYXBlKHtcbiAgICAgICAgaW5wdXRzOiB7IHg6IGltMkNvbCB9LFxuICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICBhdHRyczogeyBzaGFwZTogWzEsIHgyQ29sU2hhcGVbMF0sIHgyQ29sU2hhcGVbMV1dIH1cbiAgICB9KTtcbiAgICBpbnRlcm1lZGlhdGVzLnB1c2goaW0yQ29sKTtcbiAgICBpbnRlcm1lZGlhdGVzLnB1c2goaW0yQ29sUmVzaGFwZWQpO1xuICAgIHZhciBoYXNCaWFzID0gYmlhcyAhPSBudWxsO1xuICAgIHZhciBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyAhPSBudWxsO1xuICAgIHZhciBoYXNMZWFreXJlbHVBbHBoYSA9IGFjdGl2YXRpb24gPT09ICdsZWFreXJlbHUnO1xuICAgIHZhciBmdXNlZEFjdGl2YXRpb24gPSBhY3RpdmF0aW9uID8gbWFwQWN0aXZhdGlvblRvU2hhZGVyUHJvZ3JhbShhY3RpdmF0aW9uLCB0cnVlKSA6IG51bGw7XG4gICAgdmFyIG1hdG11bFByb2dyYW0gPSBuZXcgTWF0TXVsUGFja2VkUHJvZ3JhbShpbTJDb2xSZXNoYXBlZC5zaGFwZSwgdzJSb3cuc2hhcGUsIFsxLCBudW1Db2xzLCBjb252SW5mby5vdXRDaGFubmVsc10sIHRyYW5zcG9zZUEsIHRyYW5zcG9zZUIsIGhhc0JpYXMsIGZ1c2VkQWN0aXZhdGlvbiwgaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cywgaGFzTGVha3lyZWx1QWxwaGEpO1xuICAgIHZhciBpbnB1dHMgPSBbaW0yQ29sUmVzaGFwZWQsIHcyUm93XTtcbiAgICBpZiAoYmlhcykge1xuICAgICAgICBpbnB1dHMucHVzaChiaWFzKTtcbiAgICB9XG4gICAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMpIHtcbiAgICAgICAgaW5wdXRzLnB1c2gocHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyk7XG4gICAgfVxuICAgIGlmIChoYXNMZWFreXJlbHVBbHBoYSkge1xuICAgICAgICB2YXIgJGxlYWt5cmVsdUFscGhhID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhbXSwgJ2Zsb2F0MzInLCB0Zi51dGlsLmNyZWF0ZVNjYWxhclZhbHVlKGxlYWt5cmVsdUFscGhhLCAnZmxvYXQzMicpKTtcbiAgICAgICAgaW5wdXRzLnB1c2goJGxlYWt5cmVsdUFscGhhKTtcbiAgICAgICAgaW50ZXJtZWRpYXRlcy5wdXNoKCRsZWFreXJlbHVBbHBoYSk7XG4gICAgfVxuICAgIHZhciBwcm9kdWN0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0obWF0bXVsUHJvZ3JhbSwgaW5wdXRzLCAnZmxvYXQzMicpO1xuICAgIHZhciBvdXRTaGFwZSA9IGlzQ2hhbm5lbHNMYXN0ID9cbiAgICAgICAgWzEsIG91dEhlaWdodCwgb3V0V2lkdGgsIGNvbnZJbmZvLm91dENoYW5uZWxzXSA6XG4gICAgICAgIFsxLCBjb252SW5mby5vdXRDaGFubmVscywgb3V0SGVpZ2h0LCBvdXRXaWR0aF07XG4gICAgdmFyIG91dCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogcHJvZHVjdCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogb3V0U2hhcGUgfSB9KTtcbiAgICBpbnRlcm1lZGlhdGVzLnB1c2gocHJvZHVjdCk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBpbnRlcm1lZGlhdGVzXzIgPSBpbnRlcm1lZGlhdGVzOyBfaSA8IGludGVybWVkaWF0ZXNfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGkgPSBpbnRlcm1lZGlhdGVzXzJbX2ldO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBjb252MmQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLngsIGZpbHRlciA9IGlucHV0cy5maWx0ZXI7XG4gICAgdmFyIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGRhdGFGb3JtYXQgPSBhdHRycy5kYXRhRm9ybWF0LCBkaWxhdGlvbnMgPSBhdHRycy5kaWxhdGlvbnMsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZTtcbiAgICB2YXIgJGRhdGFGb3JtYXQgPSB0Zi5iYWNrZW5kX3V0aWwuY29udmVydENvbnYyRERhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgdmFyIGNvbnZJbmZvID0gdGYuYmFja2VuZF91dGlsLmNvbXB1dGVDb252MkRJbmZvKHguc2hhcGUsIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSwgZmFsc2UgLyogZGVwdGh3aXNlICovLCAkZGF0YUZvcm1hdCk7XG4gICAgdmFyIG91dDtcbiAgICBpZiAoY29udkluZm8uZmlsdGVySGVpZ2h0ID09PSAxICYmIGNvbnZJbmZvLmZpbHRlcldpZHRoID09PSAxICYmXG4gICAgICAgIGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0ID09PSAxICYmIGNvbnZJbmZvLmRpbGF0aW9uV2lkdGggPT09IDEgJiZcbiAgICAgICAgY29udkluZm8uc3RyaWRlSGVpZ2h0ID09PSAxICYmIGNvbnZJbmZvLnN0cmlkZVdpZHRoID09PSAxICYmXG4gICAgICAgIChjb252SW5mby5wYWRJbmZvLnR5cGUgPT09ICdTQU1FJyB8fCBjb252SW5mby5wYWRJbmZvLnR5cGUgPT09ICdWQUxJRCcpKSB7XG4gICAgICAgIG91dCA9IGNvbnYyZEJ5TWF0TXVsKHsgeDogeCwgZmlsdGVyOiBmaWx0ZXIsIGNvbnZJbmZvOiBjb252SW5mbywgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfQ09OVl9JTTJDT0wnKSAmJiB4LnNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgIG91dCA9IGNvbnYyZFdpdGhJbTJSb3coeyB4OiB4LCBmaWx0ZXI6IGZpbHRlciwgY29udkluZm86IGNvbnZJbmZvLCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgQ29udjJEUHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIG91dCA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt4LCBmaWx0ZXJdLCAnZmxvYXQzMicpO1xuICAgIH1cbiAgICB2YXIgb3V0UmVzaGFwZWQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IG91dCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogY29udkluZm8ub3V0U2hhcGUgfSB9KTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG91dCk7XG4gICAgcmV0dXJuIG91dFJlc2hhcGVkO1xufVxudmFyIGNvbnYyRENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5Db252MkQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogY29udjJkLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIENvbnYyRERlckZpbHRlclByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJERGVyRmlsdGVyUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnZHknXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmZpbHRlclNoYXBlO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIGlzQ2hhbm5lbHNMYXN0ID0gY29udkluZm8uZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIGR5KDosIDosIGQyKSB0byBnZXQgZHcod1IsIHdDLCBkMSwgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIiArIGNvbnZJbmZvLmJhdGNoU2l6ZSArIFwiOyBiKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCI7IHlSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiAtIFwiICsgcGFkVG9wICsgXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIGNvbnZJbmZvLmluSGVpZ2h0ICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIgKyBjb252SW5mby5vdXRXaWR0aCArIFwiOyB5QysrKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogXCIgKyBzdHJpZGVXaWR0aCArIFwiIC0gXCIgKyBwYWRMZWZ0ICsgXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgY29udkluZm8uaW5XaWR0aCArIFwiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgaWYgKFwiICsgaXNDaGFubmVsc0xhc3QgKyBcIikge1xcbiAgICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGQyLCB5UiwgeUMpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIGQxLCB4UiwgeEMpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJERGVyRmlsdGVyUHJvZ3JhbTtcbn0oKSk7XG52YXIgQ29udjJERGVySW5wdXRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnYyRERlcklucHV0UHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ1cnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGlzQ2hhbm5lbHNMYXN0ID0gY29udkluZm8uZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gICAgICAgIHZhciBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgcm93RGltID0gaXNDaGFubmVsc0xhc3QgPyAxIDogMjtcbiAgICAgICAgdmFyIGNvbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDM7XG4gICAgICAgIHZhciBjaGFubmVsRGltID0gaXNDaGFubmVsc0xhc3QgPyAzIDogMTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1tcIiArIGNoYW5uZWxEaW0gKyBcIl07XFxuXFxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGl2ZWMyKGNvb3Jkc1tcIiArIHJvd0RpbSArIFwiXSwgY29vcmRzW1wiICsgY29sRGltICsgXCJdKSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiICsgZmlsdGVySGVpZ2h0ICsgXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIiArIHN0cmlkZVdpZHRoICsgXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIiArIGNvbnZJbmZvLm91dFdpZHRoICsgXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIgKyBmaWx0ZXJXaWR0aCArIFwiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIiArIGNvbnZJbmZvLm91dENoYW5uZWxzICsgXCI7IGQyKyspIHtcXG5cXG4gICAgICAgICAgICAgIGlmIChcIiArIGlzQ2hhbm5lbHNMYXN0ICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgZDIsIGlkeVIsIGlkeUMpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJERGVySW5wdXRQcm9ncmFtO1xufSgpKTtcbnZhciBDb252M0REZXJGaWx0ZXJQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnYzRERlckZpbHRlclByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ2R5J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5maWx0ZXJTaGFwZTtcbiAgICAgICAgdmFyIHN0cmlkZURlcHRoID0gY29udkluZm8uc3RyaWRlRGVwdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkRnJvbnQgPSBjb252SW5mby5wYWRJbmZvLmZyb250O1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB3RiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnU7XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIiArIGNvbnZJbmZvLmJhdGNoU2l6ZSArIFwiOyBiKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeUYgPSAwOyB5RiA8IFwiICsgY29udkluZm8ub3V0RGVwdGggKyBcIjsgeUYrKykge1xcbiAgICAgICAgICAgIGludCB4RiA9IHdGICsgeUYgKiBcIiArIHN0cmlkZURlcHRoICsgXCIgLSBcIiArIHBhZEZyb250ICsgXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSBcIiArIGNvbnZJbmZvLmluRGVwdGggKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIiArIGNvbnZJbmZvLm91dEhlaWdodCArIFwiOyB5UisrKSB7XFxuICAgICAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiAtIFwiICsgcGFkVG9wICsgXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIiArIGNvbnZJbmZvLm91dFdpZHRoICsgXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiICsgc3RyaWRlV2lkdGggKyBcIiAtIFwiICsgcGFkTGVmdCArIFwiO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgY29udkluZm8uaW5XaWR0aCArIFwiKSB7XFxuICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlGLCB5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4RiwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDb252M0REZXJGaWx0ZXJQcm9ncmFtO1xufSgpKTtcbnZhciBDb252M0REZXJJbnB1dFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjNERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknLCAnVyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcbiAgICAgICAgdmFyIGZpbHRlckRlcHRoID0gY29udkluZm8uZmlsdGVyRGVwdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlRGVwdGggPSBjb252SW5mby5zdHJpZGVEZXB0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBwYWRGcm9udCA9IGZpbHRlckRlcHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8uZnJvbnQ7XG4gICAgICAgIHZhciBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIgKyBwYWRGcm9udCArIFwiLCBcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy51O1xcblxcblxcbiAgICAgICAgaXZlYzMgZHlDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlGQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLno7XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd0YgPSAwOyB3RiA8IFwiICsgZmlsdGVyRGVwdGggKyBcIjsgd0YrKykge1xcbiAgICAgICAgICBmbG9hdCBkeUYgPSBmbG9hdChkeUZDb3JuZXIgKyB3RikgLyBcIiArIHN0cmlkZURlcHRoICsgXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5RiA8IDAuMCB8fCBkeUYgPj0gXCIgKyBjb252SW5mby5vdXREZXB0aCArIFwiLjAgfHwgZnJhY3QoZHlGKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlGID0gaW50KGR5Rik7XFxuXFxuICAgICAgICAgIGludCB3RlBlcm0gPSBcIiArIGZpbHRlckRlcHRoICsgXCIgLSAxIC0gd0Y7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIgKyBzdHJpZGVIZWlnaHQgKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCIuMCB8fFxcbiAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgICAgaW50IHdSUGVybSA9IFwiICsgZmlsdGVySGVpZ2h0ICsgXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIgKyBzdHJpZGVXaWR0aCArIFwiLjA7XFxuXFxuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIiArIGNvbnZJbmZvLm91dFdpZHRoICsgXCIuMCB8fFxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgICAgaW50IHdDUGVybSA9IFwiICsgZmlsdGVyV2lkdGggKyBcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIiArIGNvbnZJbmZvLm91dENoYW5uZWxzICsgXCI7IGQyKyspIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeUYsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3RlBlcm0sIHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjNERGVySW5wdXRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY29udjJEQmFja3Byb3BGaWx0ZXIoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLngsIGR5ID0gaW5wdXRzLmR5O1xuICAgIHZhciBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBkYXRhRm9ybWF0ID0gYXR0cnMuZGF0YUZvcm1hdCwgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlLCBmaWx0ZXJTaGFwZSA9IGF0dHJzLmZpbHRlclNoYXBlO1xuICAgIHZhciAkZGF0YUZvcm1hdCA9IHRmLmJhY2tlbmRfdXRpbC5jb252ZXJ0Q29udjJERGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICB2YXIgY29udkluZm8gPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeC5zaGFwZSwgZmlsdGVyU2hhcGUsIHN0cmlkZXMsIDEgLyogZGlsYXRpb25zICovLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSwgZmFsc2UgLyogZGVwdGh3aXNlICovLCAkZGF0YUZvcm1hdCk7XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgQ29udjJERGVyRmlsdGVyUHJvZ3JhbShjb252SW5mbyk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt4LCBkeV0sICdmbG9hdDMyJyk7XG59XG52YXIgY29udjJEQmFja3Byb3BGaWx0ZXJDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQ29udjJEQmFja3Byb3BGaWx0ZXIsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogY29udjJEQmFja3Byb3BGaWx0ZXIsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBjb252MkRCYWNrcHJvcElucHV0KGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgZHkgPSBpbnB1dHMuZHksIGZpbHRlciA9IGlucHV0cy5maWx0ZXI7XG4gICAgdmFyIGlucHV0U2hhcGUgPSBhdHRycy5pbnB1dFNoYXBlLCBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBkYXRhRm9ybWF0ID0gYXR0cnMuZGF0YUZvcm1hdCwgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlO1xuICAgIHZhciAkZGF0YUZvcm1hdCA9IHRmLmJhY2tlbmRfdXRpbC5jb252ZXJ0Q29udjJERGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICB2YXIgY29udkluZm8gPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZUNvbnYyREluZm8oaW5wdXRTaGFwZSwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCAxIC8qIGRpbGF0aW9ucyAqLywgcGFkLCBkaW1Sb3VuZGluZ01vZGUsIGZhbHNlLCAkZGF0YUZvcm1hdCk7XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgQ29udjJERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2R5LCBmaWx0ZXJdLCAnZmxvYXQzMicpO1xufVxudmFyIGNvbnYyREJhY2twcm9wSW5wdXRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQ29udjJEQmFja3Byb3BJbnB1dCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBjb252MkRCYWNrcHJvcElucHV0LFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY29udjNEKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54LCBmaWx0ZXIgPSBpbnB1dHMuZmlsdGVyO1xuICAgIHZhciBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBkaWxhdGlvbnMgPSBhdHRycy5kaWxhdGlvbnM7XG4gICAgdmFyIGNvbnZJbmZvID0gdGYuYmFja2VuZF91dGlsLmNvbXB1dGVDb252M0RJbmZvKHguc2hhcGUsIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQpO1xuICAgIHZhciBwcm9ncmFtID0gbmV3IENvbnYzRFByb2dyYW0oY29udkluZm8pO1xuICAgIHJldHVybiBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbeCwgZmlsdGVyXSwgJ2Zsb2F0MzInKTtcbn1cbnZhciBjb252M0RDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQ29udjNELFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGNvbnYzRCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGNvbnYzREJhY2twcm9wRmlsdGVyVjIoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLngsIGR5ID0gaW5wdXRzLmR5O1xuICAgIHZhciBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBmaWx0ZXJTaGFwZSA9IGF0dHJzLmZpbHRlclNoYXBlO1xuICAgIHZhciBjb252SW5mbyA9IHRmLmJhY2tlbmRfdXRpbC5jb21wdXRlQ29udjNESW5mbyh4LnNoYXBlLCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgMSAvKiBkaWxhdGlvbnMgKi8sIHBhZCk7XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgQ29udjNERGVyRmlsdGVyUHJvZ3JhbShjb252SW5mbyk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt4LCBkeV0sICdmbG9hdDMyJyk7XG59XG52YXIgY29udjNEQmFja3Byb3BGaWx0ZXJWMkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5Db252M0RCYWNrcHJvcEZpbHRlclYyLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGNvbnYzREJhY2twcm9wRmlsdGVyVjJcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGNvbnYzREJhY2twcm9wSW5wdXQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBkeSA9IGlucHV0cy5keSwgZmlsdGVyID0gaW5wdXRzLmZpbHRlcjtcbiAgICB2YXIgcGFkID0gYXR0cnMucGFkLCBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgaW5wdXRTaGFwZSA9IGF0dHJzLmlucHV0U2hhcGU7XG4gICAgdmFyIGNvbnZJbmZvID0gdGYuYmFja2VuZF91dGlsLmNvbXB1dGVDb252M0RJbmZvKGlucHV0U2hhcGUsIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgMSAvKiBkaWxhdGlvbnMgKi8sIHBhZCk7XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgQ29udjNERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2R5LCBmaWx0ZXJdLCAnZmxvYXQzMicpO1xufVxudmFyIGNvbnYzREJhY2twcm9wSW5wdXRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQ29udjNEQmFja3Byb3BJbnB1dFYyLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGNvbnYzREJhY2twcm9wSW5wdXQsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgQ09TID0gQ0hFQ0tfTkFOX1NOSVBQRVRfVU5BUlkgKyBcIlxcbiAgcmV0dXJuIGNvcyh4KTtcXG5cIjtcbnZhciBjb3MgPSB1bmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IENPUyB9KTtcbnZhciBjb3NDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQ29zLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGNvcyxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBDT1NIID0gXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgteCk7XFxuICByZXR1cm4gKGUyeCArIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCI7XG52YXIgY29zaCA9IHVuYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogQ09TSCB9KTtcbnZhciBjb3NoQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkNvc2gsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogY29zaCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBDcm9wQW5kUmVzaXplUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDcm9wQW5kUmVzaXplUHJvZ3JhbShpbWFnZVNoYXBlLCBib3hTaGFwZSwgY3JvcFNpemUsIG1ldGhvZCwgZXh0cmFwb2xhdGlvblZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnSW1hZ2UnLCAnQm94ZXMnLCAnQm94SW5kJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdmFyIGJhdGNoID0gaW1hZ2VTaGFwZVswXSwgaW1hZ2VIZWlnaHQgPSBpbWFnZVNoYXBlWzFdLCBpbWFnZVdpZHRoID0gaW1hZ2VTaGFwZVsyXSwgZGVwdGggPSBpbWFnZVNoYXBlWzNdO1xuICAgICAgICB2YXIgbnVtQm94ZXMgPSBib3hTaGFwZVswXTtcbiAgICAgICAgdmFyIGNyb3BIZWlnaHQgPSBjcm9wU2l6ZVswXSwgY3JvcFdpZHRoID0gY3JvcFNpemVbMV07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbbnVtQm94ZXMsIGNyb3BIZWlnaHQsIGNyb3BXaWR0aCwgZGVwdGhdO1xuICAgICAgICB2YXIgbWV0aG9kSWQgPSBtZXRob2QgPT09ICdiaWxpbmVhcicgPyAxIDogMDtcbiAgICAgICAgdmFyIF9hID0gW2ltYWdlSGVpZ2h0IC0gMSArIFwiLjBcIiwgaW1hZ2VXaWR0aCAtIDEgKyBcIi4wXCJdLCBpbnB1dEhlaWdodEZsb2F0ID0gX2FbMF0sIGlucHV0V2lkdGhGbG9hdCA9IF9hWzFdO1xuICAgICAgICB2YXIgX2IgPSBjcm9wSGVpZ2h0ID4gMSA/XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJcIiArIChpbWFnZUhlaWdodCAtIDEpIC8gKGNyb3BIZWlnaHQgLSAxKSxcbiAgICAgICAgICAgICAgICAnKHkyLXkxKSAqIGhlaWdodF9yYXRpbycsXG4gICAgICAgICAgICAgICAgXCJ5MSpcIiArIGlucHV0SGVpZ2h0RmxvYXQgKyBcIiArIGZsb2F0KHkpKihoZWlnaHRfc2NhbGUpXCIsXG4gICAgICAgICAgICBdIDpcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnMC4wJyxcbiAgICAgICAgICAgICAgICAnMC4wJyxcbiAgICAgICAgICAgICAgICBcIjAuNSAqICh5MSt5MikgKiBcIiArIGlucHV0SGVpZ2h0RmxvYXQsXG4gICAgICAgICAgICBdLCBoZWlnaHRSYXRpbyA9IF9iWzBdLCBoZWlnaHRTY2FsZSA9IF9iWzFdLCBpblkgPSBfYlsyXTtcbiAgICAgICAgdmFyIF9jID0gY3JvcFdpZHRoID4gMSA/XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJcIiArIChpbWFnZVdpZHRoIC0gMSkgLyAoY3JvcFdpZHRoIC0gMSksXG4gICAgICAgICAgICAgICAgJyh4Mi14MSkgKiB3aWR0aF9yYXRpbycsXG4gICAgICAgICAgICAgICAgXCJ4MSpcIiArIGlucHV0V2lkdGhGbG9hdCArIFwiICsgZmxvYXQoeCkqKHdpZHRoX3NjYWxlKVwiLFxuICAgICAgICAgICAgXSA6XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJzAuMCcsXG4gICAgICAgICAgICAgICAgJzAuMCcsXG4gICAgICAgICAgICAgICAgXCIwLjUgKiAoeDEreDIpICogXCIgKyBpbnB1dFdpZHRoRmxvYXQsXG4gICAgICAgICAgICBdLCB3aWR0aFJhdGlvID0gX2NbMF0sIHdpZHRoU2NhbGUgPSBfY1sxXSwgaW5YID0gX2NbMl07XG4gICAgICAgIC8vIFJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RlbnNvcmZsb3cvYmxvYi9tYXN0ZXIvdGVuc29yZmxvdy9jb3JlL2tlcm5lbHMvY3JvcF9hbmRfcmVzaXplX29wX2dwdS5jdS5jY1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBmbG9hdCBoZWlnaHRfcmF0aW8gPSBmbG9hdChcIiArIGhlaWdodFJhdGlvICsgXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IHdpZHRoX3JhdGlvID0gZmxvYXQoXCIgKyB3aWR0aFJhdGlvICsgXCIpO1xcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgeSA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCB4ID0gY29vcmRzWzJdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICAvLyBnZXQgYm94IHZhbHNcXG4gICAgICAgIGZsb2F0IHkxID0gZ2V0Qm94ZXMoYiwwKTtcXG4gICAgICAgIGZsb2F0IHgxID0gZ2V0Qm94ZXMoYiwxKTtcXG4gICAgICAgIGZsb2F0IHkyID0gZ2V0Qm94ZXMoYiwyKTtcXG4gICAgICAgIGZsb2F0IHgyID0gZ2V0Qm94ZXMoYiwzKTtcXG5cXG4gICAgICAgIC8vIGdldCBpbWFnZSBpbiBiYXRjaCBpbmRleFxcbiAgICAgICAgaW50IGJJbmQgPSByb3VuZChnZXRCb3hJbmQoYikpO1xcbiAgICAgICAgaWYoYkluZCA8IDAgfHwgYkluZCA+PSBcIiArIGJhdGNoICsgXCIpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmxvYXQgaGVpZ2h0X3NjYWxlID0gXCIgKyBoZWlnaHRTY2FsZSArIFwiO1xcbiAgICAgICAgZmxvYXQgd2lkdGhfc2NhbGUgPSBcIiArIHdpZHRoU2NhbGUgKyBcIjtcXG5cXG4gICAgICAgIGZsb2F0IGluX3kgPSBcIiArIGluWSArIFwiO1xcbiAgICAgICAgaWYoIGluX3kgPCAwLjAgfHwgaW5feSA+IFwiICsgaW5wdXRIZWlnaHRGbG9hdCArIFwiICkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIgKyBleHRyYXBvbGF0aW9uVmFsdWUgKyBcIikpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBmbG9hdCBpbl94ID0gXCIgKyBpblggKyBcIjtcXG4gICAgICAgIGlmKCBpbl94IDwgMC4wIHx8IGluX3ggPiBcIiArIGlucHV0V2lkdGhGbG9hdCArIFwiICkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIgKyBleHRyYXBvbGF0aW9uVmFsdWUgKyBcIikpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleENSID0gdmVjMihpbl94LGluX3kpO1xcbiAgICAgICAgaWYoXCIgKyBtZXRob2RJZCArIFwiID09IDEpIHtcXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yQ1IgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhDUik7XFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxDUiA9IGl2ZWMyKGNlaWwoc291cmNlRnJhY0luZGV4Q1IpKTtcXG5cXG4gICAgICAgICAgZmxvYXQgdG9wTGVmdCA9IGdldEltYWdlKGIsIHNvdXJjZUZsb29yQ1IueSwgc291cmNlRmxvb3JDUi54LCBkKTtcXG4gICAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEltYWdlKGIsIHNvdXJjZUNlaWxDUi55LCBzb3VyY2VGbG9vckNSLngsIGQpO1xcbiAgICAgICAgICBmbG9hdCB0b3BSaWdodCA9IGdldEltYWdlKGIsIHNvdXJjZUZsb29yQ1IueSwgc291cmNlQ2VpbENSLngsIGQpO1xcbiAgICAgICAgICBmbG9hdCBib3R0b21SaWdodCA9IGdldEltYWdlKGIsIHNvdXJjZUNlaWxDUi55LCBzb3VyY2VDZWlsQ1IueCwgZCk7XFxuXFxuICAgICAgICAgIHZlYzIgZnJhY0NSID0gc291cmNlRnJhY0luZGV4Q1IgLSB2ZWMyKHNvdXJjZUZsb29yQ1IpO1xcblxcbiAgICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjQ1IueDtcXG4gICAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY0NSLng7XFxuICAgICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gdG9wICsgKGJvdHRvbSAtIHRvcCkgKiBmcmFjQ1IueTtcXG4gICAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvb3JkaW5hdG9ycyBvZiBuZWFyZXN0IG5laWdoYm9yIHBvaW50LlxcbiAgICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0Q1IgPSBpdmVjMihmbG9vcihcXG4gICAgICAgICAgICBzb3VyY2VGcmFjSW5kZXhDUiArIHZlYzIoMC41LDAuNSkpKTtcXG4gICAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSBnZXRJbWFnZShiLCBzb3VyY2VOZWFyZXN0Q1IueSwgc291cmNlTmVhcmVzdENSLngsIGQpO1xcbiAgICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDcm9wQW5kUmVzaXplUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBjcm9wQW5kUmVzaXplID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgaW1hZ2UgPSBpbnB1dHMuaW1hZ2UsIGJveGVzID0gaW5wdXRzLmJveGVzLCBib3hJbmQgPSBpbnB1dHMuYm94SW5kO1xuICAgIHZhciBjcm9wU2l6ZSA9IGF0dHJzLmNyb3BTaXplLCBtZXRob2QgPSBhdHRycy5tZXRob2QsIGV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJzLmV4dHJhcG9sYXRpb25WYWx1ZTtcbiAgICB2YXIgcHJvZ3JhbSA9IG5ldyBDcm9wQW5kUmVzaXplUHJvZ3JhbShpbWFnZS5zaGFwZSwgYm94ZXMuc2hhcGUsIGNyb3BTaXplLCBtZXRob2QsIGV4dHJhcG9sYXRpb25WYWx1ZSk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFtpbWFnZSwgYm94ZXMsIGJveEluZF0sICdmbG9hdDMyJyk7XG59O1xudmFyIGNyb3BBbmRSZXNpemVDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQ3JvcEFuZFJlc2l6ZSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBjcm9wQW5kUmVzaXplXG59O1xuXG52YXIgQ3VtU3VtUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDdW1TdW1Qcm9ncmFtKHNoYXBlLCBleGNsdXNpdmUsIHJldmVyc2UpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgdmFyIHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciB2YWwgPSBleGNsdXNpdmUgPyAnMC4wJyA6IFwiZ2V0WChcIiArIGdldENvb3JkcyQxKHJhbmssICdjb29yZHMnKSArIFwiKVwiO1xuICAgICAgICB2YXIgbGVuZ3RoID0gc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBjb25kaXRpb24gPSAnJztcbiAgICAgICAgdmFyIGlkeFN0cmluZyA9ICcnO1xuICAgICAgICAvLyBXaGVuIGV4Y2x1c2l2ZSBpcyBzZXQsIHRoZSBjdW1zdW0gb3AgYmVjb21lcyByb2xsIG9wIHRoYXQgY29waWVzIHRoZVxuICAgICAgICAvLyB2YWx1ZSBmcm9tIHRoZSBwcmV2aW91cyBpbmRleCBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZCBieSB0aGVcbiAgICAgICAgLy8gcmV2ZXJzZSBmbGFnLlxuICAgICAgICBpZiAoZXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBjb25kaXRpb24gPSByZXZlcnNlID8gXCJlbmQgIT0gXCIgKyAobGVuZ3RoIC0gMSkgOiAnZW5kICE9IDAnO1xuICAgICAgICAgICAgaWR4U3RyaW5nID0gcmV2ZXJzZSA/ICdlbmQgKyAxJyA6ICdlbmQgLSAxJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbiA9IHJldmVyc2UgPyBcImVuZCArIHBvdzIgPCBcIiArIGxlbmd0aCA6ICdlbmQgPj0gcG93Mic7XG4gICAgICAgICAgICBpZHhTdHJpbmcgPSAocmV2ZXJzZSA/ICdlbmQgKyBwb3cyJyA6ICdlbmQgLSBwb3cyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBpbmRleDtcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGdldENvb3Jkc0RhdGFUeXBlKHJhbmspICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgZW5kID0gXCIgKyBnZXRGaW5hbENvb3JkKHJhbmssICdjb29yZHMnKSArIFwiO1xcbiAgICAgICAgZmxvYXQgdmFsID0gXCIgKyB2YWwgKyBcIjtcXG4gICAgICAgIGludCBwb3cyID0gaW50KHBvdygyLjAsIGluZGV4KSk7XFxuICAgICAgICBpZiAoXCIgKyBjb25kaXRpb24gKyBcIikge1xcbiAgICAgICAgICBpbnQgaWR4ID0gXCIgKyBpZHhTdHJpbmcgKyBcIjtcXG4gICAgICAgICAgXCIgKyBnZXRGaW5hbENvb3JkKHJhbmssICdjb29yZHMnKSArIFwiID0gaWR4O1xcbiAgICAgICAgICB2YWwgKz0gZ2V0WChcIiArIGdldENvb3JkcyQxKHJhbmssICdjb29yZHMnKSArIFwiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIEN1bVN1bVByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5kZXggPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnaW5kZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihfdGhpcy5pbmRleCwgaW5kZXgpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEN1bVN1bVByb2dyYW07XG59KCkpO1xuZnVuY3Rpb24gZ2V0Q29vcmRzJDEocmFuaywgbmFtZSkge1xuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgbmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgICAgICByZXR1cm4gbmFtZSArIFwiLngsIFwiICsgbmFtZSArIFwiLnlcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMykge1xuICAgICAgICByZXR1cm4gbmFtZSArIFwiLngsIFwiICsgbmFtZSArIFwiLnksIFwiICsgbmFtZSArIFwiLnpcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgICAgICByZXR1cm4gbmFtZSArIFwiLngsIFwiICsgbmFtZSArIFwiLnksIFwiICsgbmFtZSArIFwiLnosIFwiICsgbmFtZSArIFwiLndcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiQ3VtdWxhdGl2ZSBzdW0gZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RmluYWxDb29yZChyYW5rLCBuYW1lKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBuYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgXCIueVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgXCIuelwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgXCIud1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDdW11bGF0aXZlIHN1bSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGN1bXN1bShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgYXhpcyA9IGF0dHJzLmF4aXMsIGV4Y2x1c2l2ZSA9IGF0dHJzLmV4Y2x1c2l2ZSwgcmV2ZXJzZSA9IGF0dHJzLnJldmVyc2U7XG4gICAgdmFyIHhSYW5rID0geC5zaGFwZS5sZW5ndGg7XG4gICAgdmFyIHBlcm11dGF0aW9uID0gdGYuYmFja2VuZF91dGlsLmdldEF4ZXNQZXJtdXRhdGlvbihbYXhpc10sIHhSYW5rKTtcbiAgICB2YXIgcGVybXV0ZWRYID0geDtcbiAgICBpZiAocGVybXV0YXRpb24gIT0gbnVsbCkge1xuICAgICAgICBwZXJtdXRlZFggPSB0cmFuc3Bvc2UoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBwZXJtOiBwZXJtdXRhdGlvbiB9IH0pO1xuICAgIH1cbiAgICB2YXIgcGVybXV0ZWRBeGlzID0gdGYuYmFja2VuZF91dGlsLmdldElubmVyTW9zdEF4ZXMoMSwgeFJhbmspWzBdO1xuICAgIGlmIChwZXJtdXRlZEF4aXMgIT09IHhSYW5rIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBjdW1zdW0gc2hhZGVyIGV4cGVjdHMgYW4gaW5uZXItbW9zdCBheGlzPVwiICsgKHguc2hhcGUubGVuZ3RoIC0gMSkgKyBcIiBcIiArXG4gICAgICAgICAgICAoXCJidXQgZ290IGF4aXM9XCIgKyBheGlzKSk7XG4gICAgfVxuICAgIHZhciBzaXplID0gcGVybXV0ZWRYLnNoYXBlW3Blcm11dGVkQXhpc107XG4gICAgdmFyIHJlc3VsdCA9IGlkZW50aXR5KHsgaW5wdXRzOiB7IHg6IHBlcm11dGVkWCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgIC8vIFVzZSBjdW1zdW0gcGFyYWxsZWwgYWxnb3JpdGhtLCByZWY6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS9ncHVnZW1zL2dwdWdlbXMzL3BhcnQtdmktZ3B1LWNvbXB1dGluZy9jaGFwdGVyLTM5LXBhcmFsbGVsLXByZWZpeC1zdW0tc2Nhbi1jdWRhXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gTWF0aC5jZWlsKE1hdGgubG9nMihzaXplKSkgLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgQ3VtU3VtUHJvZ3JhbShwZXJtdXRlZFguc2hhcGUsIGZhbHNlLCByZXZlcnNlKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoaSk7XG4gICAgICAgIHZhciBwcmV2UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3Jlc3VsdF0sIHJlc3VsdC5kdHlwZSwgY3VzdG9tU2V0dXApO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHByZXZSZXN1bHQpO1xuICAgIH1cbiAgICAvLyBGb3IgZXhjbHVzaXZlIGN1bXN1bSwgc2hpZnQgdGhlIGVuZCByZXN1bHQgaW4gdGhlIGRpcmVjdGlvbiBvZiBzdW1cbiAgICAvLyBhbmQgYWRkIDAgdG8gdGhlIGZyb250IGluZGV4LlxuICAgIGlmIChleGNsdXNpdmUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgQ3VtU3VtUHJvZ3JhbShwZXJtdXRlZFguc2hhcGUsIGV4Y2x1c2l2ZSwgcmV2ZXJzZSk7XG4gICAgICAgIHZhciBwcmV2UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbcmVzdWx0XSwgcmVzdWx0LmR0eXBlKTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwcmV2UmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKHBlcm11dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHJldmVyc2VQZXJtdXRhdGlvbiA9IHRmLmJhY2tlbmRfdXRpbC5nZXRVbmRvQXhlc1Blcm11dGF0aW9uKHBlcm11dGF0aW9uKTtcbiAgICAgICAgdmFyIHJldmVyc2VUcmFuc3Bvc2VkUmVzdWx0ID0gdHJhbnNwb3NlKHsgaW5wdXRzOiB7IHg6IHJlc3VsdCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBwZXJtOiByZXZlcnNlUGVybXV0YXRpb24gfSB9KTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyZXN1bHQpO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHBlcm11dGVkWCk7XG4gICAgICAgIHJldHVybiByZXZlcnNlVHJhbnNwb3NlZFJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBjdW1zdW1Db25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuQ3Vtc3VtLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGN1bXN1bVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZGVuc2VCaW5jb3VudChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueCwgd2VpZ2h0cyA9IGlucHV0cy53ZWlnaHRzO1xuICAgIHZhciBzaXplID0gYXR0cnMuc2l6ZSwgYmluYXJ5T3V0cHV0ID0gYXR0cnMuYmluYXJ5T3V0cHV0O1xuICAgIGlmICh4LnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgeFZhbHMgPSBiYWNrZW5kLnJlYWRTeW5jKHguZGF0YUlkKTtcbiAgICAgICAgdmFyIHdlaWdodHNWYWxzID0gYmFja2VuZC5yZWFkU3luYyh3ZWlnaHRzLmRhdGFJZCk7XG4gICAgICAgIHZhciBvdXRWYWxzID0gYmluY291bnRJbXBsQ1BVKHhWYWxzLCB3ZWlnaHRzVmFscywgd2VpZ2h0cy5kdHlwZSwgd2VpZ2h0cy5zaGFwZSwgc2l6ZSk7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtzaXplXSwgd2VpZ2h0cy5kdHlwZSwgb3V0VmFscyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHguc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHZhciB4QnVmID0gYmFja2VuZC5idWZmZXJTeW5jKHgpO1xuICAgICAgICB2YXIgd2VpZ2h0c0J1ZiA9IGJhY2tlbmQuYnVmZmVyU3luYyh3ZWlnaHRzKTtcbiAgICAgICAgdmFyIG91dEJ1ZiA9IGJpbmNvdW50UmVkdWNlSW1wbENQVSh4QnVmLCB3ZWlnaHRzQnVmLCBzaXplLCBiaW5hcnlPdXRwdXQpO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRCdWYuc2hhcGUsIHdlaWdodHMuZHR5cGUsIG91dEJ1Zi52YWx1ZXMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBkZW5zZUJpbmNvdW50OiBpbnB1dCBtdXN0IGJlIGF0IG1vc3QgcmFuayAyLCBidXQgZ290IHJhbmtcIiArXG4gICAgICAgICh4LnNoYXBlLmxlbmd0aCArIFwiLlwiKSk7XG59XG52YXIgZGVuc2VCaW5jb3VudENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5EZW5zZUJpbmNvdW50LFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGRlbnNlQmluY291bnRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBEZXB0aFRvU3BhY2VQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlcHRoVG9TcGFjZVByb2dyYW0ob3V0cHV0U2hhcGUsIGJsb2NrU2l6ZSwgZGF0YUZvcm1hdCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gYmxvY2tTaXplO1xuICAgICAgICB0aGlzLmRhdGFGb3JtYXQgPSBkYXRhRm9ybWF0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgIGludCBoID0gXCIgKyB0aGlzLmdldEhlaWdodENvb3JkU3RyaW5nKCkgKyBcIjtcXG4gICAgICBpbnQgdyA9IFwiICsgdGhpcy5nZXRXaWR0aENvb3JkU3RyaW5nKCkgKyBcIjtcXG4gICAgICBpbnQgZCA9IFwiICsgdGhpcy5nZXREZXB0aENvb3JkU3RyaW5nKCkgKyBcIjtcXG5cXG4gICAgICBpbnQgaW5faCA9IGggLyBcIiArIGJsb2NrU2l6ZSArIFwiO1xcbiAgICAgIGludCBvZmZzZXRfaCA9IGltb2QoaCwgXCIgKyBibG9ja1NpemUgKyBcIik7XFxuICAgICAgaW50IGluX3cgPSB3IC8gXCIgKyBibG9ja1NpemUgKyBcIjtcXG4gICAgICBpbnQgb2Zmc2V0X3cgPSBpbW9kKHcsIFwiICsgYmxvY2tTaXplICsgXCIpO1xcbiAgICAgIGludCBvZmZzZXRfZCA9IChvZmZzZXRfaCAqIFwiICsgYmxvY2tTaXplICsgXCIgKyBvZmZzZXRfdykgKlxcbiAgICAgICAgXCIgKyB0aGlzLmdldE91dHB1dERlcHRoU2l6ZSgpICsgXCI7XFxuICAgICAgaW50IGluX2QgPSBkICsgb2Zmc2V0X2Q7XFxuXFxuICAgICAgZmxvYXQgcmVzdWx0ID0gXCIgKyB0aGlzLmdldElucHV0U2FtcGxpbmdTdHJpbmcoKSArIFwiO1xcbiAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICB9XFxuICBcIjtcbiAgICB9XG4gICAgRGVwdGhUb1NwYWNlUHJvZ3JhbS5wcm90b3R5cGUuZ2V0SGVpZ2h0Q29vcmRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdOSFdDJykge1xuICAgICAgICAgICAgcmV0dXJuIFwiY29vcmRzWzFdXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJjb29yZHNbMl1cIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVwdGhUb1NwYWNlUHJvZ3JhbS5wcm90b3R5cGUuZ2V0V2lkdGhDb29yZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ05IV0MnKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJjb29yZHNbMl1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImNvb3Jkc1szXVwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZXB0aFRvU3BhY2VQcm9ncmFtLnByb3RvdHlwZS5nZXREZXB0aENvb3JkU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhRm9ybWF0ID09PSAnTkhXQycpIHtcbiAgICAgICAgICAgIHJldHVybiBcImNvb3Jkc1szXVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiY29vcmRzWzFdXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlcHRoVG9TcGFjZVByb2dyYW0ucHJvdG90eXBlLmdldE91dHB1dERlcHRoU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ05IV0MnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRTaGFwZVszXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dHB1dFNoYXBlWzFdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZXB0aFRvU3BhY2VQcm9ncmFtLnByb3RvdHlwZS5nZXRJbnB1dFNhbXBsaW5nU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhRm9ybWF0ID09PSAnTkhXQycpIHtcbiAgICAgICAgICAgIHJldHVybiBcImdldFgoYiwgaW5faCwgaW5fdywgaW5fZClcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImdldFgoYiwgaW5fZCwgaW5faCwgaW5fdylcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlcHRoVG9TcGFjZVByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBkZXB0aFRvU3BhY2UoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGJsb2NrU2l6ZSA9IGF0dHJzLmJsb2NrU2l6ZSwgZGF0YUZvcm1hdCA9IGF0dHJzLmRhdGFGb3JtYXQ7XG4gICAgdGYudXRpbC5hc3NlcnQoYmxvY2tTaXplID4gMSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJibG9ja1NpemUgc2hvdWxkIGJlID4gMSBmb3IgZGVwdGhUb1NwYWNlLCBidXQgd2FzOiBcIiArIGJsb2NrU2l6ZTsgfSk7XG4gICAgdmFyIGJhdGNoU2l6ZSA9IHguc2hhcGVbMF07XG4gICAgdmFyIGlucHV0SGVpZ2h0ID0gKGRhdGFGb3JtYXQgPT09ICdOSFdDJykgPyB4LnNoYXBlWzFdIDogeC5zaGFwZVsyXTtcbiAgICB2YXIgaW5wdXRXaWR0aCA9IChkYXRhRm9ybWF0ID09PSAnTkhXQycpID8geC5zaGFwZVsyXSA6IHguc2hhcGVbM107XG4gICAgdmFyIGlucHV0RGVwdGggPSAoZGF0YUZvcm1hdCA9PT0gJ05IV0MnKSA/IHguc2hhcGVbM10gOiB4LnNoYXBlWzFdO1xuICAgIHZhciBvdXRwdXRIZWlnaHQgPSBpbnB1dEhlaWdodCAqIGJsb2NrU2l6ZTtcbiAgICB2YXIgb3V0cHV0V2lkdGggPSBpbnB1dFdpZHRoICogYmxvY2tTaXplO1xuICAgIHZhciBvdXRwdXREZXB0aCA9IGlucHV0RGVwdGggLyAoYmxvY2tTaXplICogYmxvY2tTaXplKTtcbiAgICB2YXIgb3V0cHV0U2hhcGUgPSAoZGF0YUZvcm1hdCA9PT0gJ05IV0MnKSA/XG4gICAgICAgIFtiYXRjaFNpemUsIG91dHB1dEhlaWdodCwgb3V0cHV0V2lkdGgsIG91dHB1dERlcHRoXSA6XG4gICAgICAgIFtiYXRjaFNpemUsIG91dHB1dERlcHRoLCBvdXRwdXRIZWlnaHQsIG91dHB1dFdpZHRoXTtcbiAgICB2YXIgcHJvZ3JhbSA9IG5ldyBEZXB0aFRvU3BhY2VQcm9ncmFtKG91dHB1dFNoYXBlLCBibG9ja1NpemUsIGRhdGFGb3JtYXQpO1xuICAgIHJldHVybiBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbeF0sIHguZHR5cGUpO1xufVxudmFyIGRlcHRoVG9TcGFjZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5EZXB0aFRvU3BhY2UsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogZGVwdGhUb1NwYWNlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRGVwdGh3aXNlQ29udjJEUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXB0aHdpc2VDb252MkRQcm9ncmFtKGNvbnZJbmZvLCBhZGRCaWFzLCBhY3RpdmF0aW9uLCBoYXNQcmVsdUFjdGl2YXRpb24sIGhhc0xlYWt5UmVsdUFscGhhKSB7XG4gICAgICAgIGlmIChhZGRCaWFzID09PSB2b2lkIDApIHsgYWRkQmlhcyA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChhY3RpdmF0aW9uID09PSB2b2lkIDApIHsgYWN0aXZhdGlvbiA9IG51bGw7IH1cbiAgICAgICAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbiA9PT0gdm9pZCAwKSB7IGhhc1ByZWx1QWN0aXZhdGlvbiA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChoYXNMZWFreVJlbHVBbHBoYSA9PT0gdm9pZCAwKSB7IGhhc0xlYWt5UmVsdUFscGhhID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICAgICB2YXIgeE51bVJvd3MgPSBjb252SW5mby5pbkhlaWdodDtcbiAgICAgICAgdmFyIHhOdW1Db2xzID0gY29udkluZm8uaW5XaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgY2hhbm5lbE11bCA9IGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscztcbiAgICAgICAgdmFyIGFjdGl2YXRpb25TbmlwcGV0ID0gJycsIGFwcGx5QWN0aXZhdGlvblNuaXBwZXQgPSAnJztcbiAgICAgICAgaWYgKGFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uU25pcHBldCA9IFwiZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XFxuICAgICAgICAgIGZsb2F0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcXG4gICAgICAgICAgXCIgKyBhY3RpdmF0aW9uICsgXCJcXG4gICAgICAgIH1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0xlYWt5UmVsdUFscGhhKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBcImZsb2F0IGFjdGl2YXRpb24oZmxvYXQgYSkge1xcbiAgICAgICAgICBmbG9hdCBiID0gZ2V0TGVha3lyZWx1QWxwaGFBdE91dENvb3JkcygpO1xcbiAgICAgICAgICBcIiArIGFjdGl2YXRpb24gKyBcIlxcbiAgICAgICAgfVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBcIlxcbiAgICAgICAgICBmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IHgpIHtcXG4gICAgICAgICAgICBcIiArIGFjdGl2YXRpb24gKyBcIlxcbiAgICAgICAgICB9XFxuICAgICAgICBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwcGx5QWN0aXZhdGlvblNuaXBwZXQgPSBcInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRkQmlhc1NuaXBwZXQgPSBhZGRCaWFzID8gJ3Jlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTsnIDogJyc7XG4gICAgICAgIGlmIChhZGRCaWFzKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdwcmVsdUFjdGl2YXRpb25XZWlnaHRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xlYWt5UmVsdUFscGhhKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnbGVha3lyZWx1QWxwaGEnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBcIiArIGFjdGl2YXRpb25TbmlwcGV0ICsgXCJcXG5cXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiwgXCIgKyBzdHJpZGVXaWR0aCArIFwiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQxID0gZDIgLyBcIiArIGNoYW5uZWxNdWwgKyBcIjtcXG4gICAgICAgIGludCBxID0gZDIgLSBkMSAqIFwiICsgY2hhbm5lbE11bCArIFwiO1xcblxcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgcSkgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICAvLyBUTyBETyhkc21pbGtvdik6IEZsYXR0ZW4gdGhlIHR3byBmb3IgbG9vcHMgYW5kIHZlYzQgdGhlIG9wZXJhdGlvbnMuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIgKyBkaWxhdGlvbkhlaWdodCArIFwiO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgeE51bVJvd3MgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIgKyBkaWxhdGlvbldpZHRoICsgXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcod1IsIHdDLCBkMSwgcSk7XFxuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsICogd1ZhbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gZG90UHJvZDtcXG4gICAgICAgIFwiICsgYWRkQmlhc1NuaXBwZXQgKyBcIlxcbiAgICAgICAgXCIgKyBhcHBseUFjdGl2YXRpb25TbmlwcGV0ICsgXCJcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBEZXB0aHdpc2VDb252MkRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIERlcHRod2lzZUNvbnZQYWNrZWQyRFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVwdGh3aXNlQ29udlBhY2tlZDJEUHJvZ3JhbShjb252SW5mbywgYWRkQmlhcywgYWN0aXZhdGlvbiwgaGFzUHJlbHVBY3RpdmF0aW9uLCBoYXNMZWFreVJlbHVBbHBoYSkge1xuICAgICAgICBpZiAoYWRkQmlhcyA9PT0gdm9pZCAwKSB7IGFkZEJpYXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoYWN0aXZhdGlvbiA9PT0gdm9pZCAwKSB7IGFjdGl2YXRpb24gPSBudWxsOyB9XG4gICAgICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb24gPT09IHZvaWQgMCkgeyBoYXNQcmVsdUFjdGl2YXRpb24gPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaGFzTGVha3lSZWx1QWxwaGEgPT09IHZvaWQgMCkgeyBoYXNMZWFreVJlbHVBbHBoYSA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gICAgICAgIHRoaXMucGFja2VkSW5wdXRzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWNrZWRPdXRwdXQgPSB0cnVlO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgICAgIHZhciB4TnVtUm93cyA9IGNvbnZJbmZvLmluSGVpZ2h0O1xuICAgICAgICB2YXIgeE51bUNvbHMgPSBjb252SW5mby5pbldpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGRpbGF0aW9uSGVpZ2h0ID0gY29udkluZm8uZGlsYXRpb25IZWlnaHQ7XG4gICAgICAgIHZhciBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciB0ZXhlbHNBY3Jvc3MgPSBmaWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIG1haW5Mb29wID0gXCJpbnQgeFI7IGludCB4QzsgaW50IHhDT2Zmc2V0O1wiO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGZpbHRlckhlaWdodDsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGZpbHRlcldpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICBtYWluTG9vcCArPSBcIlxcbiAgICAgICAgICB2ZWM0IHhUZXhlbFJcIiArIHIgKyBcIkNcIiArIGMgKiAyICsgXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgdmVjNCB3UlwiICsgciArIFwiQ1wiICsgYyArIFwiID0gdmVjNCgwLik7XFxuICAgICAgICAgIHZlYzQgeFJcIiArIHIgKyBcIkNcIiArIGMgKyBcIiA9IHZlYzQoMC4pO1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHZlY3Rvcml6ZWQgaW1wbGVtZW50YXRpb24gd29ya3MgYnkgZ2F0aGVyaW5nIHRoZSB2YWx1ZXMgbmVlZGVkIGZvclxuICAgICAgICAgKiBlYWNoIG91dHB1dCBjaGFubmVsJ3MgZG90IHByb2R1Y3QgaW50byB2ZWM0J3MgYW5kIHRoZW4gbXVsdGlwbHlpbmcgdGhlbVxuICAgICAgICAgKiBhbGwgdG9nZXRoZXIgKHRoaXMgaGFwcGVucyBpbiB0aGUgZmluYWwgZG91YmxlIGZvci1sb29wIGJlbG93KS4gTW9zdCBvZlxuICAgICAgICAgKiB0aGUgbWFpbiBsb29wIGNvbnNpc3RzIG9mIGNvbnN0cnVjdGluZyB0aGVzZSB2ZWM0J3Mgd2l0aCB0aGUgbWluaW11bVxuICAgICAgICAgKiBudW1iZXIgb2YgdGV4dHVyZTJEIGNhbGxzLCB3aGljaCBtZWFucyBtYWtpbmcgdXNlIG9mIGFsbCBmb3VyIHJldHVybmVkXG4gICAgICAgICAqIHZhbHVlcyBmcm9tIGEgdGV4dHVyZTJEIGNhbGwgYXQgb25jZS5cbiAgICAgICAgICovXG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZmlsdGVySGVpZ2h0OyByKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHRleGVsQyA9IDA7IHRleGVsQyA8IHRleGVsc0Fjcm9zczsgdGV4ZWxDKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRleGVsQyAqIDI7XG4gICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gXCJcXG4gICAgICAgICAgeFIgPSB4UkNvcm5lciArIFwiICsgciAqIGRpbGF0aW9uSGVpZ2h0ICsgXCI7XFxuICAgICAgICAgIHhDID0geENDb3JuZXIgKyBcIiArIGMgKiBkaWxhdGlvbldpZHRoICsgXCI7XFxuICAgICAgICBcIjtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWRlV2lkdGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcGFkZGluZyBpcyBvZGQsIHRoZSBvdXRlciB0ZXhlbHMgaGF2ZSB0byBiZSBjb21wb3NlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWRMZWZ0ICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEVuc3VyZSB2ZWM0IHByZXZpb3VzIGRvZXMgbm90IHJlc3VsdCBpbiByZWR1bmRhbnQgc2FtcGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBhdm9pZCBzZXR0aW5nIHhUZXhlbFJDJ3MgdGhhdCBleGNlZWQgdGhlIGJvdW5kYXJ5IGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IHBsYWNlIHJhdGhlciB0aGFuIHJlc2V0dGluZyB0aGVtIHRvIHZlYzQoMCkpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGNvbXB1dGUgeENPZmZzZXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBJZiBwYWRkaW5nIGlzIG9kZCwgd2UgbXVzdCBhZGQgMSB0byBlbnN1cmUgd2UgYXNrIGZvciBhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4tbnVtYmVyZWQgcm93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gV2Ugc3VidHJhY3QgMiB0byBhY2Nlc3MgdGhlIHByZXZpb3VzIHRleGVsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5Mb29wICs9IFwiXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxO1xcbiAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIgKyB4TnVtUm93cyArIFwiICYmIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIgKyByICsgXCJDXCIgKyBjICsgXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG5cXG4gICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXFxuICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXFxuICAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgKyAxID49IFwiICsgeE51bUNvbHMgKyBcIikge1xcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiICsgciArIFwiQ1wiICsgYyArIFwiLnp3ID0gdmVjMigwLik7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIiArIHIgKyBcIkNcIiArIGMgKyBcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gMjtcXG4gICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiICsgeE51bVJvd3MgKyBcIiAmJiB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICAgICAgdmVjNCBwcmV2aW91cyA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcblxcbiAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcXG4gICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cXG4gICAgICAgICAgICAgICAgICBpZih4Q09mZnNldCArIDEgPj0gXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy56dyA9IHZlYzIoMC4pO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICB4UlwiICsgciArIFwiQ1wiICsgYyArIFwiID0gdmVjNChwcmV2aW91cy56dywgeFRleGVsUlwiICsgciArIFwiQ1wiICsgYyArIFwiLnh5KTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4UlwiICsgciArIFwiQ1wiICsgYyArIFwiID0gdmVjNCgwLCAwLCB4VGV4ZWxSXCIgKyByICsgXCJDXCIgKyBjICsgXCIueHkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZGRpbmcgaXMgZXZlbiwgc28geFJDIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIHRleGVsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5Mb29wICs9IFwiXFxuICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIiArIHhOdW1Sb3dzICsgXCIgJiYgeEMgPj0gMCAmJiB4QyA8IFwiICsgeE51bUNvbHMgKyBcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIiArIHIgKyBcIkNcIiArIGMgKyBcIiA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIiArIHIgKyBcIkNcIiArIGMgKyBcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhSXCIgKyByICsgXCJDXCIgKyBjICsgXCIgPSB4VGV4ZWxSXCIgKyByICsgXCJDXCIgKyBjICsgXCI7XFxuICAgICAgICAgICAgICBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjICsgMSA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGlsYXRpb24gaXMgZXZlbiwgdGhlIHNlY29uZCBlbnRyeSBzaG91bGQgbWF0Y2ggdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGVpdGhlciBib3RoIGFyZSBjb21wb3NlZCBvciBib3RoIGFyZSBzaW5nbGUgc2FtcGxlcykuIEJ1dCBpZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpbGF0aW9uIGlzIG9kZCwgdGhlbiB0aGUgc2Vjb25kIGVudHJ5IHNob3VsZCBiZSB0aGUgb3Bwb3NpdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgZmlyc3QgKGlmIHRoZSBmaXJzdCBpcyBjb21wb3NlZCwgdGhlIHNlY29uZCBpcyBhIHNpbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbXBsZSwgYW5kIHZpY2UgdmVyc2EuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0VGV4ZWxPZmZzZXQgPSBwYWRMZWZ0ICUgMiA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmLnV0aWwubmVhcmVzdExhcmdlckV2ZW4oZGlsYXRpb25XaWR0aCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWxhdGlvbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGlsYXRpb25XaWR0aCAlIDIgPT09IDAgJiYgcGFkTGVmdCAlIDIgPT09IDEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkaWxhdGlvbldpZHRoICUgMiAhPT0gMCAmJiBwYWRMZWZ0ICUgMiAhPT0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gXCJcXG4gICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgXCIgKyBwYWRMZWZ0ICUgMiArIFwiICsgXCIgKyBuZXh0VGV4ZWxPZmZzZXQgKyBcIjtcXG5cXG4gICAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIgKyB4TnVtUm93cyArIFwiICYmXFxuICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIgKyByICsgXCJDXCIgKyAoYyArIDIpICsgXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaWxhdGlvbiA+IDEgdGhlbiB0aGUgeFJDJ3Mgd2lsbCBub3QgYmUgYWJsZSB0byBzaGFyZSBhbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzLCBzbyBlYWNoIHhSQyB3aWxsIHJlcXVpcmUgdHdvIHVuaXF1ZSBjYWxscyB0byBnZXRYLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlsYXRpb25XaWR0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5Mb29wICs9IFwiXFxuICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCAtPSAyO1xcbiAgICAgICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiICsgeE51bVJvd3MgKyBcIiAmJlxcbiAgICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIiArIHIgKyBcIkNcIiArIGMgKyBcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiICsgciArIFwiQ1wiICsgYyArIFwiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gXCJcXG4gICAgICAgICAgICAgICAgICB4UlwiICsgciArIFwiQ1wiICsgKGMgKyAxKSArIFwiID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIiArIHIgKyBcIkNcIiArIGMgKyBcIi56dywgeFRleGVsUlwiICsgciArIFwiQ1wiICsgKGMgKyAyKSArIFwiLnh5KTtcXG4gICAgICAgICAgICAgICAgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluTG9vcCArPSBcIlxcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBcIiArIG5leHRUZXhlbE9mZnNldCArIFwiO1xcblxcbiAgICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIiArIHhOdW1Sb3dzICsgXCIgJiZcXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIiArIHIgKyBcIkNcIiArIChjICsgMikgKyBcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICB4UlwiICsgciArIFwiQ1wiICsgKGMgKyAxKSArIFwiID0geFRleGVsUlwiICsgciArIFwiQ1wiICsgKGMgKyAyKSArIFwiO1xcbiAgICAgICAgICAgICAgICBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIHN0cmlkZSA+IDFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gXCJcXG4gICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIiArIHhOdW1Sb3dzICsgXCIpIHtcXG4gICAgICAgICAgICBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB3aGV0aGVyIHBhZExlZnQgaXMgZXZlbiBvciBvZGQsIHdlIHdhbnQgZWl0aGVyIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geHkgb3IgencgY2hhbm5lbHMgZnJvbSBYIHRleGVscyBmb3IgeFIke3J9QyR7Y30uIElmIHBhZExlZnQgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4sIHhSJHtyfUMke2MgKyAxfSBpcyBzaW1wbHkgdGhlIHp3IGNoYW5uZWxzIG9mIHRleGVscyB3ZSd2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBzYW1wbGVkLiBCdXQgaWYgcGFkTGVmdCBpcyBvZGQsIHhSJHtyfUN7JGMgKyAxfS56dyB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNvbWUgZnJvbSB0aGUgeHkgY2hhbm5lbHMgb2YgYSBuZXcgdGV4ZWwsIGhlbmNlIHRoZSBgdmVjNFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluYWxgIGluaXRpYWxpemVkIGJlbG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZExlZnQgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gXCJcXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSBcIiArIHN0cmlkZVdpZHRoICsgXCI7XFxuICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIgKyByICsgXCJDXCIgKyBjICsgXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIgKyByICsgXCJDXCIgKyBjICsgXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZih4QyArIDEgPj0gMCAmJiB4QyArIDEgPCBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIgKyByICsgXCJDXCIgKyAoYyArIDIpICsgXCIgPSBnZXRYKGJhdGNoLCB4UiwgeEMgKyAxLCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiICsgciArIFwiQ1wiICsgKGMgKyAyKSArIFwiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeFJcIiArIHIgKyBcIkNcIiArIGMgKyBcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiICsgciArIFwiQ1wiICsgYyArIFwiLnp3LCB4VGV4ZWxSXCIgKyByICsgXCJDXCIgKyAoYyArIDIpICsgXCIuencpO1xcbiAgICAgICAgICAgICAgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgKyAxIDwgZmlsdGVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gXCJcXG4gICAgICAgICAgICAgICAgICB2ZWM0IGZpbmFsID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgKyBcIiArIHN0cmlkZVdpZHRoICsgXCI7XFxuICAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiICsgeE51bUNvbHMgKyBcIikge1xcbiAgICAgICAgICAgICAgICAgICAgZmluYWwgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgeFJcIiArIHIgKyBcIkNcIiArIChjICsgMSkgKyBcIiA9IHZlYzQoeFRleGVsUlwiICsgciArIFwiQ1wiICsgKGMgKyAyKSArIFwiLnh5LCBmaW5hbC54eSk7XFxuICAgICAgICAgICAgICAgIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5Mb29wICs9IFwiXFxuICAgICAgICAgICAgICAgIGlmKHhDID49IDAgJiYgeEMgPCBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIgKyByICsgXCJDXCIgKyBjICsgXCIgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIgKyByICsgXCJDXCIgKyBjICsgXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgXCIgKyBzdHJpZGVXaWR0aCArIFwiO1xcbiAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiICsgciArIFwiQ1wiICsgKGMgKyAyKSArIFwiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiICsgciArIFwiQ1wiICsgKGMgKyAyKSArIFwiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeFJcIiArIHIgKyBcIkNcIiArIGMgKyBcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiICsgciArIFwiQ1wiICsgYyArIFwiLnh5LCB4VGV4ZWxSXCIgKyByICsgXCJDXCIgKyAoYyArIDIpICsgXCIueHkpO1xcbiAgICAgICAgICAgICAgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgKyAxIDwgZmlsdGVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gXCJcXG4gICAgICAgICAgICAgICAgICB4UlwiICsgciArIFwiQ1wiICsgKGMgKyAxKSArIFwiID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIiArIHIgKyBcIkNcIiArIGMgKyBcIi56dywgeFRleGVsUlwiICsgciArIFwiQ1wiICsgKGMgKyAyKSArIFwiLnp3KTtcXG4gICAgICAgICAgICAgICAgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gXCJ9XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluTG9vcCArPSBcIlxcbiAgICAgICAgICAgIHZlYzQgd1RleGVsUlwiICsgciArIFwiQ1wiICsgYyArIFwiID0gZ2V0VyhcIiArIHIgKyBcIiwgXCIgKyBjICsgXCIsIGQxLCBxKTtcXG4gICAgICAgICAgICB3UlwiICsgciArIFwiQ1wiICsgYyArIFwiID0gdmVjNCh3VGV4ZWxSXCIgKyByICsgXCJDXCIgKyBjICsgXCIueHosIHdUZXhlbFJcIiArIHIgKyBcIkNcIiArIGMgKyBcIi54eik7XFxuICAgICAgICAgIFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyArIDEgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gXCJcXG4gICAgICAgICAgICAgIHZlYzQgd1RleGVsUlwiICsgciArIFwiQ1wiICsgKGMgKyAxKSArIFwiID0gZ2V0VyhcIiArIHIgKyBcIiwgXCIgKyAoYyArIDEpICsgXCIsIGQxLCBxKTtcXG4gICAgICAgICAgICAgIHdSXCIgKyByICsgXCJDXCIgKyAoYyArIDEpICsgXCIgPVxcbiAgICAgICAgICAgICAgICB2ZWM0KHdUZXhlbFJcIiArIHIgKyBcIkNcIiArIChjICsgMSkgKyBcIi54eiwgd1RleGVsUlwiICsgciArIFwiQ1wiICsgKGMgKyAxKSArIFwiLnh6KTtcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGZpbHRlckhlaWdodDsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGZpbHRlcldpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICBtYWluTG9vcCArPSBcImRvdFByb2QgKz0geFJcIiArIHIgKyBcIkNcIiArIGMgKyBcIiAqIHdSXCIgKyByICsgXCJDXCIgKyBjICsgXCI7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGl2YXRpb25TbmlwcGV0ID0gJycsIGFwcGx5QWN0aXZhdGlvblNuaXBwZXQgPSAnJztcbiAgICAgICAgaWYgKGFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uU25pcHBldCA9IFwidmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcXG4gICAgICAgICAgXCIgKyBhY3RpdmF0aW9uICsgXCJcXG4gICAgICAgIH1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0xlYWt5UmVsdUFscGhhKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBcInZlYzQgYWN0aXZhdGlvbih2ZWM0IGEpIHtcXG4gICAgICAgICAgdmVjNCBiID0gZ2V0TGVha3lyZWx1QWxwaGFBdE91dENvb3JkcygpO1xcbiAgICAgICAgICBcIiArIGFjdGl2YXRpb24gKyBcIlxcbiAgICAgICAgfVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBcInZlYzQgYWN0aXZhdGlvbih2ZWM0IHgpIHtcXG4gICAgICAgICAgXCIgKyBhY3RpdmF0aW9uICsgXCJcXG4gICAgICAgIH1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwcGx5QWN0aXZhdGlvblNuaXBwZXQgPSBcInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRkQmlhc1NuaXBwZXQgPSBhZGRCaWFzID8gJ3Jlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTsnIDogJyc7XG4gICAgICAgIGlmIChhZGRCaWFzKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdwcmVsdUFjdGl2YXRpb25XZWlnaHRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xlYWt5UmVsdUFscGhhKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnbGVha3lyZWx1QWxwaGEnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBcIiArIGFjdGl2YXRpb25TbmlwcGV0ICsgXCJcXG5cXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiwgXCIgKyBzdHJpZGVXaWR0aCArIFwiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG5cXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQxID0gZDI7XFxuICAgICAgICBpbnQgcSA9IDA7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgdmVjNCBkb3RQcm9kID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBcIiArIG1haW5Mb29wICsgXCJcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gZG90UHJvZDtcXG4gICAgICAgIFwiICsgYWRkQmlhc1NuaXBwZXQgKyBcIlxcbiAgICAgICAgXCIgKyBhcHBseUFjdGl2YXRpb25TbmlwcGV0ICsgXCJcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBEZXB0aHdpc2VDb252UGFja2VkMkRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZGVwdGh3aXNlQ29udjJkTmF0aXZlKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54LCBmaWx0ZXIgPSBpbnB1dHMuZmlsdGVyO1xuICAgIHZhciBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBkaWxhdGlvbnMgPSBhdHRycy5kaWxhdGlvbnMsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZTtcbiAgICB2YXIgJGRpbGF0aW9ucyA9IGRpbGF0aW9ucztcbiAgICBpZiAoJGRpbGF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICRkaWxhdGlvbnMgPSBbMSwgMV07XG4gICAgfVxuICAgIHRmLnV0aWwuYXNzZXJ0KHRmLmJhY2tlbmRfdXRpbC5laXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUoc3RyaWRlcywgJGRpbGF0aW9ucyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlICcgK1xuICAgICAgICAoXCIxLiBHb3Qgc3RyaWRlcyBcIiArIHN0cmlkZXMgKyBcIiBhbmQgZGlsYXRpb25zICdcIiArICRkaWxhdGlvbnMgKyBcIidcIik7IH0pO1xuICAgIHZhciBjb252SW5mbyA9IHRmLmJhY2tlbmRfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4LnNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsICRkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlLCB0cnVlIC8qIGRlcHRod2lzZSAqLyk7XG4gICAgdmFyIHByb2dyYW07XG4gICAgaWYgKHRmLmVudigpLmdldEJvb2woJ1dFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVicpICYmIGNvbnZJbmZvLnN0cmlkZVdpZHRoIDw9IDIgJiZcbiAgICAgICAgY29udkluZm8ub3V0Q2hhbm5lbHMgLyBjb252SW5mby5pbkNoYW5uZWxzID09PSAxKSB7XG4gICAgICAgIHByb2dyYW0gPSBuZXcgRGVwdGh3aXNlQ29udlBhY2tlZDJEUHJvZ3JhbShjb252SW5mbyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm9ncmFtID0gbmV3IERlcHRod2lzZUNvbnYyRFByb2dyYW0oY29udkluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3gsIGZpbHRlcl0sICdmbG9hdDMyJyk7XG59XG52YXIgZGVwdGh3aXNlQ29udjJkTmF0aXZlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkRlcHRod2lzZUNvbnYyZE5hdGl2ZSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBkZXB0aHdpc2VDb252MmROYXRpdmUsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRGVwdGh3aXNlQ29udjJERGVyRmlsdGVyUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXB0aHdpc2VDb252MkREZXJGaWx0ZXJQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdkeSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uZmlsdGVyU2hhcGU7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgY2hhbm5lbE11bCA9IGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscztcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZG0gPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMiA9IGQxICogXCIgKyBjaGFubmVsTXVsICsgXCIgKyBkbTtcXG5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICAvLyBUTyBETzogVmVjNCBvdmVyIHRoZSBiYXRjaCBzaXplXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiICsgY29udkluZm8uYmF0Y2hTaXplICsgXCI7IGIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIgKyBjb252SW5mby5vdXRIZWlnaHQgKyBcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIiArIHN0cmlkZUhlaWdodCArIFwiIC0gXCIgKyBwYWRUb3AgKyBcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIiArIGNvbnZJbmZvLm91dFdpZHRoICsgXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIiArIHN0cmlkZVdpZHRoICsgXCIgLSBcIiArIHBhZExlZnQgKyBcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyBjb252SW5mby5pbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIERlcHRod2lzZUNvbnYyRERlckZpbHRlclByb2dyYW07XG59KCkpO1xudmFyIERlcHRod2lzZUNvbnYyRERlcklucHV0UHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXB0aHdpc2VDb252MkREZXJJbnB1dFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydkeScsICdXJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5pblNoYXBlO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgY2hhbm5lbE11bCA9IGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscztcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIgKyBzdHJpZGVIZWlnaHQgKyBcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIiArIGNvbnZJbmZvLm91dEhlaWdodCArIFwiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGludCB3UlBlcm0gPSBcIiArIGZpbHRlckhlaWdodCArIFwiIC0gMSAtIHdSO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIgKyBzdHJpZGVXaWR0aCArIFwiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIgKyBjb252SW5mby5vdXRXaWR0aCArIFwiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgaW50IHdDUGVybSA9IFwiICsgZmlsdGVyV2lkdGggKyBcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICAvLyBUTyBETzogVmVjNCBvdmVyIHRoZSBjaGFubmVsTXVsXFxuICAgICAgICAgICAgZm9yIChpbnQgZG0gPSAwOyBkbSA8IFwiICsgY2hhbm5lbE11bCArIFwiOyBkbSsrKSB7XFxuICAgICAgICAgICAgICBpbnQgZDIgPSBkMSAqIFwiICsgY2hhbm5lbE11bCArIFwiICsgZG07XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGRtKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBEZXB0aHdpc2VDb252MkREZXJJbnB1dFByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBkZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcEZpbHRlcihhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueCwgZHkgPSBpbnB1dHMuZHk7XG4gICAgdmFyIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBkaWxhdGlvbnMgPSBhdHRycy5kaWxhdGlvbnMsIHBhZCA9IGF0dHJzLnBhZCwgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlLCBmaWx0ZXJTaGFwZSA9IGF0dHJzLmZpbHRlclNoYXBlO1xuICAgIHZhciBjb252SW5mbyA9IHRmLmJhY2tlbmRfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4LnNoYXBlLCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSwgdHJ1ZSAvKiBkZXB0aHdpc2UgKi8pO1xuICAgIHZhciBwcm9ncmFtID0gbmV3IERlcHRod2lzZUNvbnYyRERlckZpbHRlclByb2dyYW0oY29udkluZm8pO1xuICAgIHJldHVybiBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbeCwgZHldLCAnZmxvYXQzMicpO1xufVxudmFyIGRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wRmlsdGVyQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wRmlsdGVyLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wRmlsdGVyXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBkZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcElucHV0KGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgZHkgPSBpbnB1dHMuZHksIGZpbHRlciA9IGlucHV0cy5maWx0ZXI7XG4gICAgdmFyIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBkaWxhdGlvbnMgPSBhdHRycy5kaWxhdGlvbnMsIHBhZCA9IGF0dHJzLnBhZCwgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlLCBpbnB1dFNoYXBlID0gYXR0cnMuaW5wdXRTaGFwZTtcbiAgICB2YXIgY29udkluZm8gPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZUNvbnYyREluZm8oaW5wdXRTaGFwZSwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlLCB0cnVlIC8qIGRlcHRod2lzZSAqLyk7XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgRGVwdGh3aXNlQ29udjJERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2R5LCBmaWx0ZXJdLCAnZmxvYXQzMicpO1xufVxudmFyIGRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wSW5wdXRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuRGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BJbnB1dCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBkZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcElucHV0XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRGlhZ1Byb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlhZ1Byb2dyYW0oc2l6ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ1gnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtzaXplLCBzaXplXTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgZmxvYXQgdmFsID0gY29vcmRzWzBdID09IGNvb3Jkc1sxXSA/IGdldFgoY29vcmRzWzBdKSA6IDAuMDtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIERpYWdQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZGlhZyhhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIG91dFNoYXBlID0geC5zaGFwZS5jb25jYXQoeC5zaGFwZSk7XG4gICAgdmFyIHhTaXplID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKHguc2hhcGUpO1xuICAgIHZhciBmbGF0ID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBbeFNpemVdIH0gfSk7XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgRGlhZ1Byb2dyYW0oeFNpemUpO1xuICAgIHZhciByZXMgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbZmxhdF0sIGZsYXQuZHR5cGUpO1xuICAgIHZhciBvdXQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHJlcyB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogb3V0U2hhcGUgfSB9KTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGZsYXQpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzKTtcbiAgICByZXR1cm4gb3V0O1xufVxudmFyIGRpYWdDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuRGlhZyxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBkaWFnXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRGlsYXRpb24yRFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlsYXRpb24yRFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICAgICB2YXIgaW5IZWlnaHQgPSBjb252SW5mby5pbkhlaWdodCwgaW5XaWR0aCA9IGNvbnZJbmZvLmluV2lkdGgsIHBhZEluZm8gPSBjb252SW5mby5wYWRJbmZvLCBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGgsIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aCwgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodCwgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBwYWRJbmZvLnRvcCwgcGFkTGVmdCA9IHBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG4gICAgICBjb25zdCBmbG9hdCBuZWdfaW5maW5pdHkgPSAtMy40ZTM4O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMudztcXG4gICAgICAgIGl2ZWMyIG91dFRvcExlZnRDb3JuZXIgPVxcbiAgICAgICAgICAgIGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IGhCZWcgPSBvdXRUb3BMZWZ0Q29ybmVyLng7XFxuICAgICAgICBpbnQgd0JlZyA9IG91dFRvcExlZnRDb3JuZXIueTtcXG5cXG4gICAgICAgIGZsb2F0IGN1clZhbCA9IG5lZ19pbmZpbml0eTtcXG4gICAgICAgIGZvciAoaW50IGggPSAwOyBoIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgaCsrKSB7XFxuICAgICAgICAgIGludCBoSW4gPSBoQmVnICsgaCAqIFwiICsgZGlsYXRpb25IZWlnaHQgKyBcIjtcXG5cXG4gICAgICAgICAgaWYgKGhJbiA+PSAwICYmIGhJbiA8IFwiICsgaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgIGZvciAoaW50IHcgPSAwOyB3IDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3KyspIHtcXG4gICAgICAgICAgICAgIGludCB3SW4gPSB3QmVnICsgdyAqIFwiICsgZGlsYXRpb25XaWR0aCArIFwiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHdJbiA+PSAwICYmIHdJbiA8IFwiICsgaW5XaWR0aCArIFwiKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBoSW4sIHdJbiwgZDEpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0VyhoLCB3LCBkMSk7XFxuXFxuICAgICAgICAgICAgICAgIGZsb2F0IHZhbCA9IHhWYWwgKyB3VmFsO1xcbiAgICAgICAgICAgICAgICBpZiAodmFsID4gY3VyVmFsKSB7XFxuICAgICAgICAgICAgICAgICAgY3VyVmFsID0gdmFsO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSBjdXJWYWw7XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gRGlsYXRpb24yRFByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBkaWxhdGlvbjJEKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54LCBmaWx0ZXIgPSBpbnB1dHMuZmlsdGVyO1xuICAgIHZhciBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBkaWxhdGlvbnMgPSBhdHRycy5kaWxhdGlvbnM7XG4gICAgdmFyIGNvbnZJbmZvID0gdGYuYmFja2VuZF91dGlsLmNvbXB1dGVEaWxhdGlvbjJESW5mbyh4LnNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIHBhZCwgJ05IV0MnIC8qIGRhdGFGb3JtYXQgKi8sIGRpbGF0aW9ucyk7XG4gICAgdmFyIG91dDtcbiAgICB2YXIgcHJvZ3JhbSA9IG5ldyBEaWxhdGlvbjJEUHJvZ3JhbShjb252SW5mbyk7XG4gICAgb3V0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3gsIGZpbHRlcl0sICdmbG9hdDMyJyk7XG4gICAgdmFyIG91dFJlc2hhcGVkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiBvdXQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IGNvbnZJbmZvLm91dFNoYXBlIH0gfSk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvdXQpO1xuICAgIHJldHVybiBvdXRSZXNoYXBlZDtcbn1cbnZhciBkaWxhdGlvbjJEQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkRpbGF0aW9uMkQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogZGlsYXRpb24yRCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBFTFUkMiA9IFwicmV0dXJuICh4ID49IDAuMCkgPyB4IDogKGV4cCh4KSAtIDEuMCk7XCI7XG52YXIgRUxVX1BBQ0tFRCA9IFwiXFxuICB2ZWM0IHJlc3VsdDtcXG5cXG4gIHJlc3VsdC5yID0gKHguciA+PSAwLjApID8geC5yIDogKGV4cCh4LnIpIC0gMS4wKTtcXG4gIHJlc3VsdC5nID0gKHguZyA+PSAwLjApID8geC5nIDogKGV4cCh4LmcpIC0gMS4wKTtcXG4gIHJlc3VsdC5iID0gKHguYiA+PSAwLjApID8geC5iIDogKGV4cCh4LmIpIC0gMS4wKTtcXG4gIHJlc3VsdC5hID0gKHguYSA+PSAwLjApID8geC5hIDogKGV4cCh4LmEpIC0gMS4wKTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCI7XG52YXIgZWx1ID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBFTFUkMiwgcGFja2VkT3BTbmlwcGV0OiBFTFVfUEFDS0VEIH0pO1xudmFyIGVsdUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5FbHUsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogZWx1XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRUxVX0RFUiA9IFwicmV0dXJuIChiID49IDEuMCkgPyBhIDogYSAqIChiICsgMS4wKTtcIjtcbnZhciBFTFVfREVSX1BBQ0tFRCA9IFwiXFxuICB2ZWM0IGJHVEVaZXJvID0gdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMC4pKSk7XFxuICByZXR1cm4gKGJHVEVaZXJvICogYSkgKyAoKHZlYzQoMS4wKSAtIGJHVEVaZXJvKSAqIChhICogKGIgKyB2ZWM0KDEuMCkpKSk7XFxuXCI7XG52YXIgZWx1R3JhZCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciBkeSA9IGlucHV0cy5keSwgeSA9IGlucHV0cy55O1xuICAgIHZhciBwcm9ncmFtID0gdGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OUycpID9cbiAgICAgICAgbmV3IEJpbmFyeU9wUGFja2VkUHJvZ3JhbShFTFVfREVSX1BBQ0tFRCwgZHkuc2hhcGUsIHkuc2hhcGUpIDpcbiAgICAgICAgbmV3IEJpbmFyeU9wUHJvZ3JhbShFTFVfREVSLCBkeS5zaGFwZSwgeS5zaGFwZSk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFtkeSwgeV0sIGR5LmR0eXBlKTtcbn07XG52YXIgZWx1R3JhZENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5FbHVHcmFkLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGVsdUdyYWRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBQQUNLRURfRVFVQUwgPSBcIlxcbiAgcmV0dXJuIHZlYzQoZXF1YWwoYSwgYikpO1xcblwiO1xudmFyIEVRVUFMID0gXCJyZXR1cm4gZmxvYXQoYSA9PSBiKTtcIjtcbnZhciBlcXVhbCA9IGJpbmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IEVRVUFMLCBwYWNrZWRPcFNuaXBwZXQ6IFBBQ0tFRF9FUVVBTCwgZHR5cGU6ICdib29sJyB9KTtcbnZhciBlcXVhbENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5FcXVhbCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBlcXVhbFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIEVSRiA9IFwiXFxuICAvLyBFcnJvciBmdW5jdGlvbiBpcyBjYWxjdWxhdGVkIGFwcHJveGltYXRlbHkgd2l0aCBlbGVtZW50YXJ5IGZ1bmN0aW9uLlxcbiAgLy8gU2VlIFxcXCJIYW5kYm9vayBvZiBNYXRoZW1hdGljYWwgRnVuY3Rpb25zIHdpdGggRm9ybXVsYXMsXFxuICAvLyBHcmFwaHMsIGFuZCBNYXRoZW1hdGljYWwgVGFibGVzXFxcIiwgQWJyYW1vd2l0eiBhbmQgU3RlZ3VuLlxcbiAgZmxvYXQgcCA9IFwiICsgdGYuYmFja2VuZF91dGlsLkVSRl9QICsgXCI7XFxuICBmbG9hdCBhMSA9IFwiICsgdGYuYmFja2VuZF91dGlsLkVSRl9BMSArIFwiO1xcbiAgZmxvYXQgYTIgPSBcIiArIHRmLmJhY2tlbmRfdXRpbC5FUkZfQTIgKyBcIjtcXG4gIGZsb2F0IGEzID0gXCIgKyB0Zi5iYWNrZW5kX3V0aWwuRVJGX0EzICsgXCI7XFxuICBmbG9hdCBhNCA9IFwiICsgdGYuYmFja2VuZF91dGlsLkVSRl9BNCArIFwiO1xcbiAgZmxvYXQgYTUgPSBcIiArIHRmLmJhY2tlbmRfdXRpbC5FUkZfQTUgKyBcIjtcXG5cXG4gIGZsb2F0IHNpZ24gPSBzaWduKHgpO1xcbiAgeCA9IGFicyh4KTtcXG4gIGZsb2F0IHQgPSAxLjAgLyAoMS4wICsgcCAqIHgpO1xcbiAgcmV0dXJuIHNpZ24gKiAoMS4wIC0gKCgoKChhNSp0ICsgYTQpKnQpICsgYTMpKnQgKyBhMikqdCArIGExKSp0KmV4cCgteCp4KSk7XFxuXCI7XG52YXIgZXJmID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBFUkYgfSk7XG52YXIgZXJmQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkVyZixcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBlcmYsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRVhQID0gXCJyZXR1cm4gZXhwKHgpO1wiO1xudmFyIGV4cCA9IHVuYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogRVhQLCBwYWNrZWRPcFNuaXBwZXQ6IEVYUCwgY3B1S2VybmVsSW1wbDogZXhwSW1wbENQVSB9KTtcbnZhciBleHBDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuRXhwLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGV4cFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIEFTIElTIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGV4cGFuZERpbXMoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYXR0cnMgPSBhcmdzLmF0dHJzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciBkaW0gPSBhdHRycy5kaW07XG4gICAgdmFyIGlucHV0ID0gaW5wdXRzLmlucHV0O1xuICAgIHZhciBpbnB1dFJhbmsgPSBpbnB1dC5zaGFwZS5sZW5ndGg7XG4gICAgdmFyIG5ld1NoYXBlID0gaW5wdXQuc2hhcGUuc2xpY2UoKTtcbiAgICB2YXIgJGRpbSA9IGRpbTtcbiAgICBpZiAoZGltIDwgMCkge1xuICAgICAgICAvLyBOZWdhdGl2ZSB2YWx1ZSBpcyBjb3VudGVkIGZyb20gdGhlIHRhaWwgb2YgcmFuay5cbiAgICAgICAgdGYudXRpbC5hc3NlcnQoLShpbnB1dFJhbmsgKyAxKSA8PSBkaW0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQXhpcyBtdXN0IGJlIGluIHRoZSBpbnRlcnZhbCBbXCIgKyAtKGlucHV0UmFuayArIDEpICsgXCIsIFwiICsgaW5wdXRSYW5rICsgXCJdXCI7IH0pO1xuICAgICAgICAkZGltID0gaW5wdXRSYW5rICsgZGltICsgMTtcbiAgICB9XG4gICAgbmV3U2hhcGUuc3BsaWNlKCRkaW0sIDAsIDEpO1xuICAgIHJldHVybiByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IGlucHV0IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBuZXdTaGFwZSB9IH0pO1xufVxudmFyIGV4cGFuZERpbXNDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuRXhwYW5kRGltcyxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBleHBhbmREaW1zLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIEVYUE0xID0gXCJyZXR1cm4gZXhwKHgpIC0gMS4wO1wiO1xudmFyIGV4cG0xID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBFWFBNMSwgcGFja2VkT3BTbmlwcGV0OiBFWFBNMSwgY3B1S2VybmVsSW1wbDogZXhwbTFJbXBsQ1BVIH0pO1xudmFyIGV4cG0xQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkV4cG0xLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGV4cG0xXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRkZUUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGRlRQcm9ncmFtKGNvbXBvbmVudCwgaW5wdXRTaGFwZSwgaW52ZXJzZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3JlYWwnLCAnaW1hZyddO1xuICAgICAgICB2YXIgaW5uZXJEaW0gPSBpbnB1dFNoYXBlWzFdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgICAgICAgdmFyIGV4cG9uZW50TXVsdGlwbGllclNuaXBwZXQgPSBpbnZlcnNlID8gXCIyLjAgKiBcIiArIE1hdGguUEkgOiBcIi0yLjAgKiBcIiArIE1hdGguUEk7XG4gICAgICAgIHZhciByZXN1bHREZW5vbWluYXRvciA9IGludmVyc2UgPyBpbm5lckRpbSArIFwiLjBcIiA6ICcxLjAnO1xuICAgICAgICB2YXIgb3BTdHJpbmc7XG4gICAgICAgIGlmIChjb21wb25lbnQgPT09ICdyZWFsJykge1xuICAgICAgICAgICAgb3BTdHJpbmcgPSAncmV0dXJuIHJlYWwgKiBleHBSIC0gaW1hZyAqIGV4cEk7JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQgPT09ICdpbWFnJykge1xuICAgICAgICAgICAgb3BTdHJpbmcgPSAncmV0dXJuIHJlYWwgKiBleHBJICsgaW1hZyAqIGV4cFI7JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZGVCBjb21wb25lbnQgbXVzdCBiZSBlaXRoZXIgXFxcInJlYWxcXFwiIG9yIFxcXCJpbWFnXFxcIiwgZ290IFwiICsgY29tcG9uZW50ICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGZsb2F0IGV4cG9uZW50TXVsdGlwbGllciA9IFwiICsgZXhwb25lbnRNdWx0aXBsaWVyU25pcHBldCArIFwiO1xcblxcbiAgICAgIGZsb2F0IHVuYXJ5T3BDb21wbGV4KGZsb2F0IHJlYWwsIGZsb2F0IGV4cFIsIGZsb2F0IGltYWcsIGZsb2F0IGV4cEkpIHtcXG4gICAgICAgIFwiICsgb3BTdHJpbmcgKyBcIlxcbiAgICAgIH1cXG5cXG4gICAgICBmbG9hdCBtdWxNYXRERlQoaW50IGJhdGNoLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4UmF0aW8gPSBmbG9hdChpbmRleCkgLyBmbG9hdChcIiArIGlubmVyRGltICsgXCIpO1xcbiAgICAgICAgZmxvYXQgZXhwb25lbnRNdWx0aXBsaWVyVGltZXNJbmRleFJhdGlvID1cXG4gICAgICAgICAgICBleHBvbmVudE11bHRpcGxpZXIgKiBpbmRleFJhdGlvO1xcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIGlubmVyRGltICsgXCI7IGkrKykge1xcbiAgICAgICAgICAvLyB4ID0gKC0yfDIgKiBQSSAvIE4pICogaW5kZXggKiBpO1xcbiAgICAgICAgICBmbG9hdCB4ID0gZXhwb25lbnRNdWx0aXBsaWVyVGltZXNJbmRleFJhdGlvICogZmxvYXQoaSk7XFxuICAgICAgICAgIGZsb2F0IGV4cFIgPSBjb3MoeCk7XFxuICAgICAgICAgIGZsb2F0IGV4cEkgPSBzaW4oeCk7XFxuICAgICAgICAgIGZsb2F0IHJlYWwgPSBnZXRSZWFsKGJhdGNoLCBpKTtcXG4gICAgICAgICAgZmxvYXQgaW1hZyA9IGdldEltYWcoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICByZXN1bHQgKz1cXG4gICAgICAgICAgICAgIHVuYXJ5T3BDb21wbGV4KHJlYWwsIGV4cFIsIGltYWcsIGV4cEkpIC8gXCIgKyByZXN1bHREZW5vbWluYXRvciArIFwiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQobXVsTWF0REZUKGNvb3Jkc1swXSwgY29vcmRzWzFdKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEZGVFByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBmZnRJbXBsKHgsIGludmVyc2UsIGJhY2tlbmQpIHtcbiAgICB2YXIgeERhdGEgPSBiYWNrZW5kLnRleERhdGEuZ2V0KHguZGF0YUlkKTtcbiAgICB2YXIgaW5wdXRTaXplID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKHguc2hhcGUpO1xuICAgIC8vIENvbGxhcHNlIGFsbCBvdXRlciBkaW1lbnNpb25zIHRvIGEgc2luZ2xlIGJhdGNoIGRpbWVuc2lvbi5cbiAgICB2YXIgaW5uZXJEaW1lbnNpb25TaXplID0geC5zaGFwZVt4LnNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIHZhciBiYXRjaCA9IGlucHV0U2l6ZSAvIGlubmVyRGltZW5zaW9uU2l6ZTtcbiAgICB2YXIgaW5wdXQyRCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogW2JhdGNoLCBpbm5lckRpbWVuc2lvblNpemVdIH0gfSk7XG4gICAgdmFyIHhTaGFwZSA9IGlucHV0MkQuc2hhcGU7XG4gICAgdmFyIHJlYWxQcm9ncmFtID0gbmV3IEZGVFByb2dyYW0oJ3JlYWwnLCB4U2hhcGUsIGludmVyc2UpO1xuICAgIHZhciBpbWFnUHJvZ3JhbSA9IG5ldyBGRlRQcm9ncmFtKCdpbWFnJywgeFNoYXBlLCBpbnZlcnNlKTtcbiAgICB2YXIgaW5wdXRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBkYXRhSWQ6IHhEYXRhLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLmRhdGFJZCxcbiAgICAgICAgICAgIGR0eXBlOiB4RGF0YS5jb21wbGV4VGVuc29ySW5mb3MucmVhbC5kdHlwZSxcbiAgICAgICAgICAgIHNoYXBlOiB4U2hhcGVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgZGF0YUlkOiB4RGF0YS5jb21wbGV4VGVuc29ySW5mb3MuaW1hZy5kYXRhSWQsXG4gICAgICAgICAgICBkdHlwZTogeERhdGEuY29tcGxleFRlbnNvckluZm9zLmltYWcuZHR5cGUsXG4gICAgICAgICAgICBzaGFwZTogeFNoYXBlXG4gICAgICAgIH1cbiAgICBdO1xuICAgIHZhciByZWFsUGFydCA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHJlYWxQcm9ncmFtLCBpbnB1dHMsICdmbG9hdDMyJyk7XG4gICAgdmFyIGltYWdQYXJ0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0oaW1hZ1Byb2dyYW0sIGlucHV0cywgJ2Zsb2F0MzInKTtcbiAgICB2YXIgY29tcGxleE91dHB1dCA9IGNvbXBsZXgoeyBpbnB1dHM6IHsgcmVhbDogcmVhbFBhcnQsIGltYWc6IGltYWdQYXJ0IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyZWFsUGFydCk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpbWFnUGFydCk7XG4gICAgdmFyIGNvbXBsZXhPdXRwdXRSZXNoYXBlZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogY29tcGxleE91dHB1dCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogeC5zaGFwZSB9IH0pO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaW5wdXQyRCk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhjb21wbGV4T3V0cHV0KTtcbiAgICByZXR1cm4gY29tcGxleE91dHB1dFJlc2hhcGVkO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBmZnQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgaW5wdXQgPSBpbnB1dHMuaW5wdXQ7XG4gICAgcmV0dXJuIGZmdEltcGwoaW5wdXQsIGZhbHNlIC8qIGludmVyc2UgKi8sIGJhY2tlbmQpO1xufVxudmFyIGZmdENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5GRlQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogZmZ0XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRmlsbFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlsbFByb2dyYW0oc2hhcGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCB2YWx1ZTtcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAvLyBJbnB1dCBjYW4gYmUgb2J0YWluZWQgZnJvbSB1bmlmb3JtIHZhbHVlLlxcbiAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBGaWxsUHJvZ3JhbS5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ3BncHUsIHdlYkdMUHJvZ3JhbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnZhbHVlTG9jID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZUxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cod2ViR0xQcm9ncmFtLCAndmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihfdGhpcy52YWx1ZUxvYywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEZpbGxQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZmlsbChhcmdzKSB7XG4gICAgdmFyIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgc2hhcGUgPSBhdHRycy5zaGFwZSwgdmFsdWUgPSBhdHRycy52YWx1ZTtcbiAgICB2YXIgZHR5cGUgPSBhdHRycy5kdHlwZTtcbiAgICBkdHlwZSA9IGR0eXBlIHx8IHRmLnV0aWwuaW5mZXJEdHlwZSh2YWx1ZSk7XG4gICAgaWYgKGR0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBTdHJpbmcgdHlwZSBzaG91bGQgYmUgaGFuZGxlZCBpbiBDUFUgbWVtb3J5LlxuICAgICAgICB2YXIgdmFsdWVzID0gdGYudXRpbC5nZXRBcnJheUZyb21EVHlwZShkdHlwZSwgdGYudXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKSk7XG4gICAgICAgIHZhbHVlcy5maWxsKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oc2hhcGUsIGR0eXBlLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgRmlsbFByb2dyYW0oc2hhcGUsIHZhbHVlKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmModmFsdWUpO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW10sIGR0eXBlLCBjdXN0b21TZXR1cCk7XG4gICAgfVxufVxudmFyIGZpbGxDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuRmlsbCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBmaWxsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRmxpcExlZnRSaWdodFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmxpcExlZnRSaWdodFByb2dyYW0oaW1hZ2VTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0ltYWdlJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdmFyIGltYWdlV2lkdGggPSBpbWFnZVNoYXBlWzJdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gaW1hZ2VTaGFwZTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpbnQgeCA9IGNvb3Jkc1syXTtcXG5cXG4gICAgICAgICAgaW50IGNvb3JkWCA9IFwiICsgaW1hZ2VXaWR0aCArIFwiIC0geDtcXG4gICAgICAgICAgZmxvYXQgb3V0cHV0VmFsdWU7XFxuICAgICAgICAgIGlmKGNvb3JkWCA+PSAwICYmIGNvb3JkWCA8IFwiICsgaW1hZ2VXaWR0aCArIFwiKSB7XFxuICAgICAgICAgICAgb3V0cHV0VmFsdWUgPSBnZXRJbWFnZShjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRYLCBjb29yZHNbM10pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIG91dHB1dFZhbHVlID0gZ2V0SW1hZ2UoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQob3V0cHV0VmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEZsaXBMZWZ0UmlnaHRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGZsaXBMZWZ0UmlnaHRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuRmxpcExlZnRSaWdodCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGlucHV0cyA9IF9hLmlucHV0cywgYmFja2VuZCA9IF9hLmJhY2tlbmQ7XG4gICAgICAgIHZhciBpbWFnZSA9IGlucHV0cy5pbWFnZTtcbiAgICAgICAgdmFyIHdlYmdsQmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IEZsaXBMZWZ0UmlnaHRQcm9ncmFtKGltYWdlLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHdlYmdsQmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2ltYWdlXSwgaW1hZ2UuZHR5cGUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBGTE9PUiA9IFwicmV0dXJuIGZsb29yKHgpO1wiO1xudmFyIGZsb29yID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBGTE9PUiwgcGFja2VkT3BTbmlwcGV0OiBGTE9PUiwgY3B1S2VybmVsSW1wbDogZmxvb3JJbXBsQ1BVIH0pO1xudmFyIGZsb29yQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkZsb29yLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGZsb29yLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLy8gV2UgdXNlIG5hdGl2ZSBpbnRlZ2VyIGRpdmlzaW9uIHRvIGRlYWwgd2l0aCBmbG9hdGluZyBwb2ludCBpbXByZWNpc2lvbi4gU2luY2Vcbi8vIHdlIGltcGxlbWVudCBmbG9vciBkaXZpc2lvbiBhbmQgZ2xzbCBpbXBsZW1lbnRzIHRydW5jYXRlZCBkaXZpc2lvbiwgd2Vcbi8vIGNvcnJlY3QgZm9yIHRoaXMgYnkgc3VidHJhY3RpbmcgMSBmcm9tIHJlc3VsdCB3aGVuIHRoZSByZXN1bHQgaXMgbmVnYXRpdmUgYW5kXG4vLyB0aGVyZSBpcyBhIHJlbWFpbmRlci5cbnZhciBJTlRfRElWID0gXCJcXG4gIGZsb2F0IHMgPSBzaWduKGEpICogc2lnbihiKTtcXG4gIGludCBpYSA9IHJvdW5kKGEpO1xcbiAgaW50IGliID0gcm91bmQoYik7XFxuICBpZiAoaWIgIT0gMCkge1xcbiAgICAvLyBXaW5kb3dzIChEM0QpIHdhbnRzIGd1YXJhbnRlZWQgbm9uLXplcm8gaW50IGRpdmlzaW9uIGF0IGNvbXBpbGUtdGltZS5cXG4gICAgcmV0dXJuIGZsb2F0KGlkaXYoaWEsIGliLCBzKSk7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gTkFOO1xcbiAgfVxcblwiO1xudmFyIElOVF9ESVZfUEFDS0VEID0gXCJcXG4gIGl2ZWM0IGlhID0gcm91bmQoYSk7XFxuICBpdmVjNCBpYiA9IHJvdW5kKGIpO1xcbiAgYnZlYzQgY29uZCA9IG5vdEVxdWFsKGliLCBpdmVjNCgwKSk7XFxuICBpdmVjNCByZXN1bHQgPSBpdmVjNCgwKTtcXG4gIHZlYzQgcyA9IHNpZ24oYSkgKiBzaWduKGIpO1xcblxcbiAgLy8gV2luZG93cyAoRDNEKSB3YW50cyBndWFyYW50ZWVkIG5vbi16ZXJvIGludCBkaXZpc2lvbiBhdCBjb21waWxlLXRpbWUuXFxuICBpZiAoY29uZFswXSkge1xcbiAgICByZXN1bHRbMF0gPSBpZGl2KGlhWzBdLCBpYlswXSwgc1swXSk7XFxuICB9XFxuICBpZiAoY29uZFsxXSkge1xcbiAgICByZXN1bHRbMV0gPSBpZGl2KGlhWzFdLCBpYlsxXSwgc1sxXSk7XFxuICB9XFxuICBpZiAoY29uZFsyXSkge1xcbiAgICByZXN1bHRbMl0gPSBpZGl2KGlhWzJdLCBpYlsyXSwgc1syXSk7XFxuICB9XFxuICBpZiAoY29uZFszXSkge1xcbiAgICByZXN1bHRbM10gPSBpZGl2KGlhWzNdLCBpYlszXSwgc1szXSk7XFxuICB9XFxuICByZXR1cm4gdmVjNChyZXN1bHQpO1xcblwiO1xudmFyIGZsb29yRGl2ID0gYmluYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogSU5UX0RJViwgcGFja2VkT3BTbmlwcGV0OiBJTlRfRElWX1BBQ0tFRCwgZHR5cGU6ICdpbnQzMicgfSk7XG52YXIgZmxvb3JEaXZDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuRmxvb3JEaXYsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogZmxvb3JEaXZcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBGcm9tUGl4ZWxzUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcm9tUGl4ZWxzUHJvZ3JhbShvdXRwdXRTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIGdsc2wgPSBnZXRHbHNsRGlmZmVyZW5jZXMoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IG91dHB1dFNoYXBlWzBdLCB3aWR0aCA9IG91dHB1dFNoYXBlWzFdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHRleFIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgdGV4QyA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBkZXB0aCA9IGNvb3Jkc1syXTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiICsgd2lkdGggKyBcIi4wLCBcIiArIGhlaWdodCArIFwiLjApO1xcblxcbiAgICAgICAgdmVjNCB2YWx1ZXMgPSBcIiArIGdsc2wudGV4dHVyZTJEICsgXCIoQSwgdXYpO1xcbiAgICAgICAgZmxvYXQgdmFsdWU7XFxuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5yO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAxKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmc7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDIpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYjtcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMykge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5hO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGZsb29yKHZhbHVlICogMjU1LjAgKyAwLjUpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gRnJvbVBpeGVsc1Byb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgRnJvbVBpeGVsc1BhY2tlZFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnJvbVBpeGVsc1BhY2tlZFByb2dyYW0ob3V0cHV0U2hhcGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMucGFja2VkSW5wdXRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFja2VkT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGdsc2wgPSBnZXRHbHNsRGlmZmVyZW5jZXMoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IG91dHB1dFNoYXBlWzBdLCB3aWR0aCA9IG91dHB1dFNoYXBlWzFdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHRleFIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgdGV4QyA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBkZXB0aCA9IGNvb3Jkc1syXTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBmb3IoaW50IHJvdz0wOyByb3c8PTE7IHJvdysrKSB7XFxuICAgICAgICAgIGZvcihpbnQgY29sPTA7IGNvbDw9MTsgY29sKyspIHtcXG4gICAgICAgICAgICB0ZXhDID0gY29vcmRzWzFdICsgcm93O1xcbiAgICAgICAgICAgIGRlcHRoID0gY29vcmRzWzJdICsgY29sO1xcblxcbiAgICAgICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHdpZHRoICsgXCIuMCwgXCIgKyBoZWlnaHQgKyBcIi4wKTtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IFwiICsgZ2xzbC50ZXh0dXJlMkQgKyBcIihBLCB1dik7XFxuICAgICAgICAgICAgZmxvYXQgdmFsdWU7XFxuICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLnI7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAxKSB7XFxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5nO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMikge1xcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYjtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDMpIHtcXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmE7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJlc3VsdFtyb3cgKiAyICsgY29sXSA9IGZsb29yKHZhbHVlICogMjU1LjAgKyAwLjUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIiArIGdsc2wub3V0cHV0ICsgXCIgPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEZyb21QaXhlbHNQYWNrZWRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGZyb21QaXhlbHNDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuRnJvbVBpeGVscyxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBmcm9tUGl4ZWxzLFxufTtcbnZhciBmcm9tUGl4ZWxzMkRDb250ZXh0O1xuZnVuY3Rpb24gZnJvbVBpeGVscyhhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHBpeGVscyA9IGlucHV0cy5waXhlbHM7XG4gICAgdmFyIG51bUNoYW5uZWxzID0gYXR0cnMubnVtQ2hhbm5lbHM7XG4gICAgdmFyIGlzVmlkZW8gPSB0eXBlb2YgKEhUTUxWaWRlb0VsZW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBwaXhlbHMgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50O1xuICAgIHZhciBpc0ltYWdlID0gdHlwZW9mIChIVE1MSW1hZ2VFbGVtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgcGl4ZWxzIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudDtcbiAgICB2YXIgaXNJbWFnZUJpdG1hcCA9IHR5cGVvZiAoSW1hZ2VCaXRtYXApICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBwaXhlbHMgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcDtcbiAgICB2YXIgX2EgPSBpc1ZpZGVvID9cbiAgICAgICAgW1xuICAgICAgICAgICAgcGl4ZWxzLnZpZGVvV2lkdGgsXG4gICAgICAgICAgICBwaXhlbHMudmlkZW9IZWlnaHRcbiAgICAgICAgXSA6XG4gICAgICAgIFtwaXhlbHMud2lkdGgsIHBpeGVscy5oZWlnaHRdLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICB2YXIgdGV4U2hhcGUgPSBbaGVpZ2h0LCB3aWR0aF07XG4gICAgdmFyIG91dFNoYXBlID0gW2hlaWdodCwgd2lkdGgsIG51bUNoYW5uZWxzXTtcbiAgICBpZiAoaXNJbWFnZSB8fCBpc1ZpZGVvIHx8IGlzSW1hZ2VCaXRtYXApIHtcbiAgICAgICAgaWYgKGZyb21QaXhlbHMyRENvbnRleHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZnJvbVBpeGVsczJEQ29udGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBmcm9tUGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShwaXhlbHMsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwaXhlbHMgPSBmcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcztcbiAgICB9XG4gICAgdmFyIHRlbXBQaXhlbEhhbmRsZSA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8odGV4U2hhcGUsICdpbnQzMicpO1xuICAgIC8vIFRoaXMgaXMgYSBieXRlIHRleHR1cmUgd2l0aCBwaXhlbHMuXG4gICAgYmFja2VuZC50ZXhEYXRhLmdldCh0ZW1wUGl4ZWxIYW5kbGUuZGF0YUlkKS51c2FnZSA9IFRleHR1cmVVc2FnZS5QSVhFTFM7XG4gICAgYmFja2VuZC5ncGdwdS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUoYmFja2VuZC5nZXRUZXh0dXJlKHRlbXBQaXhlbEhhbmRsZS5kYXRhSWQpLCBwaXhlbHMpO1xuICAgIHZhciBwcm9ncmFtID0gdGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfUEFDSycpID9cbiAgICAgICAgbmV3IEZyb21QaXhlbHNQYWNrZWRQcm9ncmFtKG91dFNoYXBlKSA6XG4gICAgICAgIG5ldyBGcm9tUGl4ZWxzUHJvZ3JhbShvdXRTaGFwZSk7XG4gICAgdmFyIHJlcyA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt0ZW1wUGl4ZWxIYW5kbGVdLCAnaW50MzInKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VEYXRhKHRlbXBQaXhlbEhhbmRsZS5kYXRhSWQpO1xuICAgIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIGZ1c2VkQ29udjJkKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54LCBmaWx0ZXIgPSBpbnB1dHMuZmlsdGVyLCBiaWFzID0gaW5wdXRzLmJpYXMsIHByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBpbnB1dHMucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztcbiAgICB2YXIgc3RyaWRlcyA9IGF0dHJzLnN0cmlkZXMsIHBhZCA9IGF0dHJzLnBhZCwgZGF0YUZvcm1hdCA9IGF0dHJzLmRhdGFGb3JtYXQsIGRpbGF0aW9ucyA9IGF0dHJzLmRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlLCBhY3RpdmF0aW9uID0gYXR0cnMuYWN0aXZhdGlvbiwgbGVha3lyZWx1QWxwaGEgPSBhdHRycy5sZWFreXJlbHVBbHBoYTtcbiAgICB2YXIgJGRhdGFGb3JtYXQgPSB0Zi5iYWNrZW5kX3V0aWwuY29udmVydENvbnYyRERhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgdmFyIGNvbnZJbmZvID0gdGYuYmFja2VuZF91dGlsLmNvbXB1dGVDb252MkRJbmZvKHguc2hhcGUsIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSwgZmFsc2UgLyogZGVwdGh3aXNlICovLCAkZGF0YUZvcm1hdCk7XG4gICAgdmFyIG91dDtcbiAgICB2YXIgaW50ZXJtZWRpYXRlcyA9IFtdO1xuICAgIGlmIChjb252SW5mby5maWx0ZXJIZWlnaHQgPT09IDEgJiYgY29udkluZm8uZmlsdGVyV2lkdGggPT09IDEgJiZcbiAgICAgICAgY29udkluZm8uZGlsYXRpb25IZWlnaHQgPT09IDEgJiYgY29udkluZm8uZGlsYXRpb25XaWR0aCA9PT0gMSAmJlxuICAgICAgICBjb252SW5mby5zdHJpZGVIZWlnaHQgPT09IDEgJiYgY29udkluZm8uc3RyaWRlV2lkdGggPT09IDEgJiZcbiAgICAgICAgKGNvbnZJbmZvLnBhZEluZm8udHlwZSA9PT0gJ1NBTUUnIHx8IGNvbnZJbmZvLnBhZEluZm8udHlwZSA9PT0gJ1ZBTElEJykpIHtcbiAgICAgICAgb3V0ID0gY29udjJkQnlNYXRNdWwoe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgY29udkluZm86IGNvbnZJbmZvLFxuICAgICAgICAgICAgYmFja2VuZDogYmFja2VuZCxcbiAgICAgICAgICAgIGJpYXM6IGJpYXMsXG4gICAgICAgICAgICBhY3RpdmF0aW9uOiBhY3RpdmF0aW9uLFxuICAgICAgICAgICAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0czogcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyxcbiAgICAgICAgICAgIGxlYWt5cmVsdUFscGhhOiBsZWFreXJlbHVBbHBoYVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfQ09OVl9JTTJDT0wnKSAmJiB4LnNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgIG91dCA9IGNvbnYyZFdpdGhJbTJSb3coe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgY29udkluZm86IGNvbnZJbmZvLFxuICAgICAgICAgICAgYmFja2VuZDogYmFja2VuZCxcbiAgICAgICAgICAgIGJpYXM6IGJpYXMsXG4gICAgICAgICAgICBhY3RpdmF0aW9uOiBhY3RpdmF0aW9uLFxuICAgICAgICAgICAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0czogcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyxcbiAgICAgICAgICAgIGxlYWt5cmVsdUFscGhhOiBsZWFreXJlbHVBbHBoYVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBoYXNCaWFzID0gYmlhcyAhPSBudWxsO1xuICAgICAgICB2YXIgaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IHByZWx1QWN0aXZhdGlvbldlaWdodHMgIT0gbnVsbDtcbiAgICAgICAgdmFyIGhhc0xlYWt5cmVsdUFscGhhID0gYWN0aXZhdGlvbiA9PT0gJ2xlYWt5cmVsdSc7XG4gICAgICAgIHZhciBmdXNlZEFjdGl2YXRpb24gPSBhY3RpdmF0aW9uID8gbWFwQWN0aXZhdGlvblRvU2hhZGVyUHJvZ3JhbShhY3RpdmF0aW9uLCBmYWxzZSkgOiBudWxsO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBDb252MkRQcm9ncmFtKGNvbnZJbmZvLCBoYXNCaWFzLCBmdXNlZEFjdGl2YXRpb24sIGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMsIGhhc0xlYWt5cmVsdUFscGhhKTtcbiAgICAgICAgdmFyIGlucHV0c18xID0gW3gsIGZpbHRlcl07XG4gICAgICAgIGlmIChiaWFzKSB7XG4gICAgICAgICAgICBpbnB1dHNfMS5wdXNoKGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVsdUFjdGl2YXRpb25XZWlnaHRzKSB7XG4gICAgICAgICAgICBpbnB1dHNfMS5wdXNoKHByZWx1QWN0aXZhdGlvbldlaWdodHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNMZWFreXJlbHVBbHBoYSkge1xuICAgICAgICAgICAgdmFyICRsZWFreXJlbHVBbHBoYSA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8oW10sICdmbG9hdDMyJywgdGYudXRpbC5jcmVhdGVTY2FsYXJWYWx1ZShsZWFreXJlbHVBbHBoYSwgJ2Zsb2F0MzInKSk7XG4gICAgICAgICAgICBpbnB1dHNfMS5wdXNoKCRsZWFreXJlbHVBbHBoYSk7XG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVzLnB1c2goJGxlYWt5cmVsdUFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBpbnB1dHNfMSwgJ2Zsb2F0MzInKTtcbiAgICB9XG4gICAgdmFyIG91dFJlc2hhcGVkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiBvdXQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IGNvbnZJbmZvLm91dFNoYXBlIH0gfSk7XG4gICAgaW50ZXJtZWRpYXRlcy5wdXNoKG91dCk7XG4gICAgaW50ZXJtZWRpYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IHJldHVybiBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHQpOyB9KTtcbiAgICByZXR1cm4gb3V0UmVzaGFwZWQ7XG59XG52YXIgZnVzZWRDb252MkRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuRnVzZWRDb252MkQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogZnVzZWRDb252MmQsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBmdXNlZERlcHRod2lzZUNvbnYyRChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueCwgZmlsdGVyID0gaW5wdXRzLmZpbHRlciwgYmlhcyA9IGlucHV0cy5iaWFzLCBwcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gaW5wdXRzLnByZWx1QWN0aXZhdGlvbldlaWdodHM7XG4gICAgdmFyIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGRpbGF0aW9ucyA9IGF0dHJzLmRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlID0gYXR0cnMuZGltUm91bmRpbmdNb2RlLCBhY3RpdmF0aW9uID0gYXR0cnMuYWN0aXZhdGlvbiwgbGVha3lyZWx1QWxwaGEgPSBhdHRycy5sZWFreXJlbHVBbHBoYTtcbiAgICB2YXIgaW50ZXJtZWRpYXRlcyA9IFtdO1xuICAgIHZhciAkZGlsYXRpb25zID0gZGlsYXRpb25zO1xuICAgIGlmICgkZGlsYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgJGRpbGF0aW9ucyA9IFsxLCAxXTtcbiAgICB9XG4gICAgdGYudXRpbC5hc3NlcnQodGYuYmFja2VuZF91dGlsLmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShzdHJpZGVzLCAkZGlsYXRpb25zKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Vycm9yIGluIGRlcHRod2lzZUNvbnYyZDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgJyArXG4gICAgICAgIChcIjEuIEdvdCBzdHJpZGVzIFwiICsgc3RyaWRlcyArIFwiIGFuZCBkaWxhdGlvbnMgJ1wiICsgJGRpbGF0aW9ucyArIFwiJ1wiKTsgfSk7XG4gICAgdmFyIGNvbnZJbmZvID0gdGYuYmFja2VuZF91dGlsLmNvbXB1dGVDb252MkRJbmZvKHguc2hhcGUsIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgJGRpbGF0aW9ucywgcGFkLCBkaW1Sb3VuZGluZ01vZGUsIHRydWUgLyogZGVwdGh3aXNlICovKTtcbiAgICB2YXIgc2hvdWxkUGFja0RlcHRod2lzZUNvbnYgPSB0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9QQUNLX0RFUFRIV0lTRUNPTlYnKSAmJlxuICAgICAgICBjb252SW5mby5zdHJpZGVXaWR0aCA8PSAyICYmXG4gICAgICAgIGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscyA9PT0gMTtcbiAgICB2YXIgZnVzZWRBY3RpdmF0aW9uID0gYWN0aXZhdGlvbiA/XG4gICAgICAgIG1hcEFjdGl2YXRpb25Ub1NoYWRlclByb2dyYW0oYWN0aXZhdGlvbiwgc2hvdWxkUGFja0RlcHRod2lzZUNvbnYpIDpcbiAgICAgICAgbnVsbDtcbiAgICB2YXIgcHJvZ3JhbUlucHV0cyA9IFt4LCBmaWx0ZXJdO1xuICAgIHZhciBoYXNCaWFzID0gYmlhcyAhPSBudWxsO1xuICAgIHZhciBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyAhPSBudWxsO1xuICAgIHZhciBoYXNMZWFreXJlbHVBbHBoYSA9IGFjdGl2YXRpb24gPT09ICdsZWFreXJlbHUnO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgIHByb2dyYW1JbnB1dHMucHVzaChiaWFzKTtcbiAgICB9XG4gICAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMpIHtcbiAgICAgICAgcHJvZ3JhbUlucHV0cy5wdXNoKHByZWx1QWN0aXZhdGlvbldlaWdodHMpO1xuICAgIH1cbiAgICBpZiAoaGFzTGVha3lyZWx1QWxwaGEpIHtcbiAgICAgICAgdmFyICRsZWFreXJlbHVBbHBoYSA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8oW10sICdmbG9hdDMyJywgdGYudXRpbC5jcmVhdGVTY2FsYXJWYWx1ZShsZWFreXJlbHVBbHBoYSwgJ2Zsb2F0MzInKSk7XG4gICAgICAgIHByb2dyYW1JbnB1dHMucHVzaCgkbGVha3lyZWx1QWxwaGEpO1xuICAgICAgICBpbnRlcm1lZGlhdGVzLnB1c2goJGxlYWt5cmVsdUFscGhhKTtcbiAgICB9XG4gICAgdmFyIHByb2dyYW07XG4gICAgaWYgKHNob3VsZFBhY2tEZXB0aHdpc2VDb252KSB7XG4gICAgICAgIHByb2dyYW0gPSBuZXcgRGVwdGh3aXNlQ29udlBhY2tlZDJEUHJvZ3JhbShjb252SW5mbywgaGFzQmlhcywgZnVzZWRBY3RpdmF0aW9uLCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzLCBoYXNMZWFreXJlbHVBbHBoYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm9ncmFtID0gbmV3IERlcHRod2lzZUNvbnYyRFByb2dyYW0oY29udkluZm8sIGhhc0JpYXMsIGZ1c2VkQWN0aXZhdGlvbiwgaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cywgaGFzTGVha3lyZWx1QWxwaGEpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgcHJvZ3JhbUlucHV0cywgJ2Zsb2F0MzInKTtcbiAgICBpbnRlcm1lZGlhdGVzLmZvckVhY2goZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odCk7IH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG52YXIgZnVzZWREZXB0aHdpc2VDb252MkRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuRnVzZWREZXB0aHdpc2VDb252MkQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogZnVzZWREZXB0aHdpc2VDb252MkQsXG59O1xuXG52YXIgR2F0aGVyTkRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdhdGhlck5EUHJvZ3JhbShzbGljZURpbSwgc3RyaWRlcywgc2hhcGUpIHtcbiAgICAgICAgdGhpcy5zbGljZURpbSA9IHNsaWNlRGltO1xuICAgICAgICB0aGlzLnN0cmlkZXMgPSBzdHJpZGVzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnaW5kaWNlcyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gc2hhcGU7XG4gICAgICAgIHZhciBzdHJpZGVzVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHN0cmlkZXMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoc2hhcGUubGVuZ3RoKTtcbiAgICAgICAgdmFyIHN0cmlkZVN0cmluZyA9IHRoaXMuc2xpY2VEaW0gPiAxID8gJ3N0cmlkZXNbal0nIDogJ3N0cmlkZXMnO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICAgIFwiICsgc3RyaWRlc1R5cGUgKyBcIiBzdHJpZGVzID0gXCIgKyBzdHJpZGVzVHlwZSArIFwiKFwiICsgdGhpcy5zdHJpZGVzICsgXCIpO1xcbiAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIgKyBkdHlwZSArIFwiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpbnQgZmxhdHRlbkluZGV4ID0gMDtcXG4gICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBcIiArIHRoaXMuc2xpY2VEaW0gKyBcIjsgaisrKSB7XFxuICAgICAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHNbMF0sIGopKTtcXG4gICAgICAgICAgICBmbGF0dGVuSW5kZXggKz0gaW5kZXggKiBcIiArIHN0cmlkZVN0cmluZyArIFwiO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKGZsYXR0ZW5JbmRleCwgY29vcmRzWzFdKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBHYXRoZXJORFByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBnYXRoZXJOZChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciBwYXJhbXMgPSBpbnB1dHMucGFyYW1zLCBpbmRpY2VzID0gaW5wdXRzLmluZGljZXM7XG4gICAgdmFyIGluZGljZXNTaGFwZSA9IGluZGljZXMuc2hhcGU7XG4gICAgdmFyIHNsaWNlUmFuayA9IGluZGljZXNTaGFwZVtpbmRpY2VzU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgdmFyIF9hID0gdGYuYmFja2VuZF91dGlsLnByZXBhcmVBbmRWYWxpZGF0ZShwYXJhbXMsIGluZGljZXMpLCByZXN1bHRTaGFwZSA9IF9hWzBdLCBudW1TbGljZXMgPSBfYVsxXSwgc2xpY2VTaXplID0gX2FbMl0sIHN0cmlkZXMgPSBfYVszXTtcbiAgICB2YXIgZmxhdHRlbkluZGljZXMgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IGluZGljZXMgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IFtudW1TbGljZXMsIHNsaWNlUmFua10gfSB9KTtcbiAgICB2YXIgZmxhdHRlblggPSByZXNoYXBlKHtcbiAgICAgICAgaW5wdXRzOiB7IHg6IHBhcmFtcyB9LFxuICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICBhdHRyczogeyBzaGFwZTogWyh0Zi51dGlsLnNpemVGcm9tU2hhcGUocGFyYW1zLnNoYXBlKSAvIHNsaWNlU2l6ZSksIHNsaWNlU2l6ZV0gfVxuICAgIH0pO1xuICAgIHZhciBwcm9ncmFtID0gbmV3IEdhdGhlck5EUHJvZ3JhbShzbGljZVJhbmssIHN0cmlkZXMsIFtudW1TbGljZXMsIHNsaWNlU2l6ZV0pO1xuICAgIHZhciByZXMgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbZmxhdHRlblgsIGZsYXR0ZW5JbmRpY2VzXSwgZmxhdHRlblguZHR5cGUpO1xuICAgIHZhciByZXNoYXBlZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogcmVzIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiByZXN1bHRTaGFwZSB9IH0pO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZmxhdHRlbkluZGljZXMpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZmxhdHRlblgpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzKTtcbiAgICByZXR1cm4gcmVzaGFwZWQ7XG59XG52YXIgZ2F0aGVyTmRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuR2F0aGVyTmQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogZ2F0aGVyTmRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBHYXRoZXJQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdhdGhlclByb2dyYW0oYVNoYXBlLCBvdXRwdXRTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnaW5kaWNlcyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMucmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIHNvdXJjZUNvb3JkcyA9IGdldFNvdXJjZUNvb3JkcyQxKGFTaGFwZSk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIgKyBzb3VyY2VDb29yZHMgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBHYXRoZXJQcm9ncmFtO1xufSgpKTtcbi8vIFRoZSBpbnB1dCBhbmQgb3V0cHV0IGFyZSBhbHdheXMgZmxhdHRlbmVkIGludG8gcmFuayA0IHRlbnNvcnMuXG5mdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMkMShhU2hhcGUsIGF4aXMpIHtcbiAgICB2YXIgY3VycmVudENvb3JkcyA9IFsncmVzUkMueCcsICdyZXNSQy55JywgJ3Jlc1JDLnonLCAncmVzUkMudyddO1xuICAgIHZhciBzb3VyY2VDb29yZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gMikge1xuICAgICAgICAgICAgc291cmNlQ29vcmRzLnB1c2goJ2ludChnZXRJbmRpY2VzKHJlc1JDLngsIHJlc1JDLnopKScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc291cmNlQ29vcmRzLnB1c2goXCJcIiArIGN1cnJlbnRDb29yZHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VDb29yZHMuam9pbigpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBnYXRoZXJWMihhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueCwgaW5kaWNlcyA9IGlucHV0cy5pbmRpY2VzO1xuICAgIHZhciBheGlzID0gYXR0cnMuYXhpcywgYmF0Y2hEaW1zID0gYXR0cnMuYmF0Y2hEaW1zO1xuICAgIHZhciBwYXJzZWRBeGlzID0gdGYudXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKVswXTtcbiAgICB2YXIgc2hhcGVJbmZvID0gdGYuYmFja2VuZF91dGlsLnNlZ21lbnRfdXRpbC5jb2xsZWN0R2F0aGVyT3BTaGFwZUluZm8oeCwgaW5kaWNlcywgcGFyc2VkQXhpcywgYmF0Y2hEaW1zKTtcbiAgICB2YXIgaW5kaWNlc1NpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUoaW5kaWNlcy5zaGFwZSk7XG4gICAgdmFyIHRvRGlzcG9zZSA9IFtdO1xuICAgIHZhciBmbGF0dGVuWCA9IHJlc2hhcGUoe1xuICAgICAgICBpbnB1dHM6IHsgeDogeCB9LFxuICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgc2hhcGU6IFtcbiAgICAgICAgICAgICAgICBzaGFwZUluZm8uYmF0Y2hTaXplLCBzaGFwZUluZm8ub3V0ZXJTaXplLCBzaGFwZUluZm8uZGltU2l6ZSxcbiAgICAgICAgICAgICAgICBzaGFwZUluZm8uc2xpY2VTaXplXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgZmxhdHRlbkluZGV4ID0gcmVzaGFwZSh7XG4gICAgICAgIGlucHV0czogeyB4OiBpbmRpY2VzIH0sXG4gICAgICAgIGJhY2tlbmQ6IGJhY2tlbmQsXG4gICAgICAgIGF0dHJzOiB7IHNoYXBlOiBbc2hhcGVJbmZvLmJhdGNoU2l6ZSwgaW5kaWNlc1NpemUgLyBzaGFwZUluZm8uYmF0Y2hTaXplXSB9XG4gICAgfSk7XG4gICAgdG9EaXNwb3NlLnB1c2goZmxhdHRlblgpO1xuICAgIHRvRGlzcG9zZS5wdXNoKGZsYXR0ZW5JbmRleCk7XG4gICAgdmFyIGZsYXR0ZW5PdXRwdXRTaGFwZSA9IFtcbiAgICAgICAgc2hhcGVJbmZvLmJhdGNoU2l6ZSwgc2hhcGVJbmZvLm91dGVyU2l6ZSwgaW5kaWNlc1NpemUgLyBzaGFwZUluZm8uYmF0Y2hTaXplLFxuICAgICAgICBzaGFwZUluZm8uc2xpY2VTaXplXG4gICAgXTtcbiAgICBpZiAoYmFja2VuZC5zaG91bGRFeGVjdXRlT25DUFUoW3gsIGluZGljZXNdKSB8fCB4LmR0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgaW5kaWNlc0J1ZiA9IGJhY2tlbmQuYnVmZmVyU3luYyhmbGF0dGVuSW5kZXgpO1xuICAgICAgICB2YXIgeEJ1ZiA9IGJhY2tlbmQuYnVmZmVyU3luYyhmbGF0dGVuWCk7XG4gICAgICAgIHZhciBvdXRCdWYgPSBnYXRoZXJWMkltcGxDUFUoeEJ1ZiwgaW5kaWNlc0J1ZiwgZmxhdHRlbk91dHB1dFNoYXBlKTtcbiAgICAgICAgdG9EaXNwb3NlLmZvckVhY2goZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odCk7IH0pO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhzaGFwZUluZm8ub3V0cHV0U2hhcGUsIG91dEJ1Zi5kdHlwZSwgb3V0QnVmLnZhbHVlcyk7XG4gICAgfVxuICAgIHZhciBwcm9ncmFtID0gbmV3IEdhdGhlclByb2dyYW0oZmxhdHRlblguc2hhcGUsIGZsYXR0ZW5PdXRwdXRTaGFwZSk7XG4gICAgdmFyIHJlcyA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFtmbGF0dGVuWCwgZmxhdHRlbkluZGV4XSwgZmxhdHRlblguZHR5cGUpO1xuICAgIHRvRGlzcG9zZS5wdXNoKHJlcyk7XG4gICAgdmFyIHJlc2hhcGVkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiByZXMgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IHNoYXBlSW5mby5vdXRwdXRTaGFwZSB9IH0pO1xuICAgIHRvRGlzcG9zZS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IHJldHVybiBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHQpOyB9KTtcbiAgICByZXR1cm4gcmVzaGFwZWQ7XG59XG52YXIgZ2F0aGVyVjJDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuR2F0aGVyVjIsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogZ2F0aGVyVjJcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBHUkVBVEVSID0gXCJyZXR1cm4gZmxvYXQoYSA+IGIpO1wiO1xudmFyIEdSRUFURVJfUEFDS0VEID0gXCJcXG4gIHJldHVybiB2ZWM0KGdyZWF0ZXJUaGFuKGEsIGIpKTtcXG5cIjtcbnZhciBncmVhdGVyID0gYmluYXJ5S2VybmVsRnVuYyh7XG4gICAgb3BTbmlwcGV0OiBHUkVBVEVSLFxuICAgIHBhY2tlZE9wU25pcHBldDogR1JFQVRFUl9QQUNLRUQsXG4gICAgY3B1S2VybmVsSW1wbDogZ3JlYXRlckltcGxDUFUsXG4gICAgZHR5cGU6ICdib29sJ1xufSk7XG52YXIgZ3JlYXRlckNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5HcmVhdGVyLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGdyZWF0ZXJcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBHUkVBVEVSX0VRVUFMID0gXCJyZXR1cm4gZmxvYXQoYSA+PSBiKTtcIjtcbnZhciBHUkVBVEVSX0VRVUFMX1BBQ0tFRCA9IFwiXFxuICByZXR1cm4gdmVjNChncmVhdGVyVGhhbkVxdWFsKGEsIGIpKTtcXG5cIjtcbnZhciBncmVhdGVyRXF1YWwgPSBiaW5hcnlLZXJuZWxGdW5jKHtcbiAgICBvcFNuaXBwZXQ6IEdSRUFURVJfRVFVQUwsXG4gICAgcGFja2VkT3BTbmlwcGV0OiBHUkVBVEVSX0VRVUFMX1BBQ0tFRCxcbiAgICBkdHlwZTogJ2Jvb2wnXG59KTtcbnZhciBncmVhdGVyRXF1YWxDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuR3JlYXRlckVxdWFsLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGdyZWF0ZXJFcXVhbFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gaWZmdChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciBpbnB1dCA9IGlucHV0cy5pbnB1dDtcbiAgICByZXR1cm4gZmZ0SW1wbChpbnB1dCwgdHJ1ZSAvKiBpbnZlcnNlICovLCBiYWNrZW5kKTtcbn1cbnZhciBpZmZ0Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLklGRlQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogaWZmdFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIElTX0ZJTklURSA9IFwicmV0dXJuIGZsb2F0KCFpc25hbih4KSAmJiAhaXNpbmYoeCkpO1wiO1xudmFyIGlzRmluaXRlID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBJU19GSU5JVEUsIGR0eXBlOiAnYm9vbCcgfSk7XG52YXIgaXNGaW5pdGVDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuSXNGaW5pdGUsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogaXNGaW5pdGUsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgSVNfSU5GID0gXCJyZXR1cm4gZmxvYXQoaXNpbmYoeCkpO1wiO1xudmFyIGlzSW5mID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBJU19JTkYsIGR0eXBlOiAnYm9vbCcgfSk7XG52YXIgaXNJbmZDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuSXNJbmYsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogaXNJbmYsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgSVNfTkFOID0gXCJyZXR1cm4gZmxvYXQoaXNuYW4oeCkpO1wiO1xudmFyIGlzTmFOID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBJU19OQU4sIGR0eXBlOiAnYm9vbCcgfSk7XG52YXIgaXNOYU5Db25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuSXNOYW4sXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogaXNOYU4sXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgTEVTUyA9IFwicmV0dXJuIGZsb2F0KGEgPCBiKTtcIjtcbnZhciBMRVNTX1BBQ0tFRCA9IFwiXFxuICByZXR1cm4gdmVjNChsZXNzVGhhbihhLCBiKSk7XFxuXCI7XG52YXIgbGVzcyA9IGJpbmFyeUtlcm5lbEZ1bmMoe1xuICAgIG9wU25pcHBldDogTEVTUyxcbiAgICBwYWNrZWRPcFNuaXBwZXQ6IExFU1NfUEFDS0VELFxuICAgIGNwdUtlcm5lbEltcGw6IGxlc3NJbXBsQ1BVLFxuICAgIGR0eXBlOiAnYm9vbCdcbn0pO1xudmFyIGxlc3NDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuTGVzcyxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBsZXNzXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgTEVTU19FUVVBTCA9IFwicmV0dXJuIGZsb2F0KGEgPD0gYik7XCI7XG52YXIgTEVTU19FUVVBTF9QQUNLRUQgPSBcIlxcbiAgcmV0dXJuIHZlYzQobGVzc1RoYW5FcXVhbChhLCBiKSk7XFxuXCI7XG52YXIgbGVzc0VxdWFsID0gYmluYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogTEVTU19FUVVBTCwgcGFja2VkT3BTbmlwcGV0OiBMRVNTX0VRVUFMX1BBQ0tFRCwgZHR5cGU6ICdib29sJyB9KTtcbnZhciBsZXNzRXF1YWxDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuTGVzc0VxdWFsLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGxlc3NFcXVhbFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbGluU3BhY2UoYXJncykge1xuICAgIHZhciBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHN0YXJ0ID0gYXR0cnMuc3RhcnQsIHN0b3AgPSBhdHRycy5zdG9wLCBudW0gPSBhdHRycy5udW07XG4gICAgLy8gVE9ETzogVXNlIENQVSBpbXBsZW1lbnRhdGlvbiBkdWUgdG8gdGhlIHByZWNpc2lvbiBwcm9ibGVtIGluIFNhZmFyaS5cbiAgICB2YXIgb3V0VmFscyA9IGxpblNwYWNlSW1wbENQVShzdGFydCwgc3RvcCwgbnVtKTtcbiAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhbb3V0VmFscy5sZW5ndGhdLCAnZmxvYXQzMicsIG91dFZhbHMpO1xufVxudmFyIGxpblNwYWNlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkxpblNwYWNlLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGxpblNwYWNlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgTE9HID0gXCJpZiAoeCA8IDAuMCkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiBsb2coeCk7XCI7XG52YXIgTE9HX1BBQ0tFRCA9IFwiXFxuICB2ZWM0IHJlc3VsdCA9IGxvZyh4KTtcXG4gIHZlYzQgaXNOYU4gPSB2ZWM0KGxlc3NUaGFuKHgsIHZlYzQoMC4wKSkpO1xcbiAgcmVzdWx0LnIgPSBpc05hTi5yID09IDEuMCA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID09IDEuMCA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID09IDEuMCA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID09IDEuMCA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIjtcbnZhciBsb2cgPSB1bmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IExPRywgcGFja2VkT3BTbmlwcGV0OiBMT0dfUEFDS0VELCBjcHVLZXJuZWxJbXBsOiBsb2dJbXBsQ1BVIH0pO1xudmFyIGxvZ0NvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5Mb2csXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogbG9nXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgTE9HMVAgPSBcInJldHVybiBsb2coMS4wICsgeCk7XCI7XG52YXIgbG9nMXAgPSB1bmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IExPRzFQIH0pO1xudmFyIGxvZzFwQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkxvZzFwLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGxvZzFwLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIExPR0lDQUxfQU5EID0gXCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgJiYgYiA+PSAxLjApO1wiO1xudmFyIExPR0lDQUxfQU5EX1BBQ0tFRCA9IFwiXFxuICByZXR1cm4gdmVjNChcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGEsIHZlYzQoMS4wKSkpICpcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMS4wKSkpKTtcXG5cIjtcbnZhciBsb2dpY2FsQW5kID0gYmluYXJ5S2VybmVsRnVuYyh7XG4gICAgb3BTbmlwcGV0OiBMT0dJQ0FMX0FORCxcbiAgICBwYWNrZWRPcFNuaXBwZXQ6IExPR0lDQUxfQU5EX1BBQ0tFRCxcbiAgICBkdHlwZTogJ2Jvb2wnXG59KTtcbnZhciBsb2dpY2FsQW5kQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkxvZ2ljYWxBbmQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogbG9naWNhbEFuZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIExPR0lDQUxfTk9UID0gXCJyZXR1cm4gZmxvYXQoISh4ID49IDEuMCkpO1wiO1xudmFyIGxvZ2ljYWxOb3QgPSB1bmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IExPR0lDQUxfTk9UIH0pO1xudmFyIGxvZ2ljYWxOb3RDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuTG9naWNhbE5vdCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBsb2dpY2FsTm90LFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIExPR0lDQUxfT1IgPSBcInJldHVybiBmbG9hdChhID49IDEuMCB8fCBiID49IDEuMCk7XCI7XG52YXIgTE9HSUNBTF9PUl9QQUNLRUQgPSBcIlxcbiAgcmV0dXJuIG1pbihcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGEsIHZlYzQoMS4wKSkpICtcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMS4wKSkpLFxcbiAgICB2ZWM0KDEuMCkpO1xcblwiO1xudmFyIGxvZ2ljYWxPciA9IGJpbmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IExPR0lDQUxfT1IsIHBhY2tlZE9wU25pcHBldDogTE9HSUNBTF9PUl9QQUNLRUQsIGR0eXBlOiAnYm9vbCcgfSk7XG52YXIgbG9naWNhbE9yQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkxvZ2ljYWxPcixcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBsb2dpY2FsT3Jcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBMUk5Qcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExSTlByb2dyYW0oeFNoYXBlLCByYWRpdXMsIGJpYXMsIGFscGhhLCBiZXRhKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHZhciByYWQgPSByYWRpdXM7XG4gICAgICAgIHZhciBtYXhEID0geFNoYXBlWzNdIC0gMTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHhTaGFwZTtcbiAgICAgICAgLy8gb3B0aW1pemUgcG93KGJpYXMgKyBhbHBoYSAqIHN1bSwgLWJldGEpXG4gICAgICAgIC8vIHNyYzogaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy8uLlxuICAgICAgICAvLyBibG9iLzI2MDMzYTE2NDRhOWM0YTVmYmUzMTcwYWIyZTg2NGI2YTRjY2Q0Y2EvLi5cbiAgICAgICAgLy8gdGVuc29yZmxvdy9jb3JlL2tlcm5lbHMvbWtsX2xybl9vcC5jYyNMMzIwXG4gICAgICAgIHZhciBwb3dPcGVyYXRvcjtcbiAgICAgICAgdmFyIGJhc2lzID0gXCJmbG9hdChcIiArIGJpYXMgKyBcIikgKyBmbG9hdChcIiArIGFscGhhICsgXCIpICogc3VtXCI7XG4gICAgICAgIGlmIChiZXRhID09PSAwLjUpIHtcbiAgICAgICAgICAgIHBvd09wZXJhdG9yID0gXCJpbnZlcnNlc3FydChcIiArIGJhc2lzICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmV0YSA9PT0gMS4wKSB7XG4gICAgICAgICAgICBwb3dPcGVyYXRvciA9IFwiMS4wLyhcIiArIGJhc2lzICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3dPcGVyYXRvciA9IFwiZXhwKGxvZyhcIiArIGJhc2lzICsgXCIpICogZmxvYXQoLVwiICsgYmV0YSArIFwiKSk7XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYKGIsIHIsIGMsIGQpO1xcbiAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgaiA9IC1cIiArIHJhZCArIFwiOyBqIDw9IFwiICsgcmFkICsgXCI7IGorKykge1xcbiAgICAgICAgICBpbnQgaWR4ID0gZCArIGo7XFxuICAgICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPD0gIFwiICsgbWF4RCArIFwiKSB7XFxuICAgICAgICAgICAgZmxvYXQgeiA9IGdldFgoYiwgciwgYywgaWR4KTtcXG4gICAgICAgICAgICBzdW0gKz0geiAqIHo7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IHZhbCA9IHggKiBcIiArIHBvd09wZXJhdG9yICsgXCI7XFxuICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gTFJOUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBMUk5QYWNrZWRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExSTlBhY2tlZFByb2dyYW0oeFNoYXBlLCByYWRpdXMsIGJpYXMsIGFscGhhLCBiZXRhKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHRoaXMucGFja2VkSW5wdXRzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWNrZWRPdXRwdXQgPSB0cnVlO1xuICAgICAgICB2YXIgcmFkID0gcmFkaXVzO1xuICAgICAgICB2YXIgbWF4RCA9IHhTaGFwZVszXSAtIDE7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICAgIC8vIG9wdGltaXplIHBvdyhiaWFzICsgYWxwaGEgKiBzdW0sIC1iZXRhKVxuICAgICAgICAvLyBzcmM6IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RlbnNvcmZsb3cvLi5cbiAgICAgICAgLy8gYmxvYi8yNjAzM2ExNjQ0YTljNGE1ZmJlMzE3MGFiMmU4NjRiNmE0Y2NkNGNhLy4uXG4gICAgICAgIC8vIHRlbnNvcmZsb3cvY29yZS9rZXJuZWxzL21rbF9scm5fb3AuY2MjTDMyMFxuICAgICAgICB2YXIgcG93T3BlcmF0b3I7XG4gICAgICAgIHZhciBiYXNpcyA9IFwiZmxvYXQoXCIgKyBiaWFzICsgXCIpICsgZmxvYXQoXCIgKyBhbHBoYSArIFwiKSAqIHN1bVwiO1xuICAgICAgICBpZiAoYmV0YSA9PT0gMC41KSB7XG4gICAgICAgICAgICBwb3dPcGVyYXRvciA9IFwiaW52ZXJzZXNxcnQoXCIgKyBiYXNpcyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJldGEgPT09IDEuMCkge1xuICAgICAgICAgICAgcG93T3BlcmF0b3IgPSBcIjEuMC8oXCIgKyBiYXNpcyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG93T3BlcmF0b3IgPSBcImV4cChsb2coXCIgKyBiYXNpcyArIFwiKSAqIGZsb2F0KC1cIiArIGJldGEgKyBcIikpO1wiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHMueDtcXG4gICAgICAgIGludCByID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQgPSBjb29yZHMudztcXG5cXG4gICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IGQgPCBcIiArIHRoaXMub3V0cHV0U2hhcGVbM10gKyBcIjtcXG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IGMgPCBcIiArIHRoaXMub3V0cHV0U2hhcGVbMl0gKyBcIjtcXG5cXG4gICAgICAgIHZlYzQgc3VtID0gdmVjNCgwLik7XFxuICAgICAgICB2ZWM0IHhGcmFnQXRPdXRwdXRDb29yZHMgPSBnZXRYKGIsIHIsIGMsIGQpO1xcblxcbiAgICAgICAgdmVjNCB4QXRPdXRwdXRDb29yZHMgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMsIHZlYzIoYywgZCkpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID9cXG4gICAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMsIHZlYzIoYywgZCArIDEpKSA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/XFxuICAgICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzICwgdmVjMihjICsgMSwgZCkpIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzLCB2ZWMyKGMgKyAxLCBkICsgMSkpIDogMC4wXFxuICAgICAgICApO1xcblxcbiAgICAgICAgaW50IGZpcnN0Q2hhbm5lbCA9IGQgLSBcIiArIHJhZCArIFwiO1xcbiAgICAgICAgdmVjMiBjYWNoZSA9IHZlYzIoMC4pO1xcbiAgICAgICAgaWYoZmlyc3RDaGFubmVsID49IDApe1xcbiAgICAgICAgICB2ZWM0IGZpcnN0Q2hhbm5lbEZyYWcgPSBnZXRYKGIsIHIsIGMsIGZpcnN0Q2hhbm5lbCk7XFxuICAgICAgICAgIGNhY2hlLnggPSBnZXRDaGFubmVsKGZpcnN0Q2hhbm5lbEZyYWcsIHZlYzIoYywgZmlyc3RDaGFubmVsKSk7XFxuICAgICAgICAgICAgaWYoaGFzTmV4dFJvdyl7XFxuICAgICAgICAgICAgICBjYWNoZS55ID0gZ2V0Q2hhbm5lbChmaXJzdENoYW5uZWxGcmFnLCB2ZWMyKGMgKyAxLCBmaXJzdENoYW5uZWwpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpdmVjMiBkZXB0aCA9IGl2ZWMyKGQsIGQgKyAxKTtcXG4gICAgICAgIGZvciAoaW50IGogPSAtIFwiICsgcmFkICsgXCI7IGogPD0gXCIgKyByYWQgKyBcIjsgaisrKSB7XFxuICAgICAgICAgIGl2ZWMyIGlkeCA9IGRlcHRoICsgajtcXG4gICAgICAgICAgYnZlYzIgYWJvdmVMb3dlckJvdW5kID0gZ3JlYXRlclRoYW5FcXVhbChpZHgsIGl2ZWMyKDApKTtcXG4gICAgICAgICAgYnZlYzIgYmVsb3dVcHBlckJvdW5kID0gbGVzc1RoYW5FcXVhbChpZHgsIGl2ZWMyKFwiICsgbWF4RCArIFwiKSk7XFxuXFxuICAgICAgICAgIGJvb2wgZGVwdGhJblJhbmdlID0gYWJvdmVMb3dlckJvdW5kLnggJiYgYmVsb3dVcHBlckJvdW5kLng7XFxuICAgICAgICAgIGJvb2wgZGVwdGhQbHVzT25lSW5SYW5nZSA9IGFib3ZlTG93ZXJCb3VuZC55ICYmIGJlbG93VXBwZXJCb3VuZC55O1xcblxcbiAgICAgICAgICBpZihkZXB0aEluUmFuZ2UgfHwgZGVwdGhQbHVzT25lSW5SYW5nZSl7XFxuICAgICAgICAgICAgdmVjNCB6ID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgdmVjNCB4RnJhZ0F0Q3VycmVudERlcHRoO1xcbiAgICAgICAgICAgIHoueHogPSBjYWNoZS54eTtcXG4gICAgICAgICAgICBpZihkZXB0aFBsdXNPbmVJblJhbmdlICYmIGhhc05leHRDb2wpe1xcbiAgICAgICAgICAgICAgeEZyYWdBdEN1cnJlbnREZXB0aCA9IGlkeC55ICE9IGQgP1xcbiAgICAgICAgICAgICAgICBnZXRYKGIsIHIsIGMsIGlkeC55KSA6IHhGcmFnQXRPdXRwdXRDb29yZHM7XFxuICAgICAgICAgICAgICB6LnkgPSBnZXRDaGFubmVsKHhGcmFnQXRDdXJyZW50RGVwdGgsIHZlYzIoYywgaWR4LnkpKTtcXG4gICAgICAgICAgICAgIGlmKGhhc05leHRSb3cpe1xcbiAgICAgICAgICAgICAgICB6LncgPSBnZXRDaGFubmVsKHhGcmFnQXRDdXJyZW50RGVwdGgsIHZlYzIoYyArIDEsIGlkeC55KSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNhY2hlLnh5ID0gei55dztcXG4gICAgICAgICAgICBzdW0gKz0geiAqIHo7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0geEF0T3V0cHV0Q29vcmRzICogXCIgKyBwb3dPcGVyYXRvciArIFwiO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIExSTlBhY2tlZFByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgbHJuID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBkZXB0aFJhZGl1cyA9IGF0dHJzLmRlcHRoUmFkaXVzLCBiaWFzID0gYXR0cnMuYmlhcywgYWxwaGEgPSBhdHRycy5hbHBoYSwgYmV0YSA9IGF0dHJzLmJldGE7XG4gICAgdmFyIHByb2dyYW0gPSB0Zi5lbnYoKS5nZXRCb29sKCdXRUJHTF9QQUNLX05PUk1BTElaQVRJT04nKSA/XG4gICAgICAgIG5ldyBMUk5QYWNrZWRQcm9ncmFtKHguc2hhcGUsIGRlcHRoUmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSkgOlxuICAgICAgICBuZXcgTFJOUHJvZ3JhbSh4LnNoYXBlLCBkZXB0aFJhZGl1cywgYmlhcywgYWxwaGEsIGJldGEpO1xuICAgIHJldHVybiBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbeF0sIHguZHR5cGUpO1xufTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogdmFyaWFibGUtbmFtZVxudmFyIExSTkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5MUk4sXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogbHJuXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgTFJOR3JhZFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTFJOR3JhZFByb2dyYW0oaW5wdXRTaGFwZSwgZGVwdGhSYWRpdXMsIGJpYXMsIGFscGhhLCBiZXRhKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnaW5wdXRJbWFnZScsICdvdXRwdXRJbWFnZScsICdkeSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xuICAgICAgICB0aGlzLmRlcHRoID0gaW5wdXRTaGFwZVszXTtcbiAgICAgICAgdGhpcy5kZXB0aFJhZGl1cyA9IGRlcHRoUmFkaXVzO1xuICAgICAgICB0aGlzLmJpYXMgPSBiaWFzO1xuICAgICAgICB0aGlzLmFscGhhID0gYWxwaGE7XG4gICAgICAgIHRoaXMuYmV0YSA9IGJldGE7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgZCA9IDA7IGQgPCBcIiArIHRoaXMuZGVwdGggKyBcIjsgKytkKSB7XFxuICAgICAgICAgIGludCBkZXB0aEJlZ2luID0gaW50KG1heCgwLjAsIGZsb2F0KGQgLSBcIiArIGRlcHRoUmFkaXVzICsgXCIpKSk7XFxuICAgICAgICAgIGludCBkZXB0aEVuZCA9IGludChtaW4oZmxvYXQoXCIgKyB0aGlzLmRlcHRoICsgXCIpLFxcbiAgICAgICAgICAgICAgZmxvYXQoZCArIFwiICsgZGVwdGhSYWRpdXMgKyBcIiArIDEpKSk7XFxuXFxuICAgICAgICAgIGNvbnN0IGludCBNSU5fREVQVEhfQkVHSU4gPSAwO1xcbiAgICAgICAgICBjb25zdCBpbnQgTUFYX0RFUFRIX0VORCA9IFwiICsgdGhpcy5kZXB0aCArIFwiO1xcblxcbiAgICAgICAgICBmbG9hdCBub3JtID0gMC4wO1xcbiAgICAgICAgICBmb3IgKGludCBrID0gTUlOX0RFUFRIX0JFR0lOOyBrIDwgTUFYX0RFUFRIX0VORDsgKytrKSB7XFxuICAgICAgICAgICAgaWYgKGsgPCBkZXB0aEJlZ2luKXtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChrID49IGRlcHRoQmVnaW4gJiYgayA8IGRlcHRoRW5kKSB7XFxuICAgICAgICAgICAgICBub3JtICs9IGdldElucHV0SW1hZ2UoYiwgciwgYywgaykgKiBnZXRJbnB1dEltYWdlKGIsIHIsIGMsIGspO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBub3JtID0gZmxvYXQoXCIgKyBhbHBoYSArIFwiKSAqIG5vcm0gKyBmbG9hdChcIiArIGJpYXMgKyBcIik7XFxuXFxuICAgICAgICAgIGZvcihpbnQgayA9IE1JTl9ERVBUSF9CRUdJTjsgayA8IE1BWF9ERVBUSF9FTkQ7ICsrayl7XFxuICAgICAgICAgICAgaWYgKGsgPCBkZXB0aEJlZ2luKXtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChrID49IGRlcHRoQmVnaW4gJiYgayA8IGRlcHRoRW5kKXtcXG4gICAgICAgICAgICAgIGZsb2F0IGR5aSA9IC0yLjAgKiBmbG9hdChcIiArIGFscGhhICsgXCIpXFxuICAgICAgICAgICAgICAgICogZmxvYXQoXCIgKyBiZXRhICsgXCIpXFxuICAgICAgICAgICAgICAgICogZ2V0SW5wdXRJbWFnZShiICxyICxjLCBrKSAqIGdldE91dHB1dEltYWdlKGIsIHIsIGMsIGQpXFxuICAgICAgICAgICAgICAgIC8gbm9ybTtcXG4gICAgICAgICAgICAgIGlmIChrID09IGQpIHtcXG4gICAgICAgICAgICAgICAgZHlpICs9IHBvdyhub3JtLCAtMS4wICogXCIgKyBiZXRhICsgXCIpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaWYgKGsgPT0gY29vcmRzWzNdKSB7XFxuICAgICAgICAgICAgICAgIGR5aSAqPSBnZXREeShiLCByLCBjLCBkKTtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGR5aTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIExSTkdyYWRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGxybkdyYWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLngsIHkgPSBpbnB1dHMueSwgZHkgPSBpbnB1dHMuZHk7XG4gICAgdmFyIGRlcHRoUmFkaXVzID0gYXR0cnMuZGVwdGhSYWRpdXMsIGJpYXMgPSBhdHRycy5iaWFzLCBhbHBoYSA9IGF0dHJzLmFscGhhLCBiZXRhID0gYXR0cnMuYmV0YTtcbiAgICB2YXIgcHJvZ3JhbSA9IG5ldyBMUk5HcmFkUHJvZ3JhbSh4LnNoYXBlLCBkZXB0aFJhZGl1cywgYmlhcywgYWxwaGEsIGJldGEpO1xuICAgIHJldHVybiBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbeCwgeSwgZHldLCB4LmR0eXBlKTtcbn07XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHZhcmlhYmxlLW5hbWVcbnZhciBMUk5HcmFkQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLkxSTkdyYWQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogbHJuR3JhZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbWF4SW1wbCQxKHgsIHJlZHVjZVNoYXBlLCBvdXRTaGFwZSwgYmFja2VuZCkge1xuICAgIHZhciBpblNpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgIHZhciB4U2l6ZSA9IHRmLnV0aWwuc2l6ZUZyb21TaGFwZSh4LnNoYXBlKTtcbiAgICB2YXIgYmF0Y2hTaXplID0geFNpemUgLyBpblNpemU7XG4gICAgdmFyIHJlc2hhcGVkSW5wdXQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHggfSwgYXR0cnM6IHsgc2hhcGU6IFtiYXRjaFNpemUsIGluU2l6ZV0gfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB2YXIgcmVkdWNlZCA9IHJlZHVjZShyZXNoYXBlZElucHV0LCB4LmR0eXBlLCAnbWF4JywgYmFja2VuZCk7XG4gICAgdmFyIHJlc2hhcGVkT3V0cHV0ID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiByZWR1Y2VkIH0sIGF0dHJzOiB7IHNoYXBlOiBvdXRTaGFwZSB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzaGFwZWRJbnB1dCk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyZWR1Y2VkKTtcbiAgICByZXR1cm4gcmVzaGFwZWRPdXRwdXQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIG1heChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgcmVkdWN0aW9uSW5kaWNlcyA9IGF0dHJzLnJlZHVjdGlvbkluZGljZXMsIGtlZXBEaW1zID0gYXR0cnMua2VlcERpbXM7XG4gICAgdmFyIHhSYW5rID0geC5zaGFwZS5sZW5ndGg7XG4gICAgdmFyIG9yaWdBeGVzID0gdGYudXRpbC5wYXJzZUF4aXNQYXJhbShyZWR1Y3Rpb25JbmRpY2VzLCB4LnNoYXBlKTtcbiAgICB2YXIgYXhlcyA9IG9yaWdBeGVzO1xuICAgIHZhciBwZXJtdXRlZEF4ZXMgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHhSYW5rKTtcbiAgICB2YXIgbWF4SW5wdXRJc1RyYW5zcG9zZWQgPSBwZXJtdXRlZEF4ZXMgIT0gbnVsbDtcbiAgICB2YXIgc2hvdWxkRXhlY3V0ZU9uQ1BVID0gYmFja2VuZC5zaG91bGRFeGVjdXRlT25DUFUoW3hdKTtcbiAgICB2YXIgbWF4SW5wdXQgPSB4O1xuICAgIGlmIChtYXhJbnB1dElzVHJhbnNwb3NlZCkge1xuICAgICAgICBpZiAoc2hvdWxkRXhlY3V0ZU9uQ1BVKSB7XG4gICAgICAgICAgICB2YXIgeFRleERhdGEgPSBiYWNrZW5kLnRleERhdGEuZ2V0KG1heElucHV0LmRhdGFJZCk7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0geFRleERhdGEudmFsdWVzO1xuICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0gbmV3IEFycmF5KHhSYW5rKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtpXSA9IHguc2hhcGVbcGVybXV0ZWRBeGVzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtYXhJbnB1dFZhbHVlcyA9IHRyYW5zcG9zZUltcGxDUFUodmFsdWVzLCB4LnNoYXBlLCB4LmR0eXBlLCBwZXJtdXRlZEF4ZXMsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIG1heElucHV0ID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhuZXdTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgICAgICB2YXIgbWF4SW5wdXREYXRhID0gYmFja2VuZC50ZXhEYXRhLmdldChtYXhJbnB1dC5kYXRhSWQpO1xuICAgICAgICAgICAgbWF4SW5wdXREYXRhLnZhbHVlcyA9IG1heElucHV0VmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF4SW5wdXQgPSB0cmFuc3Bvc2VJbXBsJDEoeCwgcGVybXV0ZWRBeGVzLCBiYWNrZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBheGVzID0gdGYuYmFja2VuZF91dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIHhSYW5rKTtcbiAgICB9XG4gICAgdGYuYmFja2VuZF91dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdtYXgnLCBheGVzLCB4UmFuayk7XG4gICAgdmFyIF9hID0gdGYuYmFja2VuZF91dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMobWF4SW5wdXQuc2hhcGUsIGF4ZXMpLCBtYXhPdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgIHZhciBvdXRTaGFwZSA9IG1heE91dFNoYXBlO1xuICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAvLyByYXRoZXIgdGhhbiByZXNoYXBlIGF0IHRoZSBlbmQsIHNldCB0aGUgdGFyZ2V0IHNoYXBlIGhlcmUuXG4gICAgICAgIG91dFNoYXBlID0gdGYuYmFja2VuZF91dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKG1heE91dFNoYXBlLCBvcmlnQXhlcyk7XG4gICAgfVxuICAgIHZhciBvdXQ7XG4gICAgaWYgKHNob3VsZEV4ZWN1dGVPbkNQVSkge1xuICAgICAgICB2YXIgeFRleERhdGEgPSBiYWNrZW5kLnRleERhdGEuZ2V0KG1heElucHV0LmRhdGFJZCk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4VGV4RGF0YS52YWx1ZXM7XG4gICAgICAgIHZhciBvdXRWYWx1ZXMgPSBtYXhJbXBsQ1BVKHZhbHVlcywgdGYudXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKSwgb3V0U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICBvdXQgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIG91dERhdGEgPSBiYWNrZW5kLnRleERhdGEuZ2V0KG91dC5kYXRhSWQpO1xuICAgICAgICBvdXREYXRhLnZhbHVlcyA9IG91dFZhbHVlcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG91dCA9IG1heEltcGwkMShtYXhJbnB1dCwgcmVkdWNlU2hhcGUsIG91dFNoYXBlLCBiYWNrZW5kKTtcbiAgICB9XG4gICAgaWYgKG1heElucHV0SXNUcmFuc3Bvc2VkKSB7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obWF4SW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxudmFyIG1heENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5NYXgsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogbWF4XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgTUFYSU1VTSA9IENIRUNLX05BTl9TTklQUEVUJDEgKyBcIlxcbiAgcmV0dXJuIG1heChhLCBiKTtcXG5cIjtcbnZhciBNQVhJTVVNX1BBQ0tFRCA9IFwiXFxuICB2ZWM0IHJlc3VsdCA9IHZlYzQobWF4KGEsIGIpKTtcXG4gIHZlYzQgaXNOYU4gPSBtaW4odmVjNChpc25hbihhKSkgKyB2ZWM0KGlzbmFuKGIpKSwgdmVjNCgxLjApKTtcXG4gIFwiICtcbiAgICBDSEVDS19OQU5fU05JUFBFVCQyICsgXCJcXG4gIHJldHVybiByZXN1bHQ7XFxuXCI7XG52YXIgbWF4aW11bSA9IGJpbmFyeUtlcm5lbEZ1bmMoe1xuICAgIG9wU25pcHBldDogTUFYSU1VTSxcbiAgICBwYWNrZWRPcFNuaXBwZXQ6IE1BWElNVU1fUEFDS0VELFxuICAgIGNwdUtlcm5lbEltcGw6IG1heGltdW1JbXBsQ1BVXG59KTtcbnZhciBtYXhpbXVtQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLk1heGltdW0sXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogbWF4aW11bVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbWF4UG9vbChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICBhc3NlcnROb3RDb21wbGV4KHgsICdtYXhQb29sJyk7XG4gICAgdmFyIGZpbHRlclNpemUgPSBhdHRycy5maWx0ZXJTaXplLCBzdHJpZGVzID0gYXR0cnMuc3RyaWRlcywgcGFkID0gYXR0cnMucGFkLCBkaW1Sb3VuZGluZ01vZGUgPSBhdHRycy5kaW1Sb3VuZGluZ01vZGU7XG4gICAgdmFyIGRpbGF0aW9ucyA9IDE7XG4gICAgdGYudXRpbC5hc3NlcnQodGYuYmFja2VuZF91dGlsLmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShzdHJpZGVzLCBkaWxhdGlvbnMpLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnRXJyb3IgaW4gbWF4UG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gJyArXG4gICAgICAgIChcIkdvdCBzdHJpZGVzIFwiICsgc3RyaWRlcyArIFwiIGFuZCBkaWxhdGlvbnMgJ1wiICsgZGlsYXRpb25zICsgXCInXCIpOyB9KTtcbiAgICB2YXIgY29udkluZm8gPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZVBvb2wyREluZm8oeC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgaWYgKGNvbnZJbmZvLmZpbHRlcldpZHRoID09PSAxICYmIGNvbnZJbmZvLmZpbHRlckhlaWdodCA9PT0gMSAmJlxuICAgICAgICB0Zi51dGlsLmFycmF5c0VxdWFsKGNvbnZJbmZvLmluU2hhcGUsIGNvbnZJbmZvLm91dFNoYXBlKSkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHkoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgIH1cbiAgICB2YXIgbWF4UG9vbFByb2dyYW0gPSBuZXcgUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ21heCcsIGZhbHNlKTtcbiAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0obWF4UG9vbFByb2dyYW0sIFt4XSwgeC5kdHlwZSk7XG59XG52YXIgbWF4UG9vbENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5NYXhQb29sLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IG1heFBvb2xcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIG1heFBvb2wzZChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGF0dHJzLmZpbHRlclNpemUsIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGRhdGFGb3JtYXQgPSBhdHRycy5kYXRhRm9ybWF0LCBkaW1Sb3VuZGluZ01vZGUgPSBhdHRycy5kaW1Sb3VuZGluZ01vZGU7XG4gICAgdmFyIGRpbGF0aW9ucyA9IFsxLCAxLCAxXTtcbiAgICB2YXIgY29udkluZm8gPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZVBvb2wzREluZm8oeC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSwgZGF0YUZvcm1hdCk7XG4gICAgdmFyIG1heFBvb2xQcm9ncmFtID0gbmV3IFBvb2wzRFByb2dyYW0oY29udkluZm8sICdtYXgnLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKG1heFBvb2xQcm9ncmFtLCBbeF0sIHguZHR5cGUpO1xufVxudmFyIG1heFBvb2wzRENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5NYXhQb29sM0QsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogbWF4UG9vbDNkXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ21heFBvcyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICB2YXIgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGVmZmVjdGl2ZUZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBlZmZlY3RpdmVGaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgKiBlZmZlY3RpdmVGaWx0ZXJXaWR0aCAtIDE7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgKyBcIjtcXG4gICAgICAgICAgd1IgKz0gXCIgKyBkaWxhdGlvbkhlaWdodCArIFwiKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIgKyBjb252SW5mby5vdXRIZWlnaHQgKyBcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBlZmZlY3RpdmVGaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIgKyBzdHJpZGVXaWR0aCArIFwiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIgKyBjb252SW5mby5vdXRXaWR0aCArIFwiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xcbiAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9IFwiICsgbGFzdEluZGV4ICsgXCIgLSBpbnQoZ2V0TWF4UG9zKGIsIGlkeVIsIGlkeUMsIGQpKTtcXG5cXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXFxuICAgICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxcbiAgICAgICAgICAgIGludCBjdXJQb3NWYWx1ZSA9IHdSICogXCIgKyBlZmZlY3RpdmVGaWx0ZXJXaWR0aCArIFwiICsgd0M7XFxuICAgICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBtYXNrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbTtcbn0oKSk7XG52YXIgTWF4UG9vbDNEQmFja3Byb3BQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1heFBvb2wzREJhY2twcm9wUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ21heFBvcyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcbiAgICAgICAgdmFyIHN0cmlkZURlcHRoID0gY29udkluZm8uc3RyaWRlRGVwdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZGlsYXRpb25EZXB0aCA9IGNvbnZJbmZvLmRpbGF0aW9uRGVwdGg7XG4gICAgICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgICAgIHZhciBlZmZlY3RpdmVGaWx0ZXJEZXB0aCA9IGNvbnZJbmZvLmVmZmVjdGl2ZUZpbHRlckRlcHRoO1xuICAgICAgICB2YXIgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gY29udkluZm8uZWZmZWN0aXZlRmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBjb252SW5mby5lZmZlY3RpdmVGaWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZEZyb250ID0gZWZmZWN0aXZlRmlsdGVyRGVwdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5mcm9udDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGVmZmVjdGl2ZUZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBlZmZlY3RpdmVGaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBlZmZlY3RpdmVGaWx0ZXJEZXB0aCAqIGVmZmVjdGl2ZUZpbHRlckhlaWdodCAqIGVmZmVjdGl2ZUZpbHRlcldpZHRoIC0gMTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKFwiICsgcGFkRnJvbnQgKyBcIiwgXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgY2ggPSBjb29yZHMudTtcXG5cXG4gICAgICAgIGl2ZWMzIGR5Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgLSBwYWRzO1xcbiAgICAgICAgaW50IGR5RENvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueTtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci56O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgPywgY2gpIHdpdGggcG9zIG1hc2soOiwgOiwgOiwgZCkgdG8gZ2V0XFxuICAgICAgICAvLyBkeCh4RCwgeFIsIHhDLCBjaCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3RCA9IDA7IHdEIDwgXCIgKyBlZmZlY3RpdmVGaWx0ZXJEZXB0aCArIFwiO1xcbiAgICAgICAgICAgd0QgKz0gXCIgKyBkaWxhdGlvbkRlcHRoICsgXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlEID0gZmxvYXQoZHlEQ29ybmVyICsgd0QpIC8gXCIgKyBzdHJpZGVEZXB0aCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeUQgPCAwLjAgfHwgZHlEID49IFwiICsgY29udkluZm8ub3V0RGVwdGggKyBcIi4wIHx8IGZyYWN0KGR5RCkgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5RCA9IGludChkeUQpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQgKyBcIjtcXG4gICAgICAgICAgICAgIHdSICs9IFwiICsgZGlsYXRpb25IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIiArIGNvbnZJbmZvLm91dEhlaWdodCArIFwiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZWZmZWN0aXZlRmlsdGVyV2lkdGggKyBcIjtcXG4gICAgICAgICAgICAgICAgd0MgKz0gXCIgKyBkaWxhdGlvbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIgKyBjb252SW5mby5vdXRXaWR0aCArIFwiLjAgfHxcXG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5RCwgaWR5UiwgaWR5QywgY2gpO1xcbiAgICAgICAgICAgICAgaW50IG1heFBvc1ZhbHVlID0gXCIgKyBsYXN0SW5kZXggKyBcIiAtXFxuICAgICAgICAgICAgICAgICAgaW50KGdldE1heFBvcyhiYXRjaCwgaWR5RCwgaWR5UiwgaWR5QywgY2gpKTtcXG5cXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSwgY2hlY2sgaXQgYWdhaW5zdCB0aGUgdmFsdWUgZnJvbSB0aGVcXG4gICAgICAgICAgICAgIC8vIHBvc2l0aW9uIG1hdHJpeC5cXG4gICAgICAgICAgICAgIGludCBjdXJQb3NWYWx1ZSA9XFxuICAgICAgICAgICAgICAgICAgd0QgKiBcIiArIGVmZmVjdGl2ZUZpbHRlckhlaWdodCArIFwiICogXCIgKyBlZmZlY3RpdmVGaWx0ZXJXaWR0aCArIFwiICtcXG4gICAgICAgICAgICAgICAgICB3UiAqIFwiICsgZWZmZWN0aXZlRmlsdGVyV2lkdGggKyBcIiArIHdDO1xcbiAgICAgICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIG1hc2s7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIE1heFBvb2wzREJhY2twcm9wUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIG1heFBvb2wzREdyYWQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBkeSA9IGlucHV0cy5keSwgaW5wdXQgPSBpbnB1dHMuaW5wdXQ7XG4gICAgdmFyIHggPSBpbnB1dDtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGF0dHJzLmZpbHRlclNpemUsIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZTtcbiAgICB2YXIgZGlsYXRpb25zID0gWzEsIDEsIDFdO1xuICAgIHZhciBjb252SW5mbyA9IHRmLmJhY2tlbmRfdXRpbC5jb21wdXRlUG9vbDNESW5mbyh4LnNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB2YXIgbWF4UG9vbDNkUG9zaXRpb25zUHJvZ3JhbSA9IG5ldyBQb29sM0RQcm9ncmFtKGNvbnZJbmZvLCAnbWF4JywgdHJ1ZSAvKiBnZXQgcG9zaXRpb25zICovKTtcbiAgICB2YXIgbWF4UG9vbDNkUG9zaXRpb25zID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0obWF4UG9vbDNkUG9zaXRpb25zUHJvZ3JhbSwgW3hdLCB4LmR0eXBlKTtcbiAgICB2YXIgbWF4UG9vbEJhY2twcm9wUHJvZ3JhbSA9IG5ldyBNYXhQb29sM0RCYWNrcHJvcFByb2dyYW0oY29udkluZm8pO1xuICAgIHZhciByZXN1bHQgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShtYXhQb29sQmFja3Byb3BQcm9ncmFtLCBbZHksIG1heFBvb2wzZFBvc2l0aW9uc10sIHguZHR5cGUpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obWF4UG9vbDNkUG9zaXRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIG1heFBvb2xHcmFkM0RDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuTWF4UG9vbDNER3JhZCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBtYXhQb29sM0RHcmFkXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBtYXhQb29sR3JhZChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGR5ID0gaW5wdXRzLmR5LCBpbnB1dCA9IGlucHV0cy5pbnB1dCwgb3V0cHV0ID0gaW5wdXRzLm91dHB1dDtcbiAgICB2YXIgeCA9IGlucHV0O1xuICAgIGFzc2VydE5vdENvbXBsZXgoW2lucHV0LCBvdXRwdXRdLCAnbWF4UG9vbEdyYWQnKTtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGF0dHJzLmZpbHRlclNpemUsIHN0cmlkZXMgPSBhdHRycy5zdHJpZGVzLCBwYWQgPSBhdHRycy5wYWQsIGRpbVJvdW5kaW5nTW9kZSA9IGF0dHJzLmRpbVJvdW5kaW5nTW9kZTtcbiAgICB2YXIgY29udkluZm8gPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZVBvb2wyREluZm8oeC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgMSAvKiBkaWxhdGlvbnMgKi8sIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB2YXIgZ2V0UG9zaXRpb25zID0gdHJ1ZTtcbiAgICB2YXIgbWF4UG9vbFBvc2l0aW9uc1Byb2dyYW0gPSBuZXcgUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ21heCcsIGdldFBvc2l0aW9ucyk7XG4gICAgdmFyIG1heFBvb2xQb3NpdGlvbnMgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShtYXhQb29sUG9zaXRpb25zUHJvZ3JhbSwgW3hdLCB4LmR0eXBlKTtcbiAgICB2YXIgbWF4UG9vbEJhY2tQcm9wUHJvZ3JhbSA9IG5ldyBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW0oY29udkluZm8pO1xuICAgIHZhciByZXN1bHQgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShtYXhQb29sQmFja1Byb3BQcm9ncmFtLCBbZHksIG1heFBvb2xQb3NpdGlvbnNdLCB4LmR0eXBlKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG1heFBvb2xQb3NpdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG52YXIgbWF4UG9vbEdyYWRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuTWF4UG9vbEdyYWQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogbWF4UG9vbEdyYWRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIG1heFBvb2xXaXRoQXJnbWF4SW1wbCh4LCBpbmNsdWRlQmF0Y2hJbkluZGV4LCBjb252SW5mbywgYmFja2VuZCkge1xuICAgIHZhciBwcm9ncmFtID0gbmV3IFBvb2wyRFByb2dyYW0oY29udkluZm8sICdtYXgnLCBmYWxzZSk7XG4gICAgdmFyIHBvb2xPdXRwdXQgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbeF0sICdmbG9hdDMyJyk7XG4gICAgcHJvZ3JhbSA9IG5ldyBQb29sMkRQcm9ncmFtKGNvbnZJbmZvLCAnbWF4JywgdHJ1ZSwgdHJ1ZSwgaW5jbHVkZUJhdGNoSW5JbmRleCk7XG4gICAgdmFyIGluZGV4T3V0cHV0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3hdLCAnZmxvYXQzMicpO1xuICAgIHJldHVybiBbcG9vbE91dHB1dCwgaW5kZXhPdXRwdXRdO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgbWF4UG9vbFdpdGhBcmdtYXhDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuTWF4UG9vbFdpdGhBcmdtYXgsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBfYS5pbnB1dHMsIGF0dHJzID0gX2EuYXR0cnMsIGJhY2tlbmQgPSBfYS5iYWNrZW5kO1xuICAgICAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgICAgICB2YXIgX2IgPSBhdHRycywgZmlsdGVyU2l6ZSA9IF9iLmZpbHRlclNpemUsIHN0cmlkZXMgPSBfYi5zdHJpZGVzLCBwYWQgPSBfYi5wYWQsIGluY2x1ZGVCYXRjaEluSW5kZXggPSBfYi5pbmNsdWRlQmF0Y2hJbkluZGV4O1xuICAgICAgICB2YXIgd2ViZ2xCYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgdGYudXRpbC5hc3NlcnQoeC5zaGFwZS5sZW5ndGggPT09IDQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiRXJyb3IgaW4gbWF4UG9vbDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICsgeC5zaGFwZS5sZW5ndGggKyBcIi5cIjsgfSk7XG4gICAgICAgIHZhciBkaWxhdGlvbnMgPSBbMSwgMV07XG4gICAgICAgIHRmLnV0aWwuYXNzZXJ0KHRmLmJhY2tlbmRfdXRpbC5laXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUoc3RyaWRlcywgZGlsYXRpb25zKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Vycm9yIGluIG1heFBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuICcgK1xuICAgICAgICAgICAgKFwiR290IHN0cmlkZXMgXCIgKyBzdHJpZGVzICsgXCIgYW5kIGRpbGF0aW9ucyAnXCIgKyBkaWxhdGlvbnMgKyBcIidcIik7IH0pO1xuICAgICAgICB2YXIgY29udkluZm8gPSB0Zi5iYWNrZW5kX3V0aWwuY29tcHV0ZVBvb2wyREluZm8oeC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQpO1xuICAgICAgICB2YXIgX2MgPSBtYXhQb29sV2l0aEFyZ21heEltcGwoeCwgaW5jbHVkZUJhdGNoSW5JbmRleCwgY29udkluZm8sIHdlYmdsQmFja2VuZCksIHJlc3VsdCA9IF9jWzBdLCBpbmRleGVzID0gX2NbMV07XG4gICAgICAgIHJldHVybiBbcmVzdWx0LCBpbmRleGVzXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBtZWFuSW1wbCh4LCByZWR1Y2VTaGFwZSwgb3V0U2hhcGUsIGJhY2tlbmQpIHtcbiAgICB2YXIgaW5TaXplID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICB2YXIgeFNpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUoeC5zaGFwZSk7XG4gICAgdmFyIGJhdGNoU2l6ZSA9IHhTaXplIC8gaW5TaXplO1xuICAgIHZhciByZXNoYXBlZElucHV0ID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiB4IH0sIGF0dHJzOiB7IHNoYXBlOiBbYmF0Y2hTaXplLCBpblNpemVdIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgdmFyIHJlZHVjZWQgPSByZWR1Y2UocmVzaGFwZWRJbnB1dCwgJ2Zsb2F0MzInLCAnbWVhbicsIGJhY2tlbmQpO1xuICAgIHZhciByZXNoYXBlZE91dHB1dCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogcmVkdWNlZCB9LCBhdHRyczogeyBzaGFwZTogb3V0U2hhcGUgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlc2hhcGVkSW5wdXQpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVkdWNlZCk7XG4gICAgcmV0dXJuIHJlc2hhcGVkT3V0cHV0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgbWVhbkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5NZWFuLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaW5wdXRzID0gX2EuaW5wdXRzLCBhdHRycyA9IF9hLmF0dHJzLCBiYWNrZW5kID0gX2EuYmFja2VuZDtcbiAgICAgICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICAgICAgdmFyIF9iID0gYXR0cnMsIGtlZXBEaW1zID0gX2Iua2VlcERpbXMsIGF4aXMgPSBfYi5heGlzO1xuICAgICAgICB2YXIgd2ViZ2xCYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgdmFyIHhSYW5rID0geC5zaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBvcmlnQXhlcyA9IHRmLnV0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciBheGVzID0gb3JpZ0F4ZXM7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHhSYW5rKTtcbiAgICAgICAgdmFyIG1lYW5JbnB1dElzVHJhbnNwb3NlZCA9IHBlcm11dGVkQXhlcyAhPSBudWxsO1xuICAgICAgICB2YXIgc2hvdWxkRXhlY3V0ZU9uQ1BVID0gd2ViZ2xCYWNrZW5kLnNob3VsZEV4ZWN1dGVPbkNQVShbeF0pO1xuICAgICAgICB2YXIgaW50ZXJtZWRpYXRlcyA9IFtdO1xuICAgICAgICB2YXIgbWVhbklucHV0ID0geDtcbiAgICAgICAgaWYgKG1lYW5JbnB1dElzVHJhbnNwb3NlZCkge1xuICAgICAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGVPbkNQVSkge1xuICAgICAgICAgICAgICAgIHZhciB4VGV4RGF0YSA9IHdlYmdsQmFja2VuZC50ZXhEYXRhLmdldChtZWFuSW5wdXQuZGF0YUlkKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0geFRleERhdGEudmFsdWVzO1xuICAgICAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IG5ldyBBcnJheSh4UmFuayk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTaGFwZVtpXSA9IHguc2hhcGVbcGVybXV0ZWRBeGVzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1lYW5JbnB1dFZhbHVlcyA9IHRyYW5zcG9zZUltcGxDUFUodmFsdWVzLCB4LnNoYXBlLCB4LmR0eXBlLCBwZXJtdXRlZEF4ZXMsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgICAgICBtZWFuSW5wdXQgPSB3ZWJnbEJhY2tlbmQubWFrZVRlbnNvckluZm8obmV3U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBtZWFuSW5wdXREYXRhID0gd2ViZ2xCYWNrZW5kLnRleERhdGEuZ2V0KG1lYW5JbnB1dC5kYXRhSWQpO1xuICAgICAgICAgICAgICAgIG1lYW5JbnB1dERhdGEudmFsdWVzID0gbWVhbklucHV0VmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVhbklucHV0ID0gdHJhbnNwb3NlSW1wbCQxKHgsIHBlcm11dGVkQXhlcywgd2ViZ2xCYWNrZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludGVybWVkaWF0ZXMucHVzaChtZWFuSW5wdXQpO1xuICAgICAgICAgICAgYXhlcyA9IHRmLmJhY2tlbmRfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCB4UmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgdGYuYmFja2VuZF91dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdzdW0nLCBheGVzLCB4UmFuayk7XG4gICAgICAgIHZhciBfYyA9IHRmLmJhY2tlbmRfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKG1lYW5JbnB1dC5zaGFwZSwgYXhlcyksIG1lYW5PdXRTaGFwZSA9IF9jWzBdLCByZWR1Y2VTaGFwZSA9IF9jWzFdO1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBtZWFuT3V0U2hhcGU7XG4gICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gcmVzaGFwZSBhdCB0aGUgZW5kLCBzZXQgdGhlIHRhcmdldCBzaGFwZSBoZXJlLlxuICAgICAgICAgICAgb3V0U2hhcGUgPSB0Zi5iYWNrZW5kX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0obWVhbk91dFNoYXBlLCBvcmlnQXhlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IG1lYW5JbXBsKG1lYW5JbnB1dCwgcmVkdWNlU2hhcGUsIG91dFNoYXBlLCB3ZWJnbEJhY2tlbmQpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGludGVybWVkaWF0ZXNfMSA9IGludGVybWVkaWF0ZXM7IF9pIDwgaW50ZXJtZWRpYXRlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGkgPSBpbnRlcm1lZGlhdGVzXzFbX2ldO1xuICAgICAgICAgICAgd2ViZ2xCYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gbWluKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBheGlzID0gYXR0cnMuYXhpcywga2VlcERpbXMgPSBhdHRycy5rZWVwRGltcztcbiAgICB2YXIgeFJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgb3JpZ0F4ZXMgPSB0Zi51dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgIHZhciBheGVzID0gb3JpZ0F4ZXM7XG4gICAgdmFyIHBlcm11dGVkQXhlcyA9IHRmLmJhY2tlbmRfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeFJhbmspO1xuICAgIHZhciBwZXJtdXRlZFggPSB4O1xuICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICBwZXJtdXRlZFggPSB0cmFuc3Bvc2UoeyBpbnB1dHM6IHsgeDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBwZXJtOiBwZXJtdXRlZEF4ZXMgfSB9KTtcbiAgICAgICAgYXhlcyA9IHRmLmJhY2tlbmRfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCB4LnNoYXBlLmxlbmd0aCk7XG4gICAgfVxuICAgIHRmLmJhY2tlbmRfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnbWluJywgYXhlcywgeFJhbmspO1xuICAgIHZhciBfYSA9IHRmLmJhY2tlbmRfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHBlcm11dGVkWC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgdmFyIGluU2l6ZSA9IHRmLnV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgdmFyIGEyRCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogcGVybXV0ZWRYIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBbLTEsIGluU2l6ZV0gfSB9KTtcbiAgICB2YXIgcmVkdWNlZCA9IHJlZHVjZShhMkQsIGEyRC5kdHlwZSwgJ21pbicsIGJhY2tlbmQpO1xuICAgIHZhciByZXM7XG4gICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IHRmLmJhY2tlbmRfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShvdXRTaGFwZSwgb3JpZ0F4ZXMpO1xuICAgICAgICByZXMgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHJlZHVjZWQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IG5ld1NoYXBlIH0gfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHJlZHVjZWQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IG91dFNoYXBlIH0gfSk7XG4gICAgfVxuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYTJEKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlZHVjZWQpO1xuICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHBlcm11dGVkWCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG52YXIgbWluQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLk1pbixcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBtaW5cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBNSU5JTVVNID0gQ0hFQ0tfTkFOX1NOSVBQRVQkMSArIFwiXFxuICByZXR1cm4gbWluKGEsIGIpO1xcblwiO1xudmFyIE1JTklNVU1fUEFDS0VEID0gXCJcXG4gIHZlYzQgcmVzdWx0ID0gdmVjNChtaW4oYSwgYikpO1xcbiAgdmVjNCBpc05hTiA9IG1pbih2ZWM0KGlzbmFuKGEpKSArIHZlYzQoaXNuYW4oYikpLCB2ZWM0KDEuMCkpO1xcbiAgXCIgK1xuICAgIENIRUNLX05BTl9TTklQUEVUJDIgKyBcIlxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIjtcbnZhciBtaW5pbXVtID0gYmluYXJ5S2VybmVsRnVuYyh7XG4gICAgb3BTbmlwcGV0OiBNSU5JTVVNLFxuICAgIHBhY2tlZE9wU25pcHBldDogTUlOSU1VTV9QQUNLRUQsXG4gICAgY3B1S2VybmVsSW1wbDogbWluaW11bUltcGxDUFVcbn0pO1xudmFyIG1pbmltdW1Db25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuTWluaW11bSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBtaW5pbXVtXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgTWlycm9yUGFkUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNaXJyb3JQYWRQcm9ncmFtKHhTaGFwZSwgcGFkZGluZ3MsIG1vZGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBwYWRkaW5ncy5tYXAoZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIHBbMF0gLyogYmVmb3JlUGFkICovICsgeFNoYXBlW2ldICsgcFsxXTsgfSAvKiBhZnRlclBhZCAqLyk7XG4gICAgICAgIHZhciByYW5rID0geFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgICAgIHZhciBzdGFydCA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfSkuam9pbignLCcpO1xuICAgICAgICB2YXIgZW5kID0gcGFkZGluZ3MubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBwWzBdICsgeFNoYXBlW2ldOyB9KS5qb2luKCcsJyk7XG4gICAgICAgIHZhciB1bnBhY2tlZENvb3JkcyA9IFsnY29vcmRzWzBdJywgJ2Nvb3Jkc1sxXScsICdjb29yZHNbMl0nLCAnY29vcmRzWzNdJ10uc2xpY2UoMCwgcmFuayk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBtb2RlID09PSAncmVmbGVjdCcgPyAwIDogMTtcbiAgICAgICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgaW50IHN0YXJ0ID0gXCIgKyBzdGFydCArIFwiO1xcbiAgICAgICAgaW50IGVuZCA9IFwiICsgZW5kICsgXCI7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGludCBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGlmIChvdXRDIDwgc3RhcnQpIHtcXG4gICAgICAgICAgICBvdXRDID0gc3RhcnQgKiAyIC0gb3V0QyAtIFwiICsgb2Zmc2V0ICsgXCI7XFxuICAgICAgICAgIH0gZWxzZSBpZihvdXRDID49IGVuZCkge1xcbiAgICAgICAgICAgIG91dEMgPSAoZW5kIC0gMSkgKiAyIC0gb3V0QyArIFwiICsgb2Zmc2V0ICsgXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgob3V0QyAtIHN0YXJ0KSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgXCIgKyBkdHlwZSArIFwiIHN0YXJ0ID0gXCIgKyBkdHlwZSArIFwiKFwiICsgc3RhcnQgKyBcIik7XFxuICAgICAgXCIgKyBkdHlwZSArIFwiIGVuZCA9IFwiICsgZHR5cGUgKyBcIihcIiArIGVuZCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIHJhbmsgKyBcIjsgaSsrKSB7XFxuICAgICAgICAgIGlmIChvdXRDW2ldIDwgc3RhcnRbaV0pIHtcXG4gICAgICAgICAgICBvdXRDW2ldID0gc3RhcnRbaV0gKiAyIC0gb3V0Q1tpXSAtIFwiICsgb2Zmc2V0ICsgXCI7XFxuICAgICAgICAgIH0gZWxzZSBpZihvdXRDW2ldID49IGVuZFtpXSkge1xcbiAgICAgICAgICAgIG91dENbaV0gPSAoZW5kW2ldIC0gMSkgKiAyIC0gb3V0Q1tpXSArIFwiICsgb2Zmc2V0ICsgXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBjb29yZHMgPSBvdXRDIC0gc3RhcnQ7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIiArIHVucGFja2VkQ29vcmRzICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gTWlycm9yUGFkUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogRXhhbXBsZSBzaGFkZXIgY29kZSBmb3JcbiAqIGBtaXJyb3JQYWQodGYudGVuc29yMWQoWzEsIDIsIDNdLCAnaW50MzInKSwgW1syLCAyXV0sICdyZWZsZWN0JylgXG4gKiBgYGBcbiAqICAgIGNvbnN0IGludCBzdGFydCA9IGludCgyKTtcbiAqICAgIGNvbnN0IGludCBlbmQgPSBpbnQoNSk7XG4gKlxuICogICAgdm9pZCBtYWluKCkge1xuICogICAgICAgaW50IG91dHB1dExvYyA9IGdldE91dHB1dENvb3JkcygpO1xuICogICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcbiAqXG4gKiAgICAgICBpbnQgcmMgPSBvdXRwdXRMb2M7XG4gKlxuICogICAgICAgaW50IHNvdXJjZSA9IHJjO1xuICogICAgICAgaWYgKHNvdXJjZSA8IHN0YXJ0KSB7XG4gKiAgICAgICAgIHNvdXJjZSA9IHN0YXJ0ICogMiAtIHNvdXJjZSAtIDA7XG4gKiAgICAgICB9IGVsc2UgaWYgKHNvdXJjZSA+PSBlbmQpIHtcbiAqICAgICAgICAgc291cmNlID0gKGVuZCAtIDEpICogMiAtIHNvdXJjZSArIDA7XG4gKiAgICAgICB9XG4gKiAgICAgICBzb3VyY2UgLT0gc3RhcnQ7XG4gKlxuICogICAgICAgcmVzdWx0WzBdID0gZ2V0Q2hhbm5lbChnZXRYKHNvdXJjZSksIHNvdXJjZSk7XG4gKiAgICAgICByYyArPSAxO1xuICogICAgICAgaWYocmMgPCA2KSB7XG4gKiAgICAgICAgICBpbnQgc291cmNlID0gcmM7XG4gKiAgICAgICAgICBpZiAoc291cmNlIDwgc3RhcnQpIHtcbiAqICAgICAgICAgICAgc291cmNlID0gc3RhcnQgKiAyIC0gc291cmNlIC0gMDtcbiAqICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlID49IGVuZCkge1xuICogICAgICAgICAgICBzb3VyY2UgPSAoZW5kIC0gMSkgKiAyIC0gc291cmNlICsgMDtcbiAqICAgICAgICAgIH1cbiAqICAgICAgICAgIHNvdXJjZSAtPSBzdGFydDtcbiAqXG4gKiAgICAgICAgIHJlc3VsdFsxXSA9IGdldENoYW5uZWwoZ2V0WChzb3VyY2UpLCBzb3VyY2UpO1xuICogICAgICAgfVxuICpcbiAqICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICogICAgIH1cbiAqIGBgYFxuICovXG52YXIgTWlycm9yUGFkUGFja2VkUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNaXJyb3JQYWRQYWNrZWRQcm9ncmFtKHhTaGFwZSwgcGFkZGluZ3MsIG1vZGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIHRoaXMucGFja2VkSW5wdXRzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWNrZWRPdXRwdXQgPSB0cnVlO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gcGFkZGluZ3MubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBwWzBdIC8qIGJlZm9yZVBhZCAqLyArIHhTaGFwZVtpXSArIHBbMV07IH0gLyogYWZ0ZXJQYWQgKi8pO1xuICAgICAgICB2YXIgcmFuayA9IHhTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBkdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICAgICAgICB2YXIgc3RhcnQgPSBwYWRkaW5ncy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHBbMF07IH0pLmpvaW4oJywnKTtcbiAgICAgICAgdmFyIGVuZCA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gcFswXSArIHhTaGFwZVtpXTsgfSkuam9pbignLCcpO1xuICAgICAgICB2YXIgY29vcmRzID0gZ2V0Q2hhbm5lbHMoJ3JjJywgcmFuayk7XG4gICAgICAgIHZhciBzb3VyY2UgPSBnZXRDaGFubmVscygnc291cmNlJywgcmFuayk7XG4gICAgICAgIHZhciBjTGltaXQgPSBjb29yZHNbcmFuayAtIDFdICsgXCIgPCBcIiArIHRoaXMub3V0cHV0U2hhcGVbcmFuayAtIDFdO1xuICAgICAgICB2YXIgaW5uZXJEaW1zID0gcmFuayA9PT0gMSA/ICdzb3VyY2UnIDogXCJ2ZWMyKFwiICsgc291cmNlLnNsaWNlKC0yKS5qb2luKCkgKyBcIilcIjtcbiAgICAgICAgdmFyIG9mZnNldCA9IG1vZGUgPT09ICdyZWZsZWN0JyA/IDAgOiAxO1xuICAgICAgICB2YXIgbWFpbkxvb3AgPSAnJztcbiAgICAgICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBwYWRTZXR1cCA9IFwiXFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgc291cmNlID0gcmM7XFxuICAgICAgICBpZiAoc291cmNlIDwgc3RhcnQpIHtcXG4gICAgICAgICAgc291cmNlID0gc3RhcnQgKiAyIC0gc291cmNlIC0gXCIgKyBvZmZzZXQgKyBcIjtcXG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlID49IGVuZCkge1xcbiAgICAgICAgICBzb3VyY2UgPSAoZW5kIC0gMSkgKiAyIC0gc291cmNlICsgXCIgKyBvZmZzZXQgKyBcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIHNvdXJjZSAtPSBzdGFydDtcXG4gICAgICBcIjtcbiAgICAgICAgICAgIG1haW5Mb29wID0gXCJcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiByYyA9IG91dHB1dExvYztcXG4gICAgICAgIFwiICsgcGFkU2V0dXAgKyBcIlxcbiAgICAgICAgcmVzdWx0WzBdID0gZ2V0Q2hhbm5lbChnZXRYKFwiICsgc291cmNlLmpvaW4oKSArIFwiKSwgXCIgKyBpbm5lckRpbXMgKyBcIik7XFxuICAgICAgICBcIiArIGNvb3Jkc1tyYW5rIC0gMV0gKyBcIiArPSAxO1xcbiAgICAgICAgaWYoXCIgKyBjTGltaXQgKyBcIikge1xcbiAgICAgICAgICBcIiArIHBhZFNldHVwICsgXCJcXG4gICAgICAgICAgcmVzdWx0WzFdID0gZ2V0Q2hhbm5lbChnZXRYKFwiICsgc291cmNlLmpvaW4oKSArIFwiKSwgXCIgKyBpbm5lckRpbXMgKyBcIik7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFkU2V0dXAgPSBcIlxcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIHNvdXJjZSA9IHJjO1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIGx0ID0gXCIgKyBkdHlwZSArIFwiKGxlc3NUaGFuKHNvdXJjZSwgc3RhcnQpKTtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBndGUgPSBcIiArIGR0eXBlICsgXCIoZ3JlYXRlclRoYW5FcXVhbChzb3VyY2UsIGVuZCkpO1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIG9yaWcgPSAxIC0gKGx0ICsgZ3RlKTtcXG4gICAgICAgIHNvdXJjZSA9IG9yaWcgKiBzb3VyY2UgK1xcbiAgICAgICAgICAgICAgICBsdCAqIChzdGFydCAqIDIgLSBzb3VyY2UgLSBcIiArIG9mZnNldCArIFwiKSArXFxuICAgICAgICAgICAgICAgIGd0ZSAqICgoZW5kIC0gMSkgKiAyIC0gc291cmNlICsgXCIgKyBvZmZzZXQgKyBcIik7XFxuICAgICAgICBzb3VyY2UgLT0gc3RhcnQ7XFxuICAgICAgXCI7XG4gICAgICAgICAgICBtYWluTG9vcCA9IFwiXFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgcmMgPSBvdXRwdXRMb2M7XFxuICAgICAgICBcIiArIHBhZFNldHVwICsgXCJcXG4gICAgICAgIHJlc3VsdFswXSA9IGdldENoYW5uZWwoZ2V0WChcIiArIHNvdXJjZS5qb2luKCkgKyBcIiksIFwiICsgaW5uZXJEaW1zICsgXCIpO1xcbiAgICAgICAgXCIgKyBjb29yZHNbcmFuayAtIDFdICsgXCIgKz0gMTtcXG4gICAgICAgIGlmKFwiICsgY0xpbWl0ICsgXCIpIHtcXG4gICAgICAgICAgXCIgKyBwYWRTZXR1cCArIFwiXFxuICAgICAgICAgIHJlc3VsdFsxXSA9IGdldENoYW5uZWwoZ2V0WChcIiArIHNvdXJjZS5qb2luKCkgKyBcIiksIFwiICsgaW5uZXJEaW1zICsgXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmMgPSBvdXRwdXRMb2M7XFxuICAgICAgICBcIiArIGNvb3Jkc1tyYW5rIC0gMl0gKyBcIiArPSAxO1xcbiAgICAgICAgaWYoXCIgKyBjb29yZHNbcmFuayAtIDJdICsgXCIgPCBcIiArIHRoaXMub3V0cHV0U2hhcGVbcmFuayAtIDJdICsgXCIpIHtcXG4gICAgICAgICAgXCIgKyBwYWRTZXR1cCArIFwiXFxuICAgICAgICAgIHJlc3VsdFsyXSA9IGdldENoYW5uZWwoZ2V0WChcIiArIHNvdXJjZS5qb2luKCkgKyBcIiksIFwiICsgaW5uZXJEaW1zICsgXCIpO1xcbiAgICAgICAgICBcIiArIGNvb3Jkc1tyYW5rIC0gMV0gKyBcIiArPSAxO1xcbiAgICAgICAgICBpZihcIiArIGNMaW1pdCArIFwiKSB7XFxuICAgICAgICAgICAgXCIgKyBwYWRTZXR1cCArIFwiXFxuICAgICAgICAgICAgcmVzdWx0WzNdID0gZ2V0Q2hhbm5lbChnZXRYKFwiICsgc291cmNlLmpvaW4oKSArIFwiKSwgXCIgKyBpbm5lckRpbXMgKyBcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBcIiArIGR0eXBlICsgXCIgc3RhcnQgPSBcIiArIGR0eXBlICsgXCIoXCIgKyBzdGFydCArIFwiKTtcXG4gICAgICBjb25zdCBcIiArIGR0eXBlICsgXCIgZW5kID0gXCIgKyBkdHlwZSArIFwiKFwiICsgZW5kICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBvdXRwdXRMb2MgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICBcIiArIG1haW5Mb29wICsgXCJcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBNaXJyb3JQYWRQYWNrZWRQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIG1pcnJvclBhZEtlcm5lbEZ1bmMgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgaW5wdXRzID0gX2EuaW5wdXRzLCBiYWNrZW5kID0gX2EuYmFja2VuZCwgYXR0cnMgPSBfYS5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBwYWRkaW5ncyA9IGF0dHJzLnBhZGRpbmdzLCBtb2RlID0gYXR0cnMubW9kZTtcbiAgICB2YXIgcHJvZ3JhbSA9IHRmLmVudigpLmdldEJvb2woJ1dFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OUycpID9cbiAgICAgICAgbmV3IE1pcnJvclBhZFBhY2tlZFByb2dyYW0oeC5zaGFwZSwgcGFkZGluZ3MsIG1vZGUpIDpcbiAgICAgICAgbmV3IE1pcnJvclBhZFByb2dyYW0oeC5zaGFwZSwgcGFkZGluZ3MsIG1vZGUpO1xuICAgIHZhciBvdXRwdXQgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbeF0sIHguZHR5cGUpO1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xudmFyIG1pcnJvclBhZENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5NaXJyb3JQYWQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogbWlycm9yUGFkS2VybmVsRnVuYyxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBNT0QgPSBcImlmIChiID09IDAuMCkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiBtb2QoYSwgYik7XCI7XG52YXIgTU9EX1BBQ0tFRCA9IFwiXFxuICB2ZWM0IHJlc3VsdCA9IG1vZChhLCBiKTtcXG4gIHZlYzQgaXNOYU4gPSB2ZWM0KGVxdWFsKGIsIHZlYzQoMC4wKSkpO1xcbiAgXCIgK1xuICAgIENIRUNLX05BTl9TTklQUEVUJDIgKyBcIlxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIjtcbnZhciBtb2QgPSBiaW5hcnlLZXJuZWxGdW5jKHtcbiAgICBvcFNuaXBwZXQ6IE1PRCxcbiAgICBwYWNrZWRPcFNuaXBwZXQ6IE1PRF9QQUNLRUQsXG59KTtcbnZhciBtb2RDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuTW9kLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IG1vZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIE11bHRpbm9taWFsUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNdWx0aW5vbWlhbFByb2dyYW0oYmF0Y2hTaXplLCBudW1PdXRjb21lcywgbnVtU2FtcGxlcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3Byb2JzJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBudW1TYW1wbGVzXTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBzZWVkO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcblxcbiAgICAgICAgZmxvYXQgciA9IHJhbmRvbShzZWVkKTtcXG4gICAgICAgIGZsb2F0IGNkZiA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyAobnVtT3V0Y29tZXMgLSAxKSArIFwiOyBpKyspIHtcXG4gICAgICAgICAgY2RmICs9IGdldFByb2JzKGJhdGNoLCBpKTtcXG5cXG4gICAgICAgICAgaWYgKHIgPCBjZGYpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoaSkpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gSWYgbm8gb3RoZXIgZXZlbnQgaGFwcGVuZWQsIGxhc3QgZXZlbnQgaGFwcGVuZWQuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIgKyAobnVtT3V0Y29tZXMgLSAxKSArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgTXVsdGlub21pYWxQcm9ncmFtLnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmMgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zZWVkTG9jID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWVkTG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgJ3NlZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihfdGhpcy5zZWVkTG9jLCBzZWVkKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBNdWx0aW5vbWlhbFByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vLyBXaXRob3V0IHRoZSBlcXVhbGl0eSBjaGVjayBkaXYgcHJvZHVjZXMgMC45OTk5IGZvciBhID0gYiwgd2hpY2ggd2hlblxuLy8gZmxvb3JlZCBjYW4gY2F1c2UgZXJyb3JzLlxudmFyIERJViA9IFwiXFxuaWYgKGEgPT0gYikge1xcbiAgcmV0dXJuIDEuMDtcXG59O1xcbnJldHVybiBhIC8gYjtcIjtcbi8vIFdlIGRvIHRoZSBzYW1lIGFzIGluIC4vYmluYXJ5b3BfZ3B1LCB3aXRoIHZlYzQgYW5kIGl2ZWM0LlxuLy8gT24gTGludXgsIHRoZSB2ZWN0b3JpemVkIGltcGxlbWVudGF0aW9uIHByb2R1Y2VzIE5hTnMgd2hlbiBhIGFuZCBiIGFyZSAwLlxudmFyIERJVl9QQUNLRUQgPSBcIlxcbiAgLy8gdmVjNCBvbmUgPSB2ZWM0KGVxdWFsKGEsIGIpKTtcXG4gIC8vIHJldHVybiBvbmUgKyAodmVjNCgxLjApIC0gb25lKSAqIGEgLyBiO1xcbiAgdmVjNCByZXN1bHQgPSBhIC8gYjtcXG4gIGlmKGEueCA9PSBiLngpIHtcXG4gICAgcmVzdWx0LnggPSAxLjtcXG4gIH1cXG4gIGlmKGEueSA9PSBiLnkpIHtcXG4gICAgcmVzdWx0LnkgPSAxLjtcXG4gIH1cXG4gIGlmKGEueiA9PSBiLnopIHtcXG4gICAgcmVzdWx0LnogPSAxLjtcXG4gIH1cXG4gIGlmKGEudyA9PSBiLncpIHtcXG4gICAgcmVzdWx0LncgPSAxLjtcXG4gIH1cXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCI7XG52YXIgcmVhbERpdiA9IGJpbmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IERJViwgcGFja2VkT3BTbmlwcGV0OiBESVZfUEFDS0VELCBjaGVja091dE9mQm91bmRzOiB0cnVlIH0pO1xudmFyIHJlYWxEaXZDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuUmVhbERpdixcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiByZWFsRGl2LFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFNVQiA9ICdyZXR1cm4gYSAtIGI7JztcbnZhciBzdWIgPSBiaW5hcnlLZXJuZWxGdW5jKHtcbiAgICBvcFNuaXBwZXQ6IFNVQixcbiAgICBwYWNrZWRPcFNuaXBwZXQ6IFNVQixcbiAgICBzdXBwb3J0c0NvbXBsZXg6IHRydWUsXG4gICAgY3B1S2VybmVsSW1wbDogc3ViSW1wbENQVVxufSk7XG52YXIgc3ViQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlN1YixcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBzdWJcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHNvZnRtYXgoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBsb2dpdHMgPSBpbnB1dHMubG9naXRzO1xuICAgIHZhciBkaW0gPSBhdHRycy5kaW07XG4gICAgdmFyIGF4ZXMgPSB0Zi51dGlsLnBhcnNlQXhpc1BhcmFtKFtkaW1dLCBsb2dpdHMuc2hhcGUpO1xuICAgIHZhciBtYXhMb2dpdCA9IG1heCh7XG4gICAgICAgIGlucHV0czogeyB4OiBsb2dpdHMgfSxcbiAgICAgICAgYmFja2VuZDogYmFja2VuZCxcbiAgICAgICAgYXR0cnM6IHsgcmVkdWN0aW9uSW5kaWNlczogYXhlcywga2VlcERpbXM6IGZhbHNlIH1cbiAgICB9KTtcbiAgICB2YXIgZXhwYW5kZWRTaGFwZSA9IHRmLmJhY2tlbmRfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShtYXhMb2dpdC5zaGFwZSwgYXhlcyk7XG4gICAgdmFyIG1heExvZ2l0c1Jlc2hhcGVkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiBtYXhMb2dpdCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogZXhwYW5kZWRTaGFwZSB9IH0pO1xuICAgIHZhciBhID0gc3ViKHsgaW5wdXRzOiB7IGE6IGxvZ2l0cywgYjogbWF4TG9naXRzUmVzaGFwZWQgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICB2YXIgYiA9IGV4cCh7IGlucHV0czogeyB4OiBhIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgdmFyIHN1bUV4cCA9IHN1bSh7IGlucHV0czogeyB4OiBiIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGF4aXM6IGF4ZXMsIGtlZXBEaW1zOiBmYWxzZSB9IH0pO1xuICAgIHZhciBzdW1FeHBSZXNoYXBlZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogc3VtRXhwIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBleHBhbmRlZFNoYXBlIH0gfSk7XG4gICAgdmFyIHJlcyA9IHJlYWxEaXYoeyBpbnB1dHM6IHsgYTogYiwgYjogc3VtRXhwUmVzaGFwZWQgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG1heExvZ2l0KTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG1heExvZ2l0c1Jlc2hhcGVkKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGEpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYik7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhzdW1FeHApO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oc3VtRXhwUmVzaGFwZWQpO1xuICAgIHJldHVybiByZXM7XG59XG52YXIgc29mdG1heENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5Tb2Z0bWF4LFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHNvZnRtYXhcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIG11bHRpbm9taWFsKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgbG9naXRzID0gaW5wdXRzLmxvZ2l0cztcbiAgICB2YXIgbnVtU2FtcGxlcyA9IGF0dHJzLm51bVNhbXBsZXMsIHNlZWQgPSBhdHRycy5zZWVkLCBub3JtYWxpemVkID0gYXR0cnMubm9ybWFsaXplZDtcbiAgICB2YXIgcHJvYnMgPSBub3JtYWxpemVkID9cbiAgICAgICAgbG9naXRzIDpcbiAgICAgICAgc29mdG1heCh7IGlucHV0czogeyBsb2dpdHM6IGxvZ2l0cyB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBkaW06IGxvZ2l0cy5zaGFwZS5sZW5ndGggLSAxIH0gfSk7XG4gICAgdmFyIGJhdGNoU2l6ZSA9IHByb2JzLnNoYXBlWzBdO1xuICAgIHZhciBudW1PdXRjb21lcyA9IHByb2JzLnNoYXBlWzFdO1xuICAgIHZhciBwcm9ncmFtID0gbmV3IE11bHRpbm9taWFsUHJvZ3JhbShiYXRjaFNpemUsIG51bU91dGNvbWVzLCBudW1TYW1wbGVzKTtcbiAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhzZWVkKTtcbiAgICB2YXIgcmVzID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3Byb2JzXSwgJ2ludDMyJywgY3VzdG9tU2V0dXApO1xuICAgIGlmICghbm9ybWFsaXplZCkge1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHByb2JzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbnZhciBtdWx0aW5vbWlhbENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5NdWx0aW5vbWlhbCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBtdWx0aW5vbWlhbFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIE5FRyA9IFwicmV0dXJuIC14O1wiO1xuLy8gVGhpcyBkb2Vzbid0IHVzZSB1bmFyeUtlcm5lbEZ1bmMgYmVjYXVzZSBuZWdJbXBsQ1BVIGlzIG5vdCBvZiB0eXBlXG4vLyBTaW1wbGVVbmFyeUtlcm5lbEltcGxDUFUuXG5mdW5jdGlvbiBuZWcoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIGlmIChiYWNrZW5kLnNob3VsZEV4ZWN1dGVPbkNQVShbeF0pKSB7XG4gICAgICAgIHZhciB4RGF0YSA9IGJhY2tlbmQudGV4RGF0YS5nZXQoeC5kYXRhSWQpO1xuICAgICAgICB2YXIgX2EgPSBuZWdJbXBsQ1BVKHhEYXRhLnZhbHVlcywgeC5zaGFwZSwgeC5kdHlwZSksIG91dFZhbHVlcyA9IF9hWzBdLCBuZXdTaGFwZSA9IF9hWzFdO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhuZXdTaGFwZSwgeC5kdHlwZSwgb3V0VmFsdWVzKTtcbiAgICB9XG4gICAgdmFyIHByb2dyYW07XG4gICAgaWYgKHRmLmVudigpLmdldEJvb2woJ1dFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OUycpKSB7XG4gICAgICAgIHByb2dyYW0gPSBuZXcgVW5hcnlPcFBhY2tlZFByb2dyYW0oeC5zaGFwZSwgTkVHKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgTkVHKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt4XSwgeC5kdHlwZSk7XG59XG52YXIgbmVnQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLk5lZyxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBuZWdcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBub25NYXhTdXBwcmVzc2lvblYzSW1wbCA9IHRmLmtlcm5lbF9pbXBscy5ub25NYXhTdXBwcmVzc2lvblYzSW1wbDtcbmZ1bmN0aW9uIG5vbk1heFN1cHByZXNzaW9uVjMoYXJncykge1xuICAgIHRmLmJhY2tlbmRfdXRpbC53YXJuKCd0Zi5ub25NYXhTdXBwcmVzc2lvbigpIGluIHdlYmdsIGxvY2tzIHRoZSBVSSB0aHJlYWQuICcgK1xuICAgICAgICAnQ2FsbCB0Zi5ub25NYXhTdXBwcmVzc2lvbkFzeW5jKCkgaW5zdGVhZCcpO1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBib3hlcyA9IGlucHV0cy5ib3hlcywgc2NvcmVzID0gaW5wdXRzLnNjb3JlcztcbiAgICB2YXIgbWF4T3V0cHV0U2l6ZSA9IGF0dHJzLm1heE91dHB1dFNpemUsIGlvdVRocmVzaG9sZCA9IGF0dHJzLmlvdVRocmVzaG9sZCwgc2NvcmVUaHJlc2hvbGQgPSBhdHRycy5zY29yZVRocmVzaG9sZDtcbiAgICB2YXIgYm94ZXNWYWxzID0gYmFja2VuZC5yZWFkU3luYyhib3hlcy5kYXRhSWQpO1xuICAgIHZhciBzY29yZXNWYWxzID0gYmFja2VuZC5yZWFkU3luYyhzY29yZXMuZGF0YUlkKTtcbiAgICB2YXIgc2VsZWN0ZWRJbmRpY2VzID0gbm9uTWF4U3VwcHJlc3Npb25WM0ltcGwoYm94ZXNWYWxzLCBzY29yZXNWYWxzLCBtYXhPdXRwdXRTaXplLCBpb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkKS5zZWxlY3RlZEluZGljZXM7XG4gICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oW3NlbGVjdGVkSW5kaWNlcy5sZW5ndGhdLCAnaW50MzInLCBuZXcgSW50MzJBcnJheShzZWxlY3RlZEluZGljZXMpKTtcbn1cbnZhciBub25NYXhTdXBwcmVzc2lvblYzQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLk5vbk1heFN1cHByZXNzaW9uVjMsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogbm9uTWF4U3VwcHJlc3Npb25WM1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIG5vbk1heFN1cHByZXNzaW9uVjRJbXBsID0gdGYua2VybmVsX2ltcGxzLm5vbk1heFN1cHByZXNzaW9uVjRJbXBsO1xuZnVuY3Rpb24gbm9uTWF4U3VwcHJlc3Npb25WNChhcmdzKSB7XG4gICAgdGYuYmFja2VuZF91dGlsLndhcm4oJ3RmLm5vbk1heFN1cHByZXNzaW9uKCkgaW4gd2ViZ2wgbG9ja3MgdGhlIFVJIHRocmVhZC4gJyArXG4gICAgICAgICdDYWxsIHRmLm5vbk1heFN1cHByZXNzaW9uQXN5bmMoKSBpbnN0ZWFkJyk7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGJveGVzID0gaW5wdXRzLmJveGVzLCBzY29yZXMgPSBpbnB1dHMuc2NvcmVzO1xuICAgIHZhciBtYXhPdXRwdXRTaXplID0gYXR0cnMubWF4T3V0cHV0U2l6ZSwgaW91VGhyZXNob2xkID0gYXR0cnMuaW91VGhyZXNob2xkLCBzY29yZVRocmVzaG9sZCA9IGF0dHJzLnNjb3JlVGhyZXNob2xkLCBwYWRUb01heE91dHB1dFNpemUgPSBhdHRycy5wYWRUb01heE91dHB1dFNpemU7XG4gICAgdmFyIGJveGVzVmFscyA9IGJhY2tlbmQucmVhZFN5bmMoYm94ZXMuZGF0YUlkKTtcbiAgICB2YXIgc2NvcmVzVmFscyA9IGJhY2tlbmQucmVhZFN5bmMoc2NvcmVzLmRhdGFJZCk7XG4gICAgdmFyIF9hID0gbm9uTWF4U3VwcHJlc3Npb25WNEltcGwoYm94ZXNWYWxzLCBzY29yZXNWYWxzLCBtYXhPdXRwdXRTaXplLCBpb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkLCBwYWRUb01heE91dHB1dFNpemUpLCBzZWxlY3RlZEluZGljZXMgPSBfYS5zZWxlY3RlZEluZGljZXMsIHZhbGlkT3V0cHV0cyA9IF9hLnZhbGlkT3V0cHV0cztcbiAgICByZXR1cm4gW1xuICAgICAgICBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtzZWxlY3RlZEluZGljZXMubGVuZ3RoXSwgJ2ludDMyJywgbmV3IEludDMyQXJyYXkoc2VsZWN0ZWRJbmRpY2VzKSksXG4gICAgICAgIGJhY2tlbmQubWFrZVRlbnNvckluZm8oW10sICdpbnQzMicsIG5ldyBJbnQzMkFycmF5KFt2YWxpZE91dHB1dHNdKSlcbiAgICBdO1xufVxudmFyIG5vbk1heFN1cHByZXNzaW9uVjRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuTm9uTWF4U3VwcHJlc3Npb25WNCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBub25NYXhTdXBwcmVzc2lvblY0XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgbm9uTWF4U3VwcHJlc3Npb25WNUltcGwgPSB0Zi5rZXJuZWxfaW1wbHMubm9uTWF4U3VwcHJlc3Npb25WNUltcGw7XG5mdW5jdGlvbiBub25NYXhTdXBwcmVzc2lvblY1KGFyZ3MpIHtcbiAgICB0Zi5iYWNrZW5kX3V0aWwud2FybigndGYubm9uTWF4U3VwcHJlc3Npb24oKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiAnICtcbiAgICAgICAgJ0NhbGwgdGYubm9uTWF4U3VwcHJlc3Npb25Bc3luYygpIGluc3RlYWQnKTtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgYm94ZXMgPSBpbnB1dHMuYm94ZXMsIHNjb3JlcyA9IGlucHV0cy5zY29yZXM7XG4gICAgdmFyIG1heE91dHB1dFNpemUgPSBhdHRycy5tYXhPdXRwdXRTaXplLCBpb3VUaHJlc2hvbGQgPSBhdHRycy5pb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkID0gYXR0cnMuc2NvcmVUaHJlc2hvbGQsIHNvZnRObXNTaWdtYSA9IGF0dHJzLnNvZnRObXNTaWdtYTtcbiAgICB2YXIgYm94ZXNWYWxzID0gYmFja2VuZC5yZWFkU3luYyhib3hlcy5kYXRhSWQpO1xuICAgIHZhciBzY29yZXNWYWxzID0gYmFja2VuZC5yZWFkU3luYyhzY29yZXMuZGF0YUlkKTtcbiAgICB2YXIgbWF4T3V0cHV0U2l6ZVZhbCA9IG1heE91dHB1dFNpemU7XG4gICAgdmFyIGlvdVRocmVzaG9sZFZhbCA9IGlvdVRocmVzaG9sZDtcbiAgICB2YXIgc2NvcmVUaHJlc2hvbGRWYWwgPSBzY29yZVRocmVzaG9sZDtcbiAgICB2YXIgc29mdE5tc1NpZ21hVmFsID0gc29mdE5tc1NpZ21hO1xuICAgIHZhciBfYSA9IG5vbk1heFN1cHByZXNzaW9uVjVJbXBsKGJveGVzVmFscywgc2NvcmVzVmFscywgbWF4T3V0cHV0U2l6ZVZhbCwgaW91VGhyZXNob2xkVmFsLCBzY29yZVRocmVzaG9sZFZhbCwgc29mdE5tc1NpZ21hVmFsKSwgc2VsZWN0ZWRJbmRpY2VzID0gX2Euc2VsZWN0ZWRJbmRpY2VzLCBzZWxlY3RlZFNjb3JlcyA9IF9hLnNlbGVjdGVkU2NvcmVzO1xuICAgIHJldHVybiBbXG4gICAgICAgIGJhY2tlbmQubWFrZVRlbnNvckluZm8oW3NlbGVjdGVkSW5kaWNlcy5sZW5ndGhdLCAnaW50MzInLCBuZXcgSW50MzJBcnJheShzZWxlY3RlZEluZGljZXMpKSxcbiAgICAgICAgYmFja2VuZC5tYWtlVGVuc29ySW5mbyhbc2VsZWN0ZWRTY29yZXMubGVuZ3RoXSwgJ2Zsb2F0MzInLCBuZXcgRmxvYXQzMkFycmF5KHNlbGVjdGVkU2NvcmVzKSlcbiAgICBdO1xufVxudmFyIG5vbk1heFN1cHByZXNzaW9uVjVDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuTm9uTWF4U3VwcHJlc3Npb25WNSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBub25NYXhTdXBwcmVzc2lvblY1XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgT25lSG90UHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPbmVIb3RQcm9ncmFtKG51bUluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2luZGljZXMnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtudW1JbmRpY2VzLCBkZXB0aF07XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHMueCkpO1xcbiAgICAgICAgc2V0T3V0cHV0KG1peChmbG9hdChcIiArIG9mZlZhbHVlICsgXCIpLCBmbG9hdChcIiArIG9uVmFsdWUgKyBcIiksXFxuICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGluZGV4ID09IGNvb3Jkcy55KSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBPbmVIb3RQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIG9uZUhvdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGluZGljZXMgPSBpbnB1dHMuaW5kaWNlcztcbiAgICB2YXIgZGVwdGggPSBhdHRycy5kZXB0aCwgb25WYWx1ZSA9IGF0dHJzLm9uVmFsdWUsIG9mZlZhbHVlID0gYXR0cnMub2ZmVmFsdWU7XG4gICAgdmFyIGluZGljZXNTaXplID0gdGYudXRpbC5zaXplRnJvbVNoYXBlKGluZGljZXMuc2hhcGUpO1xuICAgIHZhciBwcm9ncmFtID0gbmV3IE9uZUhvdFByb2dyYW0oaW5kaWNlc1NpemUsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSk7XG4gICAgdmFyIHJlc2hhcGVkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiBpbmRpY2VzIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBbaW5kaWNlc1NpemVdIH0gfSk7XG4gICAgdmFyIHJlc3VsdCA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFtyZXNoYXBlZF0sIGluZGljZXMuZHR5cGUpO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzaGFwZWQpO1xuICAgIHZhciBvdXRTaGFwZSA9IGluZGljZXMuc2hhcGUuY29uY2F0KFtkZXB0aF0pO1xuICAgIHZhciBvdXQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHJlc3VsdCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogb3V0U2hhcGUgfSB9KTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlc3VsdCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG52YXIgb25lSG90Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLk9uZUhvdCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBvbmVIb3Rcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHplcm9zTGlrZShhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgaWYgKHguZHR5cGUgPT09ICdjb21wbGV4NjQnKSB7XG4gICAgICAgIHZhciByZWFsUGFydCA9IHJlYWwoeyBpbnB1dHM6IHsgaW5wdXQ6IHggfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgdmFyIHIgPSB6ZXJvc0xpa2UoeyBpbnB1dHM6IHsgeDogcmVhbFBhcnQgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgdmFyIGltYWdQYXJ0ID0gaW1hZyh7IGlucHV0czogeyBpbnB1dDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICB2YXIgaSA9IHplcm9zTGlrZSh7IGlucHV0czogeyB4OiBpbWFnUGFydCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGxleCh7IGlucHV0czogeyByZWFsOiByLCBpbWFnOiBpIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVhbFBhcnQpO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHIpO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGltYWdQYXJ0KTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmaWxsKHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHguc2hhcGUsXG4gICAgICAgICAgICAgICAgZHR5cGU6IHguZHR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHguZHR5cGUgPT09ICdzdHJpbmcnID8gJycgOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2VuZDogYmFja2VuZFxuICAgICAgICB9KTtcbiAgICB9XG59XG52YXIgemVyb3NMaWtlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlplcm9zTGlrZSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiB6ZXJvc0xpa2Vcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIG9uZXNMaWtlKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQ7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICBpZiAoeC5kdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmVzTGlrZSBpcyBub3Qgc3VwcG9ydGVkIHVuZGVyIHN0cmluZyBkdHlwZScpO1xuICAgIH1cbiAgICBlbHNlIGlmICh4LmR0eXBlID09PSAnY29tcGxleDY0Jykge1xuICAgICAgICB2YXIgcmVhbFBhcnQgPSByZWFsKHsgaW5wdXRzOiB7IGlucHV0OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIHZhciByID0gb25lc0xpa2UoeyBpbnB1dHM6IHsgeDogcmVhbFBhcnQgfSwgYmFja2VuZDogYmFja2VuZCB9KTtcbiAgICAgICAgdmFyIGltYWdQYXJ0ID0gaW1hZyh7IGlucHV0czogeyBpbnB1dDogeCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICB2YXIgaSA9IHplcm9zTGlrZSh7IGlucHV0czogeyB4OiBpbWFnUGFydCB9LCBiYWNrZW5kOiBiYWNrZW5kIH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGxleCh7IGlucHV0czogeyByZWFsOiByLCBpbWFnOiBpIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVhbFBhcnQpO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHIpO1xuICAgICAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGltYWdQYXJ0KTtcbiAgICAgICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRPRE8oY2Fpcywgc21pbGtvdik6IEFkZCBXZWJHTCBzaGFkZXIgZm9yIG9uZXNMaWtlOlxuICAgICAgICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvaXNzdWVzLzEyOTNcbiAgICAgICAgcmV0dXJuIGZpbGwoeyBhdHRyczogeyBzaGFwZTogeC5zaGFwZSwgZHR5cGU6IHguZHR5cGUsIHZhbHVlOiAxIH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgfVxufVxudmFyIG9uZXNMaWtlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLk9uZXNMaWtlLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IG9uZXNMaWtlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBwYWNrKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgYXhpcyA9IGF0dHJzLmF4aXM7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZERpbXMoeyBpbnB1dHM6IHsgaW5wdXQ6IGlucHV0c1swXSB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBkaW06IGF4aXMgfSB9KTtcbiAgICB9XG4gICAgdmFyIHNoYXBlID0gaW5wdXRzWzBdLnNoYXBlO1xuICAgIHZhciBkdHlwZSA9IGlucHV0c1swXS5kdHlwZTtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB0Zi51dGlsLmFzc2VydFNoYXBlc01hdGNoKHNoYXBlLCB0LnNoYXBlLCAnQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBzaGFwZXMnKTtcbiAgICAgICAgdGYudXRpbC5hc3NlcnQoZHR5cGUgPT09IHQuZHR5cGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIGR0eXBlcyc7IH0pO1xuICAgIH0pO1xuICAgIHZhciBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcyA9IFtdO1xuICAgIHZhciBleHBhbmRlZFRlbnNvcnMgPSBpbnB1dHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBleHBhbmRlZFQgPSBleHBhbmREaW1zKHsgaW5wdXRzOiB7IGlucHV0OiB0IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGRpbTogYXhpcyB9IH0pO1xuICAgICAgICBpbnRlcm1lZGlhdGVUZW5zb3JJbmZvcy5wdXNoKGV4cGFuZGVkVCk7XG4gICAgICAgIHJldHVybiBleHBhbmRlZFQ7XG4gICAgfSk7XG4gICAgdmFyIHJlc3VsdCA9IGNvbmNhdCh7IGlucHV0czogZXhwYW5kZWRUZW5zb3JzLCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBheGlzOiBheGlzIH0gfSk7XG4gICAgaW50ZXJtZWRpYXRlVGVuc29ySW5mb3MuZm9yRWFjaChmdW5jdGlvbiAodCkgeyByZXR1cm4gYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh0KTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBwYWNrQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlBhY2ssXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogcGFja1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFBhZFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFkUHJvZ3JhbSh4U2hhcGUsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gcGFkZGluZ3MubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBwWzBdIC8qIGJlZm9yZVBhZCAqLyArIHhTaGFwZVtpXSArIHBbMV07IH0gLyogYWZ0ZXJQYWQgKi8pO1xuICAgICAgICB2YXIgcmFuayA9IHhTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgICAgIHZhciBzdGFydCA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfSkuam9pbignLCcpO1xuICAgICAgICB2YXIgZW5kID0gcGFkZGluZ3MubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBwWzBdICsgeFNoYXBlW2ldOyB9KS5qb2luKCcsJyk7XG4gICAgICAgIHZhciB1bnBhY2tlZENvb3JkcyA9IFsnY29vcmRzWzBdJywgJ2Nvb3Jkc1sxXScsICdjb29yZHNbMl0nLCAnY29vcmRzWzNdJ10uc2xpY2UoMCwgcmFuayk7XG4gICAgICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICAgIGludCBzdGFydCA9IFwiICsgc3RhcnQgKyBcIjtcXG4gICAgICAgIGludCBlbmQgPSBcIiArIGVuZCArIFwiO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpbnQgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpZiAob3V0QyA8IHN0YXJ0IHx8IG91dEMgPj0gZW5kKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiICsgY29uc3RhbnRWYWx1ZSArIFwiKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGdldFgob3V0QyAtIHN0YXJ0KSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBcIiArIHR5cGUgKyBcIiBzdGFydCA9IFwiICsgdHlwZSArIFwiKFwiICsgc3RhcnQgKyBcIik7XFxuICAgICAgXCIgKyB0eXBlICsgXCIgZW5kID0gXCIgKyB0eXBlICsgXCIoXCIgKyBlbmQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyB0eXBlICsgXCIgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaWYgKGFueShsZXNzVGhhbihvdXRDLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKG91dEMsIGVuZCkpKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIiArIGNvbnN0YW50VmFsdWUgKyBcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIgKyB0eXBlICsgXCIgY29vcmRzID0gb3V0QyAtIHN0YXJ0O1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIiArIHVucGFja2VkQ29vcmRzICsgXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUGFkUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBQYWRQYWNrZWRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhZFBhY2tlZFByb2dyYW0oeFNoYXBlLCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdGhpcy5wYWNrZWRJbnB1dHMgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhY2tlZE91dHB1dCA9IHRydWU7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBwYWRkaW5ncy5tYXAoZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIHBbMF0gLyogYmVmb3JlUGFkICovICsgeFNoYXBlW2ldICsgcFsxXTsgfSAvKiBhZnRlclBhZCAqLyk7XG4gICAgICAgIHZhciByYW5rID0geFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgICAgIHZhciBzdGFydCA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfSkuam9pbignLCcpO1xuICAgICAgICB2YXIgZW5kID0gcGFkZGluZ3MubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBwWzBdICsgeFNoYXBlW2ldOyB9KS5qb2luKCcsJyk7XG4gICAgICAgIHZhciBjb29yZHMgPSBnZXRDaGFubmVscygncmMnLCByYW5rKTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGdldENoYW5uZWxzKCdzb3VyY2UnLCByYW5rKTtcbiAgICAgICAgdmFyIGNMaW1pdCA9IGNvb3Jkc1tyYW5rIC0gMV0gKyBcIiA8IFwiICsgdGhpcy5vdXRwdXRTaGFwZVtyYW5rIC0gMV07XG4gICAgICAgIHZhciBpbm5lckRpbXMgPSByYW5rID09PSAxID8gJ3NvdXJjZScgOiBcInZlYzIoXCIgKyBzb3VyY2Uuc2xpY2UoLTIpLmpvaW4oKSArIFwiKVwiO1xuICAgICAgICB2YXIgY29tcG9uZW50U2V0dXAgPSBbXG4gICAgICAgICAgICBkdHlwZSArIFwiIHJjID0gb3V0cHV0TG9jO1wiLCBjb29yZHNbcmFuayAtIDFdICsgXCIgKz0gMTtcXG4gICAgICAgaWYoXCIgKyBjTGltaXQgKyBcIikge1xcbiAgICAgIFwiLFxuICAgICAgICAgICAgcmFuayA9PT0gMSA/ICcnIDogXCJ9XFxuICAgICAgIHJjID0gb3V0cHV0TG9jO1xcbiAgICAgICBcIiArIGNvb3Jkc1tyYW5rIC0gMl0gKyBcIiArPSAxO1xcbiAgICAgICBpZihcIiArIGNvb3Jkc1tyYW5rIC0gMl0gKyBcIiA8IFwiICsgdGhpcy5vdXRwdXRTaGFwZVtyYW5rIC0gMl0gKyBcIikge1wiLFxuICAgICAgICAgICAgcmFuayA9PT0gMSA/ICcnIDogXCIgIFwiICsgY29vcmRzW3JhbmsgLSAxXSArIFwiICs9IDE7XFxuICAgICAgICAgaWYoXCIgKyBjTGltaXQgKyBcIikge1wiXG4gICAgICAgIF07XG4gICAgICAgIHZhciBwYWRkaW5nQXJlYSA9IHJhbmsgPT09IDEgP1xuICAgICAgICAgICAgJ3JjIDwgc3RhcnQgfHwgcmMgPj0gZW5kJyA6XG4gICAgICAgICAgICAnYW55KGxlc3NUaGFuKHJjLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKHJjLCBlbmQpKSc7XG4gICAgICAgIHZhciBtYWluTG9vcCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJhbmsgPT09IDEgPyAyIDogNDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgbWFpbkxvb3AgKz0gXCJcXG4gICAgICAgIFwiICsgY29tcG9uZW50U2V0dXBbaV0gKyBcIlxcbiAgICAgICAgaWYgKFwiICsgcGFkZGluZ0FyZWEgKyBcIikge1xcbiAgICAgICAgICByZXN1bHRbXCIgKyBpICsgXCJdID0gZmxvYXQoXCIgKyBjb25zdGFudFZhbHVlICsgXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIgKyBkdHlwZSArIFwiIHNvdXJjZSA9IHJjIC0gc3RhcnQ7XFxuICAgICAgICAgIHJlc3VsdFtcIiArIGkgKyBcIl0gPSBnZXRDaGFubmVsKGdldFgoXCIgKyBzb3VyY2Uuam9pbigpICsgXCIpLCBcIiArIGlubmVyRGltcyArIFwiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgICAgICBtYWluTG9vcCArPSAocmFuayA9PT0gMSA/IFwifSBcIiA6IFwifX1cIik7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IFwiICsgZHR5cGUgKyBcIiBzdGFydCA9IFwiICsgZHR5cGUgKyBcIihcIiArIHN0YXJ0ICsgXCIpO1xcbiAgICAgIGNvbnN0IFwiICsgZHR5cGUgKyBcIiBlbmQgPSBcIiArIGR0eXBlICsgXCIoXCIgKyBlbmQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIG91dHB1dExvYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgIFwiICsgbWFpbkxvb3AgKyBcIlxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFBhZFBhY2tlZFByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgcGFkVjIgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIHBhZGRpbmdzID0gYXR0cnMucGFkZGluZ3MsIGNvbnN0YW50VmFsdWUgPSBhdHRycy5jb25zdGFudFZhbHVlO1xuICAgIHZhciBwcm9ncmFtID0gdGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TJykgP1xuICAgICAgICBuZXcgUGFkUGFja2VkUHJvZ3JhbSh4LnNoYXBlLCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkgOlxuICAgICAgICBuZXcgUGFkUHJvZ3JhbSh4LnNoYXBlLCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt4XSwgeC5kdHlwZSk7XG59O1xudmFyIHBhZFYyQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlBhZFYyLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHBhZFYyXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgUE9XID0gXCJcXG4gIGlmKGEgPCAwLjAgJiYgZmxvb3IoYikgPCBiKXtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG4gIGlmIChiID09IDAuMCkge1xcbiAgICByZXR1cm4gMS4wO1xcbiAgfVxcbiAgcmV0dXJuIChyb3VuZChtb2QoYiwgMi4wKSkgIT0gMSkgP1xcbiAgICAgIHBvdyhhYnMoYSksIGIpIDogc2lnbihhKSAqIHBvdyhhYnMoYSksIGIpO1xcblwiO1xudmFyIFBPV19QQUNLRUQgPSBcIlxcbiAgLy8gaXNNb2RSb3VuZDEgaGFzIDEgZm9yIGNvbXBvbmVudHMgd2l0aCByb3VuZChtb2QoYiwgMi4wKSkgPT0gMSwgMCBvdGhlcndpc2UuXFxuICB2ZWM0IGlzTW9kUm91bmQxID0gdmVjNChlcXVhbChyb3VuZChtb2QoYiwgMi4wKSksIGl2ZWM0KDEpKSk7XFxuICB2ZWM0IG11bHRpcGxpZXIgPSBzaWduKGEpICogaXNNb2RSb3VuZDEgKyAodmVjNCgxLjApIC0gaXNNb2RSb3VuZDEpO1xcbiAgdmVjNCByZXN1bHQgPSBtdWx0aXBsaWVyICogcG93KGFicyhhKSwgYik7XFxuXFxuICAvLyBFbnN1cmUgdGhhdCBhXjAgPSAxLCBpbmNsdWRpbmcgMF4wID0gMSBhcyB0aGlzIGNvcnJlc3BvbmQgdG8gVEYgYW5kIEpTXFxuICBidmVjNCBpc0V4cFplcm8gPSBlcXVhbChiLCB2ZWM0KDAuMCkpO1xcbiAgcmVzdWx0LnIgPSBpc0V4cFplcm8uciA/IDEuMCA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc0V4cFplcm8uZyA/IDEuMCA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc0V4cFplcm8uYiA/IDEuMCA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc0V4cFplcm8uYSA/IDEuMCA6IHJlc3VsdC5hO1xcblxcbiAgdmVjNCBpc05hTiA9IHZlYzQobGVzc1RoYW4oYSwgdmVjNCgwLjApKSkgKiB2ZWM0KGxlc3NUaGFuKGZsb29yKGIpLCBiKSk7XFxuICBcIiArXG4gICAgQ0hFQ0tfTkFOX1NOSVBQRVQkMiArIFwiXFxuICByZXR1cm4gcmVzdWx0O1xcblwiO1xudmFyIHBvdyA9IGJpbmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IFBPVywgcGFja2VkT3BTbmlwcGV0OiBQT1dfUEFDS0VEIH0pO1xudmFyIHBvd0NvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5Qb3csXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogcG93XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBwcm9kKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBheGlzID0gYXR0cnMuYXhpcywga2VlcERpbXMgPSBhdHRycy5rZWVwRGltcztcbiAgICB2YXIgeFJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcbiAgICB2YXIgdG9EaXNwb3NlID0gW107XG4gICAgdmFyIG9yaWdBeGVzID0gdGYudXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICB2YXIgYXhlcyA9IG9yaWdBeGVzO1xuICAgIHZhciBwZXJtdXRlZEF4ZXMgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHhSYW5rKTtcbiAgICB2YXIgcGVybXV0ZWRYID0geDtcbiAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgcGVybXV0ZWRYID0gdHJhbnNwb3NlKHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgcGVybTogcGVybXV0ZWRBeGVzIH0gfSk7XG4gICAgICAgIGF4ZXMgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeFJhbmspO1xuICAgICAgICB0b0Rpc3Bvc2UucHVzaChwZXJtdXRlZFgpO1xuICAgIH1cbiAgICB0Zi5iYWNrZW5kX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ3Byb2QnLCBheGVzLCB4UmFuayk7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoYmFja2VuZC5zaG91bGRFeGVjdXRlT25DUFUoW3Blcm11dGVkWF0pKSB7XG4gICAgICAgIHZhciB4VmFscyA9IGJhY2tlbmQudGV4RGF0YS5nZXQocGVybXV0ZWRYLmRhdGFJZCkudmFsdWVzO1xuICAgICAgICB2YXIgX2EgPSBwcm9kSW1wbENQVShwZXJtdXRlZFguc2hhcGUsIHBlcm11dGVkWC5kdHlwZSwgeFZhbHMsIGF4ZXMpLCBvdXRWYWxzID0gX2Eub3V0VmFscywgb3V0U2hhcGUgPSBfYS5vdXRTaGFwZSwgb3V0RHR5cGUgPSBfYS5vdXREdHlwZTtcbiAgICAgICAgcmVzID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRTaGFwZSwgb3V0RHR5cGUsIG91dFZhbHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9iID0gdGYuYmFja2VuZF91dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMocGVybXV0ZWRYLnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYlswXSwgcmVkdWNlU2hhcGUgPSBfYlsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHRmLnV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHBlcm11dGVkWCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogWy0xLCBpblNpemVdIH0gfSk7XG4gICAgICAgIHZhciBvdXRwdXREVHlwZSA9IHRmLnN1bU91dFR5cGUoeC5kdHlwZSk7XG4gICAgICAgIHZhciByZWR1Y2VkID0gcmVkdWNlKGEyRCwgb3V0cHV0RFR5cGUsICdwcm9kJywgYmFja2VuZCk7XG4gICAgICAgIHJlcyA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogcmVkdWNlZCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogb3V0U2hhcGUgfSB9KTtcbiAgICAgICAgdG9EaXNwb3NlLnB1c2goYTJEKTtcbiAgICAgICAgdG9EaXNwb3NlLnB1c2gocmVkdWNlZCk7XG4gICAgfVxuICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICB0b0Rpc3Bvc2UucHVzaChyZXMpO1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSB0Zi5iYWNrZW5kX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ocmVzLnNoYXBlLCBvcmlnQXhlcyk7XG4gICAgICAgIHJlcyA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogcmVzIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBuZXdTaGFwZSB9IH0pO1xuICAgIH1cbiAgICB0b0Rpc3Bvc2UuZm9yRWFjaChmdW5jdGlvbiAodCkgeyByZXR1cm4gYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh0KTsgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbnZhciBwcm9kQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlByb2QsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogcHJvZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIHJhbmdlID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBzdGFydCA9IGF0dHJzLnN0YXJ0LCBzdG9wID0gYXR0cnMuc3RvcCwgc3RlcCA9IGF0dHJzLnN0ZXAsIGR0eXBlID0gYXR0cnMuZHR5cGU7XG4gICAgdmFyIHZhbHVlcyA9IHJhbmdlSW1wbENQVShzdGFydCwgc3RvcCwgc3RlcCwgZHR5cGUpO1xuICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFt2YWx1ZXMubGVuZ3RoXSwgZHR5cGUsIHZhbHVlcyk7XG59O1xudmFyIHJhbmdlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlJhbmdlLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHJhbmdlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgUkVDSVBST0NBTCA9IFwicmV0dXJuIDEuMCAvIHg7XCI7XG52YXIgcmVjaXByb2NhbCA9IHVuYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogUkVDSVBST0NBTCB9KTtcbnZhciByZWNpcHJvY2FsQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlJlY2lwcm9jYWwsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogcmVjaXByb2NhbCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBSRUxVJDIgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gKHggPCAwLjApID8gMC4wIDogeDtcXG5cIjtcbnZhciBSRUxVX1BBQ0tFRCA9IFwiXFxuICB2ZWM0IHJlc3VsdCA9IHggKiB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoeCwgdmVjNCgwLjApKSk7XFxuICBidmVjNCBpc05hTiA9IGlzbmFuKHgpO1xcblxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID8geC5yIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPyB4LmcgOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IHguYiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID8geC5hIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiO1xudmFyIHJlbHUgPSB1bmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IFJFTFUkMiwgcGFja2VkT3BTbmlwcGV0OiBSRUxVX1BBQ0tFRCB9KTtcbnZhciByZWx1Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlJlbHUsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogcmVsdVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFJFTFU2JDIgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gKHggPCAwLjApID8gMC4wIDogbWluKDYuMCwgeCk7XFxuXCI7XG52YXIgUkVMVTZfUEFDS0VEID0gXCJcXG4gIHZlYzQgcmVzdWx0ID0gbWluKHgsIHZlYzQoNi4pKSAqIHZlYzQoZ3JlYXRlclRoYW5FcXVhbCh4LCB2ZWM0KDAuMCkpKTtcXG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XFxuXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID8geC5iIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCI7XG52YXIgcmVsdTYgPSB1bmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IFJFTFU2JDIsIHBhY2tlZE9wU25pcHBldDogUkVMVTZfUEFDS0VEIH0pO1xudmFyIHJlbHU2Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlJlbHU2LFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHJlbHU2XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgUmVzaXplQmlsaW5lYXJQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZUJpbGluZWFyUHJvZ3JhbShpbnB1dFNoYXBlLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBhbGlnbkNvcm5lcnMsIGhhbGZQaXhlbENlbnRlcnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdmFyIGJhdGNoID0gaW5wdXRTaGFwZVswXSwgb2xkSGVpZ2h0ID0gaW5wdXRTaGFwZVsxXSwgb2xkV2lkdGggPSBpbnB1dFNoYXBlWzJdLCBkZXB0aCA9IGlucHV0U2hhcGVbM107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2gsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGRlcHRoXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUluU2l6ZSA9IFtcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgbmV3SGVpZ2h0ID4gMSkgPyBvbGRIZWlnaHQgLSAxIDogb2xkSGVpZ2h0LFxuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdXaWR0aCA+IDEpID8gb2xkV2lkdGggLSAxIDogb2xkV2lkdGhcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZU91dFNpemUgPSBbXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld0hlaWdodCA+IDEpID8gbmV3SGVpZ2h0IC0gMSA6IG5ld0hlaWdodCxcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgbmV3V2lkdGggPiAxKSA/IG5ld1dpZHRoIC0gMSA6IG5ld1dpZHRoXG4gICAgICAgIF07XG4gICAgICAgIHZhciBzb3VyY2VGcmFjSW5kZXhSQztcbiAgICAgICAgaWYgKGhhbGZQaXhlbENlbnRlcnMpIHtcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleFJDID1cbiAgICAgICAgICAgICAgICBcIih2ZWMyKHlSQykgKyB2ZWMyKDAuNSkpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQ1wiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgLSB2ZWMyKDAuNSlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleFJDID0gXCJ2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgdmVjMiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMihcXG4gICAgICAgICAgXCIgKyBlZmZlY3RpdmVJblNpemVbMF0gLyBlZmZlY3RpdmVPdXRTaXplWzBdICsgXCIsXFxuICAgICAgICAgIFwiICsgZWZmZWN0aXZlSW5TaXplWzFdIC8gZWZmZWN0aXZlT3V0U2l6ZVsxXSArIFwiKTtcXG4gICAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVSQyA9IHZlYzIoXCIgKyBvbGRIZWlnaHQgKyBcIi4wLCBcIiArIG9sZFdpZHRoICsgXCIuMCk7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnl6O1xcblxcbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleFJDID0gXCIgKyBzb3VyY2VGcmFjSW5kZXhSQyArIFwiO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICBpdmVjMiBzb3VyY2VGbG9vclJDID0gaXZlYzIobWF4KHNvdXJjZUZyYWNJbmRleFJDLCB2ZWMyKDAuMCkpKTtcXG4gICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxSQyA9IGl2ZWMyKFxcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWNJbmRleFJDKSkpO1xcblxcbiAgICAgICAgZmxvYXQgdG9wTGVmdCA9IGdldEEoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEEoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCB0b3BSaWdodCA9IGdldEEoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCBib3R0b21SaWdodCA9IGdldEEoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG5cXG4gICAgICAgIHZlYzIgZnJhY1JDID0gc291cmNlRnJhY0luZGV4UkMgLSB2ZWMyKHNvdXJjZUZsb29yUkMpO1xcblxcbiAgICAgICAgZmxvYXQgdG9wID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gdG9wICsgKGJvdHRvbSAtIHRvcCkgKiBmcmFjUkMueDtcXG5cXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZUJpbGluZWFyUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBSZXNpemVCaWxpbmVhclBhY2tlZFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplQmlsaW5lYXJQYWNrZWRQcm9ncmFtKGlucHV0U2hhcGUsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGFsaWduQ29ybmVycywgaGFsZlBpeGVsQ2VudGVycykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5wYWNrZWRJbnB1dHMgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhY2tlZE91dHB1dCA9IHRydWU7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdmFyIGJhdGNoID0gaW5wdXRTaGFwZVswXSwgb2xkSGVpZ2h0ID0gaW5wdXRTaGFwZVsxXSwgb2xkV2lkdGggPSBpbnB1dFNoYXBlWzJdLCBkZXB0aCA9IGlucHV0U2hhcGVbM107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2gsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGRlcHRoXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUluU2l6ZSA9IFtcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgbmV3SGVpZ2h0ID4gMSkgPyBvbGRIZWlnaHQgLSAxIDogb2xkSGVpZ2h0LFxuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdXaWR0aCA+IDEpID8gb2xkV2lkdGggLSAxIDogb2xkV2lkdGhcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZU91dFNpemUgPSBbXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld0hlaWdodCA+IDEpID8gbmV3SGVpZ2h0IC0gMSA6IG5ld0hlaWdodCxcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgbmV3V2lkdGggPiAxKSA/IG5ld1dpZHRoIC0gMSA6IG5ld1dpZHRoXG4gICAgICAgIF07XG4gICAgICAgIHZhciBzb3VyY2VGcmFjSW5kZXhSQztcbiAgICAgICAgaWYgKGhhbGZQaXhlbENlbnRlcnMpIHtcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleFJDID0gXCIodmVjMyh5UkMpICsgdmVjMygwLjUpKSAqIFwiICtcbiAgICAgICAgICAgICAgICBcImVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgLSB2ZWMzKDAuNSlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleFJDID0gXCJ2ZWMzKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgdmVjMyBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMyhcXG4gICAgICAgICAgXCIgKyBlZmZlY3RpdmVJblNpemVbMF0gLyBlZmZlY3RpdmVPdXRTaXplWzBdICsgXCIsXFxuICAgICAgICAgIFwiICsgZWZmZWN0aXZlSW5TaXplWzFdIC8gZWZmZWN0aXZlT3V0U2l6ZVsxXSArIFwiLFxcbiAgICAgICAgICBcIiArIGVmZmVjdGl2ZUluU2l6ZVsxXSAvIGVmZmVjdGl2ZU91dFNpemVbMV0gKyBcIik7XFxuICAgICAgY29uc3QgdmVjMyBpbnB1dFNoYXBlUkMgPSB2ZWMzKFwiICsgb2xkSGVpZ2h0ICsgXCIuMCwgXCIgKyBvbGRXaWR0aCArIFwiLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgb2xkV2lkdGggKyBcIi4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRBVmFsdWUoaW50IGIsIGludCByLCBpbnQgYywgaW50IGQpIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEEoYiwgciwgYywgZCksIHZlYzIoYywgZCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICAvLyBDYWxjdWxhdGUgdmFsdWVzIGZvciBuZXh0IGNvbHVtbiBpbiB5UkMuei5cXG4gICAgICAgIGl2ZWMzIHlSQyA9IGNvb3Jkcy55enogKyBpdmVjMygwLCAwLCAxKTtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMyBzb3VyY2VGcmFjSW5kZXhSQyA9IFwiICsgc291cmNlRnJhY0luZGV4UkMgKyBcIjtcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGZvdXIgaW50ZWdlciBpbmRpY2VzLlxcbiAgICAgICAgaXZlYzMgc291cmNlRmxvb3JSQyA9IGl2ZWMzKG1heChzb3VyY2VGcmFjSW5kZXhSQywgdmVjMygwLjApKSk7XFxuICAgICAgICBpdmVjMyBzb3VyY2VDZWlsUkMgPSBpdmVjMyhcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG5cXG4gICAgICAgIC8vIFNob3VsZCB3ZSBjYWxjdWxhdGUgbmV4dCBjb2x1bW4gYW5kIHJvdyBlbGVtZW50cyBpbiAyeDIgcGFja2VkIGNlbGwuXFxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBkIDwgXCIgKyAoZGVwdGggLSAxKSArIFwiO1xcbiAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gY29vcmRzLnogPCBcIiArIChuZXdXaWR0aCAtIDEpICsgXCI7XFxuXFxuICAgICAgICAvLyBJbiBwYXJhbGxlbCwgY29uc3RydWN0IGZvdXIgY29ybmVycyBmb3IgYWxsIGZvdXIgY29tcG9uZW50cyBpblxcbiAgICAgICAgLy8gcGFja2VkIDJ4MiBjZWxsLlxcbiAgICAgICAgdmVjNCB0b3BMZWZ0ID0gdmVjNChcXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnosIGQpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnosIGQgKyAxKSA6IDAuMCk7XFxuXFxuICAgICAgICB2ZWM0IGJvdHRvbUxlZnQgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueiwgZClcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjNCB0b3BSaWdodCA9IHZlYzQoXFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkICsgMSlcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy56LCBkKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnosIGQgKyAxKSA6IDAuMCk7XFxuXFxuICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkICsgMSlcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnosIGQpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjMyBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzMoc291cmNlRmxvb3JSQyk7XFxuXFxuICAgICAgICB2ZWM0IHRvcCA9IG1peCh0b3BMZWZ0LCB0b3BSaWdodCwgZnJhY1JDLnl5enopO1xcbiAgICAgICAgdmVjNCBib3R0b20gPSBtaXgoYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIGZyYWNSQy55eXp6KTtcXG4gICAgICAgIHZlYzQgbmV3VmFsdWUgPSBtaXgodG9wLCBib3R0b20sIGZyYWNSQy54KTtcXG5cXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZUJpbGluZWFyUGFja2VkUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHJlc2l6ZUJpbGluZWFyKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgaW1hZ2VzID0gaW5wdXRzLmltYWdlcztcbiAgICB2YXIgYWxpZ25Db3JuZXJzID0gYXR0cnMuYWxpZ25Db3JuZXJzLCBoYWxmUGl4ZWxDZW50ZXJzID0gYXR0cnMuaGFsZlBpeGVsQ2VudGVycywgc2l6ZSA9IGF0dHJzLnNpemU7XG4gICAgdmFyIG5ld0hlaWdodCA9IHNpemVbMF0sIG5ld1dpZHRoID0gc2l6ZVsxXTtcbiAgICB2YXIgcHJvZ3JhbSA9IHRmLmVudigpLmdldEJvb2woJ1dFQkdMX1BBQ0tfSU1BR0VfT1BFUkFUSU9OUycpID9cbiAgICAgICAgbmV3IFJlc2l6ZUJpbGluZWFyUGFja2VkUHJvZ3JhbShpbWFnZXMuc2hhcGUsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGFsaWduQ29ybmVycywgaGFsZlBpeGVsQ2VudGVycykgOlxuICAgICAgICBuZXcgUmVzaXplQmlsaW5lYXJQcm9ncmFtKGltYWdlcy5zaGFwZSwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzLCBoYWxmUGl4ZWxDZW50ZXJzKTtcbiAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2ltYWdlc10sICdmbG9hdDMyJyk7XG59XG52YXIgcmVzaXplQmlsaW5lYXJDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuUmVzaXplQmlsaW5lYXIsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogcmVzaXplQmlsaW5lYXJcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBSZXNpemVCaWxpbmVhckJhY2twcm9wUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVCaWxpbmVhckJhY2twcm9wUHJvZ3JhbShkeVNoYXBlLCBpbnB1dFNoYXBlLCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydkeSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xuICAgICAgICB2YXIgeEhlaWdodCA9IGlucHV0U2hhcGVbMV0sIHhXaWR0aCA9IGlucHV0U2hhcGVbMl07XG4gICAgICAgIHZhciB5SGVpZ2h0ID0gZHlTaGFwZVsxXSwgeVdpZHRoID0gZHlTaGFwZVsyXTtcbiAgICAgICAgLy8gSW4gdGhlIGJhY2t3YXJkcyBwYXNzLCB3ZSB3YW50IHRvIGZpbmQgdGhlIHBpeGVscyB0aGF0IHdlcmUgZ2VuZXJhdGVkIGZvclxuICAgICAgICAvLyBlYWNoIHBpeGVsIGluIHRoZSBpbnB1dCBpbWFnZSB0aGUgZm9yd2FyZCBwYXNzIGFuZCBhZGQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgLy8gY29lZmZpY2llbnQgZnJvbSBkeSB0byB0aGUgZ3JhZGllbnQgKHdpdGggc29tZSBpbnRlcnBvbGF0aW9uKS5cbiAgICAgICAgdmFyIGVmZmVjdGl2ZVhTaXplID0gW1xuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiB5SGVpZ2h0ID4gMSkgPyB4SGVpZ2h0IC0gMSA6IHhIZWlnaHQsXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlXaWR0aCA+IDEpID8geFdpZHRoIC0gMSA6IHhXaWR0aFxuICAgICAgICBdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlWVNpemUgPSBbXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlIZWlnaHQgPiAxKSA/IHlIZWlnaHQgLSAxIDogeUhlaWdodCxcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgeVdpZHRoID4gMSkgPyB5V2lkdGggLSAxIDogeVdpZHRoXG4gICAgICAgIF07XG4gICAgICAgIHZhciBoZWlnaHRTY2FsZSA9IGVmZmVjdGl2ZVhTaXplWzBdIC8gZWZmZWN0aXZlWVNpemVbMF07XG4gICAgICAgIHZhciB3aWR0aFNjYWxlID0gZWZmZWN0aXZlWFNpemVbMV0gLyBlZmZlY3RpdmVZU2l6ZVsxXTtcbiAgICAgICAgdmFyIGludkhlaWdodFNjYWxlID0gMSAvIGhlaWdodFNjYWxlO1xuICAgICAgICB2YXIgaW52V2lkdGhTY2FsZSA9IDEgLyB3aWR0aFNjYWxlO1xuICAgICAgICAvLyBUaGlzIGRlZmluZXMgdGhlIHNpemUgb2YgdGhlIHdpbmRvdyBvZiB2YWx1ZXMgYXJvdW5kIGEgcGFydGljdWxhclxuICAgICAgICAvLyBpbmRleCBpbiBkeSB0aGF0IHdlIHdhbnQgdG8gc2VhcmNoIGZvciBjb250cmlidXRpb25zIHRvIGR4LlxuICAgICAgICB2YXIgd2luSGVpZ2h0ID0gKE1hdGguY2VpbChpbnZIZWlnaHRTY2FsZSkgKiAyKSArIDI7XG4gICAgICAgIHZhciB3aW5XaWR0aCA9IChNYXRoLmNlaWwoaW52V2lkdGhTY2FsZSkgKiAyKSArIDI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGhlaWdodFNjYWxlID0gZmxvYXQoXCIgKyBoZWlnaHRTY2FsZSArIFwiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IHdpZHRoU2NhbGUgPSBmbG9hdChcIiArIHdpZHRoU2NhbGUgKyBcIik7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZIZWlnaHRTY2FsZSA9IGZsb2F0KFwiICsgaW52SGVpZ2h0U2NhbGUgKyBcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZXaWR0aFNjYWxlID0gZmxvYXQoXCIgKyBpbnZXaWR0aFNjYWxlICsgXCIpO1xcblxcbiAgICAgICAgY29uc3QgaW50IHdpbkhlaWdodCA9IGludChcIiArIHdpbkhlaWdodCArIFwiKTtcXG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludChcIiArIHdpbldpZHRoICsgXCIpO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSBib3VuZHMgZm9yIHdoZXJlIGluIGR5IHdlIHdpbGwgbG9va1xcbiAgICAgICAgZmxvYXQgc3RhcnRSTGVycCA9IGZsb29yKGZsb2F0KHIpICogaW52SGVpZ2h0U2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlSID0gaW50KHN0YXJ0UkxlcnAgLSBmbG9hdCh3aW5IZWlnaHQgLyAyKSk7XFxuXFxuICAgICAgICBmbG9hdCBzdGFydENMZXJwID0gZmxvb3IoZmxvYXQoYykgKiBpbnZXaWR0aFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5QyA9IGludChzdGFydENMZXJwIC0gZmxvYXQod2luV2lkdGggLyAyKSk7XFxuXFxuICAgICAgICAvLyBMb29wIG92ZXIgZHlcXG4gICAgICAgIGZvciAoaW50IGR5Uk9mZnNldCA9IDA7IGR5Uk9mZnNldCA8IHdpbkhlaWdodDsgZHlST2Zmc2V0KyspIHtcXG4gICAgICAgICAgaW50IGR5UiA9IGR5Uk9mZnNldCArIHN0YXJ0RHlSO1xcblxcbiAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IFwiICsgeUhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgZHlDT2Zmc2V0ID0gMDsgZHlDT2Zmc2V0IDwgd2luV2lkdGg7IGR5Q09mZnNldCsrKSB7XFxuICAgICAgICAgICAgaW50IGR5QyA9IGR5Q09mZnNldCArIHN0YXJ0RHlDO1xcblxcbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBcIiArIHlXaWR0aCArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHhSID0gZmxvYXQoZHlSKSAqIGhlaWdodFNjYWxlO1xcbiAgICAgICAgICAgIGludCB0b3BEeFJJbmRleCA9IGludChmbG9vcihkeFIpKTtcXG4gICAgICAgICAgICBpbnQgYm90dG9tRHhSSW5kZXggPSBpbnQobWluKGNlaWwoZHhSKSwgXCIgKyAoeEhlaWdodCAtIDEpICsgXCIuMCkpO1xcbiAgICAgICAgICAgIGZsb2F0IGR4UkxlcnAgPSBkeFIgLSBmbG9hdCh0b3BEeFJJbmRleCk7XFxuICAgICAgICAgICAgZmxvYXQgaW52ZXJzZUR4UkxlcnAgPSAxLjAgLSBkeFJMZXJwO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR4QyA9IGZsb2F0KGR5QykgKiB3aWR0aFNjYWxlO1xcbiAgICAgICAgICAgIGludCBsZWZ0RHhDSW5kZXggPSBpbnQoZmxvb3IoZHhDKSk7XFxuICAgICAgICAgICAgaW50IHJpZ2h0RHhDSW5kZXggPSBpbnQobWluKGNlaWwoZHhDKSwgXCIgKyAoeFdpZHRoIC0gMSkgKyBcIi4wKSk7XFxuICAgICAgICAgICAgZmxvYXQgZHhDTGVycCA9IGR4QyAtIGZsb2F0KGxlZnREeENJbmRleCk7XFxuICAgICAgICAgICAgZmxvYXQgaW52ZXJzZUR4Q0xlcnAgPSAxLjAgLSBkeENMZXJwO1xcblxcbiAgICAgICAgICAgIGlmIChyID09IHRvcER4UkluZGV4ICYmIGMgPT0gbGVmdER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyB0b3BMZWZ0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPVxcbiAgICAgICAgICAgICAgICBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBpbnZlcnNlRHhSTGVycCAqIGludmVyc2VEeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSB0b3BEeFJJbmRleCAmJiBjID09IHJpZ2h0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIHRvcFJpZ2h0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBpbnZlcnNlRHhSTGVycCAqIGR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IGJvdHRvbUR4UkluZGV4ICYmIGMgPT0gbGVmdER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyBib3R0b21MZWZ0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBkeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IGJvdHRvbUR4UkluZGV4ICYmIGMgPT0gcmlnaHREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gYm90dG9tUmlnaHRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGR4UkxlcnAgKiBkeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRW5kIGxvb3Agb3ZlciBkeVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGFjY3VtdWxhdG9yKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUmVzaXplQmlsaW5lYXJCYWNrcHJvcFByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiByZXNpemVCaWxpbmVhckdyYWQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBpbWFnZXMgPSBpbnB1dHMuaW1hZ2VzLCBkeSA9IGlucHV0cy5keTtcbiAgICB2YXIgYWxpZ25Db3JuZXJzID0gYXR0cnMuYWxpZ25Db3JuZXJzO1xuICAgIHZhciBwcm9ncmFtID0gbmV3IFJlc2l6ZUJpbGluZWFyQmFja3Byb3BQcm9ncmFtKGR5LnNoYXBlLCBpbWFnZXMuc2hhcGUsIGFsaWduQ29ybmVycyk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFtkeV0sIGR5LmR0eXBlKTtcbn1cbnZhciByZXNpemVCaWxpbmVhckdyYWRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuUmVzaXplQmlsaW5lYXJHcmFkLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHJlc2l6ZUJpbGluZWFyR3JhZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFJlc2l6ZU5lYXJlc3ROZWlnaGJvclByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplTmVhcmVzdE5laWdoYm9yUHJvZ3JhbShpbnB1dFNoYXBlLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBhbGlnbkNvcm5lcnMsIGhhbGZQaXhlbENlbnRlcnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdmFyIGJhdGNoID0gaW5wdXRTaGFwZVswXSwgb2xkSGVpZ2h0ID0gaW5wdXRTaGFwZVsxXSwgb2xkV2lkdGggPSBpbnB1dFNoYXBlWzJdLCBkZXB0aCA9IGlucHV0U2hhcGVbM107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2gsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGRlcHRoXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUluU2l6ZSA9IFtcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgbmV3SGVpZ2h0ID4gMSkgPyBvbGRIZWlnaHQgLSAxIDogb2xkSGVpZ2h0LFxuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdXaWR0aCA+IDEpID8gb2xkV2lkdGggLSAxIDogb2xkV2lkdGhcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZU91dFNpemUgPSBbXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld0hlaWdodCA+IDEpID8gbmV3SGVpZ2h0IC0gMSA6IG5ld0hlaWdodCxcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgbmV3V2lkdGggPiAxKSA/IG5ld1dpZHRoIC0gMSA6IG5ld1dpZHRoXG4gICAgICAgIF07XG4gICAgICAgIC8vIFdoZW4gYWxpZ24gY29ybmVycyBpcyBmYWxzZSwgd2Ugcm91bmRzIHRoZSB2YWx1ZSB3aXRoIGZsb29yLlxuICAgICAgICB2YXIgcm91bmRCYXNlID0gYWxpZ25Db3JuZXJzID8gJzAuNScgOiAnMC4wJztcbiAgICAgICAgdmFyIHNvdXJjZUZyYWNJbmRleFJDO1xuICAgICAgICBpZiAoaGFsZlBpeGVsQ2VudGVycykge1xuICAgICAgICAgICAgc291cmNlRnJhY0luZGV4UkMgPVxuICAgICAgICAgICAgICAgIFwibWF4KCh2ZWMyKHlSQykgKyB2ZWMyKDAuNSkpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQ1wiICtcbiAgICAgICAgICAgICAgICAgICAgXCIsIHZlYzIoMC4wKSlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleFJDID0gXCJ2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgdmVjMiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMihcXG4gICAgICAgICAgXCIgKyBlZmZlY3RpdmVJblNpemVbMF0gLyBlZmZlY3RpdmVPdXRTaXplWzBdICsgXCIsXFxuICAgICAgICAgIFwiICsgZWZmZWN0aXZlSW5TaXplWzFdIC8gZWZmZWN0aXZlT3V0U2l6ZVsxXSArIFwiKTtcXG4gICAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVSQyA9IHZlYzIoXCIgKyBvbGRIZWlnaHQgKyBcIi4wLCBcIiArIG9sZFdpZHRoICsgXCIuMCk7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnl6O1xcblxcbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleFJDID0gXCIgKyBzb3VyY2VGcmFjSW5kZXhSQyArIFwiO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29vcmRpbmF0b3JzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcG9pbnQuXFxuICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0UkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgZmxvb3Ioc291cmNlRnJhY0luZGV4UkMgKyBcIiArIHJvdW5kQmFzZSArIFwiKSkpO1xcbiAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSBnZXRBKGIsIHNvdXJjZU5lYXJlc3RSQy54LCBzb3VyY2VOZWFyZXN0UkMueSwgZCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVOZWFyZXN0TmVpZ2hib3JQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gcmVzaXplTmVhcmVzdE5laWdoYm9yKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgaW1hZ2VzID0gaW5wdXRzLmltYWdlcztcbiAgICB2YXIgYWxpZ25Db3JuZXJzID0gYXR0cnMuYWxpZ25Db3JuZXJzLCBoYWxmUGl4ZWxDZW50ZXJzID0gYXR0cnMuaGFsZlBpeGVsQ2VudGVycywgc2l6ZSA9IGF0dHJzLnNpemU7XG4gICAgdmFyIG5ld0hlaWdodCA9IHNpemVbMF0sIG5ld1dpZHRoID0gc2l6ZVsxXTtcbiAgICB2YXIgcHJvZ3JhbSA9IG5ldyBSZXNpemVOZWFyZXN0TmVpZ2hib3JQcm9ncmFtKGltYWdlcy5zaGFwZSwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzLCBoYWxmUGl4ZWxDZW50ZXJzKTtcbiAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2ltYWdlc10sIGltYWdlcy5kdHlwZSk7XG59XG52YXIgcmVzaXplTmVhcmVzdE5laWdoYm9yQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlJlc2l6ZU5lYXJlc3ROZWlnaGJvcixcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiByZXNpemVOZWFyZXN0TmVpZ2hib3Jcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBSZXNpemVOZWFyZXN0TmVpZ2JvckJhY2twcm9wUHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVOZWFyZXN0TmVpZ2JvckJhY2twcm9wUHJvZ3JhbShkeVNoYXBlLCBpbnB1dFNoYXBlLCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydkeSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xuICAgICAgICB2YXIgeEhlaWdodCA9IGlucHV0U2hhcGVbMV0sIHhXaWR0aCA9IGlucHV0U2hhcGVbMl07XG4gICAgICAgIHZhciB5SGVpZ2h0ID0gZHlTaGFwZVsxXSwgeVdpZHRoID0gZHlTaGFwZVsyXTtcbiAgICAgICAgLy8gSW4gdGhlIGJhY2t3YXJkcyBwYXNzLCB3ZSB3YW50IHRvIGZpbmQgdGhlIHBpeGVscyB0aGF0IHdlcmUgZ2VuZXJhdGVkIGZvclxuICAgICAgICAvLyBlYWNoIHBpeGVsIGluIHRoZSBpbnB1dCBpbWFnZSB0aGUgZm9yd2FyZCBwYXNzIGFuZCBhZGQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgLy8gY29lZmZpY2llbnQgZnJvbSBkeSB0byB0aGUgZ3JhZGllbnQgKHdpdGggc29tZSBpbnRlcnBvbGF0aW9uKS5cbiAgICAgICAgdmFyIGVmZmVjdGl2ZVhTaXplID0gW1xuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiB5SGVpZ2h0ID4gMSkgPyB4SGVpZ2h0IC0gMSA6IHhIZWlnaHQsXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlXaWR0aCA+IDEpID8geFdpZHRoIC0gMSA6IHhXaWR0aFxuICAgICAgICBdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlWVNpemUgPSBbXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlIZWlnaHQgPiAxKSA/IHlIZWlnaHQgLSAxIDogeUhlaWdodCxcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgeVdpZHRoID4gMSkgPyB5V2lkdGggLSAxIDogeVdpZHRoXG4gICAgICAgIF07XG4gICAgICAgIHZhciBoZWlnaHRTY2FsZSA9IGVmZmVjdGl2ZVhTaXplWzBdIC8gZWZmZWN0aXZlWVNpemVbMF07XG4gICAgICAgIHZhciB3aWR0aFNjYWxlID0gZWZmZWN0aXZlWFNpemVbMV0gLyBlZmZlY3RpdmVZU2l6ZVsxXTtcbiAgICAgICAgdmFyIGludkhlaWdodFNjYWxlID0gMSAvIGhlaWdodFNjYWxlO1xuICAgICAgICB2YXIgaW52V2lkdGhTY2FsZSA9IDEgLyB3aWR0aFNjYWxlO1xuICAgICAgICAvLyBUaGlzIGRlZmluZXMgdGhlIHNpemUgb2YgdGhlIHdpbmRvdyBvZiB2YWx1ZXMgYXJvdW5kIGEgcGFydGljdWxhclxuICAgICAgICAvLyBpbmRleCBpbiBkeSB0aGF0IHdlIHdhbnQgdG8gc2VhcmNoIGZvciBjb250cmlidXRpb25zIHRvIGR4LlxuICAgICAgICB2YXIgd2luSGVpZ2h0ID0gKE1hdGguY2VpbChpbnZIZWlnaHRTY2FsZSkgKiAyKSArIDI7XG4gICAgICAgIHZhciB3aW5XaWR0aCA9IChNYXRoLmNlaWwoaW52V2lkdGhTY2FsZSkgKiAyKSArIDI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGhlaWdodFNjYWxlID0gZmxvYXQoXCIgKyBoZWlnaHRTY2FsZSArIFwiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IHdpZHRoU2NhbGUgPSBmbG9hdChcIiArIHdpZHRoU2NhbGUgKyBcIik7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZIZWlnaHRTY2FsZSA9IGZsb2F0KFwiICsgaW52SGVpZ2h0U2NhbGUgKyBcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZXaWR0aFNjYWxlID0gZmxvYXQoXCIgKyBpbnZXaWR0aFNjYWxlICsgXCIpO1xcblxcbiAgICAgICAgY29uc3QgaW50IHdpbkhlaWdodCA9IGludChcIiArIHdpbkhlaWdodCArIFwiKTtcXG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludChcIiArIHdpbldpZHRoICsgXCIpO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSBib3VuZHMgZm9yIHdoZXJlIGluIGR5IHdlIHdpbGwgbG9va1xcbiAgICAgICAgZmxvYXQgc3RhcnRSTGVycCA9IGZsb29yKGZsb2F0KHIpICogaW52SGVpZ2h0U2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlSID0gaW50KGZsb29yKHN0YXJ0UkxlcnAgLSBmbG9hdCh3aW5IZWlnaHQgLyAyKSkpO1xcblxcbiAgICAgICAgZmxvYXQgc3RhcnRDTGVycCA9IGZsb29yKGZsb2F0KGMpICogaW52V2lkdGhTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeUMgPSBpbnQoZmxvb3Ioc3RhcnRDTGVycCAtIGZsb2F0KHdpbldpZHRoIC8gMikpKTtcXG5cXG4gICAgICAgIC8vIExvb3Agb3ZlciBkeVxcbiAgICAgICAgZm9yIChpbnQgZHlST2Zmc2V0ID0gMDsgZHlST2Zmc2V0IDwgd2luSGVpZ2h0OyBkeVJPZmZzZXQrKykge1xcbiAgICAgICAgICBpbnQgZHlSID0gZHlST2Zmc2V0ICsgc3RhcnREeVI7XFxuXFxuICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gXCIgKyB5SGVpZ2h0ICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCBkeUNPZmZzZXQgPSAwOyBkeUNPZmZzZXQgPCB3aW5XaWR0aDsgZHlDT2Zmc2V0KyspIHtcXG4gICAgICAgICAgICBpbnQgZHlDID0gZHlDT2Zmc2V0ICsgc3RhcnREeUM7XFxuXFxuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IFwiICsgeVdpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCBzb3VyY2VGcmFjUm93ID1cXG4gICAgICAgICAgICAgIGZsb2F0KFwiICsgZWZmZWN0aXZlWFNpemVbMF0gKyBcIikgKlxcbiAgICAgICAgICAgICAgICAoZmxvYXQoZHlSKSAvIGZsb2F0KFwiICsgZWZmZWN0aXZlWVNpemVbMF0gKyBcIikpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IHNvdXJjZUZyYWNDb2wgPVxcbiAgICAgICAgICAgICAgICBmbG9hdChcIiArIGVmZmVjdGl2ZVhTaXplWzFdICsgXCIpICpcXG4gICAgICAgICAgICAgICAgICAoZmxvYXQoZHlDKSAvIGZsb2F0KFwiICsgZWZmZWN0aXZlWVNpemVbMV0gKyBcIikpO1xcblxcbiAgICAgICAgICAgIGludCBzb3VyY2VOZWFyZXN0Um93ID0gaW50KG1pbihcXG4gICAgICAgICAgICAgICAgZmxvYXQoaW50KFwiICsgeEhlaWdodCArIFwiKSAtIDEpLFxcbiAgICAgICAgICAgICAgICBcIiArIGFsaWduQ29ybmVycyArIFwiID8gZmxvYXQocm91bmQoc291cmNlRnJhY1JvdykpIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQoZmxvb3Ioc291cmNlRnJhY1JvdykpKSk7XFxuXFxuICAgICAgICAgICAgaW50IHNvdXJjZU5lYXJlc3RDb2wgPSBpbnQobWluKFxcbiAgICAgICAgICAgICAgICBmbG9hdChpbnQoXCIgKyB4V2lkdGggKyBcIikgLSAxKSxcXG4gICAgICAgICAgICAgICAgXCIgKyBhbGlnbkNvcm5lcnMgKyBcIiA/IGZsb2F0KHJvdW5kKHNvdXJjZUZyYWNDb2wpKSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGZsb29yKHNvdXJjZUZyYWNDb2wpKSkpO1xcblxcbiAgICAgICAgICAgIGlmIChyID09IHNvdXJjZU5lYXJlc3RSb3cgJiYgYyA9PSBzb3VyY2VOZWFyZXN0Q29sKSB7XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAvLyBFbmQgbG9vcCBvdmVyIGR5XFxuXFxuICAgICAgICBzZXRPdXRwdXQoYWNjdW11bGF0b3IpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVOZWFyZXN0TmVpZ2JvckJhY2twcm9wUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWQoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBpbWFnZXMgPSBpbnB1dHMuaW1hZ2VzLCBkeSA9IGlucHV0cy5keTtcbiAgICB2YXIgYWxpZ25Db3JuZXJzID0gYXR0cnMuYWxpZ25Db3JuZXJzO1xuICAgIHZhciBwcm9ncmFtID0gbmV3IFJlc2l6ZU5lYXJlc3ROZWlnYm9yQmFja3Byb3BQcm9ncmFtKGR5LnNoYXBlLCBpbWFnZXMuc2hhcGUsIGFsaWduQ29ybmVycyk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFtkeV0sIGR5LmR0eXBlKTtcbn1cbnZhciByZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogcmVzaXplTmVhcmVzdE5laWdoYm9yR3JhZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFJldmVyc2VQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJldmVyc2VQcm9ncmFtKHhTaGFwZSwgYXhpcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdmFyIHJhbmsgPSB4U2hhcGUubGVuZ3RoO1xuICAgICAgICBpZiAocmFuayA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYkdMIGJhY2tlbmQ6IFJldmVyc2Ugb2YgcmFuay1cIiArIHJhbmsgKyBcIiB0ZW5zb3IgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHhTaGFwZTtcbiAgICAgICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpbnQgY29vcmQgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIgKyB4U2hhcGVbMF0gKyBcIiAtIGNvb3JkIC0gMSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXRJbkNvb3JkID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmIChheGlzLmluZGV4T2YoaSkgIT09IC0xICYmIHhTaGFwZVtpXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4U2hhcGVbaV0gKyBcIiAtIGNvb3Jkc1tcIiArIGkgKyBcIl0gLSAxXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJjb29yZHNbXCIgKyBpICsgXCJdXCI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbkNvb3JkcyA9IHhTaGFwZS5tYXAoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIGdldEluQ29vcmQoaSk7IH0pLmpvaW4oJywnKTtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyB0eXBlICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIiArIGluQ29vcmRzICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUmV2ZXJzZVByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgUmV2ZXJzZVBhY2tlZFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV2ZXJzZVBhY2tlZFByb2dyYW0oeFNoYXBlLCBheGlzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB0aGlzLnBhY2tlZElucHV0cyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFja2VkT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJhbmsgPSB4U2hhcGUubGVuZ3RoO1xuICAgICAgICBpZiAocmFuayA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYkdMIGJhY2tlbmQ6IFJldmVyc2Ugb2YgcmFuay1cIiArIHJhbmsgKyBcIiB0ZW5zb3IgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHhTaGFwZTtcbiAgICAgICAgdmFyIGNoYW5uZWxzID0gZ2V0Q2hhbm5lbHMoJ3JjJywgcmFuayk7XG4gICAgICAgIHZhciBuZXh0Q29sdW1uID0gY2hhbm5lbHNbcmFuayAtIDFdICsgXCIgKyAxIDwgXCIgKyB0aGlzLm91dHB1dFNoYXBlW3JhbmsgLSAxXTtcbiAgICAgICAgdmFyIG5leHRSb3cgPSBjaGFubmVsc1tyYW5rIC0gMl0gKyBcIiArIDEgPCBcIiArIHRoaXMub3V0cHV0U2hhcGVbcmFuayAtIDJdO1xuICAgICAgICB2YXIgdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICAgICAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgICB2b2lkIG1haW4oKXtcXG4gICAgICAgICAgaW50IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICAgIHJlc3VsdC5yID0gZ2V0Q2hhbm5lbChnZXRYKFwiICsgeFNoYXBlWzBdICsgXCIgLSByYyAtIDEpLFxcbiAgICAgICAgICAgIFwiICsgeFNoYXBlWzBdICsgXCIgLSByYyAtIDEpO1xcbiAgICAgICAgICBpZihcIiArIG5leHRDb2x1bW4gKyBcIil7XFxuICAgICAgICAgICAgICByZXN1bHQuZyA9IGdldENoYW5uZWwoZ2V0WChcIiArIHhTaGFwZVswXSArIFwiIC0gKHJjICArIDEpIC0gMSksXFxuICAgICAgICAgICAgICAgIFwiICsgeFNoYXBlWzBdICsgXCIgLSAocmMgICsgMSkgLSAxKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBcIiArIHR5cGUgKyBcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgICAgICByZXN1bHQuciA9IFwiICsgZ2V0UihjaGFubmVscy5zbGljZSgpKSArIFwiO1xcbiAgICAgICAgICBpZihcIiArIG5leHRDb2x1bW4gKyBcIil7XFxuICAgICAgICAgICAgcmVzdWx0LmcgPSBcIiArIGdldEcoY2hhbm5lbHMuc2xpY2UoKSkgKyBcIjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZihcIiArIG5leHRSb3cgKyBcIikge1xcbiAgICAgICAgICAgIHJlc3VsdC5iID0gXCIgKyBnZXRCKGNoYW5uZWxzLnNsaWNlKCkpICsgXCI7XFxuICAgICAgICAgICAgaWYoXCIgKyBuZXh0Q29sdW1uICsgXCIpIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5hID0gXCIgKyBnZXRBKGNoYW5uZWxzLnNsaWNlKCkpICsgXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgICAgfVxcbiAgICBcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRSKGNoYW5uZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChjaGFubmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RyhjaGFubmVscykge1xuICAgICAgICAgICAgY2hhbm5lbHNbcmFuayAtIDFdID0gJygnICsgY2hhbm5lbHNbcmFuayAtIDFdICsgXCIgKyAxKVwiO1xuICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoY2hhbm5lbHMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEIoY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGNoYW5uZWxzW3JhbmsgLSAyXSA9ICcoJyArIGNoYW5uZWxzW3JhbmsgLSAyXSArIFwiICsgMSlcIjtcbiAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKGNoYW5uZWxzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRBKGNoYW5uZWxzKSB7XG4gICAgICAgICAgICBjaGFubmVsc1tyYW5rIC0gMV0gPSAnKCcgKyBjaGFubmVsc1tyYW5rIC0gMV0gKyBcIiArIDEpXCI7XG4gICAgICAgICAgICBjaGFubmVsc1tyYW5rIC0gMl0gPSAnKCcgKyBjaGFubmVsc1tyYW5rIC0gMl0gKyBcIiArIDEpXCI7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChjaGFubmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2hhbm5lbChjaGFubmVscykge1xuICAgICAgICAgICAgdmFyIGluQ29vcmRzQXJyYXkgPSB4U2hhcGUubWFwKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBnZXRJbkNvb3JkKGksIGNoYW5uZWxzKTsgfSk7XG4gICAgICAgICAgICB2YXIgaW5Db29yZHMgPSBpbkNvb3Jkc0FycmF5LmpvaW4oJywnKTtcbiAgICAgICAgICAgIHZhciBpbm5lckRpbXMgPSBpbkNvb3Jkc0FycmF5LnNsaWNlKC0yKS5qb2luKCcsJyk7XG4gICAgICAgICAgICByZXR1cm4gXCJnZXRDaGFubmVsKGdldFgoXCIgKyBpbkNvb3JkcyArIFwiKSwgdmVjMihcIiArIGlubmVyRGltcyArIFwiKSlcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRJbkNvb3JkKGksIGNoYW5uZWxzMSkge1xuICAgICAgICAgICAgaWYgKGF4aXMuaW5kZXhPZihpKSAhPT0gLTEgJiYgeFNoYXBlW2ldICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhTaGFwZVtpXSArIFwiIC0gXCIgKyBjaGFubmVsczFbaV0gKyBcIiAtIDFcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiICsgY2hhbm5lbHMxW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZXZlcnNlUGFja2VkUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHJldmVyc2UoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGRpbXMgPSBhdHRycy5kaW1zO1xuICAgIHZhciB4UmFuayA9IHguc2hhcGUubGVuZ3RoO1xuICAgIHZhciAkZGltcyA9IHRmLnV0aWwucGFyc2VBeGlzUGFyYW0oZGltcywgeC5zaGFwZSk7XG4gICAgaWYgKHhSYW5rID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQgfSk7XG4gICAgfVxuICAgIHZhciBwcm9ncmFtID0gdGYuZW52KCkuZ2V0Qm9vbCgnV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TJykgP1xuICAgICAgICBuZXcgUmV2ZXJzZVBhY2tlZFByb2dyYW0oeC5zaGFwZSwgJGRpbXMpIDpcbiAgICAgICAgbmV3IFJldmVyc2VQcm9ncmFtKHguc2hhcGUsICRkaW1zKTtcbiAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3hdLCB4LmR0eXBlKTtcbn1cbnZhciByZXZlcnNlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlJldmVyc2UsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogcmV2ZXJzZVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFJvdGF0ZVByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm90YXRlUHJvZ3JhbShpbWFnZVNoYXBlLCByYWRpYW5zLCBmaWxsVmFsdWUsIGNlbnRlcikge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0ltYWdlJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdmFyIGltYWdlSGVpZ2h0ID0gaW1hZ2VTaGFwZVsxXTtcbiAgICAgICAgdmFyIGltYWdlV2lkdGggPSBpbWFnZVNoYXBlWzJdO1xuICAgICAgICB2YXIgc2luRmFjdG9yID0gTWF0aC5zaW4ocmFkaWFucykudG9GaXhlZCgzKTtcbiAgICAgICAgdmFyIGNvc0ZhY3RvciA9IE1hdGguY29zKHJhZGlhbnMpLnRvRml4ZWQoMyk7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBpbWFnZVNoYXBlO1xuICAgICAgICB2YXIgX2EgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0SW1hZ2VDZW50ZXIoY2VudGVyLCBpbWFnZUhlaWdodCwgaW1hZ2VXaWR0aCksIGNlbnRlclggPSBfYVswXSwgY2VudGVyWSA9IF9hWzFdO1xuICAgICAgICB2YXIgY2VudGVyWFN0cmluZyA9IGNlbnRlclgudG9GaXhlZCgzKTtcbiAgICAgICAgdmFyIGNlbnRlcllTdHJpbmcgPSBjZW50ZXJZLnRvRml4ZWQoMyk7XG4gICAgICAgIHZhciBmaWxsU25pcHBldCA9ICcnO1xuICAgICAgICBpZiAodHlwZW9mIGZpbGxWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZpbGxTbmlwcGV0ID0gXCJmbG9hdCBvdXRwdXRWYWx1ZSA9IFwiICsgZmlsbFZhbHVlLnRvRml4ZWQoMikgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbGxTbmlwcGV0ID0gXCJcXG4gICAgICAgIHZlYzMgZmlsbCA9IHZlYzMoXCIgKyBmaWxsVmFsdWUuam9pbignLCcpICsgXCIpO1xcbiAgICAgICAgZmxvYXQgb3V0cHV0VmFsdWUgPSBmaWxsW2Nvb3Jkc1szXV07XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpbnQgeCA9IGNvb3Jkc1syXTtcXG4gICAgICAgICAgaW50IHkgPSBjb29yZHNbMV07XFxuICAgICAgICAgIGZsb2F0IGNvb3JkWEZsb2F0ID0gKGZsb2F0KHgpIC0gXCIgKyBjZW50ZXJYU3RyaW5nICsgXCIpICogXCIgKyBjb3NGYWN0b3IgKyBcIiAtIChmbG9hdCh5KSAtIFwiICsgY2VudGVyWVN0cmluZyArIFwiKSAqIFwiICsgc2luRmFjdG9yICsgXCI7XFxuICAgICAgICAgIGZsb2F0IGNvb3JkWUZsb2F0ID0gKGZsb2F0KHgpIC0gXCIgKyBjZW50ZXJYU3RyaW5nICsgXCIpICogXCIgKyBzaW5GYWN0b3IgKyBcIiArIChmbG9hdCh5KSAtIFwiICsgY2VudGVyWVN0cmluZyArIFwiKSAqIFwiICsgY29zRmFjdG9yICsgXCI7XFxuICAgICAgICAgIGludCBjb29yZFggPSBpbnQocm91bmQoY29vcmRYRmxvYXQgKyBcIiArIGNlbnRlclhTdHJpbmcgKyBcIikpO1xcbiAgICAgICAgICBpbnQgY29vcmRZID0gaW50KHJvdW5kKGNvb3JkWUZsb2F0ICsgXCIgKyBjZW50ZXJZU3RyaW5nICsgXCIpKTtcXG4gICAgICAgICAgXCIgKyBmaWxsU25pcHBldCArIFwiXFxuICAgICAgICAgIGlmKGNvb3JkWCA+PSAwICYmIGNvb3JkWCA8IFwiICsgaW1hZ2VXaWR0aCArIFwiICYmIGNvb3JkWSA+PSAwICYmIGNvb3JkWSA8IFwiICsgaW1hZ2VIZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgIG91dHB1dFZhbHVlID0gZ2V0SW1hZ2UoY29vcmRzWzBdLCBjb29yZFksIGNvb3JkWCwgY29vcmRzWzNdKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQob3V0cHV0VmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFJvdGF0ZVByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgcm90YXRlV2l0aE9mZnNldENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5Sb3RhdGVXaXRoT2Zmc2V0LFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaW5wdXRzID0gX2EuaW5wdXRzLCBhdHRycyA9IF9hLmF0dHJzLCBiYWNrZW5kID0gX2EuYmFja2VuZDtcbiAgICAgICAgdmFyIGltYWdlID0gaW5wdXRzLmltYWdlO1xuICAgICAgICB2YXIgX2IgPSBhdHRycywgcmFkaWFucyA9IF9iLnJhZGlhbnMsIGZpbGxWYWx1ZSA9IF9iLmZpbGxWYWx1ZSwgY2VudGVyID0gX2IuY2VudGVyO1xuICAgICAgICB2YXIgd2ViZ2xCYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgUm90YXRlUHJvZ3JhbShpbWFnZS5zaGFwZSwgcmFkaWFucywgZmlsbFZhbHVlLCBjZW50ZXIpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gd2ViZ2xCYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbaW1hZ2VdLCBpbWFnZS5kdHlwZSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFJPVU5EID0gXCJcXG4gIC8vIE9wZW5HTCBFUyBkb2VzIG5vdCBzdXBwb3J0IHJvdW5kIGZ1bmN0aW9uLlxcbiAgLy8gVGhlIGFsZ29yaXRobSBpcyBiYXNlZCBvbiBiYW5rZXIncyByb3VuZGluZy5cXG4gIGZsb2F0IGJhc2UgPSBmbG9vcih4KTtcXG4gIGlmICgoeCAtIGJhc2UpIDwgMC41KSB7XFxuICAgIHJldHVybiBmbG9vcih4KTtcXG4gIH0gZWxzZSBpZiAoKHggLSBiYXNlKSA+IDAuNSkge1xcbiAgICByZXR1cm4gY2VpbCh4KTtcXG4gIH0gZWxzZSB7XFxuICAgIGlmIChtb2QoYmFzZSwgMi4wKSA9PSAwLjApIHtcXG4gICAgICByZXR1cm4gYmFzZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gYmFzZSArIDEuMDtcXG4gICAgfVxcbiAgfVxcblwiO1xudmFyIHJvdW5kID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBST1VORCB9KTtcbnZhciByb3VuZENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5Sb3VuZCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiByb3VuZCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBSU1FSVCA9IFwicmV0dXJuIGludmVyc2VzcXJ0KHgpO1wiO1xudmFyIHJzcXJ0ID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBSU1FSVCwgY3B1S2VybmVsSW1wbDogcnNxcnRJbXBsQ1BVIH0pO1xudmFyIHJzcXJ0Q29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlJzcXJ0LFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHJzcXJ0XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgU2NhdHRlclByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2NhdHRlclByb2dyYW0odXBkYXRlU2l6ZSwgc2xpY2VEaW0sIGluZGljZXNSYW5rLCB1cGRhdGVzUmFuaywgc3RyaWRlcywgc2hhcGUsIHN1bW1pbmdEdXBlSW5kZXgpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd1cGRhdGVzJywgJ2luZGljZXMnLCAnZGVmYXVsdFZhbHVlJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgdmFyIHN0cmlkZXNUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoc3RyaWRlcy5sZW5ndGgpO1xuICAgICAgICB2YXIgZHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShzaGFwZS5sZW5ndGgpO1xuICAgICAgICB2YXIgaW5kaWNlc1N0cmluZyA9ICcnO1xuICAgICAgICBpZiAoaW5kaWNlc1JhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIGluZGljZXNTdHJpbmcgPSAnaSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kaWNlc1JhbmsgPT09IDIpIHtcbiAgICAgICAgICAgIGluZGljZXNTdHJpbmcgPSAnaSwgaic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGljZXNTbmlwcGV0ID0gXCJnZXRJbmRpY2VzKFwiICsgaW5kaWNlc1N0cmluZyArIFwiKVwiO1xuICAgICAgICB2YXIgdXBkYXRlc1N0cmluZyA9ICcnO1xuICAgICAgICBpZiAodXBkYXRlc1JhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHVwZGF0ZXNTdHJpbmcgPSAnaSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXBkYXRlc1JhbmsgPT09IDIpIHtcbiAgICAgICAgICAgIHVwZGF0ZXNTdHJpbmcgPSAnaSwgY29vcmRzWzFdJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXBkYXRlc1NuaXBwZXQgPSBcImdldFVwZGF0ZXMoXCIgKyB1cGRhdGVzU3RyaW5nICsgXCIpXCI7XG4gICAgICAgIHZhciBzdHJpZGVTdHJpbmcgPSBzbGljZURpbSA+IDEgPyAnc3RyaWRlc1tqXScgOiAnc3RyaWRlcyc7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgXCIgKyBzdHJpZGVzVHlwZSArIFwiIHN0cmlkZXMgPSBcIiArIHN0cmlkZXNUeXBlICsgXCIoXCIgKyBzdHJpZGVzICsgXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBcIiArIGR0eXBlICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGZsb2F0IHN1bSA9IDAuMDtcXG4gICAgICAgICAgYm9vbCBmb3VuZCA9IGZhbHNlO1xcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgdXBkYXRlU2l6ZSArIFwiOyBpKyspIHtcXG4gICAgICAgICAgICBpbnQgZmxhdHRlbmVkSW5kZXggPSAwO1xcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIgKyBzbGljZURpbSArIFwiOyBqKyspIHtcXG4gICAgICAgICAgICAgIGludCBpbmRleCA9IHJvdW5kKFwiICsgaW5kaWNlc1NuaXBwZXQgKyBcIik7XFxuICAgICAgICAgICAgICBmbGF0dGVuZWRJbmRleCArPSBpbmRleCAqIFwiICsgc3RyaWRlU3RyaW5nICsgXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChmbGF0dGVuZWRJbmRleCA9PSBjb29yZHNbMF0pIHtcXG4gICAgICAgICAgICAgIHN1bSArPSBcIiArIHVwZGF0ZXNTbmlwcGV0ICsgXCI7XFxuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChtaXgoZ2V0RGVmYXVsdFZhbHVlKCksIHN1bSwgZmxvYXQoZm91bmQpKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBTY2F0dGVyUHJvZ3JhbTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHNjYXR0ZXJOZChhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIGluZGljZXMgPSBpbnB1dHMuaW5kaWNlcywgdXBkYXRlcyA9IGlucHV0cy51cGRhdGVzO1xuICAgIHZhciBzaGFwZSA9IGF0dHJzLnNoYXBlO1xuICAgIHZhciBfYSA9IHRmLmJhY2tlbmRfdXRpbC5jYWxjdWxhdGVTaGFwZXModXBkYXRlcywgaW5kaWNlcywgc2hhcGUpLCBzbGljZVJhbmsgPSBfYS5zbGljZVJhbmssIG51bVVwZGF0ZXMgPSBfYS5udW1VcGRhdGVzLCBzbGljZVNpemUgPSBfYS5zbGljZVNpemUsIHN0cmlkZXMgPSBfYS5zdHJpZGVzLCBvdXRwdXRTaXplID0gX2Eub3V0cHV0U2l6ZTtcbiAgICB2YXIgZmxhdHRlblNoYXBlID0gW291dHB1dFNpemUgLyBzbGljZVNpemUsIHNsaWNlU2l6ZV07XG4gICAgaWYgKG91dHB1dFNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oc2hhcGUsIGluZGljZXMuZHR5cGUpO1xuICAgIH1cbiAgICB2YXIgZmxhdHRlbkluZGljZXMgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IGluZGljZXMgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IFtudW1VcGRhdGVzLCBzbGljZVJhbmtdIH0gfSk7XG4gICAgdmFyIGZsYXR0ZW5YID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiB1cGRhdGVzIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBbbnVtVXBkYXRlcywgc2xpY2VTaXplXSB9IH0pO1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtdLCAnZmxvYXQzMicsIG5ldyBGbG9hdDMyQXJyYXkoWzBdKSk7IC8vIHNjYWxhcigwKVxuICAgIHZhciBwcm9ncmFtID0gbmV3IFNjYXR0ZXJQcm9ncmFtKG51bVVwZGF0ZXMsIHNsaWNlUmFuaywgZmxhdHRlbkluZGljZXMuc2hhcGUubGVuZ3RoLCBmbGF0dGVuWC5zaGFwZS5sZW5ndGgsIHN0cmlkZXMsIGZsYXR0ZW5TaGFwZSk7XG4gICAgdmFyIHJlcyA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFtmbGF0dGVuWCwgZmxhdHRlbkluZGljZXMsIGRlZmF1bHRWYWx1ZV0sIGZsYXR0ZW5YLmR0eXBlKTtcbiAgICB2YXIgcmVzaGFwZWQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHJlcyB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogc2hhcGUgfSB9KTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGZsYXR0ZW5JbmRpY2VzKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGZsYXR0ZW5YKTtcbiAgICBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlcyk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhkZWZhdWx0VmFsdWUpO1xuICAgIHJldHVybiByZXNoYXBlZDtcbn1cbnZhciBzY2F0dGVyTmRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuU2NhdHRlck5kLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHNjYXR0ZXJOZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFNlbGVjdFByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VsZWN0UHJvZ3JhbShjUmFuaywgc2hhcGUsIHJhbmspIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydjJywgJ2EnLCAnYiddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gc2hhcGU7XG4gICAgICAgIHZhciBjQ29vcmRzO1xuICAgICAgICB2YXIgYWJDb29yZHM7XG4gICAgICAgIGlmIChyYW5rID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJXaGVyZSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICAgICAgYWJDb29yZHMgPSBcInJlc1JDXCI7XG4gICAgICAgICAgICBjQ29vcmRzID0gXCJyZXNSQ1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRDb29yZHMgPSBbJ3Jlc1JDLngnLCAncmVzUkMueScsICdyZXNSQy56JywgJ3Jlc1JDLncnXTtcbiAgICAgICAgICAgIHZhciBjQ29vcmRWYXJzID0gW107XG4gICAgICAgICAgICB2YXIgYWJDb29yZFZhcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhYkNvb3JkVmFycy5wdXNoKFwiXCIgKyBjdXJyZW50Q29vcmRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IGNSYW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNDb29yZFZhcnMucHVzaChcIlwiICsgY3VycmVudENvb3Jkc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY0Nvb3JkcyA9IGNDb29yZFZhcnMuam9pbigpO1xuICAgICAgICAgICAgYWJDb29yZHMgPSBhYkNvb3JkVmFycy5qb2luKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgY1ZhbCA9IGdldEMoXCIgKyBjQ29vcmRzICsgXCIpO1xcbiAgICAgICAgaWYgKGNWYWwgPj0gMS4wKSB7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRBKFwiICsgYWJDb29yZHMgKyBcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldEIoXCIgKyBhYkNvb3JkcyArIFwiKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFNlbGVjdFByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBzZWxlY3QoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZDtcbiAgICB2YXIgY29uZGl0aW9uID0gaW5wdXRzLmNvbmRpdGlvbiwgdCA9IGlucHV0cy50LCBlID0gaW5wdXRzLmU7XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgU2VsZWN0UHJvZ3JhbShjb25kaXRpb24uc2hhcGUubGVuZ3RoLCB0LnNoYXBlLCB0LnNoYXBlLmxlbmd0aCk7XG4gICAgcmV0dXJuIGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFtjb25kaXRpb24sIHQsIGVdLCB0Zi51cGNhc3RUeXBlKHQuZHR5cGUsIGUuZHR5cGUpKTtcbn1cbnZhciBzZWxlY3RDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuU2VsZWN0LFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHNlbGVjdFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFNFTFUgPSBcIlxcbiAgLy8gU3RhYmxlIGFuZCBBdHRyYWN0aW5nIEZpeGVkIFBvaW50ICgwLCAxKSBmb3IgTm9ybWFsaXplZCBXZWlnaHRzLlxcbiAgLy8gc2VlOiBodHRwczovL2FyeGl2Lm9yZy9hYnMvMTcwNi4wMjUxNVxcbiAgZmxvYXQgc2NhbGVBbHBoYSA9IFwiICsgdGYuYmFja2VuZF91dGlsLlNFTFVfU0NBTEVBTFBIQSArIFwiO1xcbiAgZmxvYXQgc2NhbGUgPSBcIiArIHRmLmJhY2tlbmRfdXRpbC5TRUxVX1NDQUxFICsgXCI7XFxuICByZXR1cm4gKHggPj0gMC4wKSA/IHNjYWxlICogeCA6IHNjYWxlQWxwaGEgKiAoZXhwKHgpIC0gMS4wKTtcXG5cIjtcbnZhciBzZWx1ID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBTRUxVIH0pO1xudmFyIHNlbHVDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuU2VsdSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBzZWx1LFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFNJR01PSUQgPSBcInJldHVybiAxLjAgLyAoMS4wICsgZXhwKC0xLjAgKiB4KSk7XCI7XG52YXIgc2lnbW9pZCA9IHVuYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogU0lHTU9JRCB9KTtcbnZhciBzaWdtb2lkQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlNpZ21vaWQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogc2lnbW9pZCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8vIFNpZ24gZG9lcyBub3QgcHJvcGFnYXRlIE5BTnMuXG52YXIgU0lHTiA9IFwiXFxuICBpZiAoaXNuYW4oeCkpIHsgcmV0dXJuIDAuMDsgfVxcbiAgcmV0dXJuIHNpZ24oeCk7XFxuXCI7XG52YXIgc2lnbiA9IHVuYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogU0lHTiB9KTtcbnZhciBzaWduQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlNpZ24sXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogc2lnbixcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBTSU4gPSBDSEVDS19OQU5fU05JUFBFVF9VTkFSWSArIFwiXFxuICByZXR1cm4gc2luKHgpO1xcblwiO1xudmFyIHNpbiA9IHVuYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogU0lOIH0pO1xudmFyIHNpbkNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5TaW4sXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogc2luLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFNJTkggPSBcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKHgpO1xcbiAgcmV0dXJuIChlMnggLSAxLjAgLyBlMngpIC8gMi4wO1xcblwiO1xudmFyIHNpbmggPSB1bmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IFNJTkggfSk7XG52YXIgc2luaENvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5TaW5oLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHNpbmgsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgU09GVFBMVVMgPSBcIlxcbiAgZmxvYXQgZXBzaWxvbiA9IDEuMTkyMDkyODk1NTA3ODEyNWUtNztcXG4gIGZsb2F0IHRocmVzaG9sZCA9IGxvZyhlcHNpbG9uKSArIDIuMDtcXG5cXG4gIGJvb2wgdG9vX2xhcmdlID0geCA+IC10aHJlc2hvbGQ7XFxuICBib29sIHRvb19zbWFsbCA9IHggPCB0aHJlc2hvbGQ7XFxuXFxuICBmbG9hdCByZXN1bHQ7XFxuICBmbG9hdCBleHBfeCA9IGV4cCh4KTtcXG5cXG4gIGlmICh0b29fbGFyZ2Upe1xcbiAgICByZXN1bHQgPSB4O1xcbiAgfVxcbiAgZWxzZSBpZiAodG9vX3NtYWxsKXtcXG4gICAgcmVzdWx0ID0gZXhwX3g7XFxuICB9XFxuICBlbHNle1xcbiAgICByZXN1bHQgPSBsb2coZXhwX3ggKyAxLjApO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIjtcbnZhciBzb2Z0cGx1cyA9IHVuYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogU09GVFBMVVMgfSk7XG52YXIgc29mdHBsdXNDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuU29mdHBsdXMsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogc29mdHBsdXMsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgc3BhY2VUb0JhdGNoTkQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGJsb2NrU2hhcGUgPSBhdHRycy5ibG9ja1NoYXBlLCBwYWRkaW5ncyA9IGF0dHJzLnBhZGRpbmdzO1xuICAgIHRmLnV0aWwuYXNzZXJ0KHguc2hhcGUubGVuZ3RoIDw9IDQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdzcGFjZVRvQmF0Y2hORCBmb3IgcmFuayA+IDQgd2l0aCBhIFdlYkdMIGJhY2tlbmQgbm90ICcgK1xuICAgICAgICAnaW1wbGVtZW50ZWQgeWV0JzsgfSk7XG4gICAgdmFyIHByb2QgPSBibG9ja1NoYXBlLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAqIGI7IH0pO1xuICAgIHZhciBjb21wbGV0ZVBhZGRpbmdzID0gW1swLCAwXV07XG4gICAgY29tcGxldGVQYWRkaW5ncy5wdXNoLmFwcGx5KGNvbXBsZXRlUGFkZGluZ3MsIHBhZGRpbmdzKTtcbiAgICBmb3IgKHZhciBpID0gMSArIGJsb2NrU2hhcGUubGVuZ3RoOyBpIDwgeC5zaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb21wbGV0ZVBhZGRpbmdzLnB1c2goWzAsIDBdKTtcbiAgICB9XG4gICAgdmFyIHRvRGlzcG9zZSA9IFtdO1xuICAgIHZhciBwYWRkZWRYID0gcGFkVjIoe1xuICAgICAgICBpbnB1dHM6IHsgeDogeCB9LFxuICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICBhdHRyczogeyBwYWRkaW5nczogY29tcGxldGVQYWRkaW5ncywgY29uc3RhbnRWYWx1ZTogMCB9XG4gICAgfSk7XG4gICAgdmFyIHJlc2hhcGVkUGFkZGVkU2hhcGUgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0UmVzaGFwZWQocGFkZGVkWC5zaGFwZSwgYmxvY2tTaGFwZSwgcHJvZCwgZmFsc2UpO1xuICAgIHZhciBwZXJtdXRlZFJlc2hhcGVkUGFkZGVkUGVybXV0YXRpb24gPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0UGVybXV0ZWQocmVzaGFwZWRQYWRkZWRTaGFwZS5sZW5ndGgsIGJsb2NrU2hhcGUubGVuZ3RoLCBmYWxzZSk7XG4gICAgdmFyIGZsYXR0ZW5TaGFwZSA9IHRmLmJhY2tlbmRfdXRpbC5nZXRSZXNoYXBlZFBlcm11dGVkKHBhZGRlZFguc2hhcGUsIGJsb2NrU2hhcGUsIHByb2QsIGZhbHNlKTtcbiAgICB2YXIgcmVzaGFwZWRQYWRkZWRYID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiBwYWRkZWRYIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiByZXNoYXBlZFBhZGRlZFNoYXBlIH0gfSk7XG4gICAgdmFyIHBhZGRlZFhUID0gdHJhbnNwb3NlKHtcbiAgICAgICAgaW5wdXRzOiB7IHg6IHJlc2hhcGVkUGFkZGVkWCB9LFxuICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICBhdHRyczogeyBwZXJtOiBwZXJtdXRlZFJlc2hhcGVkUGFkZGVkUGVybXV0YXRpb24gfVxuICAgIH0pO1xuICAgIHZhciByZXN1bHQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHBhZGRlZFhUIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBmbGF0dGVuU2hhcGUgfSB9KTtcbiAgICB0b0Rpc3Bvc2UucHVzaChwYWRkZWRYKTtcbiAgICB0b0Rpc3Bvc2UucHVzaChyZXNoYXBlZFBhZGRlZFgpO1xuICAgIHRvRGlzcG9zZS5wdXNoKHBhZGRlZFhUKTtcbiAgICB0b0Rpc3Bvc2UuZm9yRWFjaChmdW5jdGlvbiAodCkgeyByZXR1cm4gYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh0KTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgc3BhY2VUb0JhdGNoTkRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuU3BhY2VUb0JhdGNoTkQsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogc3BhY2VUb0JhdGNoTkRcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHNwYXJzZVRvRGVuc2UoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciBzcGFyc2VJbmRpY2VzID0gaW5wdXRzLnNwYXJzZUluZGljZXMsIHNwYXJzZVZhbHVlcyA9IGlucHV0cy5zcGFyc2VWYWx1ZXMsIGRlZmF1bHRWYWx1ZSA9IGlucHV0cy5kZWZhdWx0VmFsdWU7XG4gICAgdmFyIG91dHB1dFNoYXBlID0gYXR0cnMub3V0cHV0U2hhcGU7XG4gICAgdmFyIF9hID0gdGYuYmFja2VuZF91dGlsLmNhbGN1bGF0ZVNoYXBlcyhzcGFyc2VWYWx1ZXMsIHNwYXJzZUluZGljZXMsIG91dHB1dFNoYXBlKSwgc2xpY2VSYW5rID0gX2Euc2xpY2VSYW5rLCBudW1VcGRhdGVzID0gX2EubnVtVXBkYXRlcywgc3RyaWRlcyA9IF9hLnN0cmlkZXMsIG91dHB1dFNpemUgPSBfYS5vdXRwdXRTaXplO1xuICAgIHZhciBzdW1EdXBlSW5kaWNlcyA9IGZhbHNlO1xuICAgIHZhciBwcm9ncmFtID0gbmV3IFNjYXR0ZXJQcm9ncmFtKG51bVVwZGF0ZXMsIHNsaWNlUmFuaywgc3BhcnNlSW5kaWNlcy5zaGFwZS5sZW5ndGgsIHNwYXJzZVZhbHVlcy5zaGFwZS5sZW5ndGgsIHN0cmlkZXMsIFtvdXRwdXRTaXplLCAxXSwgc3VtRHVwZUluZGljZXMpO1xuICAgIHZhciByZXMgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbc3BhcnNlVmFsdWVzLCBzcGFyc2VJbmRpY2VzLCBkZWZhdWx0VmFsdWVdLCBzcGFyc2VWYWx1ZXMuZHR5cGUpO1xuICAgIHZhciByZXNoYXBlZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogcmVzIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBvdXRwdXRTaGFwZSB9IH0pO1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocmVzKTtcbiAgICByZXR1cm4gcmVzaGFwZWQ7XG59XG52YXIgc3BhcnNlVG9EZW5zZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5TcGFyc2VUb0RlbnNlLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHNwYXJzZVRvRGVuc2Vcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHNwbGl0VihhcmdzKSB7XG4gICAgdmFyIGlucHV0cyA9IGFyZ3MuaW5wdXRzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kLCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgbnVtT3JTaXplU3BsaXRzID0gYXR0cnMubnVtT3JTaXplU3BsaXRzLCBheGlzID0gYXR0cnMuYXhpcztcbiAgICB2YXIgJGF4aXMgPSB0Zi51dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpWzBdO1xuICAgIHZhciBzcGxpdFNpemVzID0gdGYuYmFja2VuZF91dGlsLnByZXBhcmVTcGxpdFNpemUoeCwgbnVtT3JTaXplU3BsaXRzLCAkYXhpcyk7XG4gICAgdmFyIHhSYW5rID0geC5zaGFwZS5sZW5ndGg7XG4gICAgdmFyIGJlZ2luID0gbmV3IEFycmF5KHhSYW5rKS5maWxsKDApO1xuICAgIHZhciBzaXplID0geC5zaGFwZS5zbGljZSgpO1xuICAgIHJldHVybiBzcGxpdFNpemVzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgc2xpY2VTaXplID0gc2l6ZS5zbGljZSgpO1xuICAgICAgICBzbGljZVNpemVbJGF4aXNdID0gcztcbiAgICAgICAgdmFyIHNsaWNlVCA9IHNsaWNlKHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgYmVnaW46IGJlZ2luLCBzaXplOiBzbGljZVNpemUgfSB9KTtcbiAgICAgICAgYmVnaW5bJGF4aXNdICs9IHM7XG4gICAgICAgIHJldHVybiBzbGljZVQ7XG4gICAgfSk7XG59XG52YXIgc3BsaXRWQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlNwbGl0VixcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBzcGxpdFZcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBTUVJUID0gXCJyZXR1cm4gc3FydCh4KTtcIjtcbnZhciBzcXJ0ID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBTUVJUIH0pO1xudmFyIHNxcnRDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuU3FydCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBzcXJ0XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgU1FVQVJFID0gXCJyZXR1cm4geCAqIHg7XCI7XG52YXIgc3F1YXJlID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBTUVVBUkUgfSk7XG52YXIgc3F1YXJlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlNxdWFyZSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBzcXVhcmUsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgU1FVQVJFRF9ESUZGRVJFTkNFID0gJ3JldHVybiAoYSAtIGIpICogKGEgLSBiKTsnO1xudmFyIHNxdWFyZWREaWZmZXJlbmNlID0gYmluYXJ5S2VybmVsRnVuYyh7IG9wU25pcHBldDogU1FVQVJFRF9ESUZGRVJFTkNFLCBwYWNrZWRPcFNuaXBwZXQ6IFNRVUFSRURfRElGRkVSRU5DRSB9KTtcbnZhciBzcXVhcmVkRGlmZmVyZW5jZUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5TcXVhcmVkRGlmZmVyZW5jZSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiBzcXVhcmVkRGlmZmVyZW5jZSxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHN0ZXAoX2EpIHtcbiAgICB2YXIgaW5wdXRzID0gX2EuaW5wdXRzLCBhdHRycyA9IF9hLmF0dHJzLCBiYWNrZW5kID0gX2EuYmFja2VuZDtcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIHZhciBvcFNuaXBwZXQgPSBDSEVDS19OQU5fU05JUFBFVCArIChcIlxcbiAgICByZXR1cm4geCA+IDAuMCA/IDEuMCA6IGZsb2F0KFwiICsgYXR0cnMuYWxwaGEgKyBcIik7XFxuICBcIik7XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgb3BTbmlwcGV0KTtcbiAgICByZXR1cm4gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3hdLCB4LmR0eXBlKTtcbn1cbnZhciBzdGVwQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlN0ZXAsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogc3RlcCxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBTdHJpZGVkU2xpY2VQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmlkZWRTbGljZVByb2dyYW0oYmVnaW4sIHN0cmlkZXMsIHNpemUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBzaXplO1xuICAgICAgICB2YXIgcmFuayA9IHNpemUubGVuZ3RoO1xuICAgICAgICB2YXIgaW5wdXREdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHNpemUubGVuZ3RoKTtcbiAgICAgICAgdmFyIGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoc2l6ZS5sZW5ndGgpO1xuICAgICAgICB2YXIgbmV3Q29vcmRzID0gJyc7XG4gICAgICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgICAgICBuZXdDb29yZHMgPSAnY29vcmRzICogc3RyaWRlcyArIGJlZ2luJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRBeGlzXzEgPSAwO1xuICAgICAgICAgICAgbmV3Q29vcmRzID1cbiAgICAgICAgICAgICAgICBzaXplLm1hcChmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRBeGlzXzErKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpemUubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29vcmRzICogc3RyaWRlc1tcIiArIGkgKyBcIl0gKyBiZWdpbltcIiArIGkgKyBcIl1cIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNvb3Jkc1tcIiArIChvdXRwdXRBeGlzXzEgLSAxKSArIFwiXSAqIHN0cmlkZXNbXCIgKyBpICsgXCJdICsgYmVnaW5bXCIgKyBpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBcIiArIGlucHV0RHR5cGUgKyBcIiBiZWdpbiA9IFwiICsgaW5wdXREdHlwZSArIFwiKFwiICsgYmVnaW4gKyBcIik7XFxuICAgICAgXCIgKyBpbnB1dER0eXBlICsgXCIgc3RyaWRlcyA9IFwiICsgaW5wdXREdHlwZSArIFwiKFwiICsgc3RyaWRlcyArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIiArIG5ld0Nvb3JkcyArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmlkZWRTbGljZVByb2dyYW07XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBzdHJpZGVkU2xpY2UoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGJlZ2luID0gYXR0cnMuYmVnaW4sIGVuZCA9IGF0dHJzLmVuZCwgc3RyaWRlcyA9IGF0dHJzLnN0cmlkZXMsIGJlZ2luTWFzayA9IGF0dHJzLmJlZ2luTWFzaywgZW5kTWFzayA9IGF0dHJzLmVuZE1hc2ssIGVsbGlwc2lzTWFzayA9IGF0dHJzLmVsbGlwc2lzTWFzaywgbmV3QXhpc01hc2sgPSBhdHRycy5uZXdBeGlzTWFzaywgc2hyaW5rQXhpc01hc2sgPSBhdHRycy5zaHJpbmtBeGlzTWFzaztcbiAgICB2YXIgX2EgPSB0Zi5zbGljZV91dGlsLnNsaWNlSW5mbyh4LnNoYXBlLCBiZWdpbiwgZW5kLCBzdHJpZGVzLCBiZWdpbk1hc2ssIGVuZE1hc2ssIGVsbGlwc2lzTWFzaywgbmV3QXhpc01hc2ssIHNocmlua0F4aXNNYXNrKSwgbm9uU3RyaWRlZCA9IF9hLm5vblN0cmlkZWQsICRiZWdpbiA9IF9hLiRiZWdpbiwgJHN0cmlkZXMgPSBfYS4kc3RyaWRlcywgc2l6ZSA9IF9hLnNpemUsIG5ld1NoYXBlID0gX2EubmV3U2hhcGUsIG91dFNoYXBlID0gX2Eub3V0U2hhcGU7XG4gICAgdmFyICR4ID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBuZXdTaGFwZSB9IH0pO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKG5vblN0cmlkZWQpIHtcbiAgICAgICAgdmFyIHNsaWNlZCA9IHNsaWNlKHsgaW5wdXRzOiB7IHg6ICR4IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IGJlZ2luOiAkYmVnaW4sIHNpemU6IHNpemUgfSB9KTtcbiAgICAgICAgcmVzdWx0ID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiBzbGljZWQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IG91dFNoYXBlIH0gfSk7XG4gICAgICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oc2xpY2VkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0U2hhcGUuc29tZShmdW5jdGlvbiAoYXhpcykgeyByZXR1cm4gYXhpcyA9PT0gMDsgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRTaGFwZSwgeC5kdHlwZSwgW10pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHNob3VsZEV4ZWN1dGVPbkNQVSA9IGJhY2tlbmQuc2hvdWxkRXhlY3V0ZU9uQ1BVKFskeF0pO1xuICAgICAgICBpZiAoc2hvdWxkRXhlY3V0ZU9uQ1BVKSB7XG4gICAgICAgICAgICB2YXIgeFRleERhdGEgPSBiYWNrZW5kLnRleERhdGEuZ2V0KCR4LmRhdGFJZCk7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0geFRleERhdGEudmFsdWVzO1xuICAgICAgICAgICAgdmFyIHhCdWYgPSB0Zi5idWZmZXIoJHguc2hhcGUsICR4LmR0eXBlLCB2YWx1ZXMpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IHN0cmlkZWRTbGljZUltcGxDUFUob3V0U2hhcGUsIHhCdWYsICRzdHJpZGVzLCAkYmVnaW4pO1xuICAgICAgICAgICAgcmVzdWx0ID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRTaGFwZSwgJHguZHR5cGUsIHJlc3VsdFZhbHVlcy52YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgU3RyaWRlZFNsaWNlUHJvZ3JhbSgkYmVnaW4sICRzdHJpZGVzLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICByZXN1bHQgPSBiYWNrZW5kLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbJHhdLCAkeC5kdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdFJlc2hhcGVkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiByZXN1bHQgfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgc2hhcGU6IG91dFNoYXBlIH0gfSk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbygkeCk7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHRSZXNoYXBlZDtcbn1cbnZhciBzdHJpZGVkU2xpY2VDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuU3RyaWRlZFNsaWNlLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHN0cmlkZWRTbGljZVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFRBTiA9IFwicmV0dXJuIHRhbih4KTtcIjtcbnZhciB0YW4gPSB1bmFyeUtlcm5lbEZ1bmMoeyBvcFNuaXBwZXQ6IFRBTiB9KTtcbnZhciB0YW5Db25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuVGFuLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHRhbixcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBUQU5IID0gXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgtMi4wICogYWJzKHgpKTtcXG4gIHJldHVybiBzaWduKHgpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtcXG5cIjtcbnZhciB0YW5oID0gdW5hcnlLZXJuZWxGdW5jKHsgb3BTbmlwcGV0OiBUQU5IIH0pO1xudmFyIHRhbmhDb25maWcgPSB7XG4gICAga2VybmVsTmFtZTogdGYuVGFuaCxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiB0YW5oLFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIFRpbGVQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbGVQcm9ncmFtKGFTaGFwZSwgcmVwcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGFTaGFwZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGFTaGFwZVtpXSAqIHJlcHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBkdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayk7XG4gICAgICAgIHZhciBzb3VyY2VDb29yZHMgPSBnZXRTb3VyY2VDb29yZHMkMihhU2hhcGUpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRBKFwiICsgc291cmNlQ29vcmRzICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gVGlsZVByb2dyYW07XG59KCkpO1xuZnVuY3Rpb24gZ2V0U291cmNlQ29vcmRzJDIoYVNoYXBlKSB7XG4gICAgdmFyIHJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIGlmIChyYW5rID4gNSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRpbGUgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcImltb2QocmVzUkMsIFwiICsgYVNoYXBlWzBdICsgXCIpXCI7XG4gICAgfVxuICAgIHZhciBjdXJyZW50Q29vcmRzID0gWydyZXNSQy54JywgJ3Jlc1JDLnknLCAncmVzUkMueicsICdyZXNSQy53JywgJ3Jlc1JDLnUnXTtcbiAgICB2YXIgc291cmNlQ29vcmRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhU2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc291cmNlQ29vcmRzLnB1c2goXCJpbW9kKFwiICsgY3VycmVudENvb3Jkc1tpXSArIFwiLCBcIiArIGFTaGFwZVtpXSArIFwiKVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZUNvb3Jkcy5qb2luKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHRpbGUocGFyYW1zKSB7XG4gICAgdmFyIGlucHV0cyA9IHBhcmFtcy5pbnB1dHMsIGJhY2tlbmQgPSBwYXJhbXMuYmFja2VuZCwgYXR0cnMgPSBwYXJhbXMuYXR0cnM7XG4gICAgdmFyIHggPSBpbnB1dHMueDtcbiAgICB2YXIgcmVwcyA9IGF0dHJzLnJlcHM7XG4gICAgaWYgKHguZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEV2ZW4gdGhvdWdodCBzdHJpbmcgdGVuc29yIGlzIGFsd2F5cyBvbiBDUFUsIGp1c3QgdG8gYmUgY29uc2lzdGVudCBvbiBob3dcbiAgICAgICAgLy8gdG8gYWNjZXNzIHRlbnNvciBkYXRhLlxuICAgICAgICB2YXIgZGF0YSA9IGJhY2tlbmQucmVhZFN5bmMoeC5kYXRhSWQpO1xuICAgICAgICB2YXIgZGVjb2RlZERhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gdGYudXRpbC5kZWNvZGVTdHJpbmcoZCk7IH0pO1xuICAgICAgICB2YXIgYnVmID0gdGYuYnVmZmVyKHguc2hhcGUsIHguZHR5cGUsIGRlY29kZWREYXRhKTtcbiAgICAgICAgdmFyIG91dEJ1ZiA9IHRpbGVJbXBsQ1BVKGJ1ZiwgcmVwcyk7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dEJ1Zi5zaGFwZSwgb3V0QnVmLmR0eXBlLCBvdXRCdWYudmFsdWVzKTtcbiAgICB9XG4gICAgdmFyIHByb2dyYW0gPSBuZXcgVGlsZVByb2dyYW0oeC5zaGFwZSwgcmVwcyk7XG4gICAgdmFyIG91dHB1dCA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt4XSwgeC5kdHlwZSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbnZhciB0aWxlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlRpbGUsXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogdGlsZSxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHRvcEsoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB4ID0gaW5wdXRzLng7XG4gICAgdmFyIGsgPSBhdHRycy5rLCBzb3J0ZWQgPSBhdHRycy5zb3J0ZWQ7XG4gICAgdmFyIHhWYWxzID0gYmFja2VuZC5yZWFkU3luYyh4LmRhdGFJZCk7XG4gICAgdmFyIF9hID0gdG9wS0ltcGxDUFUoeFZhbHMsIHguc2hhcGUsIHguZHR5cGUsIGspLCBhbGxUb3BLVmFscyA9IF9hWzBdLCBhbGxUb3BLSW5kaWNlcyA9IF9hWzFdO1xuICAgIHJldHVybiBbXG4gICAgICAgIGJhY2tlbmQubWFrZVRlbnNvckluZm8oYWxsVG9wS1ZhbHMuc2hhcGUsIGFsbFRvcEtWYWxzLmR0eXBlLCBhbGxUb3BLVmFscy52YWx1ZXMpLFxuICAgICAgICBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKGFsbFRvcEtJbmRpY2VzLnNoYXBlLCBhbGxUb3BLSW5kaWNlcy5kdHlwZSwgYWxsVG9wS0luZGljZXMudmFsdWVzKVxuICAgIF07XG59XG52YXIgdG9wS0NvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5Ub3BLLFxuICAgIGJhY2tlbmROYW1lOiAnd2ViZ2wnLFxuICAgIGtlcm5lbEZ1bmM6IHRvcEtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBBUyBJUyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiB1bmlxdWUoYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYXR0cnMgPSBhcmdzLmF0dHJzLCBiYWNrZW5kID0gYXJncy5iYWNrZW5kO1xuICAgIHZhciBheGlzID0gYXR0cnMuYXhpcztcbiAgICB2YXIgeCA9IGlucHV0cy54O1xuICAgIGFzc2VydE5vdENvbXBsZXgoeCwgJ3VuaXF1ZScpO1xuICAgIC8vIEZvciBub3csIGFsd2F5cyBmb3J3YXJkIGNhbGN1bGF0aW9uIHRvIHRoZSBDUFUgYmFja2VuZC5cbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6ICcsICdVSSBtaWdodCBiZSBsb2NrZWQgdGVtcG9yYXJpbHkgYXMgZGF0YSBpcyBiZWluZyBkb3dubG9hZGVkJyk7XG4gICAgdmFyIHZhbHVlcyA9IGJhY2tlbmQucmVhZFN5bmMoeC5kYXRhSWQpO1xuICAgIHZhciBfYSA9IHVuaXF1ZUltcGxDUFUodmFsdWVzLCBheGlzLCB4LnNoYXBlLCB4LmR0eXBlKSwgb3V0cHV0VmFsdWVzID0gX2Eub3V0cHV0VmFsdWVzLCBvdXRwdXRTaGFwZSA9IF9hLm91dHB1dFNoYXBlLCBpbmRpY2VzID0gX2EuaW5kaWNlcztcbiAgICByZXR1cm4gW1xuICAgICAgICBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKG91dHB1dFNoYXBlLCB4LmR0eXBlLCBvdXRwdXRWYWx1ZXMpLFxuICAgICAgICBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFtpbmRpY2VzLmxlbmd0aF0sICdpbnQzMicsIGluZGljZXMpLFxuICAgIF07XG59XG52YXIgdW5pcXVlQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlVuaXF1ZSxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiB1bmlxdWUsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiB1bnBhY2soYXJncykge1xuICAgIHZhciBpbnB1dHMgPSBhcmdzLmlucHV0cywgYmFja2VuZCA9IGFyZ3MuYmFja2VuZCwgYXR0cnMgPSBhcmdzLmF0dHJzO1xuICAgIHZhciB2YWx1ZSA9IGlucHV0cy52YWx1ZTtcbiAgICB2YXIgYXhpcyA9IGF0dHJzLmF4aXM7XG4gICAgaWYgKGF4aXMgPCAwKSB7XG4gICAgICAgIGF4aXMgKz0gdmFsdWUuc2hhcGUubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgeCA9IHZhbHVlO1xuICAgIHZhciB4UmFuayA9IHguc2hhcGUubGVuZ3RoO1xuICAgIHZhciBudW0gPSB2YWx1ZS5zaGFwZVtheGlzXTtcbiAgICB2YXIgb3V0U2hhcGUgPSBuZXcgQXJyYXkoeFJhbmsgLSAxKTtcbiAgICB2YXIgb3V0SW5kZXggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeFJhbms7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gYXhpcykge1xuICAgICAgICAgICAgb3V0U2hhcGVbb3V0SW5kZXgrK10gPSB4LnNoYXBlW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB0b0Rpc3Bvc2UgPSBbXTtcbiAgICB2YXIgYmVnaW4gPSBuZXcgQXJyYXkoeFJhbmspLmZpbGwoMCk7XG4gICAgdmFyIHNpemUgPSB4LnNoYXBlLnNsaWNlKCk7XG4gICAgc2l6ZVtheGlzXSA9IDE7XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheShudW0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJlZ2luW2F4aXNdID0gaTtcbiAgICAgICAgdmFyIHNsaWNlZCA9IHNsaWNlKHsgaW5wdXRzOiB7IHg6IHggfSwgYmFja2VuZDogYmFja2VuZCwgYXR0cnM6IHsgYmVnaW46IGJlZ2luLCBzaXplOiBzaXplIH0gfSk7XG4gICAgICAgIHZhciByZXNoYXBlZCA9IHJlc2hhcGUoeyBpbnB1dHM6IHsgeDogc2xpY2VkIH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHNoYXBlOiBvdXRTaGFwZSB9IH0pO1xuICAgICAgICByZXNbaV0gPSByZXNoYXBlZDtcbiAgICAgICAgdG9EaXNwb3NlLnB1c2goc2xpY2VkKTtcbiAgICB9XG4gICAgdG9EaXNwb3NlLmZvckVhY2goZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odCk7IH0pO1xuICAgIHJldHVybiByZXM7XG59XG52YXIgdW5wYWNrQ29uZmlnID0ge1xuICAgIGtlcm5lbE5hbWU6IHRmLlVucGFjayxcbiAgICBiYWNrZW5kTmFtZTogJ3dlYmdsJyxcbiAgICBrZXJuZWxGdW5jOiB1bnBhY2tcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBTZWdtZW50T3BQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlZ21lbnRPcFByb2dyYW0oc2VnT3BJbmZvLCBzZWdPcFR5cGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ3NlZ21lbnRJZHMnXTtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSBzZWdPcEluZm8ud2luZG93U2l6ZTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHNlZ09wSW5mby5iYXRjaFNpemU7XG4gICAgICAgIHZhciBpblNpemUgPSBzZWdPcEluZm8uaW5TaXplO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdPcEluZm8ubnVtU2VnbWVudHM7XG4gICAgICAgIHZhciBvdXRTaXplID0gbnVtU2VnbWVudHMgKiBNYXRoLmNlaWwoaW5TaXplIC8gd2luZG93U2l6ZSk7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRTaXplXTtcbiAgICAgICAgdmFyIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMC4wJztcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gXCJzdW1WYWx1ZVwiO1xuICAgICAgICB2YXIgd2luZG93U2l6ZU5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcih3aW5kb3dTaXplIC8gNCkgKiA0O1xuICAgICAgICB2YXIgd2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPSB3aW5kb3dTaXplICUgNDtcbiAgICAgICAgdmFyIHVwZGF0ZVNuaXBwZXQgPSBcIlxcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgc2VnRmlsdGVyKTtcXG4gICAgXCI7XG4gICAgICAgIHZhciBjaGVja1ZhbHVlT3V0T2ZCb3VuZHMgPSAnJztcbiAgICAgICAgaWYgKGluU2l6ZSAlIHdpbmRvd1NpemUgPiAwKSB7XG4gICAgICAgICAgICBjaGVja1ZhbHVlT3V0T2ZCb3VuZHMgPSBcIlxcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSBcIiArIGluU2l6ZSArIFwiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGVja1NlZ21lbnRJZE91dE9mQm91bmRzID0gJyc7XG4gICAgICAgIGlmIChpblNpemUgJSB3aW5kb3dTaXplID4gMCkge1xuICAgICAgICAgICAgY2hlY2tTZWdtZW50SWRPdXRPZkJvdW5kcyA9IFwiXFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49IFwiICsgaW5TaXplICsgXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIC0xLjA7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XFxuICAgICAgICBcIiArIGNoZWNrVmFsdWVPdXRPZkJvdW5kcyArIFwiXFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgaW5JZHgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBmbG9hdCBnZXRTZWdtZW50SWRBdEluZGV4KGludCBpbklkeCkge1xcbiAgICAgICAgXCIgKyBjaGVja1NlZ21lbnRJZE91dE9mQm91bmRzICsgXCJcXG4gICAgICAgIHJldHVybiBnZXRTZWdtZW50SWRzKGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gaW50KGZsb29yKGZsb2F0KG91dElkeCkgLyBmbG9hdChcXG4gICAgICAgICAgXCIgKyBudW1TZWdtZW50cyArIFwiKSkgKiBmbG9hdChcIiArIHdpbmRvd1NpemUgKyBcIikpO1xcbiAgICAgICAgaW50IGN1cnJlbnRTZWcgPSBpbnQobW9kKGZsb2F0KG91dElkeCksIGZsb2F0KFwiICsgbnVtU2VnbWVudHMgKyBcIikpKTtcXG5cXG4gICAgICAgIGZsb2F0IHN1bVZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIHdpbmRvd1NpemVOZWFyZXN0VmVjNCArIFwiOyBpICs9IDQpIHtcXG4gICAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBpO1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAzKVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMikpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDMpKSA9PSBjdXJyZW50U2VnID8gMSA6IDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIgKyB3aW5kb3dTaXplTmVhcmVzdFZlYzQgKyBcIjtcXG4gICAgICAgIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBpbnQgaW5JZHhTZWcgPSBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgICAwLFxcbiAgICAgICAgICAgICAgMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAyKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIiArIHJldHVyblZhbHVlICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBTZWdtZW50T3BQcm9ncmFtO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gdW5zb3J0ZWRTZWdtZW50U3VtKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRzID0gYXJncy5pbnB1dHMsIGJhY2tlbmQgPSBhcmdzLmJhY2tlbmQsIGF0dHJzID0gYXJncy5hdHRycztcbiAgICB2YXIgeCA9IGlucHV0cy54LCBzZWdtZW50SWRzID0gaW5wdXRzLnNlZ21lbnRJZHM7XG4gICAgdmFyIG51bVNlZ21lbnRzID0gYXR0cnMubnVtU2VnbWVudHM7XG4gICAgdmFyIHhSYW5rID0geC5zaGFwZS5sZW5ndGg7XG4gICAgdmFyIHRvRGlzcG9zZSA9IFtdO1xuICAgIHZhciBheGlzID0gMDtcbiAgICB2YXIgcGVybXV0YXRpb24gPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKFtheGlzXSwgeFJhbmspO1xuICAgIHZhciBwZXJtdXRlZFggPSB4O1xuICAgIGlmIChwZXJtdXRhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHBlcm11dGVkWCA9IHRyYW5zcG9zZSh7IGlucHV0czogeyB4OiB4IH0sIGJhY2tlbmQ6IGJhY2tlbmQsIGF0dHJzOiB7IHBlcm06IHBlcm11dGF0aW9uIH0gfSk7XG4gICAgICAgIHRvRGlzcG9zZS5wdXNoKHBlcm11dGVkWCk7XG4gICAgICAgIGF4aXMgPSB0Zi5iYWNrZW5kX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcygxLCB4UmFuaylbMF07XG4gICAgfVxuICAgIHZhciBvdXRTaGFwZSA9IHRmLmJhY2tlbmRfdXRpbC5zZWdtZW50X3V0aWwuY29tcHV0ZU91dFNoYXBlKHBlcm11dGVkWC5zaGFwZSwgYXhpcywgbnVtU2VnbWVudHMpO1xuICAgIHZhciBpblNpemUgPSB0Zi51dGlsLnNpemVGcm9tU2hhcGUoW3Blcm11dGVkWC5zaGFwZVtheGlzXV0pO1xuICAgIHZhciBhMkQgPSByZXNoYXBlKHsgaW5wdXRzOiB7IHg6IHBlcm11dGVkWCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogWy0xLCBpblNpemVdIH0gfSk7XG4gICAgdG9EaXNwb3NlLnB1c2goYTJEKTtcbiAgICB2YXIgb3V0cHV0RFR5cGUgPSB0Zi5zdW1PdXRUeXBlKHguZHR5cGUpO1xuICAgIHZhciBzZWdPcENvbXB1dGUgPSBmdW5jdGlvbiAoeCwgc2VnT3BUeXBlLCBzZWdtZW50SWRzLCBkdHlwZSwgbnVtU2VnbWVudHMpIHtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHguc2hhcGVbMF07XG4gICAgICAgIHZhciBpblNpemUgPSB4LnNoYXBlWzFdO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHRmLmJhY2tlbmRfdXRpbC5zZWdtZW50X3V0aWwuc2VnT3BDb21wdXRlT3B0aW1hbFdpbmRvd1NpemUoaW5TaXplLCBudW1TZWdtZW50cyk7XG4gICAgICAgIHZhciBzZWdPcEluZm8gPSB7IHdpbmRvd1NpemU6IHdpbmRvd1NpemUsIGluU2l6ZTogaW5TaXplLCBiYXRjaFNpemU6IGJhdGNoU2l6ZSwgbnVtU2VnbWVudHM6IG51bVNlZ21lbnRzIH07XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IFNlZ21lbnRPcFByb2dyYW0oc2VnT3BJbmZvLCBzZWdPcFR5cGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gYmFja2VuZC5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCBzZWdtZW50SWRzXSwgZHR5cGUpO1xuICAgICAgICB0b0Rpc3Bvc2UucHVzaChvdXRwdXQpO1xuICAgICAgICAvLyBObyBuZWVkIHRvIHJ1biBhbm90aGVyIEdQR1BVIHByb2dyYW0uXG4gICAgICAgIGlmIChvdXRwdXQuc2hhcGVbMV0gPT09IG51bVNlZ21lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZUluZm8gPSByYW5nZSh7XG4gICAgICAgICAgICBiYWNrZW5kOiBiYWNrZW5kLFxuICAgICAgICAgICAgYXR0cnM6IHsgc3RhcnQ6IDAsIHN0b3A6IG51bVNlZ21lbnRzLCBzdGVwOiAxLCBkdHlwZTogJ2Zsb2F0MzInIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0aWxlSW5mbyA9IHRpbGUoe1xuICAgICAgICAgICAgaW5wdXRzOiB7IHg6IHJhbmdlSW5mbyB9LFxuICAgICAgICAgICAgYmFja2VuZDogYmFja2VuZCxcbiAgICAgICAgICAgIGF0dHJzOiB7IHJlcHM6IFtpblNpemUgLyB3aW5kb3dTaXplXSB9XG4gICAgICAgIH0pO1xuICAgICAgICB0b0Rpc3Bvc2UucHVzaChyYW5nZUluZm8pO1xuICAgICAgICB0b0Rpc3Bvc2UucHVzaCh0aWxlSW5mbyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBzZWdPcENvbXB1dGUob3V0cHV0LCBzZWdPcFR5cGUsIHRpbGVJbmZvLCBkdHlwZSwgbnVtU2VnbWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgdmFyIHNlZ09wUmVzdWx0ID0gc2VnT3BDb21wdXRlKGEyRCwgJ3Vuc29ydGVkU2VnbWVudFN1bScsIHNlZ21lbnRJZHMsIG91dHB1dERUeXBlLCBudW1TZWdtZW50cyk7XG4gICAgdmFyIHJlc2hhcGVkID0gcmVzaGFwZSh7IGlucHV0czogeyB4OiBzZWdPcFJlc3VsdCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBzaGFwZTogb3V0U2hhcGUgfSB9KTtcbiAgICB2YXIgcmVzdWx0ID0gcmVzaGFwZWQ7XG4gICAgaWYgKHBlcm11dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdG9EaXNwb3NlLnB1c2gocmVzaGFwZWQpO1xuICAgICAgICB2YXIgcGVybSA9IHRmLmJhY2tlbmRfdXRpbC5nZXRVbmRvQXhlc1Blcm11dGF0aW9uKHBlcm11dGF0aW9uKTtcbiAgICAgICAgcmVzdWx0ID0gdHJhbnNwb3NlKHsgaW5wdXRzOiB7IHg6IHJlc3VsdCB9LCBiYWNrZW5kOiBiYWNrZW5kLCBhdHRyczogeyBwZXJtOiBwZXJtIH0gfSk7XG4gICAgfVxuICAgIHRvRGlzcG9zZS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IHJldHVybiBiYWNrZW5kLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHQpOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIHVuc29ydGVkU2VnbWVudFN1bUNvbmZpZyA9IHtcbiAgICBrZXJuZWxOYW1lOiB0Zi5VbnNvcnRlZFNlZ21lbnRTdW0sXG4gICAgYmFja2VuZE5hbWU6ICd3ZWJnbCcsXG4gICAga2VybmVsRnVuYzogdW5zb3J0ZWRTZWdtZW50U3VtXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vLyBMaXN0IGFsbCBrZXJuZWwgY29uZmlncyBoZXJlXG52YXIga2VybmVsQ29uZmlncyA9IFtcbiAgICBMUk5Db25maWcsXG4gICAgTFJOR3JhZENvbmZpZyxcbiAgICBfZnVzZWRNYXRNdWxDb25maWcsXG4gICAgYWJzQ29uZmlnLFxuICAgIGFjb3NDb25maWcsXG4gICAgYWNvc2hDb25maWcsXG4gICAgYWRkQ29uZmlnLFxuICAgIGFkZE5Db25maWcsXG4gICAgYWxsQ29uZmlnLFxuICAgIGFueUNvbmZpZyxcbiAgICBhcmdNYXhDb25maWcsXG4gICAgYXJnTWluQ29uZmlnLFxuICAgIGFzaW5Db25maWcsXG4gICAgYXNpbmhDb25maWcsXG4gICAgYXRhbjJDb25maWcsXG4gICAgYXRhbkNvbmZpZyxcbiAgICBhdGFuaENvbmZpZyxcbiAgICBhdmdQb29sM0RDb25maWcsXG4gICAgYXZnUG9vbENvbmZpZyxcbiAgICBhdmdQb29sR3JhZDNEQ29uZmlnLFxuICAgIGF2Z1Bvb2xHcmFkQ29uZmlnLFxuICAgIGJhdGNoTWF0TXVsQ29uZmlnLFxuICAgIGJhdGNoTm9ybUNvbmZpZyxcbiAgICBiYXRjaFRvU3BhY2VORENvbmZpZyxcbiAgICBiaW5jb3VudENvbmZpZyxcbiAgICBjYXN0Q29uZmlnLFxuICAgIGNlaWxDb25maWcsXG4gICAgY2xpcEJ5VmFsdWVDb25maWcsXG4gICAgY29tcGxleEFic0NvbmZpZyxcbiAgICBjb21wbGV4Q29uZmlnLFxuICAgIGNvbmNhdENvbmZpZyxcbiAgICBjb252MkRCYWNrcHJvcEZpbHRlckNvbmZpZyxcbiAgICBjb252MkRCYWNrcHJvcElucHV0Q29uZmlnLFxuICAgIGNvbnYyRENvbmZpZyxcbiAgICBjb252M0RCYWNrcHJvcEZpbHRlclYyQ29uZmlnLFxuICAgIGNvbnYzREJhY2twcm9wSW5wdXRDb25maWcsXG4gICAgY29udjNEQ29uZmlnLFxuICAgIGNvc0NvbmZpZyxcbiAgICBjb3NoQ29uZmlnLFxuICAgIGNyb3BBbmRSZXNpemVDb25maWcsXG4gICAgY3Vtc3VtQ29uZmlnLFxuICAgIGRlbnNlQmluY291bnRDb25maWcsXG4gICAgZGVwdGhUb1NwYWNlQ29uZmlnLFxuICAgIGRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wRmlsdGVyQ29uZmlnLFxuICAgIGRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wSW5wdXRDb25maWcsXG4gICAgZGVwdGh3aXNlQ29udjJkTmF0aXZlQ29uZmlnLFxuICAgIGRpYWdDb25maWcsXG4gICAgZGlsYXRpb24yRENvbmZpZyxcbiAgICBlbHVDb25maWcsXG4gICAgZWx1R3JhZENvbmZpZyxcbiAgICBlcXVhbENvbmZpZyxcbiAgICBlcmZDb25maWcsXG4gICAgZXhwQ29uZmlnLFxuICAgIGV4cGFuZERpbXNDb25maWcsXG4gICAgZXhwbTFDb25maWcsXG4gICAgZmZ0Q29uZmlnLFxuICAgIGZpbGxDb25maWcsXG4gICAgZmxpcExlZnRSaWdodENvbmZpZyxcbiAgICBmbG9vckNvbmZpZyxcbiAgICBmbG9vckRpdkNvbmZpZyxcbiAgICBmcm9tUGl4ZWxzQ29uZmlnLFxuICAgIGZ1c2VkQ29udjJEQ29uZmlnLFxuICAgIGZ1c2VkRGVwdGh3aXNlQ29udjJEQ29uZmlnLFxuICAgIGdhdGhlck5kQ29uZmlnLFxuICAgIGdhdGhlclYyQ29uZmlnLFxuICAgIGdyZWF0ZXJDb25maWcsXG4gICAgZ3JlYXRlckVxdWFsQ29uZmlnLFxuICAgIGlkZW50aXR5Q29uZmlnLFxuICAgIGlmZnRDb25maWcsXG4gICAgaW1hZ0NvbmZpZyxcbiAgICBpc0Zpbml0ZUNvbmZpZyxcbiAgICBpc0luZkNvbmZpZyxcbiAgICBpc05hTkNvbmZpZyxcbiAgICBsZWFreVJlbHVDb25maWcsXG4gICAgbGVzc0NvbmZpZyxcbiAgICBsZXNzRXF1YWxDb25maWcsXG4gICAgbGluU3BhY2VDb25maWcsXG4gICAgbG9nMXBDb25maWcsXG4gICAgbG9nQ29uZmlnLFxuICAgIGxvZ2ljYWxBbmRDb25maWcsXG4gICAgbG9naWNhbE5vdENvbmZpZyxcbiAgICBsb2dpY2FsT3JDb25maWcsXG4gICAgbWF4Q29uZmlnLFxuICAgIG1heFBvb2wzRENvbmZpZyxcbiAgICBtYXhQb29sQ29uZmlnLFxuICAgIG1heFBvb2xHcmFkM0RDb25maWcsXG4gICAgbWF4UG9vbEdyYWRDb25maWcsXG4gICAgbWF4UG9vbFdpdGhBcmdtYXhDb25maWcsXG4gICAgbWF4aW11bUNvbmZpZyxcbiAgICBtZWFuQ29uZmlnLFxuICAgIG1pbkNvbmZpZyxcbiAgICBtaW5pbXVtQ29uZmlnLFxuICAgIG1pcnJvclBhZENvbmZpZyxcbiAgICBtb2RDb25maWcsXG4gICAgbXVsdGlub21pYWxDb25maWcsXG4gICAgbXVsdGlwbHlDb25maWcsXG4gICAgbmVnQ29uZmlnLFxuICAgIG5vbk1heFN1cHByZXNzaW9uVjNDb25maWcsXG4gICAgbm9uTWF4U3VwcHJlc3Npb25WNENvbmZpZyxcbiAgICBub25NYXhTdXBwcmVzc2lvblY1Q29uZmlnLFxuICAgIG5vdEVxdWFsQ29uZmlnLFxuICAgIG9uZUhvdENvbmZpZyxcbiAgICBvbmVzTGlrZUNvbmZpZyxcbiAgICBwYWNrQ29uZmlnLFxuICAgIHBhZFYyQ29uZmlnLFxuICAgIHBvd0NvbmZpZyxcbiAgICBwcmVsdUNvbmZpZyxcbiAgICBwcm9kQ29uZmlnLFxuICAgIHJhbmdlQ29uZmlnLFxuICAgIHJlYWxDb25maWcsXG4gICAgcmVhbERpdkNvbmZpZyxcbiAgICByZWNpcHJvY2FsQ29uZmlnLFxuICAgIHJlbHU2Q29uZmlnLFxuICAgIHJlbHVDb25maWcsXG4gICAgcmVzaGFwZUNvbmZpZyxcbiAgICByZXNpemVCaWxpbmVhckNvbmZpZyxcbiAgICByZXNpemVCaWxpbmVhckdyYWRDb25maWcsXG4gICAgcmVzaXplTmVhcmVzdE5laWdoYm9yQ29uZmlnLFxuICAgIHJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWRDb25maWcsXG4gICAgcmV2ZXJzZUNvbmZpZyxcbiAgICByb3RhdGVXaXRoT2Zmc2V0Q29uZmlnLFxuICAgIHJvdW5kQ29uZmlnLFxuICAgIHJzcXJ0Q29uZmlnLFxuICAgIHNjYXR0ZXJOZENvbmZpZyxcbiAgICBzZWxlY3RDb25maWcsXG4gICAgc2VsdUNvbmZpZyxcbiAgICBzaWdtb2lkQ29uZmlnLFxuICAgIHNpZ25Db25maWcsXG4gICAgc2luQ29uZmlnLFxuICAgIHNpbmhDb25maWcsXG4gICAgc2xpY2VDb25maWcsXG4gICAgc29mdG1heENvbmZpZyxcbiAgICBzb2Z0cGx1c0NvbmZpZyxcbiAgICBzcGFjZVRvQmF0Y2hORENvbmZpZyxcbiAgICBzcGFyc2VUb0RlbnNlQ29uZmlnLFxuICAgIHNwbGl0VkNvbmZpZyxcbiAgICBzcXJ0Q29uZmlnLFxuICAgIHNxdWFyZUNvbmZpZyxcbiAgICBzcXVhcmVkRGlmZmVyZW5jZUNvbmZpZyxcbiAgICBzdGVwQ29uZmlnLFxuICAgIHN0cmlkZWRTbGljZUNvbmZpZyxcbiAgICBzdWJDb25maWcsXG4gICAgc3VtQ29uZmlnLFxuICAgIHRhbkNvbmZpZyxcbiAgICB0YW5oQ29uZmlnLFxuICAgIHRpbGVDb25maWcsXG4gICAgdG9wS0NvbmZpZyxcbiAgICB0cmFuc3Bvc2VDb25maWcsXG4gICAgdW5pcXVlQ29uZmlnLFxuICAgIHVucGFja0NvbmZpZyxcbiAgICB1bnNvcnRlZFNlZ21lbnRTdW1Db25maWcsXG4gICAgemVyb3NMaWtlQ29uZmlnXG5dO1xuZm9yICh2YXIgX2kgPSAwLCBrZXJuZWxDb25maWdzXzEgPSBrZXJuZWxDb25maWdzOyBfaSA8IGtlcm5lbENvbmZpZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIga2VybmVsQ29uZmlnID0ga2VybmVsQ29uZmlnc18xW19pXTtcbiAgICB0Zi5yZWdpc3Rlcktlcm5lbChrZXJuZWxDb25maWcpO1xufVxuXG5leHBvcnRzLkdQR1BVQ29udGV4dCA9IEdQR1BVQ29udGV4dDtcbmV4cG9ydHMuTWF0aEJhY2tlbmRXZWJHTCA9IE1hdGhCYWNrZW5kV2ViR0w7XG5leHBvcnRzLmZvcmNlSGFsZkZsb2F0ID0gZm9yY2VIYWxmRmxvYXQ7XG5leHBvcnRzLmdwZ3B1X3V0aWwgPSBncGdwdV91dGlsO1xuZXhwb3J0cy5zZXRXZWJHTENvbnRleHQgPSBzZXRXZWJHTENvbnRleHQ7XG5leHBvcnRzLnZlcnNpb25fd2ViZ2wgPSB2ZXJzaW9uO1xuZXhwb3J0cy53ZWJnbCA9IHdlYmdsO1xuZXhwb3J0cy53ZWJnbF91dGlsID0gd2ViZ2xfdXRpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmLWJhY2tlbmQtd2ViZ2wubm9kZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@tensorflow+tfjs-backend-webgl@2.8.6_@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-backend-webgl/dist/tf-backend-webgl.node.js\n");

/***/ })

};
;