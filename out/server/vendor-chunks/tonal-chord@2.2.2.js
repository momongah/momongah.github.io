"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tonal-chord@2.2.2";
exports.ids = ["vendor-chunks/tonal-chord@2.2.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/tonal-chord@2.2.2/node_modules/tonal-chord/build/es5.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/tonal-chord@2.2.2/node_modules/tonal-chord/build/es5.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar tonalNote = __webpack_require__(/*! tonal-note */ \"(ssr)/./node_modules/.pnpm/tonal-note@2.2.2/node_modules/tonal-note/build/es5.js\");\nvar tonalDistance = __webpack_require__(/*! tonal-distance */ \"(ssr)/./node_modules/.pnpm/tonal-distance@2.2.2/node_modules/tonal-distance/build/es5.js\");\nvar tonalDictionary = __webpack_require__(/*! tonal-dictionary */ \"(ssr)/./node_modules/.pnpm/tonal-dictionary@2.2.2/node_modules/tonal-dictionary/build/es5.js\");\nvar tonalPcset = __webpack_require__(/*! tonal-pcset */ \"(ssr)/./node_modules/.pnpm/tonal-pcset@2.2.2/node_modules/tonal-pcset/build/es5.js\");\n\n/**\n * [![npm version](https://img.shields.io/npm/v/tonal-chord.svg)](https://www.npmjs.com/package/tonal-chord)\n * [![tonal](https://img.shields.io/badge/tonal-chord-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-chord` is a collection of functions to manipulate musical chords\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * @example\n * // es6\n * import * as Chord from \"tonal-chord\"\n * // es5\n * const Chord = require(\"tonal-chord\")\n *\n * @example\n * Chord.notes(\"CMaj7\") // => [\"C\", \"E\", \"G\", \"B\"]\n *\n * @module Chord\n */\n\n/**\n * Return the available chord names\n *\n * @function\n * @param {boolean} aliases - true to include aliases\n * @return {Array} the chord names\n *\n * @example\n * Chord.names() // => [\"maj7\", ...]\n */\nvar names = tonalDictionary.chord.names;\n\nvar NO_CHORD = Object.freeze({\n  name: null,\n  names: [],\n  intervals: [],\n  chroma: null,\n  setnum: null\n});\n\nvar properties = function (name) {\n  var intervals = tonalDictionary.chord(name);\n  if (!intervals) { return NO_CHORD; }\n  var s = { intervals: intervals, name: name };\n  s.chroma = tonalPcset.chroma(intervals);\n  s.setnum = parseInt(s.chroma, 2);\n  s.names = tonalDictionary.chord.names(s.chroma);\n  return s;\n};\n\nvar memo = function (fn, cache) {\n  if ( cache === void 0 ) cache = {};\n\n  return function (str) { return cache[str] || (cache[str] = fn(str)); };\n};\n\n/**\n * Get chord properties. It returns an object with:\n *\n * - name: the chord name\n * - names: a list with all possible names (includes the current)\n * - intervals: an array with the chord intervals\n * - chroma:  chord croma (see pcset)\n * - setnum: chord chroma number\n *\n * @function\n * @param {string} name - the chord name (without tonic)\n * @return {Object} an object with the properties or a object with all properties\n * set to null if not valid chord name\n */\nvar props = memo(properties);\n\n/**\n * Get chord intervals. It always returns an array\n *\n * @function\n * @param {string} name - the chord name (optionally a tonic and type)\n * @return {Array<String>} a list of intervals or null if the type is not known\n */\nvar intervals = function (name) { return props(tokenize(name)[1]).intervals; };\n\n/**\n * Get the chord notes of a chord. This function accepts either a chord name\n * (for example: \"Cmaj7\") or a list of notes.\n *\n * It always returns an array, even if the chord is not found.\n *\n * @function\n * @param {string} nameOrTonic - name of the chord or the tonic (if the second parameter is present)\n * @param {string} [name] - (Optional) name if the first parameter is the tonic\n * @return {Array} an array of notes or an empty array\n *\n * @example\n * Chord.notes(\"Cmaj7\") // => [\"C\", \"E\", \"G\", \"B\"]\n * Chord.notes(\"C\", \"maj7\") // => [\"C\", \"E\", \"G\", \"B\"]\n */\nfunction notes(nameOrTonic, name) {\n  if (name) { return props(name).intervals.map(tonalDistance.transpose(nameOrTonic)); }\n  var ref = tokenize(nameOrTonic);\n  var tonic = ref[0];\n  var type = ref[1];\n  return props(type).intervals.map(tonalDistance.transpose(tonic));\n}\n\n/**\n * Check if a given name correspond to a chord in the dictionary\n *\n * @function\n * @param {string} name\n * @return {Boolean}\n * @example\n * Chord.exists(\"CMaj7\") // => true\n * Chord.exists(\"Maj7\") // => true\n * Chord.exists(\"Ablah\") // => false\n */\nvar exists = function (name) { return tonalDictionary.chord(tokenize(name)[1]) !== undefined; };\n\n/**\n * Get all chords names that are a superset of the given one\n * (has the same notes and at least one more)\n *\n * @function\n * @param {string} name\n * @return {Array} a list of chord names\n */\nvar supersets = function (name) {\n  if (!intervals(name).length) { return []; }\n  var isSuperset = tonalPcset.isSupersetOf(intervals(name));\n  return tonalDictionary.chord.names().filter(function (name) { return isSuperset(tonalDictionary.chord(name)); });\n};\n\n/**\n * Find all chords names that are a subset of the given one\n * (has less notes but all from the given chord)\n *\n * @function\n * @param {string} name\n * @return {Array} a list of chord names\n */\nvar subsets = function (name) {\n  var isSubset = tonalPcset.isSubsetOf(intervals(name));\n  return tonalDictionary.chord.names().filter(function (name) { return isSubset(tonalDictionary.chord(name)); });\n};\n\n// 6, 64, 7, 9, 11 and 13 are consider part of the chord\n// (see https://github.com/danigb/tonal/issues/55)\nvar NUM_TYPES = /^(6|64|7|9|11|13)$/;\n/**\n * Tokenize a chord name. It returns an array with the tonic and chord type\n * If not tonic is found, all the name is considered the chord name.\n *\n * This function does NOT check if the chord type exists or not. It only tries\n * to split the tonic and chord type.\n *\n * @function\n * @param {string} name - the chord name\n * @return {Array} an array with [tonic, type]\n * @example\n * Chord.tokenize(\"Cmaj7\") // => [ \"C\", \"maj7\" ]\n * Chord.tokenize(\"C7\") // => [ \"C\", \"7\" ]\n * Chord.tokenize(\"mMaj7\") // => [ \"\", \"mMaj7\" ]\n * Chord.tokenize(\"Cnonsense\") // => [ \"C\", \"nonsense\" ]\n */\nfunction tokenize(name) {\n  var p = tonalNote.tokenize(name);\n  if (p[0] === \"\") { return [\"\", name]; }\n  // aug is augmented (see https://github.com/danigb/tonal/issues/55)\n  if (p[0] === \"A\" && p[3] === \"ug\") { return [\"\", \"aug\"]; }\n\n  if (NUM_TYPES.test(p[2])) {\n    return [p[0] + p[1], p[2] + p[3]];\n  } else {\n    return [p[0] + p[1] + p[2], p[3]];\n  }\n}\n\nexports.names = names;\nexports.props = props;\nexports.intervals = intervals;\nexports.notes = notes;\nexports.exists = exists;\nexports.supersets = supersets;\nexports.subsets = subsets;\nexports.tokenize = tokenize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdG9uYWwtY2hvcmRAMi4yLjIvbm9kZV9tb2R1bGVzL3RvbmFsLWNob3JkL2J1aWxkL2VzNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGdCQUFnQixtQkFBTyxDQUFDLG9HQUFZO0FBQ3BDLG9CQUFvQixtQkFBTyxDQUFDLGdIQUFnQjtBQUM1QyxzQkFBc0IsbUJBQU8sQ0FBQyxzSEFBa0I7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMsdUdBQWE7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGdFQUFnRSxpREFBaUQ7QUFDakg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLCtDQUErQztBQUMvRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2IsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9tb25nYWguZ2l0aHViLmlvLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3RvbmFsLWNob3JkQDIuMi4yL25vZGVfbW9kdWxlcy90b25hbC1jaG9yZC9idWlsZC9lczUuanM/YjY4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0b25hbE5vdGUgPSByZXF1aXJlKCd0b25hbC1ub3RlJyk7XG52YXIgdG9uYWxEaXN0YW5jZSA9IHJlcXVpcmUoJ3RvbmFsLWRpc3RhbmNlJyk7XG52YXIgdG9uYWxEaWN0aW9uYXJ5ID0gcmVxdWlyZSgndG9uYWwtZGljdGlvbmFyeScpO1xudmFyIHRvbmFsUGNzZXQgPSByZXF1aXJlKCd0b25hbC1wY3NldCcpO1xuXG4vKipcbiAqIFshW25wbSB2ZXJzaW9uXShodHRwczovL2ltZy5zaGllbGRzLmlvL25wbS92L3RvbmFsLWNob3JkLnN2ZyldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3RvbmFsLWNob3JkKVxuICogWyFbdG9uYWxdKGh0dHBzOi8vaW1nLnNoaWVsZHMuaW8vYmFkZ2UvdG9uYWwtY2hvcmQteWVsbG93LnN2ZyldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9icm93c2Uva2V5d29yZC90b25hbClcbiAqXG4gKiBgdG9uYWwtY2hvcmRgIGlzIGEgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdG8gbWFuaXB1bGF0ZSBtdXNpY2FsIGNob3Jkc1xuICpcbiAqIFRoaXMgaXMgcGFydCBvZiBbdG9uYWxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3RvbmFsKSBtdXNpYyB0aGVvcnkgbGlicmFyeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gZXM2XG4gKiBpbXBvcnQgKiBhcyBDaG9yZCBmcm9tIFwidG9uYWwtY2hvcmRcIlxuICogLy8gZXM1XG4gKiBjb25zdCBDaG9yZCA9IHJlcXVpcmUoXCJ0b25hbC1jaG9yZFwiKVxuICpcbiAqIEBleGFtcGxlXG4gKiBDaG9yZC5ub3RlcyhcIkNNYWo3XCIpIC8vID0+IFtcIkNcIiwgXCJFXCIsIFwiR1wiLCBcIkJcIl1cbiAqXG4gKiBAbW9kdWxlIENob3JkXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGF2YWlsYWJsZSBjaG9yZCBuYW1lc1xuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtib29sZWFufSBhbGlhc2VzIC0gdHJ1ZSB0byBpbmNsdWRlIGFsaWFzZXNcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgY2hvcmQgbmFtZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogQ2hvcmQubmFtZXMoKSAvLyA9PiBbXCJtYWo3XCIsIC4uLl1cbiAqL1xudmFyIG5hbWVzID0gdG9uYWxEaWN0aW9uYXJ5LmNob3JkLm5hbWVzO1xuXG52YXIgTk9fQ0hPUkQgPSBPYmplY3QuZnJlZXplKHtcbiAgbmFtZTogbnVsbCxcbiAgbmFtZXM6IFtdLFxuICBpbnRlcnZhbHM6IFtdLFxuICBjaHJvbWE6IG51bGwsXG4gIHNldG51bTogbnVsbFxufSk7XG5cbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGludGVydmFscyA9IHRvbmFsRGljdGlvbmFyeS5jaG9yZChuYW1lKTtcbiAgaWYgKCFpbnRlcnZhbHMpIHsgcmV0dXJuIE5PX0NIT1JEOyB9XG4gIHZhciBzID0geyBpbnRlcnZhbHM6IGludGVydmFscywgbmFtZTogbmFtZSB9O1xuICBzLmNocm9tYSA9IHRvbmFsUGNzZXQuY2hyb21hKGludGVydmFscyk7XG4gIHMuc2V0bnVtID0gcGFyc2VJbnQocy5jaHJvbWEsIDIpO1xuICBzLm5hbWVzID0gdG9uYWxEaWN0aW9uYXJ5LmNob3JkLm5hbWVzKHMuY2hyb21hKTtcbiAgcmV0dXJuIHM7XG59O1xuXG52YXIgbWVtbyA9IGZ1bmN0aW9uIChmbiwgY2FjaGUpIHtcbiAgaWYgKCBjYWNoZSA9PT0gdm9pZCAwICkgY2FjaGUgPSB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gY2FjaGVbc3RyXSB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpOyB9O1xufTtcblxuLyoqXG4gKiBHZXQgY2hvcmQgcHJvcGVydGllcy4gSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aDpcbiAqXG4gKiAtIG5hbWU6IHRoZSBjaG9yZCBuYW1lXG4gKiAtIG5hbWVzOiBhIGxpc3Qgd2l0aCBhbGwgcG9zc2libGUgbmFtZXMgKGluY2x1ZGVzIHRoZSBjdXJyZW50KVxuICogLSBpbnRlcnZhbHM6IGFuIGFycmF5IHdpdGggdGhlIGNob3JkIGludGVydmFsc1xuICogLSBjaHJvbWE6ICBjaG9yZCBjcm9tYSAoc2VlIHBjc2V0KVxuICogLSBzZXRudW06IGNob3JkIGNocm9tYSBudW1iZXJcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIGNob3JkIG5hbWUgKHdpdGhvdXQgdG9uaWMpXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9yIGEgb2JqZWN0IHdpdGggYWxsIHByb3BlcnRpZXNcbiAqIHNldCB0byBudWxsIGlmIG5vdCB2YWxpZCBjaG9yZCBuYW1lXG4gKi9cbnZhciBwcm9wcyA9IG1lbW8ocHJvcGVydGllcyk7XG5cbi8qKlxuICogR2V0IGNob3JkIGludGVydmFscy4gSXQgYWx3YXlzIHJldHVybnMgYW4gYXJyYXlcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIGNob3JkIG5hbWUgKG9wdGlvbmFsbHkgYSB0b25pYyBhbmQgdHlwZSlcbiAqIEByZXR1cm4ge0FycmF5PFN0cmluZz59IGEgbGlzdCBvZiBpbnRlcnZhbHMgb3IgbnVsbCBpZiB0aGUgdHlwZSBpcyBub3Qga25vd25cbiAqL1xudmFyIGludGVydmFscyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBwcm9wcyh0b2tlbml6ZShuYW1lKVsxXSkuaW50ZXJ2YWxzOyB9O1xuXG4vKipcbiAqIEdldCB0aGUgY2hvcmQgbm90ZXMgb2YgYSBjaG9yZC4gVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGVpdGhlciBhIGNob3JkIG5hbWVcbiAqIChmb3IgZXhhbXBsZTogXCJDbWFqN1wiKSBvciBhIGxpc3Qgb2Ygbm90ZXMuXG4gKlxuICogSXQgYWx3YXlzIHJldHVybnMgYW4gYXJyYXksIGV2ZW4gaWYgdGhlIGNob3JkIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lT3JUb25pYyAtIG5hbWUgb2YgdGhlIGNob3JkIG9yIHRoZSB0b25pYyAoaWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgcHJlc2VudClcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSAoT3B0aW9uYWwpIG5hbWUgaWYgdGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgdG9uaWNcbiAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBub3RlcyBvciBhbiBlbXB0eSBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBDaG9yZC5ub3RlcyhcIkNtYWo3XCIpIC8vID0+IFtcIkNcIiwgXCJFXCIsIFwiR1wiLCBcIkJcIl1cbiAqIENob3JkLm5vdGVzKFwiQ1wiLCBcIm1hajdcIikgLy8gPT4gW1wiQ1wiLCBcIkVcIiwgXCJHXCIsIFwiQlwiXVxuICovXG5mdW5jdGlvbiBub3RlcyhuYW1lT3JUb25pYywgbmFtZSkge1xuICBpZiAobmFtZSkgeyByZXR1cm4gcHJvcHMobmFtZSkuaW50ZXJ2YWxzLm1hcCh0b25hbERpc3RhbmNlLnRyYW5zcG9zZShuYW1lT3JUb25pYykpOyB9XG4gIHZhciByZWYgPSB0b2tlbml6ZShuYW1lT3JUb25pYyk7XG4gIHZhciB0b25pYyA9IHJlZlswXTtcbiAgdmFyIHR5cGUgPSByZWZbMV07XG4gIHJldHVybiBwcm9wcyh0eXBlKS5pbnRlcnZhbHMubWFwKHRvbmFsRGlzdGFuY2UudHJhbnNwb3NlKHRvbmljKSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBuYW1lIGNvcnJlc3BvbmQgdG8gYSBjaG9yZCBpbiB0aGUgZGljdGlvbmFyeVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICogQ2hvcmQuZXhpc3RzKFwiQ01hajdcIikgLy8gPT4gdHJ1ZVxuICogQ2hvcmQuZXhpc3RzKFwiTWFqN1wiKSAvLyA9PiB0cnVlXG4gKiBDaG9yZC5leGlzdHMoXCJBYmxhaFwiKSAvLyA9PiBmYWxzZVxuICovXG52YXIgZXhpc3RzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRvbmFsRGljdGlvbmFyeS5jaG9yZCh0b2tlbml6ZShuYW1lKVsxXSkgIT09IHVuZGVmaW5lZDsgfTtcblxuLyoqXG4gKiBHZXQgYWxsIGNob3JkcyBuYW1lcyB0aGF0IGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBnaXZlbiBvbmVcbiAqIChoYXMgdGhlIHNhbWUgbm90ZXMgYW5kIGF0IGxlYXN0IG9uZSBtb3JlKVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0FycmF5fSBhIGxpc3Qgb2YgY2hvcmQgbmFtZXNcbiAqL1xudmFyIHN1cGVyc2V0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaW50ZXJ2YWxzKG5hbWUpLmxlbmd0aCkgeyByZXR1cm4gW107IH1cbiAgdmFyIGlzU3VwZXJzZXQgPSB0b25hbFBjc2V0LmlzU3VwZXJzZXRPZihpbnRlcnZhbHMobmFtZSkpO1xuICByZXR1cm4gdG9uYWxEaWN0aW9uYXJ5LmNob3JkLm5hbWVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpc1N1cGVyc2V0KHRvbmFsRGljdGlvbmFyeS5jaG9yZChuYW1lKSk7IH0pO1xufTtcblxuLyoqXG4gKiBGaW5kIGFsbCBjaG9yZHMgbmFtZXMgdGhhdCBhcmUgYSBzdWJzZXQgb2YgdGhlIGdpdmVuIG9uZVxuICogKGhhcyBsZXNzIG5vdGVzIGJ1dCBhbGwgZnJvbSB0aGUgZ2l2ZW4gY2hvcmQpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7QXJyYXl9IGEgbGlzdCBvZiBjaG9yZCBuYW1lc1xuICovXG52YXIgc3Vic2V0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBpc1N1YnNldCA9IHRvbmFsUGNzZXQuaXNTdWJzZXRPZihpbnRlcnZhbHMobmFtZSkpO1xuICByZXR1cm4gdG9uYWxEaWN0aW9uYXJ5LmNob3JkLm5hbWVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpc1N1YnNldCh0b25hbERpY3Rpb25hcnkuY2hvcmQobmFtZSkpOyB9KTtcbn07XG5cbi8vIDYsIDY0LCA3LCA5LCAxMSBhbmQgMTMgYXJlIGNvbnNpZGVyIHBhcnQgb2YgdGhlIGNob3JkXG4vLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5pZ2IvdG9uYWwvaXNzdWVzLzU1KVxudmFyIE5VTV9UWVBFUyA9IC9eKDZ8NjR8N3w5fDExfDEzKSQvO1xuLyoqXG4gKiBUb2tlbml6ZSBhIGNob3JkIG5hbWUuIEl0IHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgdG9uaWMgYW5kIGNob3JkIHR5cGVcbiAqIElmIG5vdCB0b25pYyBpcyBmb3VuZCwgYWxsIHRoZSBuYW1lIGlzIGNvbnNpZGVyZWQgdGhlIGNob3JkIG5hbWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIE5PVCBjaGVjayBpZiB0aGUgY2hvcmQgdHlwZSBleGlzdHMgb3Igbm90LiBJdCBvbmx5IHRyaWVzXG4gKiB0byBzcGxpdCB0aGUgdG9uaWMgYW5kIGNob3JkIHR5cGUuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBjaG9yZCBuYW1lXG4gKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgd2l0aCBbdG9uaWMsIHR5cGVdXG4gKiBAZXhhbXBsZVxuICogQ2hvcmQudG9rZW5pemUoXCJDbWFqN1wiKSAvLyA9PiBbIFwiQ1wiLCBcIm1hajdcIiBdXG4gKiBDaG9yZC50b2tlbml6ZShcIkM3XCIpIC8vID0+IFsgXCJDXCIsIFwiN1wiIF1cbiAqIENob3JkLnRva2VuaXplKFwibU1hajdcIikgLy8gPT4gWyBcIlwiLCBcIm1NYWo3XCIgXVxuICogQ2hvcmQudG9rZW5pemUoXCJDbm9uc2Vuc2VcIikgLy8gPT4gWyBcIkNcIiwgXCJub25zZW5zZVwiIF1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemUobmFtZSkge1xuICB2YXIgcCA9IHRvbmFsTm90ZS50b2tlbml6ZShuYW1lKTtcbiAgaWYgKHBbMF0gPT09IFwiXCIpIHsgcmV0dXJuIFtcIlwiLCBuYW1lXTsgfVxuICAvLyBhdWcgaXMgYXVnbWVudGVkIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RhbmlnYi90b25hbC9pc3N1ZXMvNTUpXG4gIGlmIChwWzBdID09PSBcIkFcIiAmJiBwWzNdID09PSBcInVnXCIpIHsgcmV0dXJuIFtcIlwiLCBcImF1Z1wiXTsgfVxuXG4gIGlmIChOVU1fVFlQRVMudGVzdChwWzJdKSkge1xuICAgIHJldHVybiBbcFswXSArIHBbMV0sIHBbMl0gKyBwWzNdXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3BbMF0gKyBwWzFdICsgcFsyXSwgcFszXV07XG4gIH1cbn1cblxuZXhwb3J0cy5uYW1lcyA9IG5hbWVzO1xuZXhwb3J0cy5wcm9wcyA9IHByb3BzO1xuZXhwb3J0cy5pbnRlcnZhbHMgPSBpbnRlcnZhbHM7XG5leHBvcnRzLm5vdGVzID0gbm90ZXM7XG5leHBvcnRzLmV4aXN0cyA9IGV4aXN0cztcbmV4cG9ydHMuc3VwZXJzZXRzID0gc3VwZXJzZXRzO1xuZXhwb3J0cy5zdWJzZXRzID0gc3Vic2V0cztcbmV4cG9ydHMudG9rZW5pemUgPSB0b2tlbml6ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/tonal-chord@2.2.2/node_modules/tonal-chord/build/es5.js\n");

/***/ })

};
;