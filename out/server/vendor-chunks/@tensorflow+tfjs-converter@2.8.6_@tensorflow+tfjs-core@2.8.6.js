"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tensorflow+tfjs-converter@2.8.6_@tensorflow+tfjs-core@2.8.6";
exports.ids = ["vendor-chunks/@tensorflow+tfjs-converter@2.8.6_@tensorflow+tfjs-core@2.8.6"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@tensorflow+tfjs-converter@2.8.6_@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-converter/dist/tf-converter.node.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tensorflow+tfjs-converter@2.8.6_@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-converter/dist/tf-converter.node.js ***!
  \***********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar tfOps = __webpack_require__(/*! @tensorflow/tfjs-core */ \"(ssr)/./node_modules/.pnpm/@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-core/dist/tf-core.node.js\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n/** DataType enum. */\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"DT_INVALID\"] = 0] = \"DT_INVALID\";\n    DataType[DataType[\"DT_FLOAT\"] = 1] = \"DT_FLOAT\";\n    DataType[DataType[\"DT_DOUBLE\"] = 2] = \"DT_DOUBLE\";\n    DataType[DataType[\"DT_INT32\"] = 3] = \"DT_INT32\";\n    DataType[DataType[\"DT_UINT8\"] = 4] = \"DT_UINT8\";\n    DataType[DataType[\"DT_INT16\"] = 5] = \"DT_INT16\";\n    DataType[DataType[\"DT_INT8\"] = 6] = \"DT_INT8\";\n    DataType[DataType[\"DT_STRING\"] = 7] = \"DT_STRING\";\n    DataType[DataType[\"DT_COMPLEX64\"] = 8] = \"DT_COMPLEX64\";\n    DataType[DataType[\"DT_INT64\"] = 9] = \"DT_INT64\";\n    DataType[DataType[\"DT_BOOL\"] = 10] = \"DT_BOOL\";\n    DataType[DataType[\"DT_QINT8\"] = 11] = \"DT_QINT8\";\n    DataType[DataType[\"DT_QUINT8\"] = 12] = \"DT_QUINT8\";\n    DataType[DataType[\"DT_QINT32\"] = 13] = \"DT_QINT32\";\n    DataType[DataType[\"DT_BFLOAT16\"] = 14] = \"DT_BFLOAT16\";\n    DataType[DataType[\"DT_FLOAT_REF\"] = 101] = \"DT_FLOAT_REF\";\n    DataType[DataType[\"DT_DOUBLE_REF\"] = 102] = \"DT_DOUBLE_REF\";\n    DataType[DataType[\"DT_INT32_REF\"] = 103] = \"DT_INT32_REF\";\n    DataType[DataType[\"DT_UINT8_REF\"] = 104] = \"DT_UINT8_REF\";\n    DataType[DataType[\"DT_INT16_REF\"] = 105] = \"DT_INT16_REF\";\n    DataType[DataType[\"DT_INT8_REF\"] = 106] = \"DT_INT8_REF\";\n    DataType[DataType[\"DT_STRING_REF\"] = 107] = \"DT_STRING_REF\";\n    DataType[DataType[\"DT_COMPLEX64_REF\"] = 108] = \"DT_COMPLEX64_REF\";\n    DataType[DataType[\"DT_INT64_REF\"] = 109] = \"DT_INT64_REF\";\n    DataType[DataType[\"DT_BOOL_REF\"] = 110] = \"DT_BOOL_REF\";\n    DataType[DataType[\"DT_QINT8_REF\"] = 111] = \"DT_QINT8_REF\";\n    DataType[DataType[\"DT_QUINT8_REF\"] = 112] = \"DT_QUINT8_REF\";\n    DataType[DataType[\"DT_QINT32_REF\"] = 113] = \"DT_QINT32_REF\";\n    DataType[DataType[\"DT_BFLOAT16_REF\"] = 114] = \"DT_BFLOAT16_REF\";\n})(DataType || (DataType = {}));\nvar SaverDef;\n(function (SaverDef) {\n    /** CheckpointFormatVersion enum. */\n    var CheckpointFormatVersion;\n    (function (CheckpointFormatVersion) {\n        CheckpointFormatVersion[CheckpointFormatVersion[\"LEGACY\"] = 0] = \"LEGACY\";\n        CheckpointFormatVersion[CheckpointFormatVersion[\"V1\"] = 1] = \"V1\";\n        CheckpointFormatVersion[CheckpointFormatVersion[\"V2\"] = 2] = \"V2\";\n    })(CheckpointFormatVersion = SaverDef.CheckpointFormatVersion || (SaverDef.CheckpointFormatVersion = {}));\n})(SaverDef || (SaverDef = {}));\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar CUSTOM_OPS = {};\n/**\n * Register an Op for graph model executor. This allow you to register\n * TensorFlow custom op or override existing op.\n *\n * Here is an example of registering a new MatMul Op.\n * ```js\n * const customMatmul = (node) =>\n *    tf.matMul(\n *        node.inputs[0], node.inputs[1],\n *        node.attrs['transpose_a'], node.attrs['transpose_b']);\n *\n * tf.registerOp('MatMul', customMatmul);\n * ```\n * The inputs and attrs of the node object is based on the TensorFlow op\n * registry.\n *\n * @param name The Tensorflow Op name.\n * @param opFunc An op function which is called with the current graph node\n * during execution and needs to return a tensor or a list of tensors. The node\n * has the following attributes:\n *    - attr: A map from attribute name to its value\n *    - inputs: A list of input tensors\n *\n * @doc {heading: 'Models', subheading: 'Op Registry'}\n */\nfunction registerOp(name, opFunc) {\n    var opMapper = {\n        tfOpName: name,\n        category: 'custom',\n        inputs: [],\n        attrs: [],\n        customExecutor: opFunc\n    };\n    CUSTOM_OPS[name] = opMapper;\n}\n/**\n * Retrieve the OpMapper object for the registered op.\n *\n * @param name The Tensorflow Op name.\n *\n * @doc {heading: 'Models', subheading: 'Op Registry'}\n */\nfunction getRegisteredOp(name) {\n    return CUSTOM_OPS[name];\n}\n/**\n * Deregister the Op for graph model executor.\n *\n * @param name The Tensorflow Op name.\n *\n * @doc {heading: 'Models', subheading: 'Op Registry'}\n */\nfunction deregisterOp(name) {\n    delete CUSTOM_OPS[name];\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction getParamValue(paramName, node, tensorMap, context, resourceManager) {\n    var inputParam = node.inputParams[paramName];\n    if (inputParam && inputParam.inputIndexStart !== undefined) {\n        var start = inputParam.inputIndexStart;\n        var end = inputParam.inputIndexEnd === 0 ?\n            undefined :\n            (inputParam.inputIndexEnd === undefined ? start + 1 :\n                inputParam.inputIndexEnd);\n        if (inputParam.type === 'tensor') {\n            return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);\n        }\n        if (inputParam.type === 'tensors') {\n            var inputs = node.inputNames.slice(start, end);\n            return inputs.map(function (name) { return getTensor(name, tensorMap, context, resourceManager); });\n        }\n        var tensor = getTensor(node.inputNames.slice(start)[0], tensorMap, context, resourceManager);\n        var data = tensor.dataSync();\n        return inputParam.type === 'number' ?\n            data[0] :\n            tfOps.util.toNestedArray(tensor.shape, data);\n    }\n    var attrParam = node.attrParams[paramName];\n    return attrParam && attrParam.value;\n}\n/**\n * Retrieve the tensor from tensorsMap based on input name.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n * @param context contains tensors and information for running the current node.\n * @param resourceManager Optional. Contains global resources of the model.\n */\nfunction getTensor(name, tensorsMap, context, resourceManager) {\n    var _a = __read(parseNodeName(name), 2), nodeName = _a[0], index = _a[1];\n    if (resourceManager != null) {\n        var tensor = resourceManager.getHashTableHandleByName(nodeName);\n        if (tensor != null) {\n            return tensor;\n        }\n    }\n    var contextId = context.currentContextIds.find(function (contextId) {\n        return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n    });\n    return contextId !== undefined ?\n        tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] :\n        undefined;\n}\n/**\n * Retrieve the tensors based on input name for current context.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\nfunction getTensorsForCurrentContenxt(name, tensorsMap, context) {\n    return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n/**\n * Returns the node name and index from the Node input name.\n * @param inputName The input name of the node, in format of\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\n * default to 0.\n */\nfunction getNodeNameAndIndex(inputName, context) {\n    var _a = __read(parseNodeName(inputName), 2), nodeName = _a[0], index = _a[1];\n    return [\n        getNodeNameWithContextId(nodeName, context && context.currentContextId),\n        index\n    ];\n}\nfunction getNodeNameWithContextId(name, contextId) {\n    return !!contextId ? name + \"-\" + contextId : name;\n}\nfunction parseNodeName(name) {\n    var parts = name.split(':');\n    if (parts.length === 1) {\n        return [name, 0];\n    }\n    var nodeName = parts[0];\n    return [nodeName, Number(parts[parts.length - 1])];\n}\nfunction getPadding(node, tensorMap, context) {\n    var pad = getParamValue('pad', node, tensorMap, context);\n    if (pad === 'explicit') {\n        // This is 1d array, we need to convert it to 2d array\n        pad = getParamValue('explicitPaddings', node, tensorMap, context);\n        var explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];\n        for (var i = 0; i < 4; i++) {\n            explicitPadding[i][0] = pad[i * 2];\n            explicitPadding[i][1] = pad[i * 2 + 1];\n        }\n        return explicitPadding;\n    }\n    return pad;\n}\n/**\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\n *  internally they use a tensor as the id for TensorArray and TensorList, and\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\n * These id tensors have been marked as kept in the backend, we need avoid clone\n * them in order to create new Tensor.id.\n * @param tensor\n */\nfunction cloneTensor(tensor) {\n    return tensor.kept ? tensor : tfOps.clone(tensor);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json = [\n    {\n        'tfOpName': 'Add',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'AddV2',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'AddN',\n        'category': 'arithmetic',\n        'inputs': [{ 'start': 0, 'end': 0, 'name': 'tensors', 'type': 'tensors' }]\n    },\n    {\n        'tfOpName': 'BiasAdd',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Sub',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'RealDiv',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Div',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'DivNoNan',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'FloorDiv',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Mul',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Maximum',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' }\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Minimum',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' }\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Pow',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'SquaredDifference',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Mod',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'FloorMod',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'T',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }]\n    }\n];\n\nvar arithmetic = {\n    __proto__: null,\n    json: json\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$1 = [\n    {\n        'tfOpName': 'Abs',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Acos',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Asin',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Atan',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Atan2',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'y', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Ceil',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'ClipByValue',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'clipValueMin', 'type': 'number' },\n            { 'start': 2, 'name': 'clipValueMax', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Complex',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'real', 'type': 'tensor' },\n            { 'start': 1, 'name': 'imag', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'ComplexAbs',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Cos',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Cosh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Elu',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Exp',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Floor',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Log',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Imag',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }, {\n                'tfName': 'Tout',\n                'name': 'outputType',\n                'type': 'dtype',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Neg',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Real',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }, {\n                'tfName': 'Tout',\n                'name': 'outputType',\n                'type': 'dtype',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Prelu',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'alpha', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Relu',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Relu6',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Selu',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Sigmoid',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Sin',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Sinh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Sqrt',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Rsqrt',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Square',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Tan',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Tanh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Sign',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Round',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Expm1',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Log1p',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Reciprocal',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Softplus',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Asinh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Acosh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Atanh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Erf',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Prod',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axes', 'type': 'number[]' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'keep_dims',\n                'name': 'keepDims',\n                'type': 'bool',\n                'notSupported': true\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'LeakyRelu',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'alpha',\n                'name': 'alpha',\n                'type': 'number',\n                'defaultValue': 0.2\n            },\n            {\n                'tfName': 'T',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }\n        ]\n    }\n];\n\nvar basicMath = {\n    __proto__: null,\n    json: json$1\n};\n\nvar json$2 = [\n    {\n        'tfOpName': 'EmptyTensorList',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'elementShape', 'type': 'shape' },\n            { 'start': 1, 'name': 'maxNumElements', 'type': 'number' },\n        ],\n        'attrs': [{ 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'LoopCond',\n        'category': 'control',\n        'inputs': [{ 'start': 0, 'name': 'pred', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'Switch',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'data', 'type': 'tensor' },\n            { 'start': 1, 'name': 'pred', 'type': 'tensor' }\n        ]\n    },\n    {\n        'tfOpName': 'Merge',\n        'category': 'control',\n        'inputs': [{ 'start': 0, 'end': 0, 'name': 'tensors', 'type': 'tensors' }]\n    },\n    {\n        'tfOpName': 'Enter',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true },\n            { 'tfName': 'frame_name', 'name': 'frameName', 'type': 'string' },\n            { 'tfName': 'is_constant', 'name': 'isConstant', 'type': 'bool' }\n        ]\n    },\n    {\n        'tfOpName': 'Exit',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'NextIteration',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArrayV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'size', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' },\n            { 'tfName': 'element_shape', 'name': 'elementShape', 'type': 'shape' },\n            { 'tfName': 'dynamic_size', 'name': 'dynamicSize', 'type': 'bool' },\n            { 'tfName': 'clear_after_read', 'name': 'clearAfterRead', 'type': 'bool' },\n            {\n                'tfName': 'identical_element_shapes',\n                'name': 'identicalElementShapes',\n                'type': 'bool'\n            },\n            { 'tfName': 'tensor_array_name', 'name': 'name', 'type': 'string' }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArrayWriteV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'index', 'type': 'number' },\n            { 'start': 2, 'name': 'tensor', 'type': 'tensor' },\n            { 'start': 3, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArrayReadV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'index', 'type': 'number' },\n            { 'start': 2, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [{\n                'tfName': 'dtype',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }]\n    },\n    {\n        'tfOpName': 'TensorArrayGatherV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'indices', 'type': 'number[]' },\n            { 'start': 2, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' },\n            { 'tfName': 'element_shape', 'name': 'elementShape', 'type': 'shape' }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArrayScatterV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'indices', 'type': 'number[]' },\n            { 'start': 2, 'name': 'tensor', 'type': 'tensor' },\n            { 'start': 3, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorArrayConcatV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' }, {\n                'tfName': 'element_shape_except0',\n                'name': 'elementShapeExcept0',\n                'type': 'shape',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArraySplitV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'tensor', 'type': 'tensor' },\n            { 'start': 2, 'name': 'lengths', 'type': 'number[]' },\n            { 'start': 3, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorArraySizeV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'flowIn', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArrayCloseV3',\n        'category': 'control',\n        'inputs': [{ 'start': 0, 'name': 'tensorArrayId', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'StatelessIf',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'cond', 'type': 'tensor' },\n            { 'start': 1, 'end': 0, 'name': 'args', 'type': 'tensors' }\n        ],\n        'attrs': [\n            { 'tfName': 'then_branch', 'name': 'thenBranch', 'type': 'func' },\n            { 'tfName': 'else_branch', 'name': 'elseBranch', 'type': 'func' }\n        ]\n    },\n    {\n        'tfOpName': 'If',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'cond', 'type': 'tensor' },\n            { 'start': 1, 'end': 0, 'name': 'args', 'type': 'tensors' }\n        ],\n        'attrs': [\n            { 'tfName': 'then_branch', 'name': 'thenBranch', 'type': 'func' },\n            { 'tfName': 'else_branch', 'name': 'elseBranch', 'type': 'func' }\n        ]\n    },\n    {\n        'tfOpName': 'StatelessWhile',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'end': 0, 'name': 'args', 'type': 'tensors' },\n        ],\n        'attrs': [\n            { 'tfName': 'cond', 'name': 'cond', 'type': 'func' },\n            { 'tfName': 'body', 'name': 'body', 'type': 'func' }\n        ]\n    },\n    {\n        'tfOpName': 'While',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'end': 0, 'name': 'args', 'type': 'tensors' },\n        ],\n        'attrs': [\n            { 'tfName': 'cond', 'name': 'cond', 'type': 'func' },\n            { 'tfName': 'body', 'name': 'body', 'type': 'func' }\n        ]\n    },\n    {\n        'tfOpName': 'TensorListScatter',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n            { 'start': 1, 'name': 'indices', 'type': 'number[]' },\n            { 'start': 2, 'name': 'elementShape', 'type': 'shape' }\n        ],\n        'attrs': [{ 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorListScatterV2',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n            { 'start': 1, 'name': 'indices', 'type': 'number[]' },\n            { 'start': 2, 'name': 'elementShape', 'type': 'shape' },\n            { 'start': 3, 'name': 'numElements', 'type': 'number' },\n        ],\n        'attrs': [{ 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorListGather',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorListId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'indices', 'type': 'number[]' },\n            { 'start': 2, 'name': 'elementShape', 'type': 'shape' },\n        ],\n        'attrs': [{ 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorListGetItem',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorListId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'index', 'type': 'number' },\n            { 'start': 2, 'name': 'elementShape', 'type': 'shape' },\n        ],\n        'attrs': [{ 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorListSetItem',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorListId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'index', 'type': 'number' },\n            { 'start': 2, 'name': 'tensor', 'type': 'tensor' },\n        ],\n        'attrs': [{ 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorListReserve',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'elementShape', 'type': 'shape' },\n            { 'start': 1, 'name': 'numElements', 'type': 'number' },\n        ],\n        'attrs': [{ 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorListFromTensor',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n            { 'start': 1, 'name': 'elementShape', 'type': 'shape' }\n        ],\n        'attrs': [{ 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorListStack',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorListId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'elementShape', 'type': 'shape' },\n        ],\n        'attrs': [\n            { 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' },\n            { 'tfName': 'num_elements', 'name': 'numElements', 'type': 'dtype' }\n        ]\n    },\n    {\n        'tfOpName': 'TensorListSplit',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n            { 'start': 1, 'name': 'elementShape', 'type': 'shape' },\n            { 'start': 2, 'name': 'lengths', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorListConcat',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorListId', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'element_shape', 'name': 'elementShape', 'type': 'shape' },\n            { 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }\n        ]\n    },\n    {\n        'tfOpName': 'TensorListPopBack',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorListId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'elementShape', 'type': 'shape' },\n        ],\n        'attrs': [{ 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorListPushBack',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorListId', 'type': 'tensor' },\n            { 'start': 1, 'name': 'tensor', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'element_dtype', 'name': 'elementDType', 'type': 'dtype' }\n        ]\n    }\n];\n\nvar control = {\n    __proto__: null,\n    json: json$2\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$3 = [\n    {\n        'tfOpName': 'AvgPool',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            },\n            { 'tfName': 'ksize', 'name': 'kernelSize', 'type': 'number[]' },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'MaxPool',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            },\n            { 'tfName': 'ksize', 'name': 'kernelSize', 'type': 'number[]' }, {\n                'tfName': 'explicit_paddings',\n                'name': 'explicitPaddings',\n                'type': 'number[]',\n                'defaultValue': [],\n                'notSupported': true\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'MaxPoolWithArgmax',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' },\n            { 'tfName': 'ksize', 'name': 'kernelSize', 'type': 'number[]' }, {\n                'tfName': 'include_batch_in_index',\n                'name': 'includeBatchInIndex',\n                'type': 'bool'\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'AvgPool3D',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            },\n            { 'tfName': 'ksize', 'name': 'kernelSize', 'type': 'number[]' },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'MaxPool3D',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            },\n            { 'tfName': 'ksize', 'name': 'kernelSize', 'type': 'number[]' },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Conv1D',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'stride', 'name': 'stride', 'type': 'number' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'defaultValue': 'NWC'\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }, {\n                'tfName': 'dilation',\n                'name': 'dilation',\n                'type': 'number',\n                'defaultValue': 1\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Conv2D',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true },\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' },\n            { 'tfName': 'useCudnnOnGpu', 'name': 'useCudnnOnGpu', 'type': 'bool' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'defaultValue': 'NHWC'\n            },\n            {\n                'tfName': 'explicit_paddings',\n                'name': 'explicitPaddings',\n                'type': 'number[]',\n                'defaultValue': []\n            },\n            { 'tfName': 'dilations', 'name': 'dilations', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': '_FusedConv2D',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n            { 'start': 2, end: 0, 'name': 'args', 'type': 'tensors' },\n        ],\n        'attrs': [\n            { 'tfName': 'num_args', 'name': 'numArgs', 'type': 'number' },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true },\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'explicit_paddings',\n                'name': 'explicitPaddings',\n                'type': 'number[]',\n                'defaultValue': []\n            },\n            {\n                'tfName': 'use_cudnn_on_gpu',\n                'name': 'useCudnnOnGpu',\n                'type': 'bool',\n                'defaultValue': true\n            },\n            {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'defaultValue': 'NHWC'\n            },\n            {\n                'tfName': 'dilations',\n                'name': 'dilations',\n                'type': 'number[]',\n                'defaultValue': [1, 1, 1, 1]\n            },\n            {\n                'tfName': 'fused_ops',\n                'name': 'fusedOps',\n                'type': 'string[]',\n                'defaultValue': []\n            },\n            {\n                'tfName': 'epsilon',\n                'name': 'epsilon',\n                'type': 'number',\n                'defaultValue': 0.0001\n            },\n            {\n                'tfName': 'leakyrelu_alpha',\n                'name': 'leakyreluAlpha',\n                'type': 'number'\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Conv2DBackpropInput',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 2, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n            { 'start': 0, 'name': 'outputShape', 'type': 'number[]' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            },\n            {\n                'tfName': 'explicit_paddings',\n                'name': 'explicitPaddings',\n                'type': 'number[]',\n                'defaultValue': []\n            },\n            {\n                'tfName': 'dilations',\n                'name': 'dilations',\n                'type': 'number[]',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'DepthwiseConv2d',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'input', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'defaultValue': 'NHWC'\n            },\n            {\n                'tfName': 'explicit_paddings',\n                'name': 'explicitPaddings',\n                'type': 'number[]',\n                'defaultValue': []\n            },\n            { 'tfName': 'dilations', 'name': 'dilations', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'DepthwiseConv2dNative',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'input', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'defaultValue': 'NHWC'\n            },\n            {\n                'tfName': 'explicit_paddings',\n                'name': 'explicitPaddings',\n                'type': 'number[]',\n                'defaultValue': []\n            },\n            { 'tfName': 'dilations', 'name': 'dilations', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'FusedDepthwiseConv2dNative',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n            { 'start': 2, end: 0, 'name': 'args', 'type': 'tensors' },\n        ],\n        'attrs': [\n            { 'tfName': 'num_args', 'name': 'numArgs', 'type': 'number' },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true },\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'defaultValue': 'NHWC'\n            },\n            {\n                'tfName': 'dilations',\n                'name': 'dilations',\n                'type': 'number[]',\n                'defaultValue': [1, 1, 1, 1]\n            },\n            {\n                'tfName': 'fused_ops',\n                'name': 'fusedOps',\n                'type': 'string[]',\n                'defaultValue': []\n            },\n            {\n                'tfName': 'explicit_paddings',\n                'name': 'explicitPaddings',\n                'type': 'number[]',\n                'defaultValue': []\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Conv3D',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'defaultValue': 'NHWC'\n            },\n            { 'tfName': 'dilations', 'name': 'dilations', 'type': 'number[]' }\n        ],\n    },\n    {\n        'tfOpName': 'Dilation2D',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'rates', 'name': 'dilations', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }\n        ]\n    }\n];\n\nvar convolution = {\n    __proto__: null,\n    json: json$3\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$4 = [\n    {\n        'tfOpName': 'Fill',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'shape', 'type': 'number[]' },\n            { 'start': 1, 'name': 'value', 'type': 'number' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'LinSpace',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'start', 'type': 'number' },\n            { 'start': 1, 'name': 'stop', 'type': 'number' },\n            { 'start': 2, 'name': 'num', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'OneHot',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'indices', 'type': 'tensor' },\n            { 'start': 1, 'name': 'depth', 'type': 'number' },\n            { 'start': 2, 'name': 'onValue', 'type': 'number', 'defaultValue': 1 },\n            { 'start': 3, 'name': 'offValue', 'type': 'number', 'defaultValue': 0 },\n        ],\n        'attrs': [\n            {\n                'tfName': 'axis',\n                'name': 'axis',\n                'type': 'number',\n                'notSupported': true\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Ones',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'shape', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'OnesLike',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [{ 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'RandomUniform',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'shape', 'type': 'number[]' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'minval',\n                'name': 'minval',\n                'type': 'number',\n                'defaultValue': 0\n            },\n            {\n                'tfName': 'maxval',\n                'name': 'maxval',\n                'type': 'number',\n                'defaultValue': 1\n            },\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' },\n            { 'tfName': 'seed', 'name': 'seed', 'type': 'number', 'defaultValue': 0 }, {\n                'tfName': 'seed2',\n                'name': 'seed2',\n                'type': 'number',\n                'defaultValue': 0,\n                'notSupported': true\n            },\n            { 'tfName': 'T', 'name': 'T', 'type': 'number', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Range',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'start', 'type': 'number' },\n            { 'start': 1, 'name': 'stop', 'type': 'number' },\n            { 'start': 2, 'name': 'step', 'type': 'number', 'defaultValue': 0 },\n        ],\n        'attrs': [{ 'tfName': 'Tidx', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TruncatedNormal',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'shape', 'type': 'number[]' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'means',\n                'name': 'mean',\n                'type': 'number',\n                'defaultValue': 0.0\n            },\n            {\n                'tfName': 'stddev',\n                'name': 'stdDev',\n                'type': 'number',\n                'defaultValue': 1.0\n            },\n            { 'tfName': 'seed', 'name': 'seed', 'type': 'number' }, {\n                'tfName': 'seed2',\n                'name': 'seed2',\n                'type': 'number',\n                'defaultValue': 0,\n                'notSupported': true\n            },\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' },\n            { 'tfName': 'T', 'name': 'T', 'type': 'number', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Zeros',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'shape', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'ZerosLike',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'Multinomial',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'logits', 'type': 'tensor' },\n            { 'start': 1, 'name': 'numSamples', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'seed', 'name': 'seed', 'type': 'number' },\n            { 'tfName': 'seed2', 'name': 'seed2', 'type': 'number' },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' },\n            { 'tfName': 'output_dtype', 'name': 'output_dtype', 'type': 'dtype' }\n        ]\n    }\n];\n\nvar creation = {\n    __proto__: null,\n    json: json$4\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$5 = [\n    {\n        'tfOpName': 'NonMaxSuppressionV2',\n        'category': 'dynamic',\n        'inputs': [\n            { 'start': 0, 'name': 'boxes', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scores', 'type': 'tensor' },\n            { 'start': 2, 'name': 'maxOutputSize', 'type': 'number' },\n            { 'start': 3, 'name': 'iouThreshold', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'NonMaxSuppressionV3',\n        'category': 'dynamic',\n        'inputs': [\n            { 'start': 0, 'name': 'boxes', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scores', 'type': 'tensor' },\n            { 'start': 2, 'name': 'maxOutputSize', 'type': 'number' },\n            { 'start': 3, 'name': 'iouThreshold', 'type': 'number' },\n            { 'start': 4, 'name': 'scoreThreshold', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'NonMaxSuppressionV4',\n        'category': 'dynamic',\n        'inputs': [\n            { 'start': 0, 'name': 'boxes', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scores', 'type': 'tensor' },\n            { 'start': 2, 'name': 'maxOutputSize', 'type': 'number' },\n            { 'start': 3, 'name': 'iouThreshold', 'type': 'number' },\n            { 'start': 4, 'name': 'scoreThreshold', 'type': 'number' }\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }, {\n                'tfName': 'T_threshold',\n                'name': 'threshold',\n                'type': 'dtype',\n                'notSupported': true\n            },\n            {\n                'tfName': 'pad_to_max_output_size',\n                'name': 'padToMaxOutputSize',\n                'type': 'bool'\n            }\n        ]\n    },\n    {\n        'tfOpName': 'NonMaxSuppressionV5',\n        'category': 'dynamic',\n        'inputs': [\n            { 'start': 0, 'name': 'boxes', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scores', 'type': 'tensor' },\n            { 'start': 2, 'name': 'maxOutputSize', 'type': 'number' },\n            { 'start': 3, 'name': 'iouThreshold', 'type': 'number' },\n            { 'start': 4, 'name': 'scoreThreshold', 'type': 'number' },\n            { 'start': 5, 'name': 'softNmsSigma', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'Where',\n        'category': 'dynamic',\n        'inputs': [\n            { 'start': 0, 'name': 'condition', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'ListDiff',\n        'category': 'dynamic',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'y', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'T',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }]\n    }\n];\n\nvar dynamic = {\n    __proto__: null,\n    json: json$5\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$6 = [\n    {\n        'tfOpName': 'TopKV2',\n        'category': 'evaluation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'k', 'type': 'number' },\n        ],\n        'attrs': [{ 'tfName': 'sorted', 'name': 'sorted', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'Unique',\n        'category': 'evaluation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n    },\n    {\n        'tfOpName': 'UniqueV2',\n        'category': 'evaluation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number' },\n        ],\n    },\n];\n\nvar evaluation = {\n    __proto__: null,\n    json: json$6\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$7 = [\n    {\n        'tfOpName': 'PlaceholderWithDefault',\n        'category': 'graph',\n        'inputs': [\n            { 'start': 0, 'name': 'default', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'shape', 'name': 'shape', 'type': 'shape' },\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' }\n        ]\n    },\n    {\n        'tfOpName': 'Placeholder',\n        'category': 'graph',\n        'attrs': [\n            { 'tfName': 'shape', 'name': 'shape', 'type': 'shape' },\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' }\n        ]\n    },\n    { 'tfOpName': 'Const', 'category': 'graph' }, {\n        'tfOpName': 'Identity',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'IdentityN',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'end': 0, 'name': 'x', 'type': 'tensors' }]\n    },\n    {\n        'tfOpName': 'Snapshot',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'Rank',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'Size',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'Shape',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'ShapeN',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'end': 0, 'name': 'x', 'type': 'tensors' }]\n    },\n    {\n        'tfOpName': 'Print',\n        'category': 'graph',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'data', 'type': 'tensors' },\n        ],\n        'attrs': [\n            { 'tfName': 'message', 'name': 'message', 'type': 'string' }, {\n                'tfName': 'first_n',\n                'name': 'firstN',\n                'type': 'number',\n                'notSupported': true\n            },\n            {\n                'tfName': 'summarize',\n                'name': 'summarize',\n                'type': 'number',\n                'defaultValue': 3\n            }\n        ]\n    },\n    { 'tfOpName': 'NoOp', 'category': 'graph', 'inputs': [] }, {\n        'tfOpName': 'StopGradient',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'FakeQuantWithMinMaxVars',\n        'category': 'graph',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'min', 'name': 'min', 'type': 'number' },\n            { 'tfName': 'max', 'name': 'max', 'type': 'number' }\n        ]\n    }\n];\n\nvar graph = {\n    __proto__: null,\n    json: json$7\n};\n\nvar json$8 = [\n    {\n        'tfOpName': 'HashTable',\n        'category': 'hash_table',\n        'inputs': [],\n        'attrs': [\n            { 'tfName': 'shared_name', 'name': 'sharedName', 'type': 'string' },\n            {\n                'tfName': 'use_node_name_sharing',\n                'name': 'useNodeNameSharing',\n                'type': 'bool'\n            },\n            { 'tfName': 'key_dtype', 'name': 'keyDType', 'type': 'dtype' },\n            { 'tfName': 'value_dtype', 'name': 'valueDType', 'type': 'dtype' },\n        ]\n    },\n    {\n        'tfOpName': 'HashTableV2',\n        'category': 'hash_table',\n        'inputs': [],\n        'attrs': [\n            { 'tfName': 'shared_name', 'name': 'sharedName', 'type': 'string' },\n            {\n                'tfName': 'use_node_name_sharing',\n                'name': 'useNodeNameSharing',\n                'type': 'bool'\n            },\n            { 'tfName': 'key_dtype', 'name': 'keyDType', 'type': 'dtype' },\n            { 'tfName': 'value_dtype', 'name': 'valueDType', 'type': 'dtype' },\n        ]\n    },\n    {\n        'tfOpName': 'LookupTableImport',\n        'category': 'hash_table',\n        'inputs': [\n            { 'start': 0, 'name': 'tableHandle', 'type': 'tensor' },\n            { 'start': 1, 'name': 'keys', 'type': 'tensor' },\n            { 'start': 2, 'name': 'values', 'type': 'tensor' }\n        ],\n        'attrs': [\n            { 'tfName': 'Tin', 'name': 'tIn', 'type': 'dtype', 'notSupported': true }, {\n                'tfName': 'Tout',\n                'name': 'tOut',\n                'type': 'dtype',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'LookupTableImportV2',\n        'category': 'hash_table',\n        'inputs': [\n            { 'start': 0, 'name': 'tableHandle', 'type': 'tensor' },\n            { 'start': 1, 'name': 'keys', 'type': 'tensor' },\n            { 'start': 2, 'name': 'values', 'type': 'tensor' }\n        ],\n        'attrs': [\n            { 'tfName': 'Tin', 'name': 'tIn', 'type': 'dtype', 'notSupported': true }, {\n                'tfName': 'Tout',\n                'name': 'tOut',\n                'type': 'dtype',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'LookupTableFind',\n        'category': 'hash_table',\n        'inputs': [\n            { 'start': 0, 'name': 'tableHandle', 'type': 'tensor' },\n            { 'start': 1, 'name': 'keys', 'type': 'tensor' },\n            { 'start': 2, 'name': 'defaultValue', 'type': 'tensor' }\n        ],\n        'attrs': [\n            { 'tfName': 'Tin', 'name': 'tIn', 'type': 'dtype', 'notSupported': true }, {\n                'tfName': 'Tout',\n                'name': 'tOut',\n                'type': 'dtype',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'LookupTableFindV2',\n        'category': 'hash_table',\n        'inputs': [\n            { 'start': 0, 'name': 'tableHandle', 'type': 'tensor' },\n            { 'start': 1, 'name': 'keys', 'type': 'tensor' },\n            { 'start': 2, 'name': 'defaultValue', 'type': 'tensor' }\n        ],\n        'attrs': [\n            { 'tfName': 'Tin', 'name': 'tIn', 'type': 'dtype', 'notSupported': true }, {\n                'tfName': 'Tout',\n                'name': 'tOut',\n                'type': 'dtype',\n                'notSupported': true\n            }\n        ]\n    }\n];\n\nvar hashTable = {\n    __proto__: null,\n    json: json$8\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$9 = [\n    {\n        'tfOpName': 'ResizeBilinear',\n        'category': 'image',\n        'inputs': [\n            { 'start': 0, 'name': 'images', 'type': 'tensor' },\n            { 'start': 1, 'name': 'size', 'type': 'number[]' },\n        ],\n        'attrs': [\n            { 'tfName': 'align_corners', 'name': 'alignCorners', 'type': 'bool' }, {\n                'tfName': 'half_pixel_centers',\n                'name': 'halfPixelCenters',\n                'type': 'bool'\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'ResizeNearestNeighbor',\n        'category': 'image',\n        'inputs': [\n            { 'start': 0, 'name': 'images', 'type': 'tensor' },\n            { 'start': 1, 'name': 'size', 'type': 'number[]' },\n        ],\n        'attrs': [\n            { 'tfName': 'align_corners', 'name': 'alignCorners', 'type': 'bool' }, {\n                'tfName': 'half_pixel_centers',\n                'name': 'halfPixelCenters',\n                'type': 'bool'\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'CropAndResize',\n        'category': 'image',\n        'inputs': [\n            { 'start': 0, 'name': 'image', 'type': 'tensor' },\n            { 'start': 1, 'name': 'boxes', 'type': 'tensor' },\n            { 'start': 2, 'name': 'boxInd', 'type': 'tensor' },\n            { 'start': 3, 'name': 'cropSize', 'type': 'number[]' },\n        ],\n        'attrs': [\n            { 'tfName': 'method', 'name': 'method', 'type': 'string' }, {\n                'tfName': 'extrapolation_value',\n                'name': 'extrapolationValue',\n                'type': 'number'\n            }\n        ]\n    }\n];\n\nvar image = {\n    __proto__: null,\n    json: json$9\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$a = [\n    {\n        'tfOpName': 'Equal',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'NotEqual',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Greater',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'GreaterEqual',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Less',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'LessEqual',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'LogicalAnd',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'LogicalNot',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'LogicalOr',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Select',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'condition', 'type': 'tensor' },\n            { 'start': 1, 'name': 'a', 'type': 'tensor' },\n            { 'start': 2, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'SelectV2',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'condition', 'type': 'tensor' },\n            { 'start': 1, 'name': 'a', 'type': 'tensor' },\n            { 'start': 2, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'T',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }]\n    }\n];\n\nvar logical = {\n    __proto__: null,\n    json: json$a\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$b = [\n    {\n        'tfOpName': '_FusedMatMul',\n        'category': 'matrices',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n            { 'start': 2, end: 0, 'name': 'args', 'type': 'tensors' },\n        ],\n        'attrs': [\n            { 'tfName': 'num_args', 'name': 'numArgs', 'type': 'number' }, {\n                'tfName': 'fused_ops',\n                'name': 'fusedOps',\n                'type': 'string[]',\n                'defaultValue': []\n            },\n            {\n                'tfName': 'epsilon',\n                'name': 'epsilon',\n                'type': 'number',\n                'defaultValue': 0.0001\n            },\n            {\n                'tfName': 'transpose_a',\n                'name': 'transposeA',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            {\n                'tfName': 'transpose_b',\n                'name': 'transposeB',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'MatMul',\n        'category': 'matrices',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'transpose_a',\n                'name': 'transposeA',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            {\n                'tfName': 'transpose_b',\n                'name': 'transposeB',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'BatchMatMul',\n        'category': 'matrices',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'adj_x',\n                'name': 'transposeA',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            {\n                'tfName': 'adj_y',\n                'name': 'transposeB',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'BatchMatMulV2',\n        'category': 'matrices',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'adj_x',\n                'name': 'transposeA',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            {\n                'tfName': 'adj_y',\n                'name': 'transposeB',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Transpose',\n        'category': 'matrices',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'perm', 'type': 'number[]' },\n        ],\n        'attrs': [{\n                'tfName': 'T',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }]\n    }\n];\n\nvar matrices = {\n    __proto__: null,\n    json: json$b\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$c = [\n    {\n        'tfOpName': 'FusedBatchNorm',\n        'category': 'normalization',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scale', 'type': 'tensor' },\n            { 'start': 2, 'name': 'offset', 'type': 'tensor' },\n            { 'start': 3, 'name': 'mean', 'type': 'tensor' },\n            { 'start': 4, 'name': 'variance', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'epsilon',\n                'name': 'epsilon',\n                'type': 'number',\n                'defaultValue': 0.001\n            },\n            {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'FusedBatchNormV2',\n        'category': 'normalization',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scale', 'type': 'tensor' },\n            { 'start': 2, 'name': 'offset', 'type': 'tensor' },\n            { 'start': 3, 'name': 'mean', 'type': 'tensor' },\n            { 'start': 4, 'name': 'variance', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'epsilon',\n                'name': 'epsilon',\n                'type': 'number',\n                'defaultValue': 0.001\n            },\n            {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'FusedBatchNormV3',\n        'category': 'normalization',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scale', 'type': 'tensor' },\n            { 'start': 2, 'name': 'offset', 'type': 'tensor' },\n            { 'start': 3, 'name': 'mean', 'type': 'tensor' },\n            { 'start': 4, 'name': 'variance', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'epsilon',\n                'name': 'epsilon',\n                'type': 'number',\n                'defaultValue': 0.001\n            },\n            {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'LRN',\n        'category': 'normalization',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'depth_radius',\n                'name': 'radius',\n                'type': 'number',\n                'defaultValue': 5\n            },\n            { 'tfName': 'bias', 'name': 'bias', 'type': 'number', 'defaultValue': 1.0 },\n            {\n                'tfName': 'alpha',\n                'name': 'alpha',\n                'type': 'number',\n                'defaultValue': 1.0\n            },\n            {\n                'tfName': 'beta',\n                'name': 'beta',\n                'type': 'number',\n                'defaultValue': 0.5\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Softmax',\n        'category': 'normalization',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'LogSoftmax',\n        'category': 'normalization',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'SparseToDense',\n        'category': 'normalization',\n        'inputs': [\n            { 'start': 0, 'name': 'sparseIndices', 'type': 'tensor' },\n            { 'start': 1, 'name': 'outputShape', 'type': 'number[]' },\n            { 'start': 2, 'name': 'sparseValues', 'type': 'tensor' },\n            { 'start': 3, 'name': 'defaultValue', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'validate_indices',\n                'name': 'validateIndices',\n                'type': 'bool',\n                'defaultValue': true,\n                'notSupported': true\n            }]\n    }\n];\n\nvar normalization = {\n    __proto__: null,\n    json: json$c\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$d = [\n    {\n        'tfOpName': 'Bincount',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'size', 'type': 'number' },\n            { 'start': 2, 'name': 'weights', 'type': 'tensor' }\n        ]\n    },\n    {\n        'tfOpName': 'DenseBincount',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'size', 'type': 'number' },\n            { 'start': 2, 'name': 'weights', 'type': 'tensor' }\n        ],\n        'attrs': [{ 'tfName': 'binary_output', 'name': 'binaryOutput', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'Max',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'Mean',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'Min',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'Sum',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'All',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'Any',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'ArgMax',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'ArgMin',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'Prod',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'Cumsum',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'exclusive', 'name': 'exclusive', 'type': 'bool' },\n            { 'tfName': 'reverse', 'name': 'reverse', 'type': 'bool' }\n        ]\n    }\n];\n\nvar reduction = {\n    __proto__: null,\n    json: json$d\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$e = [\n    {\n        'tfOpName': 'ConcatV2',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'end': -1, 'name': 'tensors', 'type': 'tensors' },\n            { 'start': -1, 'name': 'axis', 'type': 'number' }\n        ],\n        'attrs': [{ 'tfName': 'N', 'name': 'n', 'type': 'number', 'defaultValue': 2 }]\n    },\n    {\n        'tfOpName': 'Concat',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 1, 'end': 0, 'name': 'tensors', 'type': 'tensors' },\n            { 'start': 0, 'name': 'axis', 'type': 'number' }\n        ],\n        'attrs': [{ 'tfName': 'N', 'name': 'n', 'type': 'number', 'defaultValue': 2 }]\n    },\n    {\n        'tfOpName': 'GatherV2',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'indices', 'type': 'tensor' },\n            { 'start': 2, 'name': 'axis', 'type': 'number', 'defaultValue': 0 }\n        ],\n        'attrs': [{\n                'tfName': 'batch_dims',\n                'name': 'batchDims',\n                'type': 'number',\n                'defaultValue': 0\n            }]\n    },\n    {\n        'tfOpName': 'Gather',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'indices', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'validate_indices',\n                'name': 'validateIndices',\n                'type': 'bool',\n                'notSupported': true\n            }]\n    },\n    {\n        'tfOpName': 'Reverse',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'dims', 'type': 'bool[]' }\n        ]\n    },\n    {\n        'tfOpName': 'ReverseV2',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'Slice',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'begin', 'type': 'number[]' },\n            { 'start': 2, 'name': 'size', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'StridedSlice',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'begin', 'type': 'number[]' },\n            { 'start': 2, 'name': 'end', 'type': 'number[]' },\n            { 'start': 3, 'name': 'strides', 'type': 'number[]' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'begin_mask',\n                'name': 'beginMask',\n                'type': 'number',\n                'defaultValue': 0\n            },\n            {\n                'tfName': 'end_mask',\n                'name': 'endMask',\n                'type': 'number',\n                'defaultValue': 0\n            },\n            {\n                'tfName': 'new_axis_mask',\n                'name': 'newAxisMask',\n                'type': 'number',\n                'defaultValue': 0\n            },\n            {\n                'tfName': 'ellipsis_mask',\n                'name': 'ellipsisMask',\n                'type': 'number',\n                'defaultValue': 0\n            },\n            {\n                'tfName': 'shrink_axis_mask',\n                'name': 'shrinkAxisMask',\n                'type': 'number',\n                'defaultValue': 0\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Pack',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'end': 0, 'name': 'tensors', 'type': 'tensors' },\n        ],\n        'attrs': [\n            { 'tfName': 'axis', 'name': 'axis', 'type': 'number', 'defaultValue': 0 }\n        ]\n    },\n    {\n        'tfOpName': 'Unpack',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'axis', 'name': 'axis', 'type': 'number', 'defaultValue': 0 }, {\n                'tfName': 'num',\n                'name': 'num',\n                'type': 'number',\n                'defaultValue': 0,\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Tile',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'reps', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'Split',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'axis', 'type': 'number', 'defaultValue': 0 },\n            { 'start': 1, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'num_split',\n                'name': 'numOrSizeSplits',\n                'type': 'number',\n                'defaultValue': 1\n            }]\n    },\n    {\n        'tfOpName': 'SplitV',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'numOrSizeSplits', 'type': 'number[]' },\n            { 'start': 2, 'name': 'axis', 'type': 'number', 'defaultValue': 0 }\n        ]\n    },\n    {\n        'tfOpName': 'ScatterNd',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'indices', 'type': 'tensor' },\n            { 'start': 1, 'name': 'values', 'type': 'tensor' },\n            { 'start': 2, 'name': 'shape', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'GatherNd',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'indices', 'type': 'tensor' }\n        ]\n    },\n    {\n        'tfOpName': 'SparseToDense',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'sparseIndices', 'type': 'tensor' },\n            { 'start': 1, 'name': 'outputShape', 'type': 'number[]' },\n            { 'start': 2, 'name': 'sparseValues', 'type': 'tensor' },\n            { 'start': 3, 'name': 'defaultValue', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'validate_indices',\n                'name': 'validateIndices',\n                'type': 'bool',\n                'defaultValue': false,\n                'notSupported': true\n            }]\n    }\n];\n\nvar sliceJoin = {\n    __proto__: null,\n    json: json$e\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$f = [\n    {\n        'tfOpName': 'FFT',\n        'category': 'spectral',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'IFFT',\n        'category': 'spectral',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'RFFT',\n        'category': 'spectral',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' }, {\n                'start': 1,\n                'name': 'fft_length',\n                'type': 'number',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'IRFFT',\n        'category': 'spectral',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' }, {\n                'start': 1,\n                'name': 'fft_length',\n                'type': 'number',\n                'notSupported': true\n            }\n        ]\n    }\n];\n\nvar spectral = {\n    __proto__: null,\n    json: json$f\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar json$g = [\n    {\n        'tfOpName': 'Cast',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'SrcT',\n                'name': 'sdtype',\n                'type': 'dtype',\n                'notSupported': true\n            },\n            { 'tfName': 'DstT', 'name': 'dtype', 'type': 'dtype' }\n        ]\n    },\n    {\n        'tfOpName': 'ExpandDims',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'MirrorPad',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'padding', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'mode', 'name': 'mode', 'type': 'string' }]\n    },\n    {\n        'tfOpName': 'Pad',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'padding', 'type': 'number[]' },\n        ],\n        'attrs': [{\n                'tfName': 'constant_value',\n                'name': 'constantValue',\n                'type': 'number',\n                'defaultValue': 0\n            }]\n    },\n    {\n        'tfOpName': 'PadV2',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'padding', 'type': 'number[]' }, {\n                'start': 2,\n                'name': 'constantValue',\n                'type': 'number',\n                'defaultValue': 0\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Reshape',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'shape', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'Squeeze',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'axis',\n                'tfDeprecatedName': 'squeeze_dims',\n                'name': 'axis',\n                'type': 'number[]'\n            }]\n    },\n    {\n        'tfOpName': 'SpaceToBatchND',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'blockShape', 'type': 'number[]' },\n            { 'start': 2, 'name': 'paddings', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'BatchToSpaceND',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'blockShape', 'type': 'number[]' },\n            { 'start': 2, 'name': 'crops', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'DepthToSpace',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'block_size', 'name': 'blockSize', 'type': 'number' },\n            { 'tfName': 'data_format', 'name': 'dataFormat', 'type': 'string' }\n        ]\n    },\n    {\n        'tfOpName': 'BroadcastTo',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'shape', 'type': 'number[]' },\n        ],\n        'attrs': []\n    }\n];\n\nvar transformation = {\n    __proto__: null,\n    json: json$g\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar OperationMapper = /** @class */ (function () {\n    // Loads the op mapping from the JSON file.\n    function OperationMapper() {\n        var ops = [\n            arithmetic, basicMath, control, convolution, creation, dynamic,\n            evaluation, logical, image, graph, matrices, normalization, reduction,\n            sliceJoin, spectral, transformation, hashTable\n        ];\n        var mappersJson = [].concat.apply([], __spread(ops.map(function (op) { return op.json; })));\n        this.opMappers = mappersJson.reduce(function (map, mapper) {\n            map[mapper.tfOpName] = mapper;\n            return map;\n        }, {});\n    }\n    Object.defineProperty(OperationMapper, \"Instance\", {\n        // Singleton instance for the mapper\n        get: function () {\n            return this._instance || (this._instance = new this());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Converts the model inference graph from Tensorflow GraphDef to local\n    // representation for TensorFlow.js API\n    OperationMapper.prototype.transformGraph = function (graph, signature) {\n        var _this = this;\n        if (signature === void 0) { signature = {}; }\n        var tfNodes = graph.node;\n        var placeholders = [];\n        var weights = [];\n        var initNodes = [];\n        var nodes = tfNodes.reduce(function (map, node) {\n            map[node.name] = _this.mapNode(node);\n            if (node.op.startsWith('Placeholder')) {\n                placeholders.push(map[node.name]);\n            }\n            else if (node.op === 'Const') {\n                weights.push(map[node.name]);\n            }\n            else if (node.input == null || node.input.length === 0) {\n                initNodes.push(map[node.name]);\n            }\n            return map;\n        }, {});\n        var inputs = [];\n        var outputs = [];\n        var inputNodeNameToKey = {};\n        var outputNodeNameToKey = {};\n        if (signature != null) {\n            inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n            outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n        }\n        var allNodes = Object.keys(nodes);\n        allNodes.forEach(function (key) {\n            var node = nodes[key];\n            node.inputNames.forEach(function (name) {\n                var _a = __read(getNodeNameAndIndex(name), 1), nodeName = _a[0];\n                node.inputs.push(nodes[nodeName]);\n                nodes[nodeName].children.push(node);\n            });\n        });\n        // if signature has not outputs set, add any node that does not have\n        // outputs.\n        if (Object.keys(outputNodeNameToKey).length === 0) {\n            allNodes.forEach(function (key) {\n                var node = nodes[key];\n                if (node.children.length === 0) {\n                    outputs.push(node);\n                }\n            });\n        }\n        else {\n            Object.keys(outputNodeNameToKey).forEach(function (name) {\n                var _a = __read(getNodeNameAndIndex(name), 1), nodeName = _a[0];\n                var node = nodes[nodeName];\n                if (node != null) {\n                    node.signatureKey = outputNodeNameToKey[name];\n                    outputs.push(node);\n                }\n            });\n        }\n        if (Object.keys(inputNodeNameToKey).length > 0) {\n            Object.keys(inputNodeNameToKey).forEach(function (name) {\n                var _a = __read(getNodeNameAndIndex(name), 1), nodeName = _a[0];\n                var node = nodes[nodeName];\n                if (node) {\n                    node.signatureKey = inputNodeNameToKey[name];\n                    inputs.push(node);\n                }\n            });\n        }\n        else {\n            inputs = placeholders;\n        }\n        var functions = {};\n        if (graph.library != null && graph.library.function != null) {\n            functions = graph.library.function.reduce(function (functions, func) {\n                functions[func.signature.name] = _this.mapFunction(func);\n                return functions;\n            }, {});\n        }\n        var result = { nodes: nodes, inputs: inputs, outputs: outputs, weights: weights, placeholders: placeholders, signature: signature, functions: functions };\n        if (initNodes.length > 0) {\n            result.initNodes = initNodes;\n        }\n        return result;\n    };\n    OperationMapper.prototype.mapSignatureEntries = function (entries) {\n        return Object.keys(entries || {})\n            .reduce(function (prev, curr) {\n            prev[entries[curr].name] = curr;\n            return prev;\n        }, {});\n    };\n    OperationMapper.prototype.mapNode = function (node) {\n        // Unsupported ops will cause an error at run-time (not parse time), since\n        // they may not be used by the actual execution subgraph.\n        var mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};\n        if (node.attr == null) {\n            node.attr = {};\n        }\n        var newNode = {\n            name: node.name,\n            op: node.op,\n            category: mapper.category,\n            inputNames: (node.input ||\n                []).map(function (input) { return input.startsWith('^') ? input.substr(1) : input; }),\n            inputs: [],\n            children: [],\n            inputParams: {},\n            attrParams: {},\n            rawAttrs: node.attr\n        };\n        if (mapper.inputs != null) {\n            newNode.inputParams =\n                mapper.inputs.reduce(function (map, param) {\n                    map[param.name] = {\n                        type: param.type,\n                        inputIndexStart: param.start,\n                        inputIndexEnd: param.end\n                    };\n                    return map;\n                }, {});\n        }\n        if (mapper.attrs != null) {\n            newNode.attrParams =\n                mapper.attrs.reduce(function (map, param) {\n                    var type = param.type;\n                    var value = undefined;\n                    switch (param.type) {\n                        case 'string':\n                            value = getStringParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'string[]':\n                            value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'number':\n                            value = getNumberParam(node.attr, param.tfName, (param.defaultValue || 0));\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'number[]':\n                            value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'bool':\n                            value = getBoolParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'bool[]':\n                            value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'shape':\n                            value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'shape[]':\n                            value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'dtype':\n                            value = getDtypeParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'dtype[]':\n                            value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'func':\n                            value = getFuncParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'tensor':\n                        case 'tensors':\n                            break;\n                        default:\n                            throw new Error(\"Unsupported param type: \" + param.type + \" for op: \" + node.op);\n                    }\n                    map[param.name] = { value: value, type: type };\n                    return map;\n                }, {});\n        }\n        return newNode;\n    };\n    // map the TFunctionDef to TFJS graph object\n    OperationMapper.prototype.mapFunction = function (functionDef) {\n        var _this = this;\n        var tfNodes = functionDef.nodeDef;\n        var placeholders = [];\n        var weights = [];\n        var nodes = {};\n        if (tfNodes != null) {\n            nodes = tfNodes.reduce(function (map, node) {\n                map[node.name] = _this.mapNode(node);\n                if (node.op === 'Const') {\n                    weights.push(map[node.name]);\n                }\n                return map;\n            }, {});\n        }\n        var inputs = [];\n        var outputs = [];\n        functionDef.signature.inputArg.forEach(function (arg) {\n            var _a = __read(getNodeNameAndIndex(arg.name), 1), nodeName = _a[0];\n            var node = {\n                name: nodeName,\n                op: 'Placeholder',\n                inputs: [],\n                inputNames: [],\n                category: 'graph',\n                inputParams: {},\n                attrParams: { dtype: { value: parseDtypeParam(arg.type), type: 'dtype' } },\n                children: []\n            };\n            node.signatureKey = arg.name;\n            inputs.push(node);\n            nodes[nodeName] = node;\n        });\n        var allNodes = Object.keys(nodes);\n        allNodes.forEach(function (key) {\n            var node = nodes[key];\n            node.inputNames.forEach(function (name) {\n                var _a = __read(getNodeNameAndIndex(name), 1), nodeName = _a[0];\n                node.inputs.push(nodes[nodeName]);\n                nodes[nodeName].children.push(node);\n            });\n        });\n        var returnNodeMap = functionDef.ret;\n        functionDef.signature.outputArg.forEach(function (output) {\n            var _a = __read(getNodeNameAndIndex(returnNodeMap[output.name]), 2), nodeName = _a[0], index = _a[1];\n            var node = nodes[nodeName];\n            if (node != null) {\n                node.defaultOutput = index;\n                outputs.push(node);\n            }\n        });\n        var signature = this.mapArgsToSignature(functionDef);\n        return { nodes: nodes, inputs: inputs, outputs: outputs, weights: weights, placeholders: placeholders, signature: signature };\n    };\n    OperationMapper.prototype.mapArgsToSignature = function (functionDef) {\n        var _this = this;\n        return {\n            methodName: functionDef.signature.name,\n            inputs: functionDef.signature.inputArg.reduce(function (map, arg) {\n                map[arg.name] = _this.mapArgToTensorInfo(arg);\n                return map;\n            }, {}),\n            outputs: functionDef.signature.outputArg.reduce(function (map, arg) {\n                map[arg.name] = _this.mapArgToTensorInfo(arg, functionDef.ret);\n                return map;\n            }, {}),\n        };\n    };\n    OperationMapper.prototype.mapArgToTensorInfo = function (arg, nameMap) {\n        var name = arg.name;\n        if (nameMap != null) {\n            name = nameMap[name];\n        }\n        return { name: name, dtype: arg.type };\n    };\n    return OperationMapper;\n}());\nfunction decodeBase64(text) {\n    var global = tfOps.env().global;\n    if (typeof global.atob !== 'undefined') {\n        return global.atob(text);\n    }\n    else if (typeof Buffer !== 'undefined') {\n        return new Buffer(text, 'base64').toString();\n    }\n    else {\n        throw new Error('Unable to decode base64 in this environment. ' +\n            'Missing built-in atob() or Buffer()');\n    }\n}\nfunction parseStringParam(s, keepCase) {\n    var value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n    return keepCase ? value : value.toLowerCase();\n}\nfunction getStringParam(attrs, name, def, keepCase) {\n    if (keepCase === void 0) { keepCase = false; }\n    var param = attrs[name];\n    if (param != null) {\n        return parseStringParam(param.s, keepCase);\n    }\n    return def;\n}\nfunction getBoolParam(attrs, name, def) {\n    var param = attrs[name];\n    return param ? param.b : def;\n}\nfunction getNumberParam(attrs, name, def) {\n    var param = attrs[name] || {};\n    var value = param['i'] != null ? param['i'] : (param['f'] != null ? param['f'] : def);\n    return (typeof value === 'number') ? value : parseInt(value, 10);\n}\nfunction parseDtypeParam(value) {\n    if (typeof (value) === 'string') {\n        // tslint:disable-next-line:no-any\n        value = DataType[value];\n    }\n    switch (value) {\n        case DataType.DT_FLOAT:\n            return 'float32';\n        case DataType.DT_INT32:\n        case DataType.DT_INT64:\n        case DataType.DT_INT8:\n        case DataType.DT_UINT8:\n            return 'int32';\n        case DataType.DT_BOOL:\n            return 'bool';\n        case DataType.DT_DOUBLE:\n            return 'float32';\n        case DataType.DT_STRING:\n            return 'string';\n        default:\n            // Unknown dtype error will happen at runtime (instead of parse time),\n            // since these nodes might not be used by the actual subgraph execution.\n            return null;\n    }\n}\nfunction getFuncParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param && param.func) {\n        return param.func.name;\n    }\n    return def;\n}\nfunction getDtypeParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param && param.type) {\n        return parseDtypeParam(param.type);\n    }\n    return def;\n}\nfunction getDtypeArrayParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param && param.list && param.list.type) {\n        return param.list.type.map(function (v) { return parseDtypeParam(v); });\n    }\n    return def;\n}\nfunction parseTensorShapeParam(shape) {\n    if (shape.unknownRank) {\n        return undefined;\n    }\n    if (shape.dim != null) {\n        return shape.dim.map(function (dim) {\n            return (typeof dim.size === 'number') ? dim.size : parseInt(dim.size, 10);\n        });\n    }\n    return [];\n}\nfunction getTensorShapeParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param && param.shape) {\n        return parseTensorShapeParam(param.shape);\n    }\n    return def;\n}\nfunction getNumericArrayParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param) {\n        return ((param.list.f && param.list.f.length ? param.list.f :\n            param.list.i) ||\n            [])\n            .map(function (v) { return (typeof v === 'number') ? v : parseInt(v, 10); });\n    }\n    return def;\n}\nfunction getStringArrayParam(attrs, name, def, keepCase) {\n    if (keepCase === void 0) { keepCase = false; }\n    var param = attrs[name];\n    if (param && param.list && param.list.s) {\n        return param.list.s.map(function (v) {\n            return parseStringParam(v, keepCase);\n        });\n    }\n    return def;\n}\nfunction getTensorShapeArrayParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param && param.list && param.list.shape) {\n        return param.list.shape.map(function (v) {\n            return parseTensorShapeParam(v);\n        });\n    }\n    return def;\n}\nfunction getBoolArrayParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param && param.list && param.list.b) {\n        return param.list.b;\n    }\n    return def;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Helper class for lookup inputs and params for nodes in the model graph.\n */\nvar NodeValueImpl = /** @class */ (function () {\n    function NodeValueImpl(node, tensorMap, context) {\n        var _this = this;\n        this.node = node;\n        this.tensorMap = tensorMap;\n        this.context = context;\n        this.inputs = [];\n        this.attrs = {};\n        this.inputs = node.inputNames.map(function (name) { return _this.getInput(name); });\n        if (node.rawAttrs != null) {\n            this.attrs = Object.keys(node.rawAttrs)\n                .reduce(function (attrs, key) {\n                attrs[key] = _this.getAttr(key);\n                return attrs;\n            }, {});\n        }\n    }\n    /**\n     * Return the value of the attribute or input param.\n     * @param name String: name of attribute or input param.\n     */\n    NodeValueImpl.prototype.getInput = function (name) {\n        return getTensor(name, this.tensorMap, this.context);\n    };\n    /**\n     * Return the value of the attribute or input param.\n     * @param name String: name of attribute or input param.\n     */\n    NodeValueImpl.prototype.getAttr = function (name, defaultValue) {\n        var value = this.node.rawAttrs[name];\n        if (value.tensor != null) {\n            return getTensor(name, this.tensorMap, this.context);\n        }\n        if (value.i != null || value.f != null) {\n            return getNumberParam(this.node.rawAttrs, name, defaultValue);\n        }\n        if (value.s != null) {\n            return getStringParam(this.node.rawAttrs, name, defaultValue);\n        }\n        if (value.b != null) {\n            return getBoolParam(this.node.rawAttrs, name, defaultValue);\n        }\n        if (value.shape != null) {\n            return getTensorShapeParam(this.node.rawAttrs, name, defaultValue);\n        }\n        if (value.type != null) {\n            return getDtypeParam(this.node.rawAttrs, name, defaultValue);\n        }\n        if (value.list != null) {\n            if (value.list.i != null || value.list.f != null) {\n                return getNumericArrayParam(this.node.rawAttrs, name, defaultValue);\n            }\n            if (value.list.s != null) {\n                return getStringArrayParam(this.node.rawAttrs, name, defaultValue);\n            }\n            if (value.list.shape != null) {\n                return getTensorShapeArrayParam(this.node.rawAttrs, name, defaultValue);\n            }\n            if (value.list.b != null) {\n                return getBoolArrayParam(this.node.rawAttrs, name, defaultValue);\n            }\n            if (value.list.type != null) {\n                return getDtypeArrayParam(this.node.rawAttrs, name, defaultValue);\n            }\n        }\n        return defaultValue;\n    };\n    return NodeValueImpl;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'BiasAdd':\n        case 'AddV2':\n        case 'Add': {\n            return [tfOps.add(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'AddN': {\n            return [tfOps.addN(getParamValue('tensors', node, tensorMap, context))];\n        }\n        case 'FloorMod':\n        case 'Mod':\n            return [tfOps.mod(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        case 'Mul':\n            return [tfOps.mul(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        case 'RealDiv':\n        case 'Div': {\n            return [tfOps.div(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'DivNoNan': {\n            return [tfOps.divNoNan(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'FloorDiv': {\n            return [tfOps.floorDiv(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Sub': {\n            return [tfOps.sub(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Minimum': {\n            return [tfOps.minimum(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Maximum': {\n            return [tfOps.maximum(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Pow': {\n            return [tfOps.pow(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'SquaredDifference': {\n            return [tfOps.squaredDifference(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$1 = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Abs':\n        case 'ComplexAbs':\n            return [tfOps.abs(getParamValue('x', node, tensorMap, context))];\n        case 'Acos':\n            return [tfOps.acos(getParamValue('x', node, tensorMap, context))];\n        case 'Acosh':\n            return [tfOps.acosh(getParamValue('x', node, tensorMap, context))];\n        case 'Asin':\n            return [tfOps.asin(getParamValue('x', node, tensorMap, context))];\n        case 'Asinh':\n            return [tfOps.asinh(getParamValue('x', node, tensorMap, context))];\n        case 'Atan':\n            return [tfOps.atan(getParamValue('x', node, tensorMap, context))];\n        case 'Atan2':\n            return [tfOps.atan2(getParamValue('x', node, tensorMap, context), getParamValue('y', node, tensorMap, context))];\n        case 'Atanh':\n            return [tfOps.atanh(getParamValue('x', node, tensorMap, context))];\n        case 'Ceil':\n            return [tfOps.ceil(getParamValue('x', node, tensorMap, context))];\n        case 'Complex':\n            return [tfOps.complex(getParamValue('real', node, tensorMap, context), getParamValue('imag', node, tensorMap, context))];\n        case 'Cos':\n            return [tfOps.cos(getParamValue('x', node, tensorMap, context))];\n        case 'Cosh':\n            return [tfOps.cosh(getParamValue('x', node, tensorMap, context))];\n        case 'Elu':\n            return [tfOps.elu(getParamValue('x', node, tensorMap, context))];\n        case 'Erf':\n            return [tfOps.erf(getParamValue('x', node, tensorMap, context))];\n        case 'Exp':\n            return [tfOps.exp(getParamValue('x', node, tensorMap, context))];\n        case 'Expm1': {\n            return [tfOps.expm1(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Floor':\n            return [tfOps.floor(getParamValue('x', node, tensorMap, context))];\n        case 'Log':\n            return [tfOps.log(getParamValue('x', node, tensorMap, context))];\n        case 'Log1p': {\n            return [tfOps.log1p(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Imag':\n            return [tfOps.imag(getParamValue('x', node, tensorMap, context))];\n        case 'Neg':\n            return [tfOps.neg(getParamValue('x', node, tensorMap, context))];\n        case 'Reciprocal': {\n            return [tfOps.reciprocal(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Real':\n            return [tfOps.real(getParamValue('x', node, tensorMap, context))];\n        case 'Relu':\n            return [tfOps.relu(getParamValue('x', node, tensorMap, context))];\n        case 'Round': {\n            return [tfOps.round(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Selu':\n            return [tfOps.selu(getParamValue('x', node, tensorMap, context))];\n        case 'Sigmoid':\n            return [tfOps.sigmoid(getParamValue('x', node, tensorMap, context))];\n        case 'Sin':\n            return [tfOps.sin(getParamValue('x', node, tensorMap, context))];\n        case 'Sign': {\n            return [tfOps.sign(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Sinh': {\n            return [tfOps.sinh(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Softplus': {\n            return [tfOps.softplus(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Sqrt': {\n            return [tfOps.sqrt(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Square': {\n            return [tfOps.square(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Tanh': {\n            return [tfOps.tanh(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Tan':\n            return [tfOps.tan(getParamValue('x', node, tensorMap, context))];\n        case 'ClipByValue':\n            return [tfOps.clipByValue(getParamValue('x', node, tensorMap, context), getParamValue('clipValueMin', node, tensorMap, context), getParamValue('clipValueMax', node, tensorMap, context))];\n        case 'Relu6':\n            return [tfOps.relu6(getParamValue('x', node, tensorMap, context))];\n        case 'Rsqrt':\n            return [tfOps.rsqrt(getTensor(node.inputNames[0], tensorMap, context))];\n        case 'Prod':\n            return [tfOps.prod(getParamValue('x', node, tensorMap, context), getParamValue('axes', node, tensorMap, context))];\n        case 'LeakyRelu':\n            return [tfOps.leakyRelu(getParamValue('x', node, tensorMap, context), getParamValue('alpha', node, tensorMap, context))];\n        case 'Prelu':\n            return [tfOps.prelu(getParamValue('x', node, tensorMap, context), getParamValue('alpha', node, tensorMap, context))];\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction assertShapesMatchAllowUndefinedSize(shapeA, shapeB, errorMessagePrefix) {\n    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }\n    tfOps.util.assert(shapesEqualAllowUndefinedSize(shapeA, shapeB), function () { return errorMessagePrefix + (\" Shapes \" + shapeA + \" and \" + shapeB + \" must match\"); });\n}\nfunction shapesEqualAllowUndefinedSize(n1, n2) {\n    if (n1.length !== n2.length) {\n        return false;\n    }\n    for (var i = 0; i < n1.length; i++) {\n        if (n1[i] !== -1 && n2[i] !== -1 && n1[i] !== n2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * The TensorArray object keeps an array of Tensors.  It\n * allows reading from the array and writing to the array.\n */\nvar TensorArray = /** @class */ (function () {\n    function TensorArray(name, dtype, maxSize, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {\n        this.name = name;\n        this.dtype = dtype;\n        this.maxSize = maxSize;\n        this.elementShape = elementShape;\n        this.identicalElementShapes = identicalElementShapes;\n        this.dynamicSize = dynamicSize;\n        this.clearAfterRead = clearAfterRead;\n        this.tensors = [];\n        this.closed_ = false;\n        this.idTensor = tfOps.scalar(0);\n        tfOps.keep(this.idTensor);\n    }\n    Object.defineProperty(TensorArray.prototype, \"id\", {\n        get: function () {\n            return this.idTensor.id;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TensorArray.prototype, \"closed\", {\n        get: function () {\n            return this.closed_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose the tensors and idTensor and mark the TensoryArray as closed.\n     */\n    TensorArray.prototype.clearAndClose = function (keepIds) {\n        this.tensors.forEach(function (tensor) {\n            if (keepIds == null || !keepIds.has(tensor.tensor.id)) {\n                tensor.tensor.dispose();\n            }\n        });\n        this.tensors = [];\n        this.closed_ = true;\n        this.idTensor.dispose();\n    };\n    TensorArray.prototype.size = function () {\n        return this.tensors.length;\n    };\n    /**\n     * Read the value at location index in the TensorArray.\n     * @param index Number the index to read from.\n     */\n    TensorArray.prototype.read = function (index) {\n        if (this.closed_) {\n            throw new Error(\"TensorArray \" + this.name + \" has already been closed.\");\n        }\n        if (index < 0 || index >= this.size()) {\n            throw new Error(\"Tried to read from index \" + index + \", but array size is: \" + this.size());\n        }\n        var tensorWithState = this.tensors[index];\n        if (tensorWithState.cleared) {\n            throw new Error(\"TensorArray \" + this.name + \": Could not read index \" + index + \" twice because it was cleared after a previous read \" +\n                \"(perhaps try setting clear_after_read = false?).\");\n        }\n        if (this.clearAfterRead) {\n            tensorWithState.cleared = true;\n        }\n        tensorWithState.read = true;\n        return tensorWithState.tensor;\n    };\n    /**\n     * Helper method to read multiple tensors from the specified indices.\n     */\n    TensorArray.prototype.readMany = function (indices) {\n        var _this = this;\n        return indices.map(function (index) { return _this.read(index); });\n    };\n    /**\n     * Write value into the index of the TensorArray.\n     * @param index number the index to write to.\n     * @param tensor\n     */\n    TensorArray.prototype.write = function (index, tensor) {\n        if (this.closed_) {\n            throw new Error(\"TensorArray \" + this.name + \" has already been closed.\");\n        }\n        if (index < 0 || !this.dynamicSize && index >= this.maxSize) {\n            throw new Error(\"Tried to write to index \" + index + \", but array is not resizeable and size is: \" + this.maxSize);\n        }\n        var t = this.tensors[index] || {};\n        if (tensor.dtype !== this.dtype) {\n            throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + index + \",\\n          because the value dtype is \" + tensor.dtype + \", but TensorArray dtype is \" + this.dtype + \".\");\n        }\n        // Set the shape for the first time write to unknow shape tensor array\n        if (this.size() === 0 &&\n            (this.elementShape == null || this.elementShape.length === 0)) {\n            this.elementShape = tensor.shape;\n        }\n        assertShapesMatchAllowUndefinedSize(this.elementShape, tensor.shape, \"TensorArray \" + this.name + \": Could not write to TensorArray index \" + index + \".\");\n        if (t.read) {\n            throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + index + \", because it has already been read.\");\n        }\n        if (t.written) {\n            throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + index + \", because it has already been written.\");\n        }\n        t.tensor = tensor;\n        tfOps.keep(tensor);\n        t.written = true;\n        this.tensors[index] = t;\n    };\n    /**\n     * Helper method to write multiple tensors to the specified indices.\n     */\n    TensorArray.prototype.writeMany = function (indices, tensors) {\n        var _this = this;\n        if (indices.length !== tensors.length) {\n            throw new Error(\"TensorArray \" + this.name + \": could not write multiple tensors,\" +\n                (\"because the index size: \" + indices.length + \" is not the same as tensors size: \" + tensors.length + \".\"));\n        }\n        indices.forEach(function (i, index) { return _this.write(i, tensors[index]); });\n    };\n    /**\n     * Return selected values in the TensorArray as a packed Tensor. All of\n     * selected values must have been written and their shapes must all match.\n     * @param [indices] number[] Optional. Taking values in [0, max_value). If the\n     *    TensorArray is not dynamic, max_value=size(). If not specified returns\n     *    all tensors in the original order.\n     * @param [dtype]\n     */\n    TensorArray.prototype.gather = function (indices, dtype) {\n        if (!!dtype && dtype !== this.dtype) {\n            throw new Error(\"TensorArray dtype is \" + this.dtype + \" but gather requested dtype \" + dtype);\n        }\n        if (!indices) {\n            indices = [];\n            for (var i = 0; i < this.size(); i++) {\n                indices.push(i);\n            }\n        }\n        else {\n            indices = indices.slice(0, this.size());\n        }\n        if (indices.length === 0) {\n            return tfOps.tensor([], [0].concat(this.elementShape));\n        }\n        // Read all the PersistentTensors into a vector to keep track of\n        // their memory.\n        var tensors = this.readMany(indices);\n        assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, 'TensorArray shape mismatch: ');\n        return tfOps.stack(tensors, 0);\n    };\n    /**\n     * Return the values in the TensorArray as a concatenated Tensor.\n     */\n    TensorArray.prototype.concat = function (dtype) {\n        if (!!dtype && dtype !== this.dtype) {\n            throw new Error(\"TensorArray dtype is \" + this.dtype + \" but concat requested dtype \" + dtype);\n        }\n        if (this.size() === 0) {\n            return tfOps.tensor([], [0].concat(this.elementShape));\n        }\n        var indices = [];\n        for (var i = 0; i < this.size(); i++) {\n            indices.push(i);\n        }\n        // Collect all the tensors from the tensors array.\n        var tensors = this.readMany(indices);\n        assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, \"TensorArray shape mismatch: tensor array shape (\" + this.elementShape + \") vs first tensor shape (\" + tensors[0].shape + \")\");\n        return tfOps.concat(tensors, 0);\n    };\n    /**\n     * Scatter the values of a Tensor in specific indices of a TensorArray.\n     * @param indices nummber[] values in [0, max_value). If the\n     *    TensorArray is not dynamic, max_value=size().\n     * @param tensor Tensor input tensor.\n     */\n    TensorArray.prototype.scatter = function (indices, tensor) {\n        if (tensor.dtype !== this.dtype) {\n            throw new Error(\"TensorArray dtype is \" + this.dtype + \" but tensor has dtype \" + tensor.dtype);\n        }\n        if (indices.length !== tensor.shape[0]) {\n            throw new Error(\"Expected len(indices) == tensor.shape[0], but saw: \" + indices.length + \" vs. \" + tensor.shape[0]);\n        }\n        var maxIndex = Math.max.apply(Math, __spread(indices));\n        if (!this.dynamicSize && maxIndex >= this.maxSize) {\n            throw new Error(\"Max index must be < array size (\" + maxIndex + \"  vs. \" + this.maxSize + \")\");\n        }\n        this.writeMany(indices, tfOps.unstack(tensor, 0));\n    };\n    /**\n     * Split the values of a Tensor into the TensorArray.\n     * @param length number[] with the lengths to use when splitting value along\n     *    its first dimension.\n     * @param tensor Tensor, the tensor to split.\n     */\n    TensorArray.prototype.split = function (length, tensor) {\n        var _this = this;\n        if (tensor.dtype !== this.dtype) {\n            throw new Error(\"TensorArray dtype is \" + this.dtype + \" but tensor has dtype \" + tensor.dtype);\n        }\n        var totalLength = 0;\n        var cumulativeLengths = length.map(function (len) {\n            totalLength += len;\n            return totalLength;\n        });\n        if (totalLength !== tensor.shape[0]) {\n            throw new Error(\"Expected sum of lengths to be equal to\\n          tensor.shape[0], but sum of lengths is\\n        \" + totalLength + \", and tensor's shape is: \" + tensor.shape);\n        }\n        if (!this.dynamicSize && length.length !== this.maxSize) {\n            throw new Error(\"TensorArray's size is not equal to the size of lengths (\" + this.maxSize + \" vs. \" + length.length + \"), \" +\n                'and the TensorArray is not marked as dynamically resizeable');\n        }\n        var elementPerRow = totalLength === 0 ? 0 : tensor.size / totalLength;\n        var tensors = [];\n        tfOps.tidy(function () {\n            tensor = tfOps.reshape(tensor, [1, totalLength, elementPerRow]);\n            for (var i = 0; i < length.length; ++i) {\n                var previousLength = (i === 0) ? 0 : cumulativeLengths[i - 1];\n                var indices_1 = [0, previousLength, 0];\n                var sizes = [1, length[i], elementPerRow];\n                tensors[i] = tfOps.reshape(tfOps.slice(tensor, indices_1, sizes), _this.elementShape);\n            }\n            return tensors;\n        });\n        var indices = [];\n        for (var i = 0; i < length.length; i++) {\n            indices[i] = i;\n        }\n        this.writeMany(indices, tensors);\n    };\n    return TensorArray;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * TensorList stores a container of `tf.Tensor` objects, which are accessible\n * via tensors field.\n *\n * In order to get a copy of the underlying list, use the copy method:\n * ```\n *    TensorList b = a.copy();\n *    b.tensors().pushBack(t);  // This does not modify a.tensors().\n * ```\n *\n * Note that this is not a deep copy: the memory locations of the underlying\n * tensors will still point to the same locations of the corresponding tensors\n * in the original.\n */\nvar TensorList = /** @class */ (function () {\n    /**\n     *\n     * @param tensors list of tensors\n     * @param elementShape shape of each tensor\n     * @param elementDtype data type of each tensor\n     * @param maxNumElements The maximum allowed size of `tensors`. Defaults to -1\n     *   meaning that the size of `tensors` is unbounded.\n     */\n    function TensorList(tensors, elementShape, elementDtype, maxNumElements) {\n        if (maxNumElements === void 0) { maxNumElements = -1; }\n        this.tensors = tensors;\n        this.elementShape = elementShape;\n        this.elementDtype = elementDtype;\n        if (tensors != null) {\n            tensors.forEach(function (tensor) {\n                if (elementDtype !== tensor.dtype) {\n                    throw new Error(\"Invalid data types; op elements \" + elementDtype + \", but list elements \" + tensor.dtype);\n                }\n                assertShapesMatchAllowUndefinedSize(elementShape, tensor.shape, 'TensorList shape mismatch: ');\n                tfOps.keep(tensor);\n            });\n        }\n        this.idTensor = tfOps.scalar(0);\n        this.maxNumElements = maxNumElements;\n        tfOps.keep(this.idTensor);\n    }\n    Object.defineProperty(TensorList.prototype, \"id\", {\n        get: function () {\n            return this.idTensor.id;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get a new TensorList containing a copy of the underlying tensor container.\n     */\n    TensorList.prototype.copy = function () {\n        return new TensorList(__spread(this.tensors), this.elementShape, this.elementDtype);\n    };\n    /**\n     * Dispose the tensors and idTensor and clear the tensor list.\n     */\n    TensorList.prototype.clearAndClose = function (keepIds) {\n        this.tensors.forEach(function (tensor) {\n            if (keepIds == null || !keepIds.has(tensor.id)) {\n                tensor.dispose();\n            }\n        });\n        this.tensors.length = 0;\n        this.idTensor.dispose();\n    };\n    /**\n     * The size of the tensors in the tensor list.\n     */\n    TensorList.prototype.size = function () {\n        return this.tensors.length;\n    };\n    /**\n     * Return a tensor that stacks a list of rank-R tf.Tensors into one rank-(R+1)\n     * tf.Tensor.\n     * @param elementShape shape of each tensor\n     * @param elementDtype data type of each tensor\n     * @param numElements the number of elements to stack\n     */\n    TensorList.prototype.stack = function (elementShape, elementDtype, numElements) {\n        var _this = this;\n        if (numElements === void 0) { numElements = -1; }\n        if (elementDtype !== this.elementDtype) {\n            throw new Error(\"Invalid data types; op elements \" + elementDtype + \", but list elements \" + this.elementDtype);\n        }\n        if (numElements !== -1 && this.tensors.length !== numElements) {\n            throw new Error(\"Operation expected a list with \" + numElements + \" elements but got a list with \" + this.tensors.length + \" elements.\");\n        }\n        assertShapesMatchAllowUndefinedSize(elementShape, this.elementShape, 'TensorList shape mismatch: ');\n        return tfOps.tidy(function () {\n            var reshapedTensors = _this.tensors.map(function (tensor) { return tfOps.reshape(tensor, elementShape); });\n            return tfOps.stack(reshapedTensors, 0);\n        });\n    };\n    /**\n     * Pop a tensor from the end of the list.\n     * @param elementShape shape of the tensor\n     * @param elementDtype data type of the tensor\n     */\n    TensorList.prototype.popBack = function (elementShape, elementDtype) {\n        if (elementDtype !== this.elementDtype) {\n            throw new Error(\"Invalid data types; op elements \" + elementDtype + \", but list elements \" + this.elementDtype);\n        }\n        if (this.size() === 0) {\n            throw new Error('Trying to pop from an empty list.');\n        }\n        var tensor = this.tensors.pop();\n        assertShapesMatchAllowUndefinedSize(tensor.shape, elementShape, 'TensorList shape mismatch: ');\n        return tfOps.reshape(tensor, elementShape);\n    };\n    /**\n     * Push a tensor to the end of the list.\n     * @param tensor Tensor to be pushed.\n     */\n    TensorList.prototype.pushBack = function (tensor) {\n        if (tensor.dtype !== this.elementDtype) {\n            throw new Error(\"Invalid data types; op elements \" + tensor.dtype + \", but list elements \" + this.elementDtype);\n        }\n        assertShapesMatchAllowUndefinedSize(tensor.shape, this.elementShape, 'TensorList shape mismatch: ');\n        if (this.maxNumElements === this.size()) {\n            throw new Error(\"Trying to push element into a full list.\");\n        }\n        tfOps.keep(tensor);\n        this.tensors.push(tensor);\n    };\n    /**\n     * Update the size of the list.\n     * @param size the new size of the list.\n     */\n    TensorList.prototype.resize = function (size) {\n        if (size < 0) {\n            throw new Error(\"TensorListResize expects size to be non-negative. Got: \" + size);\n        }\n        if (this.maxNumElements !== -1 && size > this.maxNumElements) {\n            throw new Error(\"TensorListResize input size \" + size + \" is greater maxNumElement \" + this.maxNumElements + \".\");\n        }\n        this.tensors.length = size;\n    };\n    /**\n     * Retrieve the element at the provided index\n     * @param elementShape shape of the tensor\n     * @param elementDtype dtype of the tensor\n     * @param elementIndex index of the tensor\n     */\n    TensorList.prototype.getItem = function (elementIndex, elementShape, elementDtype) {\n        if (elementDtype !== this.elementDtype) {\n            throw new Error(\"Invalid data types; op elements \" + elementDtype + \", but list elements \" + this.elementDtype);\n        }\n        if (elementIndex < 0 || elementIndex > this.tensors.length) {\n            throw new Error(\"Trying to access element \" + elementIndex + \" in a list with \" + this.tensors.length + \" elements.\");\n        }\n        if (this.tensors[elementIndex] == null) {\n            throw new Error(\"element at index \" + elementIndex + \" is null.\");\n        }\n        assertShapesMatchAllowUndefinedSize(this.tensors[elementIndex].shape, elementShape, 'TensorList shape mismatch: ');\n        return this.tensors[elementIndex];\n    };\n    /**\n     * Set the tensor at the index\n     * @param elementIndex index of the tensor\n     * @param tensor the tensor to be inserted into the list\n     */\n    TensorList.prototype.setItem = function (elementIndex, tensor) {\n        if (tensor.dtype !== this.elementDtype) {\n            throw new Error(\"Invalid data types; op elements \" + tensor.dtype + \", but list elements \" + this.elementDtype);\n        }\n        if (elementIndex < 0 ||\n            this.maxNumElements !== -1 && elementIndex >= this.maxNumElements) {\n            throw new Error(\"Trying to set element \" + elementIndex + \" in a list with max \" + this.maxNumElements + \" elements.\");\n        }\n        assertShapesMatchAllowUndefinedSize(this.elementShape, tensor.shape, 'TensorList shape mismatch: ');\n        tfOps.keep(tensor);\n        this.tensors[elementIndex] = tensor;\n    };\n    /**\n     * Return selected values in the TensorList as a stacked Tensor. All of\n     * selected values must have been written and their shapes must all match.\n     * @param indices indices of tensors to gather\n     * @param elementDtype output tensor dtype\n     * @param elementShape output tensor element shape\n     */\n    TensorList.prototype.gather = function (indices, elementDtype, elementShape) {\n        var _this = this;\n        if (elementDtype !== this.elementDtype) {\n            throw new Error(\"Invalid data types; op elements \" + elementDtype + \", but list elements \" + this.elementDtype);\n        }\n        assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, 'TensorList shape mismatch: ');\n        // When indices is greater than the size of the list, indices beyond the\n        // size of the list are ignored.\n        indices = indices.slice(0, this.size());\n        if (indices.length === 0) {\n            return tfOps.tensor([], [0].concat(this.elementShape));\n        }\n        return tfOps.tidy(function () {\n            var tensors = indices.map(function (i) { return tfOps.reshape(_this.tensors[i], elementShape); });\n            return tfOps.stack(tensors, 0);\n        });\n    };\n    /**\n     * Return the values in the TensorList as a concatenated Tensor.\n     * @param elementDtype output tensor dtype\n     * @param elementShape output tensor element shape\n     */\n    TensorList.prototype.concat = function (elementDtype, elementShape) {\n        var _this = this;\n        if (!!elementDtype && elementDtype !== this.elementDtype) {\n            throw new Error(\"TensorList dtype is \" + this.elementDtype + \" but concat requested dtype \" + elementDtype);\n        }\n        assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, 'TensorList shape mismatch: ');\n        if (this.size() === 0) {\n            return tfOps.tensor([], [0].concat(this.elementShape));\n        }\n        return tfOps.tidy(function () {\n            var tensors = _this.tensors.map(function (t) { return tfOps.reshape(t, elementShape); });\n            return tfOps.concat(tensors, 0);\n        });\n    };\n    return TensorList;\n}());\n/**\n * Creates a TensorList which, when stacked, has the value of tensor.\n * @param tensor from tensor\n * @param elementShape output tensor element shape\n */\nfunction fromTensor(tensor, elementShape, elementDtype) {\n    var dtype = tensor.dtype;\n    if (tensor.shape.length < 1) {\n        throw new Error(\"Tensor must be at least a vector, but saw shape: \" + tensor.shape);\n    }\n    if (tensor.dtype !== elementDtype) {\n        throw new Error(\"Invalid data types; op elements \" + tensor.dtype + \", but list elements \" + elementDtype);\n    }\n    var outputShape = tensor.shape.slice(1);\n    assertShapesMatchAllowUndefinedSize(outputShape, elementShape, 'TensorList shape mismatch: ');\n    var tensorList = tfOps.unstack(tensor);\n    return new TensorList(tensorList, elementShape, dtype);\n}\n/**\n * Return a TensorList of the given size with empty elements.\n * @param elementShape the shape of the future elements of the list\n * @param elementDtype the desired type of elements in the list\n * @param numElements the number of elements to reserve\n */\nfunction reserve(elementShape, elementDtype, numElements) {\n    return new TensorList([], elementShape, elementDtype, numElements);\n}\n/**\n * Put tensors at specific indices of a stacked tensor into a TensorList.\n * @param indices list of indices on how to scatter the tensor.\n * @param tensor input tensor.\n * @param elementShape the shape of the future elements of the list\n * @param numElements the number of elements to scatter\n */\nfunction scatter(tensor, indices, elementShape, numElements) {\n    if (indices.length !== tensor.shape[0]) {\n        throw new Error(\"Expected len(indices) == tensor.shape[0], but saw: \" + indices.length + \" vs. \" + tensor.shape[0]);\n    }\n    var maxIndex = Math.max.apply(Math, __spread(indices));\n    if (numElements != null && numElements !== -1 && maxIndex >= numElements) {\n        throw new Error(\"Max index must be < array size (\" + maxIndex + \"  vs. \" + numElements + \")\");\n    }\n    var list = new TensorList([], elementShape, tensor.dtype, numElements);\n    var tensors = tfOps.unstack(tensor, 0);\n    indices.forEach(function (value, index) {\n        list.setItem(value, tensors[index]);\n    });\n    return list;\n}\n/**\n * Split the values of a Tensor into a TensorList.\n * @param length the lengths to use when splitting value along\n *    its first dimension.\n * @param tensor the tensor to split.\n * @param elementShape the shape of the future elements of the list\n */\nfunction split(tensor, length, elementShape) {\n    var totalLength = 0;\n    var cumulativeLengths = length.map(function (len) {\n        totalLength += len;\n        return totalLength;\n    });\n    if (totalLength !== tensor.shape[0]) {\n        throw new Error(\"Expected sum of lengths to be equal to\\n          tensor.shape[0], but sum of lengths is\\n        \" + totalLength + \", and tensor's shape is: \" + tensor.shape);\n    }\n    var elementPerRow = totalLength === 0 ? 0 : tensor.size / totalLength;\n    var tensors = tfOps.tidy(function () {\n        var tensors = [];\n        tensor = tfOps.reshape(tensor, [1, totalLength, elementPerRow]);\n        for (var i = 0; i < length.length; ++i) {\n            var previousLength = (i === 0) ? 0 : cumulativeLengths[i - 1];\n            var indices = [0, previousLength, 0];\n            var sizes = [1, length[i], elementPerRow];\n            tensors[i] = tfOps.reshape(tfOps.slice(tensor, indices, sizes), elementShape);\n        }\n        tensor.dispose();\n        return tensors;\n    });\n    var list = new TensorList([], elementShape, tensor.dtype, length.length);\n    for (var i = 0; i < tensors.length; i++) {\n        list.setItem(i, tensors[i]);\n    }\n    return list;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar _this = undefined;\nvar executeOp$2 = function (node, tensorMap, context) { return __awaiter(_this, void 0, void 0, function () {\n    var _a, thenFunc, elseFunc, cond, args, condValue, bodyFunc, condFunc, args, condResult, argIds_1, condValue, result, _loop_1, pred, pred, data, inputName, data, frameId, data, data, data, size, dtype, elementShape, dynamicSize, clearAfterRead, identicalElementShapes, name_1, tensorArray, id, index, writeTensor, writeTensorArray, readId, readIndex, readTensorArray, gatherId, gatherIndices, gatherDtype, gatherTensorArray, scatterId, scatterIndices, scatterTensor, scatterTensorArray, concatId, concatTensorArray, concatDtype, splitId, splitTensor, lengths, splitTensorArray, sizeId, sizeTensorArray, closeId, closeTensorArray, idTensor, index, writeTensor, tensorList, idTensor, readIndex, elementShape, elementDType, tensorList, scatterIndices, scatterTensor, elementShape, numElements, tensorList, elementShape, elementDtype, numElementsParam, numElements, tensorList, gatherId, gatherIndices, elementShape, elementDtype, tensorList, idTensor, elementShape, elementDtype, numElements, tensorList, tensor, elementShape, elementDtype, tensorList, concatId, tensorList, concatDtype, elementShape, idTensor, writeTensor, tensorList, idTensor, elementShape, elementDType, tensorList, splitTensor, elementShape, lengths, tensorList;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                _a = node.op;\n                switch (_a) {\n                    case 'If': return [3 /*break*/, 1];\n                    case 'StatelessIf': return [3 /*break*/, 1];\n                    case 'While': return [3 /*break*/, 3];\n                    case 'StatelessWhile': return [3 /*break*/, 3];\n                    case 'LoopCond': return [3 /*break*/, 9];\n                    case 'Switch': return [3 /*break*/, 10];\n                    case 'Merge': return [3 /*break*/, 12];\n                    case 'Enter': return [3 /*break*/, 13];\n                    case 'Exit': return [3 /*break*/, 14];\n                    case 'NextIteration': return [3 /*break*/, 15];\n                    case 'TensorArrayV3': return [3 /*break*/, 16];\n                    case 'TensorArrayWriteV3': return [3 /*break*/, 17];\n                    case 'TensorArrayReadV3': return [3 /*break*/, 18];\n                    case 'TensorArrayGatherV3': return [3 /*break*/, 19];\n                    case 'TensorArrayScatterV3': return [3 /*break*/, 20];\n                    case 'TensorArrayConcatV3': return [3 /*break*/, 21];\n                    case 'TensorArraySplitV3': return [3 /*break*/, 22];\n                    case 'TensorArraySizeV3': return [3 /*break*/, 23];\n                    case 'TensorArrayCloseV3': return [3 /*break*/, 24];\n                    case 'TensorListSetItem': return [3 /*break*/, 25];\n                    case 'TensorListGetItem': return [3 /*break*/, 26];\n                    case 'TensorListScatterV2': return [3 /*break*/, 27];\n                    case 'TensorListScatter': return [3 /*break*/, 27];\n                    case 'TensorListReserve': return [3 /*break*/, 28];\n                    case 'EmptyTensorList': return [3 /*break*/, 28];\n                    case 'TensorListGather': return [3 /*break*/, 29];\n                    case 'TensorListStack': return [3 /*break*/, 30];\n                    case 'TensorListFromTensor': return [3 /*break*/, 31];\n                    case 'TensorListConcat': return [3 /*break*/, 32];\n                    case 'TensorListPushBack': return [3 /*break*/, 33];\n                    case 'TensorListPopBack': return [3 /*break*/, 34];\n                    case 'TensorListSplit': return [3 /*break*/, 35];\n                }\n                return [3 /*break*/, 36];\n            case 1:\n                thenFunc = getParamValue('thenBranch', node, tensorMap, context);\n                elseFunc = getParamValue('elseBranch', node, tensorMap, context);\n                cond = getParamValue('cond', node, tensorMap, context);\n                args = getParamValue('args', node, tensorMap, context);\n                return [4 /*yield*/, cond.data()];\n            case 2:\n                condValue = _b.sent();\n                if (condValue[0]) {\n                    return [2 /*return*/, context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap)];\n                }\n                else {\n                    return [2 /*return*/, context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap)];\n                }\n            case 3:\n                bodyFunc = getParamValue('body', node, tensorMap, context);\n                condFunc = getParamValue('cond', node, tensorMap, context);\n                args = getParamValue('args', node, tensorMap, context);\n                return [4 /*yield*/, context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap)];\n            case 4:\n                condResult = (_b.sent());\n                argIds_1 = args.map(function (tensor) { return tensor.id; });\n                return [4 /*yield*/, condResult[0].data()];\n            case 5:\n                condValue = _b.sent();\n                // Dispose the intermediate tensors for condition function\n                condResult.forEach(function (tensor) {\n                    if (!tensor.kept && argIds_1.indexOf(tensor.id) === -1) {\n                        tensor.dispose();\n                    }\n                });\n                result = args;\n                _loop_1 = function () {\n                    var origResult, resultIds, condResult_1;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                origResult = result;\n                                return [4 /*yield*/, context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap)];\n                            case 1:\n                                // Execution the body of the loop\n                                result = _a.sent();\n                                resultIds = result.map(function (tensor) { return tensor.id; });\n                                // Dispose the intermediate tensor for body function that is not global\n                                // kept, not input/output of the body function\n                                origResult.forEach(function (tensor) {\n                                    if (!tensor.kept && argIds_1.indexOf(tensor.id) === -1 &&\n                                        resultIds.indexOf(tensor.id) === -1) {\n                                        tensor.dispose();\n                                    }\n                                });\n                                return [4 /*yield*/, context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap)];\n                            case 2:\n                                condResult_1 = (_a.sent());\n                                return [4 /*yield*/, condResult_1[0].data()];\n                            case 3:\n                                condValue = _a.sent();\n                                // Dispose the intermediate tensors for condition function\n                                condResult_1.forEach(function (tensor) {\n                                    if (!tensor.kept && argIds_1.indexOf(tensor.id) === -1 &&\n                                        resultIds.indexOf(tensor.id) === -1) {\n                                        tensor.dispose();\n                                    }\n                                });\n                                return [2 /*return*/];\n                        }\n                    });\n                };\n                _b.label = 6;\n            case 6:\n                if (!condValue[0]) return [3 /*break*/, 8];\n                return [5 /*yield**/, _loop_1()];\n            case 7:\n                _b.sent();\n                return [3 /*break*/, 6];\n            case 8: return [2 /*return*/, result];\n            case 9:\n                {\n                    pred = getParamValue('pred', node, tensorMap, context);\n                    return [2 /*return*/, [cloneTensor(pred)]];\n                }\n            case 10:\n                pred = getParamValue('pred', node, tensorMap, context);\n                data = getParamValue('data', node, tensorMap, context);\n                if (!data.kept) {\n                    data = cloneTensor(data);\n                }\n                return [4 /*yield*/, pred.data()];\n            case 11: \n            // Outputs nodes :0 => false, :1 => true\n            return [2 /*return*/, (_b.sent())[0] ? [undefined, data] : [data, undefined]];\n            case 12:\n                {\n                    inputName = node.inputNames.find(function (name) { return getTensor(name, tensorMap, context) !== undefined; });\n                    if (inputName) {\n                        data = getTensor(inputName, tensorMap, context);\n                        return [2 /*return*/, [cloneTensor(data)]];\n                    }\n                    return [2 /*return*/, undefined];\n                }\n            case 13:\n                {\n                    frameId = getParamValue('frameName', node, tensorMap, context);\n                    data = getParamValue('tensor', node, tensorMap, context);\n                    context.enterFrame(frameId);\n                    return [2 /*return*/, [cloneTensor(data)]];\n                }\n            case 14:\n                {\n                    data = getParamValue('tensor', node, tensorMap, context);\n                    context.exitFrame();\n                    return [2 /*return*/, [cloneTensor(data)]];\n                }\n            case 15:\n                {\n                    data = getParamValue('tensor', node, tensorMap, context);\n                    context.nextIteration();\n                    return [2 /*return*/, [cloneTensor(data)]];\n                }\n            case 16:\n                {\n                    size = getParamValue('size', node, tensorMap, context);\n                    dtype = getParamValue('dtype', node, tensorMap, context);\n                    elementShape = getParamValue('elementShape', node, tensorMap, context);\n                    dynamicSize = getParamValue('dynamicSize', node, tensorMap, context);\n                    clearAfterRead = getParamValue('clearAfterRead', node, tensorMap, context);\n                    identicalElementShapes = getParamValue('identicalElementShapes', node, tensorMap, context);\n                    name_1 = getParamValue('name', node, tensorMap, context);\n                    tensorArray = new TensorArray(name_1, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\n                    context.addTensorArray(tensorArray);\n                    return [2 /*return*/, [tensorArray.idTensor, tfOps.scalar(1.0)]];\n                }\n            case 17:\n                {\n                    id = getParamValue('tensorArrayId', node, tensorMap, context);\n                    index = getParamValue('index', node, tensorMap, context);\n                    writeTensor = getParamValue('tensor', node, tensorMap, context);\n                    writeTensorArray = context.getTensorArray(id.id);\n                    writeTensorArray.write(index, writeTensor);\n                    return [2 /*return*/, [writeTensorArray.idTensor]];\n                }\n            case 18:\n                {\n                    readId = getParamValue('tensorArrayId', node, tensorMap, context);\n                    readIndex = getParamValue('index', node, tensorMap, context);\n                    readTensorArray = context.getTensorArray(readId.id);\n                    return [2 /*return*/, [readTensorArray.read(readIndex)]];\n                }\n            case 19:\n                {\n                    gatherId = getParamValue('tensorArrayId', node, tensorMap, context);\n                    gatherIndices = getParamValue('indices', node, tensorMap, context);\n                    gatherDtype = getParamValue('dtype', node, tensorMap, context);\n                    gatherTensorArray = context.getTensorArray(gatherId.id);\n                    return [2 /*return*/, [gatherTensorArray.gather(gatherIndices, gatherDtype)]];\n                }\n            case 20:\n                {\n                    scatterId = getParamValue('tensorArrayId', node, tensorMap, context);\n                    scatterIndices = getParamValue('indices', node, tensorMap, context);\n                    scatterTensor = getParamValue('tensor', node, tensorMap, context);\n                    scatterTensorArray = context.getTensorArray(scatterId.id);\n                    scatterTensorArray.scatter(scatterIndices, scatterTensor);\n                    return [2 /*return*/, [scatterTensorArray.idTensor]];\n                }\n            case 21:\n                {\n                    concatId = getParamValue('tensorArrayId', node, tensorMap, context);\n                    concatTensorArray = context.getTensorArray(concatId.id);\n                    concatDtype = getParamValue('dtype', node, tensorMap, context);\n                    return [2 /*return*/, [concatTensorArray.concat(concatDtype)]];\n                }\n            case 22:\n                {\n                    splitId = getParamValue('tensorArrayId', node, tensorMap, context);\n                    splitTensor = getParamValue('tensor', node, tensorMap, context);\n                    lengths = getParamValue('lengths', node, tensorMap, context);\n                    splitTensorArray = context.getTensorArray(splitId.id);\n                    splitTensorArray.split(lengths, splitTensor);\n                    return [2 /*return*/, [splitTensorArray.idTensor]];\n                }\n            case 23:\n                {\n                    sizeId = getParamValue('tensorArrayId', node, tensorMap, context);\n                    sizeTensorArray = context.getTensorArray(sizeId.id);\n                    return [2 /*return*/, [tfOps.scalar(sizeTensorArray.size(), 'int32')]];\n                }\n            case 24:\n                {\n                    closeId = getParamValue('tensorArrayId', node, tensorMap, context);\n                    closeTensorArray = context.getTensorArray(closeId.id);\n                    closeTensorArray.clearAndClose();\n                    return [2 /*return*/, [closeTensorArray.idTensor]];\n                }\n            case 25:\n                {\n                    idTensor = getParamValue('tensorListId', node, tensorMap, context);\n                    index = getParamValue('index', node, tensorMap, context);\n                    writeTensor = getParamValue('tensor', node, tensorMap, context);\n                    tensorList = context.getTensorList(idTensor.id);\n                    tensorList.setItem(index, writeTensor);\n                    return [2 /*return*/, [tensorList.idTensor]];\n                }\n            case 26:\n                {\n                    idTensor = getParamValue('tensorListId', node, tensorMap, context);\n                    readIndex = getParamValue('index', node, tensorMap, context);\n                    elementShape = getParamValue('elementShape', node, tensorMap, context);\n                    elementDType = getParamValue('elementDType', node, tensorMap, context);\n                    tensorList = context.getTensorList(idTensor.id);\n                    return [2 /*return*/, [tensorList.getItem(readIndex, elementShape, elementDType)]];\n                }\n            case 27:\n                {\n                    scatterIndices = getParamValue('indices', node, tensorMap, context);\n                    scatterTensor = getParamValue('tensor', node, tensorMap, context);\n                    elementShape = getParamValue('elementShape', node, tensorMap, context);\n                    numElements = getParamValue('numElements', node, tensorMap, context);\n                    tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);\n                    context.addTensorList(tensorList);\n                    return [2 /*return*/, [tensorList.idTensor]];\n                }\n            case 28:\n                {\n                    elementShape = getParamValue('elementShape', node, tensorMap, context);\n                    elementDtype = getParamValue('elementDType', node, tensorMap, context);\n                    numElementsParam = void 0;\n                    if (node.op === 'TensorListReserve') {\n                        numElementsParam = 'numElements';\n                    }\n                    else {\n                        numElementsParam = 'maxNumElements';\n                    }\n                    numElements = getParamValue(numElementsParam, node, tensorMap, context);\n                    tensorList = reserve(elementShape, elementDtype, numElements);\n                    context.addTensorList(tensorList);\n                    return [2 /*return*/, [tensorList.idTensor]];\n                }\n            case 29:\n                {\n                    gatherId = getParamValue('tensorListId', node, tensorMap, context);\n                    gatherIndices = getParamValue('indices', node, tensorMap, context);\n                    elementShape = getParamValue('elementShape', node, tensorMap, context);\n                    elementDtype = getParamValue('elementDType', node, tensorMap, context);\n                    tensorList = context.getTensorList(gatherId.id);\n                    return [2 /*return*/, [tensorList.gather(gatherIndices, elementDtype, elementShape)]];\n                }\n            case 30:\n                {\n                    idTensor = getParamValue('tensorListId', node, tensorMap, context);\n                    elementShape = getParamValue('elementShape', node, tensorMap, context);\n                    elementDtype = getParamValue('elementDType', node, tensorMap, context);\n                    numElements = getParamValue('numElements', node, tensorMap, context);\n                    tensorList = context.getTensorList(idTensor.id);\n                    return [2 /*return*/, [tensorList.stack(elementShape, elementDtype, numElements)]];\n                }\n            case 31:\n                {\n                    tensor = getParamValue('tensor', node, tensorMap, context);\n                    elementShape = getParamValue('elementShape', node, tensorMap, context);\n                    elementDtype = getParamValue('elementDType', node, tensorMap, context);\n                    tensorList = fromTensor(tensor, elementShape, elementDtype);\n                    context.addTensorList(tensorList);\n                    return [2 /*return*/, [tensorList.idTensor]];\n                }\n            case 32:\n                {\n                    concatId = getParamValue('tensorListId', node, tensorMap, context);\n                    tensorList = context.getTensorList(concatId.id);\n                    concatDtype = getParamValue('dtype', node, tensorMap, context);\n                    elementShape = getParamValue('elementShape', node, tensorMap, context);\n                    return [2 /*return*/, [tensorList.concat(concatDtype, elementShape)]];\n                }\n            case 33:\n                {\n                    idTensor = getParamValue('tensorListId', node, tensorMap, context);\n                    writeTensor = getParamValue('tensor', node, tensorMap, context);\n                    tensorList = context.getTensorList(idTensor.id);\n                    tensorList.pushBack(writeTensor);\n                    return [2 /*return*/, [tensorList.idTensor]];\n                }\n            case 34:\n                {\n                    idTensor = getParamValue('tensorListId', node, tensorMap, context);\n                    elementShape = getParamValue('elementShape', node, tensorMap, context);\n                    elementDType = getParamValue('elementDType', node, tensorMap, context);\n                    tensorList = context.getTensorList(idTensor.id);\n                    return [2 /*return*/, [tensorList.popBack(elementShape, elementDType)]];\n                }\n            case 35:\n                {\n                    splitTensor = getParamValue('tensor', node, tensorMap, context);\n                    elementShape = getParamValue('elementShape', node, tensorMap, context);\n                    lengths = getParamValue('lengths', node, tensorMap, context);\n                    tensorList = split(splitTensor, lengths, elementShape);\n                    context.addTensorList(tensorList);\n                    return [2 /*return*/, [tensorList.idTensor]];\n                }\n            case 36: throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n        }\n    });\n}); };\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction fusedConvAndDepthWiseParams(node, tensorMap, context) {\n    var _a = __read(getParamValue('fusedOps', node, tensorMap, context), 2), extraOp = _a[0], activationFunc = _a[1];\n    var isBiasAdd = extraOp === 'biasadd';\n    var isPrelu = activationFunc === 'prelu';\n    var isBatchNorm = extraOp === 'fusedbatchnorm';\n    var numArgs = getParamValue('numArgs', node, tensorMap, context);\n    if (isBiasAdd) {\n        if (isPrelu && numArgs !== 2) {\n            throw new Error('FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu ' +\n                'must have two extra arguments: bias and alpha.');\n        }\n        if (!isPrelu && numArgs !== 1) {\n            throw new Error('FusedConv2d and DepthwiseConv2d with BiasAdd must have ' +\n                'one extra argument: bias.');\n        }\n    }\n    if (isBatchNorm) {\n        throw new Error('FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.');\n    }\n    var stride = getParamValue('strides', node, tensorMap, context);\n    var pad = getPadding(node, tensorMap, context);\n    var dataFormat = getParamValue('dataFormat', node, tensorMap, context)\n        .toUpperCase();\n    var dilations = getParamValue('dilations', node, tensorMap, context);\n    var _b = __read(getParamValue('args', node, tensorMap, context), 2), biasArg = _b[0], preluArg = _b[1];\n    var leakyreluAlpha = getParamValue('leakyreluAlpha', node, tensorMap, context);\n    return {\n        stride: stride,\n        pad: pad,\n        dataFormat: dataFormat,\n        dilations: dilations,\n        biasArg: biasArg,\n        preluArg: preluArg,\n        activationFunc: activationFunc,\n        leakyreluAlpha: leakyreluAlpha\n    };\n}\nvar executeOp$3 = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Conv1D': {\n            var stride = getParamValue('stride', node, tensorMap, context);\n            var pad = getParamValue('pad', node, tensorMap, context);\n            var dataFormat = getParamValue('dataFormat', node, tensorMap, context)\n                .toUpperCase();\n            var dilation = getParamValue('dilation', node, tensorMap, context);\n            return [tfOps.conv1d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), stride, pad, dataFormat, dilation)];\n        }\n        case 'Conv2D': {\n            var stride = getParamValue('strides', node, tensorMap, context);\n            var pad = getPadding(node, tensorMap, context);\n            var dataFormat = getParamValue('dataFormat', node, tensorMap, context)\n                .toUpperCase();\n            var dilations = getParamValue('dilations', node, tensorMap, context);\n            return [tfOps.conv2d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[1], dilations[2]])];\n        }\n        case '_FusedConv2D': {\n            var _a = fusedConvAndDepthWiseParams(node, tensorMap, context), stride = _a.stride, pad = _a.pad, dataFormat = _a.dataFormat, dilations = _a.dilations, biasArg = _a.biasArg, preluArg = _a.preluArg, activationFunc = _a.activationFunc, leakyreluAlpha = _a.leakyreluAlpha;\n            return [tfOps.fused.conv2d({\n                    x: getParamValue('x', node, tensorMap, context),\n                    filter: getParamValue('filter', node, tensorMap, context),\n                    strides: [stride[1], stride[2]],\n                    pad: pad,\n                    dataFormat: dataFormat,\n                    dilations: [dilations[1], dilations[2]],\n                    bias: biasArg,\n                    activation: activationFunc,\n                    preluActivationWeights: preluArg,\n                    leakyreluAlpha: leakyreluAlpha\n                })];\n        }\n        case 'FusedDepthwiseConv2dNative': {\n            var _b = fusedConvAndDepthWiseParams(node, tensorMap, context), stride = _b.stride, pad = _b.pad, dataFormat = _b.dataFormat, dilations = _b.dilations, biasArg = _b.biasArg, preluArg = _b.preluArg, activationFunc = _b.activationFunc, leakyreluAlpha = _b.leakyreluAlpha;\n            return [tfOps.fused.depthwiseConv2d({\n                    x: getParamValue('x', node, tensorMap, context),\n                    filter: getParamValue('filter', node, tensorMap, context),\n                    strides: [stride[1], stride[2]],\n                    pad: pad,\n                    dataFormat: dataFormat,\n                    dilations: [dilations[1], dilations[2]],\n                    bias: biasArg,\n                    activation: activationFunc,\n                    preluActivationWeights: preluArg,\n                    leakyreluAlpha: leakyreluAlpha\n                })];\n        }\n        case 'Conv2DBackpropInput':\n        case 'Conv2dTranspose': {\n            var shape = getParamValue('outputShape', node, tensorMap, context);\n            var stride = getParamValue('strides', node, tensorMap, context);\n            var pad = getPadding(node, tensorMap, context);\n            return [tfOps.conv2dTranspose(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), shape, [stride[1], stride[2]], pad)];\n        }\n        case 'DepthwiseConv2dNative':\n        case 'DepthwiseConv2d': {\n            var stride = getParamValue('strides', node, tensorMap, context);\n            var pad = getPadding(node, tensorMap, context);\n            var dilations = getParamValue('dilations', node, tensorMap, context);\n            var dataFormat = getParamValue('dataFormat', node, tensorMap, context)\n                .toUpperCase();\n            return [tfOps.depthwiseConv2d(getParamValue('input', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[1], dilations[2]])];\n        }\n        case 'Conv3D': {\n            var stride = getParamValue('strides', node, tensorMap, context);\n            var pad = getParamValue('pad', node, tensorMap, context);\n            var dataFormat = getParamValue('dataFormat', node, tensorMap, context)\n                .toUpperCase();\n            var dilations = getParamValue('dilations', node, tensorMap, context);\n            return [tfOps.conv3d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [stride[1], stride[2], stride[3]], pad, dataFormat, [dilations[1], dilations[2], dilations[3]])];\n        }\n        case 'AvgPool': {\n            var stride = getParamValue('strides', node, tensorMap, context);\n            var pad = getParamValue('pad', node, tensorMap, context);\n            var kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n            return [tfOps.avgPool(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];\n        }\n        case 'MaxPool': {\n            var stride = getParamValue('strides', node, tensorMap, context);\n            var pad = getParamValue('pad', node, tensorMap, context);\n            var kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n            return [tfOps.maxPool(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];\n        }\n        case 'MaxPoolWithArgmax': {\n            var stride = getParamValue('strides', node, tensorMap, context);\n            var pad = getParamValue('pad', node, tensorMap, context);\n            var kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n            var includeBatchInIndex = getParamValue('includeBatchInIndex', node, tensorMap, context);\n            var _c = tfOps.maxPoolWithArgmax(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad, includeBatchInIndex), result = _c.result, indexes = _c.indexes;\n            return [result, indexes];\n        }\n        case 'AvgPool3D': {\n            var stride = getParamValue('strides', node, tensorMap, context);\n            var pad = getParamValue('pad', node, tensorMap, context);\n            var kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n            return [tfOps.avgPool3d(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad)];\n        }\n        case 'MaxPool3D': {\n            var stride = getParamValue('strides', node, tensorMap, context);\n            var pad = getParamValue('pad', node, tensorMap, context);\n            var kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n            return [tfOps.maxPool3d(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad)];\n        }\n        case 'Dilation2D': {\n            var strides = getParamValue('strides', node, tensorMap, context);\n            var pad = getParamValue('pad', node, tensorMap, context);\n            var dilations = getParamValue('dilations', node, tensorMap, context);\n            // strides: [1, stride_height, stride_width, 1].\n            var strideHeight = strides[1];\n            var strideWidth = strides[2];\n            // dilations: [1, dilation_height, dilation_width, 1].\n            var dilationHeight = dilations[1];\n            var dilationWidth = dilations[2];\n            return [tfOps.dilation2d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [strideHeight, strideWidth], pad, [dilationHeight, dilationWidth], 'NHWC' /* dataFormat */)];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$4 = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Fill': {\n            var shape = getParamValue('shape', node, tensorMap, context);\n            var dtype = getParamValue('dtype', node, tensorMap, context);\n            var value = getParamValue('value', node, tensorMap, context);\n            return [tfOps.fill(shape, value, dtype)];\n        }\n        case 'LinSpace': {\n            var start = getParamValue('start', node, tensorMap, context);\n            var stop_1 = getParamValue('stop', node, tensorMap, context);\n            var num = getParamValue('num', node, tensorMap, context);\n            return [tfOps.linspace(start, stop_1, num)];\n        }\n        case 'Multinomial': {\n            var logits = getParamValue('logits', node, tensorMap, context);\n            var numSamples = getParamValue('numSamples', node, tensorMap, context);\n            var seed = getParamValue('seed', node, tensorMap, context);\n            return [tfOps.multinomial(logits, numSamples, seed)];\n        }\n        case 'OneHot': {\n            var indices = getParamValue('indices', node, tensorMap, context);\n            var depth = getParamValue('depth', node, tensorMap, context);\n            var onValue = getParamValue('onValue', node, tensorMap, context);\n            var offValue = getParamValue('offValue', node, tensorMap, context);\n            return [tfOps.oneHot(indices, depth, onValue, offValue)];\n        }\n        case 'Ones': {\n            return [tfOps.ones(getParamValue('shape', node, tensorMap, context), getParamValue('dtype', node, tensorMap, context))];\n        }\n        case 'OnesLike': {\n            return [tfOps.onesLike(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'RandomUniform': {\n            return [tfOps.randomUniform(\n                // tslint:disable-next-line:no-any\n                getParamValue('shape', node, tensorMap, context), getParamValue('minval', node, tensorMap, context), getParamValue('maxval', node, tensorMap, context), getParamValue('dtype', node, tensorMap, context))];\n        }\n        case 'Range': {\n            var start = getParamValue('start', node, tensorMap, context);\n            var stop_2 = getParamValue('stop', node, tensorMap, context);\n            var step = getParamValue('step', node, tensorMap, context);\n            return [tfOps.range(start, stop_2, step, getParamValue('dtype', node, tensorMap, context))];\n        }\n        case 'TruncatedNormal': {\n            var shape = getParamValue('shape', node, tensorMap, context);\n            var mean = getParamValue('mean', node, tensorMap, context);\n            var stdDev = getParamValue('stdDev', node, tensorMap, context);\n            var seed = getParamValue('seed', node, tensorMap, context);\n            return [tfOps.truncatedNormal(shape, mean, stdDev, getParamValue('dtype', node, tensorMap, context), seed)];\n        }\n        case 'Zeros': {\n            return [tfOps.zeros(getParamValue('shape', node, tensorMap, context), getParamValue('dtype', node, tensorMap, context))];\n        }\n        case 'ZerosLike': {\n            return [tfOps.zerosLike(getParamValue('x', node, tensorMap, context))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar _this$1 = undefined;\nfunction nmsParams(node, tensorMap, context) {\n    var boxes = getParamValue('boxes', node, tensorMap, context);\n    var scores = getParamValue('scores', node, tensorMap, context);\n    var maxOutputSize = getParamValue('maxOutputSize', node, tensorMap, context);\n    var iouThreshold = getParamValue('iouThreshold', node, tensorMap, context);\n    var scoreThreshold = getParamValue('scoreThreshold', node, tensorMap, context);\n    var softNmsSigma = getParamValue('softNmsSigma', node, tensorMap, context);\n    return {\n        boxes: boxes,\n        scores: scores,\n        maxOutputSize: maxOutputSize,\n        iouThreshold: iouThreshold,\n        scoreThreshold: scoreThreshold,\n        softNmsSigma: softNmsSigma\n    };\n}\nvar executeOp$5 = function (node, tensorMap, context) { return __awaiter(_this$1, void 0, void 0, function () {\n    var _a, _b, boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, result, _c, boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize, result, _d, boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, condition, result;\n    return __generator(this, function (_e) {\n        switch (_e.label) {\n            case 0:\n                _a = node.op;\n                switch (_a) {\n                    case 'NonMaxSuppressionV5': return [3 /*break*/, 1];\n                    case 'NonMaxSuppressionV4': return [3 /*break*/, 3];\n                    case 'NonMaxSuppressionV3': return [3 /*break*/, 5];\n                    case 'NonMaxSuppressionV2': return [3 /*break*/, 5];\n                    case 'Where': return [3 /*break*/, 7];\n                    case 'ListDiff': return [3 /*break*/, 9];\n                }\n                return [3 /*break*/, 10];\n            case 1:\n                _b = nmsParams(node, tensorMap, context), boxes = _b.boxes, scores = _b.scores, maxOutputSize = _b.maxOutputSize, iouThreshold = _b.iouThreshold, scoreThreshold = _b.scoreThreshold, softNmsSigma = _b.softNmsSigma;\n                return [4 /*yield*/, tfOps.image.nonMaxSuppressionWithScoreAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma)];\n            case 2:\n                result = _e.sent();\n                return [2 /*return*/, [result.selectedIndices, result.selectedScores]];\n            case 3:\n                _c = nmsParams(node, tensorMap, context), boxes = _c.boxes, scores = _c.scores, maxOutputSize = _c.maxOutputSize, iouThreshold = _c.iouThreshold, scoreThreshold = _c.scoreThreshold;\n                padToMaxOutputSize = getParamValue('padToMaxOutputSize', node, tensorMap, context);\n                return [4 /*yield*/, tfOps.image.nonMaxSuppressionPaddedAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize)];\n            case 4:\n                result = _e.sent();\n                return [2 /*return*/, [result.selectedIndices, result.validOutputs]];\n            case 5:\n                _d = nmsParams(node, tensorMap, context), boxes = _d.boxes, scores = _d.scores, maxOutputSize = _d.maxOutputSize, iouThreshold = _d.iouThreshold, scoreThreshold = _d.scoreThreshold;\n                return [4 /*yield*/, tfOps.image.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];\n            case 6: return [2 /*return*/, [_e.sent()]];\n            case 7:\n                condition = tfOps.cast(getParamValue('condition', node, tensorMap, context), 'bool');\n                return [4 /*yield*/, tfOps.whereAsync(condition)];\n            case 8:\n                result = [_e.sent()];\n                condition.dispose();\n                return [2 /*return*/, result];\n            case 9:\n                {\n                    return [2 /*return*/, tfOps.setdiff1dAsync(getParamValue('x', node, tensorMap, context), getParamValue('y', node, tensorMap, context))];\n                }\n            case 10: throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n        }\n    });\n}); };\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$6 = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'TopKV2': {\n            var x = getParamValue('x', node, tensorMap, context);\n            var k = getParamValue('k', node, tensorMap, context);\n            var sorted = getParamValue('sorted', node, tensorMap, context);\n            var result = tfOps.topk(x, k, sorted);\n            return [result.values, result.indices];\n        }\n        case 'Unique': {\n            var x = getParamValue('x', node, tensorMap, context);\n            var result = tfOps.unique(x);\n            return [result.values, result.indices];\n        }\n        case 'UniqueV2': {\n            var x = getParamValue('x', node, tensorMap, context);\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var result = tfOps.unique(x, axis);\n            return [result.values, result.indices];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$7 = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Const': {\n            return tensorMap[node.name];\n        }\n        case 'PlaceholderWithDefault':\n            var def = getParamValue('default', node, tensorMap, context);\n            return [getTensor(node.name, tensorMap, context) || def];\n        case 'Placeholder':\n            return [getTensor(node.name, tensorMap, context)];\n        case 'Identity':\n        case 'StopGradient':\n        case 'FakeQuantWithMinMaxVars': { // This op is currently ignored.\n            var data_1 = getParamValue('x', node, tensorMap, context);\n            return [cloneTensor(data_1)];\n        }\n        case 'IdentityN':\n            return getParamValue('x', node, tensorMap, context)\n                .map(function (t) { return cloneTensor(t); });\n        case 'Snapshot':\n            var snapshot = getParamValue('x', node, tensorMap, context);\n            return [cloneTensor(snapshot)];\n        case 'Shape':\n            return [tfOps.tensor1d(getParamValue('x', node, tensorMap, context).shape, 'int32')];\n        case 'ShapeN':\n            return getParamValue('x', node, tensorMap, context)\n                .map(function (t) { return tfOps.tensor1d(t.shape); });\n        case 'Size':\n            return [tfOps.scalar(getParamValue('x', node, tensorMap, context).size, 'int32')];\n        case 'Rank':\n            return [tfOps.scalar(getParamValue('x', node, tensorMap, context).rank, 'int32')];\n        case 'NoOp':\n            return [tfOps.scalar(1)];\n        case 'Print':\n            var input = getParamValue('x', node, tensorMap, context);\n            var data = getParamValue('data', node, tensorMap, context);\n            var message = getParamValue('message', node, tensorMap, context);\n            var summarize = getParamValue('summarize', node, tensorMap, context);\n            console.warn('The graph has a tf.print() operation,' +\n                'usually used for debugging, which slows down performance.');\n            console.log(message);\n            for (var i = 0; i < data.length; i++) {\n                console.log(Array.prototype.slice.call(data[i].dataSync())\n                    .slice(0, summarize));\n            }\n            return [input];\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * Hashtable contains a set of tensors, which can be accessed by key.\n */\nvar HashTable = /** @class */ (function () {\n    /**\n     * Constructor of HashTable. Creates a hash table.\n     *\n     * @param keyDType `dtype` of the table keys.\n     * @param valueDType `dtype` of the table values.\n     */\n    function HashTable(keyDType, valueDType) {\n        this.keyDType = keyDType;\n        this.valueDType = valueDType;\n        this.handle = tfOps.scalar(0);\n        // tslint:disable-next-line: no-any\n        this.tensorMap = new Map();\n        tfOps.keep(this.handle);\n    }\n    Object.defineProperty(HashTable.prototype, \"id\", {\n        get: function () {\n            return this.handle.id;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose the tensors and handle and clear the hashtable.\n     */\n    HashTable.prototype.clearAndClose = function () {\n        this.tensorMap.forEach(function (value) { return value.dispose(); });\n        this.tensorMap.clear();\n        this.handle.dispose();\n    };\n    /**\n     * The number of items in the hash table.\n     */\n    HashTable.prototype.size = function () {\n        return this.tensorMap.size;\n    };\n    /**\n     * Replaces the contents of the table with the specified keys and values.\n     * @param keys Keys to store in the hashtable.\n     * @param values Values to store in the hashtable.\n     */\n    HashTable.prototype.import = function (keys, values) {\n        return __awaiter(this, void 0, void 0, function () {\n            var $keys;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.checkKeyAndValueTensor(keys, values);\n                        return [4 /*yield*/, keys.data()];\n                    case 1:\n                        $keys = _a.sent();\n                        // Clear the hashTable before inserting new values.\n                        this.tensorMap.forEach(function (value) { return value.dispose(); });\n                        this.tensorMap.clear();\n                        return [2 /*return*/, tfOps.tidy(function () {\n                                var $values = tfOps.unstack(values);\n                                var keysLength = $keys.length;\n                                var valuesLength = $values.length;\n                                tfOps.util.assert(keysLength === valuesLength, function () { return \"The number of elements doesn't match, keys has \" +\n                                    (keysLength + \" elements, the values has \" + valuesLength + \" \") +\n                                    \"elements.\"; });\n                                for (var i = 0; i < keysLength; i++) {\n                                    var key = $keys[i];\n                                    var value = $values[i];\n                                    tfOps.keep(value);\n                                    _this.tensorMap.set(key, value);\n                                }\n                                return _this.handle;\n                            })];\n                }\n            });\n        });\n    };\n    /**\n     * Looks up keys in a hash table, outputs the corresponding values.\n     *\n     * Performs batch lookups, for every element in the key tensor, `find`\n     * stacks the corresponding value into the return tensor.\n     *\n     * If an element is not present in the table, the given `defaultValue` is\n     * used.\n     *\n     * @param keys Keys to look up. Must have the same type as the keys of the\n     *     table.\n     * @param defaultValue The scalar `defaultValue` is the value output for keys\n     *     not present in the table. It must also be of the same type as the\n     *     table values.\n     */\n    HashTable.prototype.find = function (keys, defaultValue) {\n        return __awaiter(this, void 0, void 0, function () {\n            var $keys;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.checkKeyAndValueTensor(keys, defaultValue);\n                        return [4 /*yield*/, keys.data()];\n                    case 1:\n                        $keys = _a.sent();\n                        return [2 /*return*/, tfOps.tidy(function () {\n                                var result = [];\n                                for (var i = 0; i < $keys.length; i++) {\n                                    var key = $keys[i];\n                                    var value = _this.findWithDefault(key, defaultValue);\n                                    result.push(value);\n                                }\n                                return tfOps.stack(result);\n                            })];\n                }\n            });\n        });\n    };\n    // tslint:disable-next-line: no-any\n    HashTable.prototype.findWithDefault = function (key, defaultValue) {\n        var result = this.tensorMap.get(key);\n        return result != null ? result : defaultValue;\n    };\n    HashTable.prototype.checkKeyAndValueTensor = function (key, value) {\n        if (key.dtype !== this.keyDType) {\n            throw new Error(\"Expect key dtype \" + this.keyDType + \", but got \" +\n                (\"\" + key.dtype));\n        }\n        if (value.dtype !== this.valueDType) {\n            throw new Error(\"Expect value dtype \" + this.valueDType + \", but got \" +\n                (\"\" + value.dtype));\n        }\n    };\n    return HashTable;\n}());\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar _this$2 = undefined;\nvar executeOp$8 = function (node, tensorMap, context, resourceManager) { return __awaiter(_this$2, void 0, void 0, function () {\n    var _a, keyDType, valueDType, hashTable, handle, keys, values, hashTable, handle, keys, defaultValue, hashTable;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                _a = node.op;\n                switch (_a) {\n                    case 'HashTable': return [3 /*break*/, 1];\n                    case 'HashTableV2': return [3 /*break*/, 1];\n                    case 'LookupTableImport': return [3 /*break*/, 2];\n                    case 'LookupTableImportV2': return [3 /*break*/, 2];\n                    case 'LookupTableFind': return [3 /*break*/, 4];\n                    case 'LookupTableFindV2': return [3 /*break*/, 4];\n                }\n                return [3 /*break*/, 6];\n            case 1:\n                {\n                    keyDType = getParamValue('keyDType', node, tensorMap, context);\n                    valueDType = getParamValue('valueDType', node, tensorMap, context);\n                    hashTable = new HashTable(keyDType, valueDType);\n                    resourceManager.addHashTable(node.name, hashTable);\n                    return [2 /*return*/, [hashTable.handle]];\n                }\n            case 2:\n                handle = getParamValue('tableHandle', node, tensorMap, context, resourceManager);\n                keys = getParamValue('keys', node, tensorMap, context);\n                values = getParamValue('values', node, tensorMap, context);\n                hashTable = resourceManager.getHashTableById(handle.id);\n                return [4 /*yield*/, hashTable.import(keys, values)];\n            case 3: return [2 /*return*/, [_b.sent()]];\n            case 4:\n                handle = getParamValue('tableHandle', node, tensorMap, context, resourceManager);\n                keys = getParamValue('keys', node, tensorMap, context);\n                defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n                hashTable = resourceManager.getHashTableById(handle.id);\n                return [4 /*yield*/, hashTable.find(keys, defaultValue)];\n            case 5: return [2 /*return*/, [_b.sent()]];\n            case 6: throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n        }\n    });\n}); };\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$9 = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'ResizeBilinear': {\n            var images = getParamValue('images', node, tensorMap, context);\n            var size = getParamValue('size', node, tensorMap, context);\n            var alignCorners = getParamValue('alignCorners', node, tensorMap, context);\n            var halfPixelCenters = getParamValue('halfPixelCenters', node, tensorMap, context);\n            return [tfOps.image.resizeBilinear(images, [size[0], size[1]], alignCorners, halfPixelCenters)];\n        }\n        case 'ResizeNearestNeighbor': {\n            var images = getParamValue('images', node, tensorMap, context);\n            var size = getParamValue('size', node, tensorMap, context);\n            var alignCorners = getParamValue('alignCorners', node, tensorMap, context);\n            var halfPixelCenters = getParamValue('halfPixelCenters', node, tensorMap, context);\n            return [tfOps.image.resizeNearestNeighbor(images, [size[0], size[1]], alignCorners, halfPixelCenters)];\n        }\n        case 'CropAndResize': {\n            var image = getParamValue('image', node, tensorMap, context);\n            var boxes = getParamValue('boxes', node, tensorMap, context);\n            var boxInd = getParamValue('boxInd', node, tensorMap, context);\n            var cropSize = getParamValue('cropSize', node, tensorMap, context);\n            var method = getParamValue('method', node, tensorMap, context);\n            var extrapolationValue = getParamValue('extrapolationValue', node, tensorMap, context);\n            return [tfOps.image.cropAndResize(image, boxes, boxInd, cropSize, method, extrapolationValue)];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$a = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Equal': {\n            return [tfOps.equal(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'NotEqual': {\n            return [tfOps.notEqual(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Greater': {\n            return [tfOps.greater(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'GreaterEqual': {\n            return [tfOps.greaterEqual(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Less': {\n            return [tfOps.less(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'LessEqual': {\n            return [tfOps.lessEqual(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'LogicalAnd': {\n            return [tfOps.logicalAnd(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'LogicalNot': {\n            return [tfOps.logicalNot(getParamValue('a', node, tensorMap, context))];\n        }\n        case 'LogicalOr': {\n            return [tfOps.logicalOr(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Select':\n        case 'SelectV2': {\n            return [tfOps.where(getParamValue('condition', node, tensorMap, context), getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$b = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'BatchMatMul':\n        case 'BatchMatMulV2':\n        case 'MatMul':\n            return [tfOps.matMul(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context), getParamValue('transposeA', node, tensorMap, context), getParamValue('transposeB', node, tensorMap, context))];\n        case 'Transpose':\n            return [tfOps.transpose(getParamValue('x', node, tensorMap, context), getParamValue('perm', node, tensorMap, context))];\n        case '_FusedMatMul':\n            var _a = __read(getParamValue('fusedOps', node, tensorMap, context), 2), extraOp = _a[0], activationFunc = _a[1];\n            var isBiasAdd = extraOp === 'biasadd';\n            var isPrelu = activationFunc === 'prelu';\n            var numArgs = getParamValue('numArgs', node, tensorMap, context);\n            var leakyreluAlpha = getParamValue('leakyreluAlpha', node, tensorMap, context);\n            if (isBiasAdd) {\n                if (isPrelu && numArgs !== 2) {\n                    throw new Error('Fused MatMul with BiasAdd and Prelu must have two ' +\n                        'extra arguments: bias and alpha.');\n                }\n                if (!isPrelu && numArgs !== 1) {\n                    throw new Error('Fused MatMul with BiasAdd must have one extra argument: bias.');\n                }\n            }\n            var _b = __read(getParamValue('args', node, tensorMap, context), 2), biasArg = _b[0], preluArg = _b[1];\n            return [tfOps.fused.matMul({\n                    a: getParamValue('a', node, tensorMap, context),\n                    b: getParamValue('b', node, tensorMap, context),\n                    transposeA: getParamValue('transposeA', node, tensorMap, context),\n                    transposeB: getParamValue('transposeB', node, tensorMap, context),\n                    bias: biasArg,\n                    activation: activationFunc,\n                    preluActivationWeights: preluArg,\n                    leakyreluAlpha: leakyreluAlpha\n                })];\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$c = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'FusedBatchNorm':\n        case 'FusedBatchNormV2': {\n            return [tfOps.batchNorm(getParamValue('x', node, tensorMap, context), getParamValue('mean', node, tensorMap, context), getParamValue('variance', node, tensorMap, context), getParamValue('offset', node, tensorMap, context), getParamValue('scale', node, tensorMap, context), getParamValue('epsilon', node, tensorMap, context))];\n        }\n        case 'FusedBatchNormV3': {\n            return [tfOps.batchNorm(getParamValue('x', node, tensorMap, context), getParamValue('mean', node, tensorMap, context), getParamValue('variance', node, tensorMap, context), getParamValue('offset', node, tensorMap, context), getParamValue('scale', node, tensorMap, context), getParamValue('epsilon', node, tensorMap, context))];\n        }\n        case 'LRN': {\n            return [tfOps.localResponseNormalization(getParamValue('x', node, tensorMap, context), getParamValue('radius', node, tensorMap, context), getParamValue('bias', node, tensorMap, context), getParamValue('alpha', node, tensorMap, context), getParamValue('beta', node, tensorMap, context))];\n        }\n        case 'Softmax': {\n            return [tfOps.softmax(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'LogSoftmax': {\n            return [tfOps.logSoftmax(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'SparseToDense': {\n            return [tfOps.sparseToDense(getParamValue('sparseIndices', node, tensorMap, context), getParamValue('outputShape', node, tensorMap, context), getParamValue('sparseValues', node, tensorMap, context), getParamValue('defaultValue', node, tensorMap, context))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$d = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Max': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var keepDims = getParamValue('keepDims', node, tensorMap, context);\n            return [tfOps.max(getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'Mean': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var keepDims = getParamValue('keepDims', node, tensorMap, context);\n            return [tfOps.mean(getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'Min': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var keepDims = getParamValue('keepDims', node, tensorMap, context);\n            return [tfOps.min(getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'Sum': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var keepDims = getParamValue('keepDims', node, tensorMap, context);\n            return [tfOps.sum(getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'All': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var keepDims = getParamValue('keepDims', node, tensorMap, context);\n            return [tfOps.all(getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'Any': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var keepDims = getParamValue('keepDims', node, tensorMap, context);\n            return [tfOps.any(getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'ArgMax': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            return [tfOps.argMax(getParamValue('x', node, tensorMap, context), axis)];\n        }\n        case 'ArgMin': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            return [tfOps.argMin(getParamValue('x', node, tensorMap, context), axis)];\n        }\n        case 'Prod': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var keepDims = getParamValue('keepDims', node, tensorMap, context);\n            return [tfOps.prod(getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'Cumsum': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var exclusive = getParamValue('exclusive', node, tensorMap, context);\n            var reverse = getParamValue('reverse', node, tensorMap, context);\n            return [tfOps.cumsum(getParamValue('x', node, tensorMap, context), axis, exclusive, reverse)];\n        }\n        case 'Bincount':\n            var x = getParamValue('x', node, tensorMap, context);\n            var weights = getParamValue('weights', node, tensorMap, context);\n            var size = getParamValue('size', node, tensorMap, context);\n            return [tfOps.bincount(x, weights, size)];\n        case 'DenseBincount': {\n            var x_1 = getParamValue('x', node, tensorMap, context);\n            var weights_1 = getParamValue('weights', node, tensorMap, context);\n            var size_1 = getParamValue('size', node, tensorMap, context);\n            var binaryOutput = getParamValue('binaryOutput', node, tensorMap, context);\n            return [tfOps.denseBincount(x_1, weights_1, size_1, binaryOutput)];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$e = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'ConcatV2':\n        case 'Concat': {\n            var n = getParamValue('n', node, tensorMap, context);\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var inputs = getParamValue('tensors', node, tensorMap, context);\n            inputs = inputs.slice(0, n);\n            return [tfOps.concat(inputs, axis)];\n        }\n        case 'Gather': {\n            var input = getParamValue('x', node, tensorMap, context);\n            var indices = getParamValue('indices', node, tensorMap, context);\n            return [tfOps.gather(input, tfOps.cast(indices, 'int32'), 0)];\n        }\n        case 'GatherV2': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var batchDims = getParamValue('batchDims', node, tensorMap, context);\n            var input = getParamValue('x', node, tensorMap, context);\n            var indices = getParamValue('indices', node, tensorMap, context);\n            return [tfOps.gather(input, tfOps.cast(indices, 'int32'), axis, batchDims)];\n        }\n        case 'Reverse': {\n            var dims = getParamValue('dims', node, tensorMap, context);\n            var axis = [];\n            for (var i = 0; i < dims.length; i++) {\n                if (dims[i]) {\n                    axis.push(i);\n                }\n            }\n            var input = getParamValue('x', node, tensorMap, context);\n            return [tfOps.reverse(input, axis)];\n        }\n        case 'ReverseV2': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var input = getParamValue('x', node, tensorMap, context);\n            return [tfOps.reverse(input, axis)];\n        }\n        case 'Slice': {\n            // tslint:disable-next-line:no-any\n            var begin = getParamValue('begin', node, tensorMap, context);\n            // tslint:disable-next-line:no-any\n            var size = getParamValue('size', node, tensorMap, context);\n            return [tfOps.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n        }\n        case 'StridedSlice': {\n            var begin = getParamValue('begin', node, tensorMap, context);\n            var end = getParamValue('end', node, tensorMap, context);\n            var strides = getParamValue('strides', node, tensorMap, context);\n            var beginMask = getParamValue('beginMask', node, tensorMap, context);\n            var endMask = getParamValue('endMask', node, tensorMap, context);\n            var ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n            var newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n            var shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n            var tensor = getParamValue('x', node, tensorMap, context);\n            return [tfOps.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n        }\n        case 'Pack': {\n            return tfOps.tidy(function () {\n                var axis = getParamValue('axis', node, tensorMap, context);\n                var tensors = getParamValue('tensors', node, tensorMap, context);\n                // Reshape the tensors to the first tensor's shape if they don't\n                // match.\n                var shape = tensors[0].shape;\n                var squeezedShape = tfOps.squeeze(tensors[0]).shape;\n                var mapped = tensors.map(function (tensor) {\n                    var sameShape = tfOps.util.arraysEqual(tensor.shape, shape);\n                    if (!sameShape &&\n                        !tfOps.util.arraysEqual(tfOps.squeeze(tensor).shape, squeezedShape)) {\n                        throw new Error('the input tensors shape does not match');\n                    }\n                    return sameShape ? tensor : tfOps.reshape(tensor, shape);\n                });\n                return [tfOps.stack(mapped, axis)];\n            });\n        }\n        case 'Unpack': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var tensor = getParamValue('tensor', node, tensorMap, context);\n            return tfOps.unstack(tensor, axis);\n        }\n        case 'Tile': {\n            var reps = getParamValue('reps', node, tensorMap, context);\n            return [tfOps.tile(getParamValue('x', node, tensorMap, context), reps)];\n        }\n        case 'Split':\n        case 'SplitV': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            var numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n            var tensor = getParamValue('x', node, tensorMap, context);\n            return tfOps.split(tensor, numOrSizeSplits, axis);\n        }\n        case 'ScatterNd': {\n            var indices = getParamValue('indices', node, tensorMap, context);\n            var values = getParamValue('values', node, tensorMap, context);\n            var shape = getParamValue('shape', node, tensorMap, context);\n            return [tfOps.scatterND(indices, values, shape)];\n        }\n        case 'GatherNd': {\n            var x = getParamValue('x', node, tensorMap, context);\n            var indices = getParamValue('indices', node, tensorMap, context);\n            return [tfOps.gatherND(x, indices)];\n        }\n        case 'SparseToDense': {\n            var indices = getParamValue('sparseIndices', node, tensorMap, context);\n            var shape = getParamValue('outputShape', node, tensorMap, context);\n            var sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n            var defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n            return [tfOps.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ?\n                    defaultValue :\n                    tfOps.cast(defaultValue, sparseValues.dtype))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$f = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'FFT': {\n            return [tfOps.fft(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'IFFT': {\n            return [tfOps.ifft(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'RFFT': {\n            return [tfOps.rfft(getParamValue('x', node, tensorMap, context))];\n        }\n        case 'IRFFT': {\n            return [tfOps.irfft(getParamValue('x', node, tensorMap, context))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar executeOp$g = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Cast': {\n            return [tfOps.cast(getParamValue('x', node, tensorMap, context), getParamValue('dtype', node, tensorMap, context))];\n        }\n        case 'ExpandDims': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            return [tfOps.expandDims(getParamValue('x', node, tensorMap, context), axis)];\n        }\n        case 'Squeeze': {\n            var axis = getParamValue('axis', node, tensorMap, context);\n            return [tfOps.squeeze(getParamValue('x', node, tensorMap, context), axis)];\n        }\n        case 'Reshape': {\n            return [tfOps.reshape(getParamValue('x', node, tensorMap, context), getParamValue('shape', node, tensorMap, context))];\n        }\n        case 'MirrorPad': {\n            return [tfOps.mirrorPad(getParamValue('x', node, tensorMap, context), getParamValue('padding', node, tensorMap, context), getParamValue('mode', node, tensorMap, context))];\n        }\n        case 'PadV2':\n        case 'Pad': {\n            return [tfOps.pad(getParamValue('x', node, tensorMap, context), getParamValue('padding', node, tensorMap, context), getParamValue('constantValue', node, tensorMap, context))];\n        }\n        case 'SpaceToBatchND': {\n            var blockShape = getParamValue('blockShape', node, tensorMap, context);\n            var paddings = getParamValue('paddings', node, tensorMap, context);\n            return [tfOps.spaceToBatchND(getParamValue('x', node, tensorMap, context), blockShape, paddings)];\n        }\n        case 'BatchToSpaceND': {\n            var blockShape = getParamValue('blockShape', node, tensorMap, context);\n            var crops = getParamValue('crops', node, tensorMap, context);\n            return [tfOps.batchToSpaceND(getParamValue('x', node, tensorMap, context), blockShape, crops)];\n        }\n        case 'DepthToSpace': {\n            var blockSize = getParamValue('blockSize', node, tensorMap, context);\n            var dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n            return [tfOps.depthToSpace(getParamValue('x', node, tensorMap, context), blockSize, dataFormat)];\n        }\n        case 'BroadcastTo': {\n            return [tfOps.broadcastTo(getParamValue('x', node, tensorMap, context), getParamValue('shape', node, tensorMap, context))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Executes the op defined by the node object.\n * @param node\n * @param tensorMap contains tensors for executed nodes and weights\n * @param context contains tensors and information for running the current node.\n * @param resourceManager Optional. Contains global resources of the model.\n */\nfunction executeOp$h(node, tensorMap, context, resourceManager) {\n    var value = (function (node, tensorMap, context) {\n        switch (node.category) {\n            case 'arithmetic':\n                return tfOps.tidy(function () { return executeOp(node, tensorMap, context); });\n            case 'basic_math':\n                return tfOps.tidy(function () { return executeOp$1(node, tensorMap, context); });\n            case 'control':\n                return executeOp$2(node, tensorMap, context);\n            case 'convolution':\n                return tfOps.tidy(function () { return executeOp$3(node, tensorMap, context); });\n            case 'creation':\n                return tfOps.tidy(function () { return executeOp$4(node, tensorMap, context); });\n            case 'dynamic':\n                return executeOp$5(node, tensorMap, context);\n            case 'evaluation':\n                return tfOps.tidy(function () { return executeOp$6(node, tensorMap, context); });\n            case 'image':\n                return tfOps.tidy(function () { return executeOp$9(node, tensorMap, context); });\n            case 'graph':\n                return tfOps.tidy(function () { return executeOp$7(node, tensorMap, context); });\n            case 'logical':\n                return tfOps.tidy(function () { return executeOp$a(node, tensorMap, context); });\n            case 'matrices':\n                return tfOps.tidy(function () { return executeOp$b(node, tensorMap, context); });\n            case 'normalization':\n                return tfOps.tidy(function () { return executeOp$c(node, tensorMap, context); });\n            case 'reduction':\n                return tfOps.tidy(function () { return executeOp$d(node, tensorMap, context); });\n            case 'slice_join':\n                return tfOps.tidy(function () { return executeOp$e(node, tensorMap, context); });\n            case 'spectral':\n                return tfOps.tidy(function () { return executeOp$f(node, tensorMap, context); });\n            case 'transformation':\n                return tfOps.tidy(function () { return executeOp$g(node, tensorMap, context); });\n            case 'hash_table':\n                return executeOp$8(node, tensorMap, context, resourceManager);\n            case 'custom':\n                var opMapper = getRegisteredOp(node.op);\n                if (opMapper && opMapper.customExecutor) {\n                    return opMapper.customExecutor(new NodeValueImpl(node, tensorMap, context));\n                }\n                else {\n                    throw TypeError(\"Custom op \" + node.op + \" is not registered.\");\n                }\n            default:\n                throw TypeError(\"Unknown op '\" + node.op + \"'. File an issue at \" +\n                    \"https://github.com/tensorflow/tfjs/issues so we can add it\" +\n                    \", or register a custom execution with tf.registerOp()\");\n        }\n    })(node, tensorMap, context);\n    if (tfOps.util.isPromise(value)) {\n        return value.then(function (data) { return [].concat(data); });\n    }\n    return [].concat(value);\n}\n\n/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nvar ExecutionContext = /** @class */ (function () {\n    function ExecutionContext(weightMap, tensorArrayMap, tensorListMap, functionMap) {\n        if (weightMap === void 0) { weightMap = {}; }\n        if (tensorArrayMap === void 0) { tensorArrayMap = {}; }\n        if (tensorListMap === void 0) { tensorListMap = {}; }\n        if (functionMap === void 0) { functionMap = {}; }\n        this.weightMap = weightMap;\n        this.tensorArrayMap = tensorArrayMap;\n        this.tensorListMap = tensorListMap;\n        this.functionMap = functionMap;\n        this.rootContext = { id: 0, frameName: '', iterationId: 0 };\n        this.contexts = [this.rootContext];\n        this.lastId = 0;\n        this.generateCurrentContextIds();\n    }\n    ExecutionContext.prototype.newFrame = function (id, frameName) {\n        return { id: id, frameName: frameName, iterationId: 0 };\n    };\n    Object.defineProperty(ExecutionContext.prototype, \"currentContext\", {\n        get: function () {\n            return this.contexts;\n        },\n        /**\n         * Set the current context\n         * @param contexts: ExecutionContextInfo[] the current path of execution\n         * frames\n         */\n        set: function (contexts) {\n            if (this.contexts !== contexts) {\n                this.contexts = contexts;\n                this.generateCurrentContextIds();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExecutionContext.prototype, \"currentContextId\", {\n        /**\n         * Returns the current context in string format.\n         */\n        get: function () {\n            return this._currentContextIds[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExecutionContext.prototype, \"currentContextIds\", {\n        /**\n         * Returns the current context and all parent contexts in string format.\n         * This allow access to the nodes in the current and parent frames.\n         */\n        get: function () {\n            return this._currentContextIds;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ExecutionContext.prototype.generateCurrentContextIds = function () {\n        var names = [];\n        for (var i = 0; i < this.contexts.length - 1; i++) {\n            var contexts = this.contexts.slice(0, this.contexts.length - i);\n            names.push(this.contextIdforContexts(contexts));\n        }\n        names.push('');\n        this._currentContextIds = names;\n    };\n    ExecutionContext.prototype.contextIdforContexts = function (contexts) {\n        return contexts ?\n            contexts\n                .map(function (context) { return (context.id === 0 && context.iterationId === 0) ?\n                '' :\n                context.frameName + \"-\" + context.iterationId; })\n                .join('/') :\n            '';\n    };\n    /**\n     * Enter a new frame, a new context is pushed on the current context list.\n     * @param frameId new frame id\n     */\n    ExecutionContext.prototype.enterFrame = function (frameId) {\n        if (this.contexts) {\n            this.lastId++;\n            this.contexts = this.contexts.slice();\n            this.contexts.push(this.newFrame(this.lastId, frameId));\n            this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n        }\n    };\n    /**\n     * Exit the current frame, the last context is removed from the current\n     * context list.\n     */\n    ExecutionContext.prototype.exitFrame = function () {\n        if (this.contexts && this.contexts.length > 1) {\n            this.contexts = this.contexts.slice();\n            this.contexts.splice(-1);\n            this.currentContextIds.shift();\n        }\n        else {\n            throw new Error('Cannot exit frame, the context is empty');\n        }\n    };\n    /**\n     * Enter the next iteration of a loop, the iteration id of last context is\n     * increased.\n     */\n    ExecutionContext.prototype.nextIteration = function () {\n        if (this.contexts && this.contexts.length > 0) {\n            this.contexts = this.contexts.slice();\n            this.lastId++;\n            var context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n            context.iterationId += 1;\n            context.id = this.lastId;\n            this.contexts.splice(-1, 1, context);\n            this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n        }\n        else {\n            throw new Error('Cannot increase frame iteration, the context is empty');\n        }\n    };\n    ExecutionContext.prototype.getWeight = function (name) {\n        return this.weightMap[name];\n    };\n    ExecutionContext.prototype.addTensorArray = function (tensorArray) {\n        this.tensorArrayMap[tensorArray.id] = tensorArray;\n    };\n    ExecutionContext.prototype.getTensorArray = function (id) {\n        return this.tensorArrayMap[id];\n    };\n    ExecutionContext.prototype.addTensorList = function (tensorList) {\n        this.tensorListMap[tensorList.id] = tensorList;\n    };\n    ExecutionContext.prototype.getTensorList = function (id) {\n        return this.tensorListMap[id];\n    };\n    ExecutionContext.prototype.dispose = function (keepIds) {\n        for (var key in this.tensorArrayMap) {\n            this.tensorArrayMap[key].clearAndClose(keepIds);\n        }\n        for (var key in this.tensorListMap) {\n            this.tensorListMap[key].clearAndClose(keepIds);\n        }\n    };\n    return ExecutionContext;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nfunction getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n    var usedNodes = new Set();\n    var missingInputs = [];\n    var dynamicNode = null;\n    var syncInputs = null;\n    // Start with the outputs, going backwards and find all the nodes that are\n    // needed to compute those outputs.\n    var seen = new Set();\n    var inputNodeNames = Object.keys(inputs).map(function (name) { return parseNodeName(name)[0]; });\n    var initNodeNames = [];\n    if (initNodes != null) {\n        initNodeNames = initNodes.map(function (node) { return parseNodeName(node.name)[0]; });\n    }\n    var frontier = __spread(outputs);\n    while (frontier.length > 0) {\n        var node = frontier.pop();\n        if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n            if (dynamicNode == null) {\n                dynamicNode = node;\n                syncInputs = dynamicNode.children.map(function (child) { return child.name; })\n                    .filter(function (name) { return usedNodes.has(name); });\n            }\n        }\n        usedNodes.add(node.name);\n        // Weights are dead end since we already have their values.\n        if (weightMap[node.name] != null) {\n            continue;\n        }\n        // This node is a dead end since it's one of the user-provided inputs.\n        if (inputNodeNames.indexOf(node.name) !== -1) {\n            continue;\n        }\n        // This node is a dead end since it doesn't have any inputs.\n        if (initNodeNames.indexOf(node.name) !== -1) {\n            continue;\n        }\n        if (node.inputs.length === 0) {\n            missingInputs.push(node.name);\n            continue;\n        }\n        node.inputs.forEach(function (input) {\n            // Don't add to the frontier if it is already there.\n            if (seen.has(input.name)) {\n                return;\n            }\n            seen.add(input.name);\n            frontier.push(input);\n        });\n    }\n    return { inputs: inputs, outputs: outputs, usedNodes: usedNodes, missingInputs: missingInputs, dynamicNode: dynamicNode, syncInputs: syncInputs };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nfunction getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n    var usedNodes = executionInfo.usedNodes, inputs = executionInfo.inputs;\n    var frontier = [];\n    var inputNodes = Object.keys(inputs)\n        .map(function (name) { return parseNodeName(name)[0]; })\n        .map(function (name) { return graph.nodes[name]; });\n    var initNodes = graph.initNodes;\n    inputNodes.forEach(function (input) {\n        if (usedNodes.has(input.name)) {\n            frontier.push(input);\n        }\n    });\n    graph.weights.forEach(function (weight) {\n        if (usedNodes.has(weight.name)) {\n            frontier.push(weight);\n        }\n    });\n    if (initNodes != null) {\n        initNodes.forEach(function (node) {\n            if (usedNodes.has(node.name)) {\n                frontier.push(node);\n            }\n        });\n    }\n    var seen = new Set();\n    var orderedNodes = [];\n    while (frontier.length > 0) {\n        var node = frontier.pop();\n        seen.add(node.name);\n        if (!weightMap[node.name]) {\n            orderedNodes.push(node);\n        }\n        node.children.forEach(function (child) {\n            if (!seen.has(child.name) && usedNodes.has(child.name) &&\n                child.inputs.every(function (input) { return seen.has(input.name); })) {\n                frontier.push(child);\n            }\n        });\n    }\n    return orderedNodes;\n}\nvar CONTROL_FLOW_OPS = [\n    'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\n    'StatelessWhile', 'if', 'While'\n];\nvar DYNAMIC_SHAPE_OPS = [\n    'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\n];\nvar HASH_TABLE_OPS = [\n    'HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2',\n    'LookupTableFind', 'LookupTableFindV2'\n];\nfunction isControlFlow(node) {\n    return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nfunction isDynamicShape(node) {\n    return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\nfunction isHashTable(node) {\n    return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar GraphExecutor = /** @class */ (function () {\n    /**\n     *\n     * @param graph Graph the model or function graph to be executed.\n     * @param parent When building function exector you need to set the parent\n     * executor. Since the weights and function executor maps are set at parant\n     * level, that function executor can access the function maps and weight maps\n     * through the parent.\n     */\n    function GraphExecutor(graph, parent) {\n        var _this = this;\n        this.graph = graph;\n        this.parent = parent;\n        this.compiledMap = new Map();\n        this._weightMap = {};\n        this.SEPERATOR = ',';\n        this._functions = {};\n        this._functionExecutorMap = {};\n        this._outputs = graph.outputs;\n        this._inputs = graph.inputs;\n        this._initNodes = graph.initNodes;\n        this._signature = graph.signature;\n        this._functions = graph.functions;\n        // create sub-graph executors\n        if (graph.functions != null) {\n            Object.keys(graph.functions).forEach(function (name) {\n                _this._functionExecutorMap[name] =\n                    new GraphExecutor(graph.functions[name], _this);\n            });\n        }\n    }\n    Object.defineProperty(GraphExecutor.prototype, \"weightIds\", {\n        get: function () {\n            return this.parent ? this.parent.weightIds : this._weightIds;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"functionExecutorMap\", {\n        get: function () {\n            return this.parent ? this.parent.functionExecutorMap :\n                this._functionExecutorMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"weightMap\", {\n        get: function () {\n            return this.parent ? this.parent.weightMap : this._weightMap;\n        },\n        set: function (weightMap) {\n            var weightIds = Object.keys(weightMap).map(function (key) { return weightMap[key].map(function (tensor) { return tensor.id; }); });\n            this._weightIds = [].concat.apply([], __spread(weightIds));\n            this._weightMap = weightMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"resourceManager\", {\n        /**\n         * Set `ResourceManager` shared by executors of a model.\n         * @param resourceManager: `ResourceManager` of the `GraphModel`.\n         */\n        set: function (resourceManager) {\n            this._resourceManager = resourceManager;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"inputs\", {\n        get: function () {\n            return this._inputs.map(function (node) {\n                return {\n                    name: node.name,\n                    shape: node.attrParams['shape'] ?\n                        node.attrParams['shape'].value :\n                        undefined,\n                    dtype: node.attrParams['dtype'] ?\n                        node.attrParams['dtype'].value :\n                        undefined\n                };\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"outputs\", {\n        get: function () {\n            return this._outputs.map(function (node) {\n                return {\n                    name: node.name,\n                    shape: node.attrParams['shape'] ?\n                        node.attrParams['shape'].value :\n                        undefined,\n                    dtype: node.attrParams['dtype'] ?\n                        node.attrParams['dtype'].value :\n                        undefined\n                };\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"inputNodes\", {\n        get: function () {\n            return this._inputs.map(function (node) { return node.signatureKey || node.name; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"outputNodes\", {\n        get: function () {\n            return this._outputs.map(function (node) {\n                var name = node.signatureKey || node.name;\n                return node.defaultOutput ? (name + \":\" + node.defaultOutput) : name;\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"functions\", {\n        get: function () {\n            var _this = this;\n            return Object.keys(this._functions).reduce(function (map, key) {\n                map[key] = _this._functions[key].signature;\n                return map;\n            }, {});\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GraphExecutor.prototype.getCompilationKey = function (inputs, outputs) {\n        var sortedInputs = inputs.map(function (node) { return node.name; }).sort();\n        var sortedOutputs = outputs.map(function (node) { return node.name; }).sort();\n        return sortedInputs.join(this.SEPERATOR) + '--' +\n            sortedOutputs.join(this.SEPERATOR);\n    };\n    /**\n     * Compiles the inference graph and returns the minimal set of nodes that are\n     * required for execution, in the correct execution order.\n     */\n    GraphExecutor.prototype.compile = function (inputs, outputs) {\n        var executionInfo = getExecutionSubgraph(inputs, outputs, this.weightMap, this._initNodes);\n        var missingInputs = executionInfo.missingInputs, dynamicNode = executionInfo.dynamicNode, syncInputs = executionInfo.syncInputs;\n        if (dynamicNode != null) {\n            throw new Error(\"This execution contains the node '\" + dynamicNode.name + \"', which has \" +\n                (\"the dynamic op '\" + dynamicNode.op + \"'. Please use \") +\n                \"model.executeAsync() instead. Alternatively, to avoid the \" +\n                (\"dynamic ops, specify the inputs [\" + syncInputs + \"]\"));\n        }\n        if (missingInputs.length > 0) {\n            var outNames = outputs.map(function (n) { return n.name; });\n            var inNames = Object.keys(inputs);\n            throw new Error(\"Cannot compute the outputs [\" + outNames + \"] from the provided inputs \" +\n                (\"[\" + inNames + \"]. Missing the following inputs: [\" + missingInputs + \"]\"));\n        }\n        return getNodesInTopologicalOrder(this.graph, this.weightMap, executionInfo);\n    };\n    /**\n     * Executes the inference for given input tensors.\n     * @param inputs Tensor map for the model inputs, keyed by the input node\n     * names.\n     * @param outputs Optional. output node name from the Tensorflow model, if\n     * no outputs are specified, the default outputs of the model would be used.\n     * You can inspect intermediate nodes of the model by adding them to the\n     * outputs array.\n     */\n    GraphExecutor.prototype.execute = function (inputs, outputs) {\n        var _this = this;\n        inputs = this.mapInputs(inputs);\n        var names = Object.keys(inputs).sort();\n        this.checkInputs(inputs);\n        this.checkInputShapeAndType(inputs);\n        outputs = this.mapOutputs(outputs);\n        this.checkOutputs(outputs);\n        var inputNodes = names.map(function (name) { return _this.graph.nodes[parseNodeName(name)[0]]; });\n        var outputNodeNames = outputs.map(function (name) { return parseNodeName(name)[0]; });\n        var outputNodes = outputNodeNames.map(function (name) { return _this.graph.nodes[name]; });\n        // If no outputs are specified, then use the default outputs of the model.\n        if (outputNodes.length === 0) {\n            outputNodes = this._outputs;\n        }\n        var compilationKey = this.getCompilationKey(inputNodes, outputNodes);\n        // Do nothing if the compiled graph cache contains the input.\n        var orderedNodes = this.compiledMap.get(compilationKey);\n        if (orderedNodes == null) {\n            orderedNodes = this.compile(inputs, outputNodes);\n            this.compiledMap.set(compilationKey, orderedNodes);\n        }\n        var tensorArrayMap = {};\n        var tensorListMap = {};\n        return tfOps.tidy(function () {\n            var context = new ExecutionContext(_this.weightMap, tensorArrayMap, tensorListMap, _this.functionExecutorMap);\n            var tensorsMap = __assign({}, _this.weightMap);\n            Object.keys(inputs).forEach(function (name) {\n                var _a = __read(parseNodeName(name), 2), nodeName = _a[0], index = _a[1];\n                var tensors = [];\n                tensors[index] = inputs[name];\n                tensorsMap[nodeName] = tensors;\n            });\n            var tensorsToKeep = _this.getFrozenTensorIds(tensorsMap);\n            var intermediateTensorConsumerCount = {};\n            for (var i = 0; i < orderedNodes.length; i++) {\n                var node = orderedNodes[i];\n                if (!tensorsMap[node.name]) {\n                    var tensors = executeOp$h(node, tensorsMap, context, _this._resourceManager);\n                    if (tfOps.util.isPromise(tensors)) {\n                        throw new Error(\"The execution of the op '\" + node.op + \"' returned a promise. \" +\n                            \"Please use model.executeAsync() instead.\");\n                    }\n                    tensorsMap[node.name] = tensors;\n                    _this.checkTensorForDisposal(node.name, node, tensorsMap, context, tensorsToKeep, outputNodeNames, intermediateTensorConsumerCount);\n                }\n            }\n            // dispose the context for the root executor\n            if (_this.parent == null) {\n                context.dispose(tensorsToKeep);\n            }\n            return outputs.map(function (name) { return getTensor(name, tensorsMap, context); });\n        });\n    };\n    GraphExecutor.prototype.getFrozenTensorIds = function (tensorMap) {\n        var ids = [].concat.apply([], Object.keys(tensorMap)\n            .map(function (key) { return tensorMap[key]; })\n            .map(function (tensors) { return tensors.map(function (tensor) { return tensor.id; }); }));\n        return new Set(ids);\n    };\n    GraphExecutor.prototype.checkTensorForDisposal = function (nodeName, node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount) {\n        // Skip output nodes and any control flow nodes, since its dependency is\n        // tricky to track correctly.\n        if (node.category === 'control' || outputNames.indexOf(nodeName) !== -1) {\n            return;\n        }\n        tensorMap[nodeName].forEach(function (tensor) {\n            if (tensor != null) {\n                intermediateTensorConsumerCount[tensor.id] =\n                    (intermediateTensorConsumerCount[tensor.id] || 0) +\n                        node.children.length;\n            }\n        });\n        node.inputs.forEach(function (input) {\n            // Skip any control flow nodes, since its dependency is tricky to track\n            // correctly.\n            if (input.category !== 'control') {\n                var tensors = getTensorsForCurrentContenxt(input.name, tensorMap, context);\n                if (tensors != null) {\n                    tensors.forEach(function (tensor) {\n                        if (tensor && !tensorsToKeep.has(tensor.id)) {\n                            var count = intermediateTensorConsumerCount[tensor.id];\n                            if (count === 1) {\n                                tensor.dispose();\n                                delete intermediateTensorConsumerCount[tensor.id];\n                            }\n                            else if (count != null) {\n                                // only intermediate nodes has count set, inputs and weights are\n                                // not.\n                                intermediateTensorConsumerCount[tensor.id]--;\n                            }\n                        }\n                    });\n                }\n            }\n        });\n    };\n    /**\n     * Executes the inference for given input tensors in Async fashion.\n     * @param inputs Tensor map for the model inputs, keyed by the input node\n     * names.\n     * @param outputs output node name from the Tensorflow model, if no outputs\n     * are specified, the default outputs of the model would be used. You can\n     * inspect intermediate nodes of the model by adding them to the outputs\n     * array.\n     */\n    GraphExecutor.prototype.executeAsync = function (inputs, outputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this._executeAsync(inputs, outputs)];\n            });\n        });\n    };\n    /**\n     * Executes the inference for given input tensors in Async fashion.\n     * @param inputs Tensor map for the model inputs, keyed by the input node\n     * names.\n     * @param outputs Optional. output node name from the Tensorflow model,\n     * if no outputs are specified, the default outputs of the model would be\n     * used. You can inspect intermediate nodes of the model by adding them to the\n     * outputs array.\n     * @param isFunctionExecution Optional. Flag for executing a function.\n     * @param tensorArrayMap Optional, global TensorArray map by id. Used for\n     * function execution.\n     * @param tensorArrayMap Optinal global TensorList map by id. Used for\n     * function execution.\n     */\n    GraphExecutor.prototype._executeAsync = function (inputs, outputs, isFunctionExecution, tensorArrayMap, tensorListMap) {\n        if (isFunctionExecution === void 0) { isFunctionExecution = false; }\n        if (tensorArrayMap === void 0) { tensorArrayMap = {}; }\n        if (tensorListMap === void 0) { tensorListMap = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var context, tensorMap, results, outputIds, inputIds, keepIds;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!isFunctionExecution) {\n                            inputs = this.mapInputs(inputs);\n                            this.checkInputs(inputs);\n                            this.checkInputShapeAndType(inputs);\n                            outputs = this.mapOutputs(outputs);\n                            this.checkOutputs(outputs);\n                        }\n                        context = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap);\n                        return [4 /*yield*/, this.executeWithControlFlow(inputs, context, outputs, isFunctionExecution)];\n                    case 1:\n                        tensorMap = _a.sent();\n                        results = outputs.map(function (name) { return getTensor(name, tensorMap, context); });\n                        outputIds = results.map(function (t) { return t.id; });\n                        inputIds = Object.keys(inputs).map(function (name) { return inputs[name].id; });\n                        keepIds = new Set(__spread(outputIds, inputIds, this.weightIds));\n                        Object.keys(tensorMap).forEach(function (key) {\n                            var tensorArray = tensorMap[key];\n                            tensorArray.forEach(function (tensor) {\n                                if (tensor && !tensor.isDisposed && !keepIds.has(tensor.id)) {\n                                    tensor.dispose();\n                                }\n                            });\n                        });\n                        // dispose the context for the root executor\n                        if (this.parent == null) {\n                            context.dispose(keepIds);\n                        }\n                        return [2 /*return*/, results];\n                }\n            });\n        });\n    };\n    GraphExecutor.prototype.executeFunctionAsync = function (inputs, tensorArrayMap, tensorListMap) {\n        return __awaiter(this, void 0, void 0, function () {\n            var mappedInputs;\n            var _this = this;\n            return __generator(this, function (_a) {\n                mappedInputs = inputs.reduce(function (map, tensor, index) {\n                    map[_this.inputs[index].name] = tensor;\n                    return map;\n                }, {});\n                return [2 /*return*/, this._executeAsync(mappedInputs, this.outputNodes, true, tensorArrayMap, tensorListMap)];\n            });\n        });\n    };\n    /**\n     * When there are control flow nodes in the graph, the graph execution use\n     * ExecutionContext to keep track of the frames and loop iterators.\n     * @param inputs placeholder tensors for the graph.\n     * @param context the execution context object for current execution.\n     * @param outputNames Optional. output node name from the Tensorflow model,\n     * if no outputs are specified, the default outputs of the model would be\n     * used. You can inspect intermediate nodes of the model by adding them to the\n     * outputs array.\n     * @param isFunctionExecution Flag for executing a function.\n     */\n    GraphExecutor.prototype.executeWithControlFlow = function (inputs, context, outputNames, isFunctionExecution) {\n        return __awaiter(this, void 0, void 0, function () {\n            var names, inputNodes, outputNodeNames, outputNodes, _a, usedNodes, missingInputs, dynamicNode, syncInputs, stack, tensorsMap, intermediateTensorConsumerCount, tensorsToKeep, added, promises, missingOutputs, alternativeMsg;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        names = Object.keys(inputs);\n                        inputNodes = names.map(function (name) { return _this.graph.nodes[parseNodeName(name)[0]]; });\n                        outputNodeNames = outputNames.map(function (name) { return parseNodeName(name)[0]; });\n                        outputNodes = outputNodeNames.map(function (name) { return _this.graph.nodes[name]; });\n                        // If no outputs are specified, then use the default outputs of the model.\n                        if (outputNodes.length === 0) {\n                            outputNodes = this._outputs;\n                        }\n                        _a = getExecutionSubgraph(inputs, outputNodes, this.weightMap, this._initNodes), usedNodes = _a.usedNodes, missingInputs = _a.missingInputs, dynamicNode = _a.dynamicNode, syncInputs = _a.syncInputs;\n                        stack = __spread(inputNodes, this.graph.weights, (this._initNodes || [])).map(function (node) {\n                            return { node: node, contexts: context.currentContext };\n                        });\n                        tensorsMap = __assign({}, this.weightMap);\n                        Object.keys(inputs).forEach(function (name) {\n                            var _a = __read(parseNodeName(name), 2), nodeName = _a[0], index = _a[1];\n                            var tensors = [];\n                            tensors[index] = inputs[name];\n                            tensorsMap[nodeName] = tensors;\n                        });\n                        intermediateTensorConsumerCount = {};\n                        tensorsToKeep = this.getFrozenTensorIds(tensorsMap);\n                        added = {};\n                        _b.label = 1;\n                    case 1:\n                        if (!(stack.length > 0)) return [3 /*break*/, 3];\n                        promises = this.processStack(inputNodes, stack, context, tensorsMap, added, tensorsToKeep, outputNodeNames, intermediateTensorConsumerCount, usedNodes);\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 2:\n                        _b.sent();\n                        return [3 /*break*/, 1];\n                    case 3:\n                        if (dynamicNode == null && !isFunctionExecution) {\n                            console.warn(\"This model execution did not contain any nodes with control flow \" +\n                                \"or dynamic output shapes. You can use model.execute() instead.\");\n                        }\n                        missingOutputs = outputNodes\n                            .filter(function (node) { return !isControlFlow(node) &&\n                            !getTensor(node.name, tensorsMap, context); })\n                            .map(function (node) { return node.name; });\n                        if (missingOutputs.length > 0) {\n                            alternativeMsg = '';\n                            if (dynamicNode != null) {\n                                alternativeMsg =\n                                    \"Alternatively, to avoid the dynamic ops, use model.execute() \" +\n                                        (\"and specify the inputs [\" + syncInputs + \"]\");\n                            }\n                            throw new Error(\"Cannot compute the outputs [\" + missingOutputs + \"] from the provided \" +\n                                (\"inputs [\" + names + \"]. Consider providing the following inputs: \") +\n                                (\"[\" + missingInputs + \"]. \" + alternativeMsg));\n                        }\n                        return [2 /*return*/, tensorsMap];\n                }\n            });\n        });\n    };\n    GraphExecutor.prototype.processStack = function (inputNodes, stack, context, tensorMap, added, tensorsToKeep, outputNames, intermediateTensorConsumerCount, usedNodes) {\n        var _this = this;\n        var promises = [];\n        var _loop_1 = function () {\n            var _a, _b;\n            var item = stack.pop();\n            context.currentContext = item.contexts;\n            var nodeName = '';\n            // The tensor of the Enter op with isConstant set should be set\n            // in the parent scope, so it will be available as constant for the\n            // whole loop.\n            if (item.node.op === 'Enter' &&\n                getParamValue('isConstant', item.node, tensorMap, context)) {\n                _a = __read(getNodeNameAndIndex(item.node.name, context), 1), nodeName = _a[0];\n            }\n            // only process nodes that are not in the tensorMap yet, this include\n            // inputNodes and internal initNodes.\n            if (tensorMap[item.node.name] == null) {\n                var tensors = executeOp$h(item.node, tensorMap, context, this_1._resourceManager);\n                if (!nodeName) {\n                    _b = __read(getNodeNameAndIndex(item.node.name, context), 1), nodeName = _b[0];\n                }\n                var currentContext_1 = context.currentContext;\n                if (tfOps.util.isPromise(tensors)) {\n                    promises.push(tensors.then(function (t) {\n                        tensorMap[nodeName] = t;\n                        context.currentContext = currentContext_1;\n                        _this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);\n                        _this.processChildNodes(item.node, stack, context, tensorMap, added, usedNodes);\n                        return t;\n                    }));\n                }\n                else {\n                    tensorMap[nodeName] = tensors;\n                    this_1.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);\n                    this_1.processChildNodes(item.node, stack, context, tensorMap, added, usedNodes);\n                }\n            }\n            else {\n                this_1.processChildNodes(item.node, stack, context, tensorMap, added, usedNodes);\n            }\n        };\n        var this_1 = this;\n        while (stack.length > 0) {\n            _loop_1();\n        }\n        return promises;\n    };\n    GraphExecutor.prototype.processChildNodes = function (node, stack, context, tensorMap, added, usedNodes) {\n        node.children.forEach(function (childNode) {\n            var _a = __read(getNodeNameAndIndex(childNode.name, context), 1), nodeName = _a[0];\n            if (added[nodeName] || !usedNodes.has(childNode.name)) {\n                return;\n            }\n            // Merge op can be pushed if any of its inputs has value.\n            if (childNode.op === 'Merge') {\n                if (childNode.inputNames.some(function (name) {\n                    return !!getTensor(name, tensorMap, context);\n                })) {\n                    added[nodeName] = true;\n                    stack.push({ contexts: context.currentContext, node: childNode });\n                }\n            }\n            else // Otherwise all inputs must to have value.\n             if (childNode.inputNames.every(function (name) {\n                return !!getTensor(name, tensorMap, context);\n            })) {\n                added[nodeName] = true;\n                stack.push({ contexts: context.currentContext, node: childNode });\n            }\n        });\n    };\n    /**\n     * Releases the memory used by the weight tensors.\n     */\n    GraphExecutor.prototype.dispose = function () {\n        var _this = this;\n        Object.keys(this.weightMap)\n            .forEach(function (key) { return _this.weightMap[key].forEach(function (tensor) { return tensor.dispose(); }); });\n    };\n    GraphExecutor.prototype.checkInputShapeAndType = function (inputs) {\n        var _this = this;\n        Object.keys(inputs).forEach(function (name) {\n            var input = inputs[name];\n            var _a = __read(parseNodeName(name), 1), nodeName = _a[0];\n            var node = _this.graph.nodes[nodeName];\n            if (node.attrParams['shape'] && node.attrParams['shape'].value) {\n                var shape_1 = node.attrParams['shape'].value;\n                var match = shape_1.length === input.shape.length &&\n                    input.shape.every(function (dim, index) { return shape_1[index] === -1 || shape_1[index] === dim; });\n                tfOps.util.assert(match, function () { return \"The shape of dict['\" + node.name + \"'] provided in \" +\n                    (\"model.execute(dict) must be [\" + shape_1 + \"], but was \") +\n                    (\"[\" + input.shape + \"]\"); });\n            }\n            if (node.attrParams['dtype'] && node.attrParams['dtype'].value) {\n                tfOps.util.assert(input.dtype === node.attrParams['dtype'].value, function () { return \"The dtype of dict['\" + node.name + \"'] provided in \" +\n                    \"model.execute(dict) must be \" +\n                    (node.attrParams['dtype'].value + \", but was \" + input.dtype); });\n            }\n        });\n    };\n    GraphExecutor.prototype.mapInputs = function (inputs) {\n        var result = {};\n        for (var inputName in inputs) {\n            if (this._signature != null && this._signature.inputs != null &&\n                this._signature.inputs[inputName] != null) {\n                var tensor = this._signature.inputs[inputName];\n                result[tensor.name] = inputs[inputName];\n            }\n            else {\n                result[inputName] = inputs[inputName];\n            }\n        }\n        return result;\n    };\n    GraphExecutor.prototype.checkInputs = function (inputs) {\n        var _this = this;\n        var notInGraph = Object.keys(inputs).filter(function (name) {\n            var _a = __read(parseNodeName(name), 1), nodeName = _a[0];\n            return _this.graph.nodes[nodeName] == null;\n        });\n        if (notInGraph.length > 0) {\n            throw new Error(\"The dict provided in model.execute(dict) has \" +\n                (\"keys: [\" + notInGraph + \"] that are not part of graph\"));\n        }\n    };\n    GraphExecutor.prototype.mapOutputs = function (outputs) {\n        var _this = this;\n        return outputs.map(function (name) {\n            if (_this._signature != null && _this._signature.outputs != null &&\n                _this._signature.outputs[name] != null) {\n                var tensor = _this._signature.outputs[name];\n                return tensor.name;\n            }\n            return name;\n        }, {});\n    };\n    GraphExecutor.prototype.checkOutputs = function (outputs) {\n        var _this = this;\n        outputs.forEach(function (name) {\n            var _a = __read(parseNodeName(name), 1), normalizedName = _a[0];\n            if (!_this.graph.nodes[normalizedName]) {\n                throw new Error(\"The output '\" + name + \"' is not found in the graph\");\n            }\n        });\n    };\n    return GraphExecutor;\n}());\n\n/**\n * Contains global resources of a model.\n */\nvar ResourceManager = /** @class */ (function () {\n    function ResourceManager(hashTableNameToHandle, hashTableMap) {\n        if (hashTableNameToHandle === void 0) { hashTableNameToHandle = {}; }\n        if (hashTableMap === void 0) { hashTableMap = {}; }\n        this.hashTableNameToHandle = hashTableNameToHandle;\n        this.hashTableMap = hashTableMap;\n    }\n    /**\n     * Register a `HashTable` in the resource manager.\n     *\n     * The `HashTable` can be retrieved by `resourceManager.getHashTableById`,\n     * where id is the table handle tensor's id.\n     *\n     * @param name Op node name that creates the `HashTable`.\n     * @param hashTable The `HashTable` to be added to resource manager.\n     */\n    ResourceManager.prototype.addHashTable = function (name, hashTable) {\n        this.hashTableNameToHandle[name] = hashTable.handle;\n        this.hashTableMap[hashTable.id] = hashTable;\n    };\n    /**\n     * Get the table handle by node name.\n     * @param name Op node name that creates the `HashTable`. This name is also\n     *     used in the inputs list of lookup and import `HashTable` ops.\n     */\n    ResourceManager.prototype.getHashTableHandleByName = function (name) {\n        return this.hashTableNameToHandle[name];\n    };\n    /**\n     * Get the actual `HashTable` by its handle tensor's id.\n     * @param id The id of the handle tensor.\n     */\n    ResourceManager.prototype.getHashTableById = function (id) {\n        return this.hashTableMap[id];\n    };\n    /**\n     * Dispose `ResourceManager`, including its hashTables and tensors in them.\n     */\n    ResourceManager.prototype.dispose = function () {\n        for (var key in this.hashTableMap) {\n            this.hashTableMap[key].clearAndClose();\n            delete this.hashTableMap[key];\n        }\n        for (var name_1 in this.hashTableNameToHandle) {\n            this.hashTableNameToHandle[name_1].dispose();\n            delete this.hashTableNameToHandle[name_1];\n        }\n    };\n    return ResourceManager;\n}());\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar TFHUB_SEARCH_PARAM = '?tfjs-format=file';\nvar DEFAULT_MODEL_NAME = 'model.json';\n/**\n * A `tf.GraphModel` is a directed, acyclic graph built from a\n * SavedModel GraphDef and allows inference execution.\n *\n * A `tf.GraphModel` can only be created by loading from a model converted from\n * a [TensorFlow SavedModel](https://www.tensorflow.org/guide/saved_model) using\n * the command line converter tool and loaded via `tf.loadGraphModel`.\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\nvar GraphModel = /** @class */ (function () {\n    /**\n     * @param modelUrl url for the model, or an `io.IOHandler`.\n     * @param weightManifestUrl url for the weight file generated by\n     * scripts/convert.py script.\n     * @param requestOption options for Request, which allows to send credentials\n     * and custom headers.\n     * @param onProgress Optional, progress callback function, fired periodically\n     * before the load is completed.\n     */\n    function GraphModel(modelUrl, loadOptions) {\n        if (loadOptions === void 0) { loadOptions = {}; }\n        this.modelUrl = modelUrl;\n        this.loadOptions = loadOptions;\n        this.version = 'n/a';\n        if (loadOptions == null) {\n            this.loadOptions = {};\n        }\n        this.resourceManager = new ResourceManager();\n    }\n    Object.defineProperty(GraphModel.prototype, \"modelVersion\", {\n        // Returns the version information for the tensorflow model GraphDef.\n        get: function () {\n            return this.version;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"inputNodes\", {\n        get: function () {\n            return this.executor.inputNodes;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"outputNodes\", {\n        get: function () {\n            return this.executor.outputNodes;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"inputs\", {\n        get: function () {\n            return this.executor.inputs;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"outputs\", {\n        get: function () {\n            return this.executor.outputs;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"weights\", {\n        get: function () {\n            return this.executor.weightMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"metadata\", {\n        get: function () {\n            return this.artifacts.userDefinedMetadata;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"modelSignature\", {\n        get: function () {\n            return this.signature;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GraphModel.prototype.findIOHandler = function () {\n        var path = this.modelUrl;\n        if (path.load != null) {\n            // Path is an IO Handler.\n            this.handler = path;\n        }\n        else if (this.loadOptions.requestInit != null) {\n            this.handler = tfOps.io.browserHTTPRequest(path, this.loadOptions);\n        }\n        else {\n            var handlers = tfOps.io.getLoadHandlers(path, this.loadOptions);\n            if (handlers.length === 0) {\n                // For backward compatibility: if no load handler can be found,\n                // assume it is a relative http path.\n                handlers.push(tfOps.io.browserHTTPRequest(path, this.loadOptions));\n            }\n            else if (handlers.length > 1) {\n                throw new Error(\"Found more than one (\" + handlers.length + \") load handlers for \" +\n                    (\"URL '\" + [path] + \"'\"));\n            }\n            this.handler = handlers[0];\n        }\n    };\n    /**\n     * Loads the model and weight files, construct the in memory weight map and\n     * compile the inference graph.\n     */\n    GraphModel.prototype.load = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var artifacts;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.findIOHandler();\n                        if (this.handler.load == null) {\n                            throw new Error('Cannot proceed with model loading because the IOHandler provided ' +\n                                'does not have the `load` method implemented.');\n                        }\n                        return [4 /*yield*/, this.handler.load()];\n                    case 1:\n                        artifacts = _a.sent();\n                        return [2 /*return*/, this.loadSync(artifacts)];\n                }\n            });\n        });\n    };\n    /**\n     * Synchronously construct the in memory weight map and\n     * compile the inference graph. Also initialize hashtable if any.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n     */\n    GraphModel.prototype.loadSync = function (artifacts) {\n        this.artifacts = artifacts;\n        var graph = this.artifacts.modelTopology;\n        var signature;\n        if (this.artifacts.userDefinedMetadata != null &&\n            this.artifacts.userDefinedMetadata.signature != null) {\n            signature = // tslint:disable-next-line:no-any\n                this.artifacts.userDefinedMetadata.signature;\n        }\n        else {\n            signature = this.artifacts.signature;\n        }\n        this.signature = signature;\n        this.version = graph.versions.producer + \".\" + graph.versions.minConsumer;\n        var weightMap = tfOps.io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);\n        this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(graph, this.signature));\n        this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);\n        // Attach a model-level resourceManager to each executor to share resources,\n        // such as `HashTable`.\n        this.executor.resourceManager = this.resourceManager;\n        if (artifacts.modelInitializer != null &&\n            artifacts.modelInitializer.node != null) {\n            var initializer = OperationMapper.Instance.transformGraph(artifacts.modelInitializer);\n            this.initializer = new GraphExecutor(initializer);\n            this.initializer.weightMap = this.executor.weightMap;\n            // Attach a model-level resourceManager to the initializer, the\n            // hashTables created from when executing the initializer will be stored\n            // in the resourceManager.\n            this.initializer.resourceManager = this.resourceManager;\n            this.initializer.executeAsync({}, []);\n        }\n        return true;\n    };\n    /**\n     * Save the configuration and/or weights of the GraphModel.\n     *\n     * An `IOHandler` is an object that has a `save` method of the proper\n     * signature defined. The `save` method manages the storing or\n     * transmission of serialized data (\"artifacts\") that represent the\n     * model's topology and weights onto or via a specific medium, such as\n     * file downloads, local storage, IndexedDB in the web browser and HTTP\n     * requests to a server. TensorFlow.js provides `IOHandler`\n     * implementations for a number of frequently used saving mediums, such as\n     * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`\n     * for more details.\n     *\n     * This method also allows you to refer to certain types of `IOHandler`s\n     * as URL-like string shortcuts, such as 'localstorage://' and\n     * 'indexeddb://'.\n     *\n     * Example 1: Save `model`'s topology and weights to browser [local\n     * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n     * then load it back.\n     *\n     * ```js\n     * const modelUrl =\n     *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';\n     * const model = await tf.loadGraphModel(modelUrl);\n     * const zeros = tf.zeros([1, 224, 224, 3]);\n     * model.predict(zeros).print();\n     *\n     * const saveResults = await model.save('localstorage://my-model-1');\n     *\n     * const loadedModel = await tf.loadGraphModel('localstorage://my-model-1');\n     * console.log('Prediction from loaded model:');\n     * model.predict(zeros).print();\n     * ```\n     *\n     * @param handlerOrURL An instance of `IOHandler` or a URL-like,\n     * scheme-based string shortcut for `IOHandler`.\n     * @param config Options for saving the model.\n     * @returns A `Promise` of `SaveResult`, which summarizes the result of\n     * the saving, such as byte sizes of the saved artifacts for the model's\n     *   topology and weight values.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n     */\n    GraphModel.prototype.save = function (handlerOrURL, config) {\n        return __awaiter(this, void 0, void 0, function () {\n            var handlers;\n            return __generator(this, function (_a) {\n                if (typeof handlerOrURL === 'string') {\n                    handlers = tfOps.io.getSaveHandlers(handlerOrURL);\n                    if (handlers.length === 0) {\n                        throw new Error(\"Cannot find any save handlers for URL '\" + handlerOrURL + \"'\");\n                    }\n                    else if (handlers.length > 1) {\n                        throw new Error(\"Found more than one (\" + handlers.length + \") save handlers for \" +\n                            (\"URL '\" + handlerOrURL + \"'\"));\n                    }\n                    handlerOrURL = handlers[0];\n                }\n                if (handlerOrURL.save == null) {\n                    throw new Error('GraphModel.save() cannot proceed because the IOHandler ' +\n                        'provided does not have the `save` attribute defined.');\n                }\n                return [2 /*return*/, handlerOrURL.save(this.artifacts)];\n            });\n        });\n    };\n    /**\n     * Execute the inference for the input tensors.\n     *\n     * @param input The input tensors, when there is single input for the model,\n     * inputs param should be a `tf.Tensor`. For models with mutliple inputs,\n     * inputs params should be in either `tf.Tensor`[] if the input order is\n     * fixed, or otherwise NamedTensorMap format.\n     *\n     * For model with multiple inputs, we recommend you use NamedTensorMap as the\n     * input type, if you use `tf.Tensor`[], the order of the array needs to\n     * follow the\n     * order of inputNodes array. @see {@link GraphModel.inputNodes}\n     *\n     * You can also feed any intermediate nodes using the NamedTensorMap as the\n     * input type. For example, given the graph\n     *    InputNode => Intermediate => OutputNode,\n     * you can execute the subgraph Intermediate => OutputNode by calling\n     *    model.execute('IntermediateNode' : tf.tensor(...));\n     *\n     * This is useful for models that uses tf.dynamic_rnn, where the intermediate\n     * state needs to be fed manually.\n     *\n     * For batch inference execution, the tensors for each input need to be\n     * concatenated together. For example with mobilenet, the required input shape\n     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].\n     * If we are provide a batched data of 100 images, the input tensor should be\n     * in the shape of [100, 244, 244, 3].\n     *\n     * @param config Prediction configuration for specifying the batch size and\n     * output node names. Currently the batch size option is ignored for graph\n     * model.\n     *\n     * @returns Inference result tensors. The output would be single `tf.Tensor`\n     * if model has single output node, otherwise Tensor[] or NamedTensorMap[]\n     * will be returned for model with multiple outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    GraphModel.prototype.predict = function (inputs, config) {\n        return this.execute(inputs, this.outputNodes);\n    };\n    GraphModel.prototype.normalizeInputs = function (inputs) {\n        if (!(inputs instanceof tfOps.Tensor) && !Array.isArray(inputs)) {\n            // The input is already a NamedTensorMap.\n            return inputs;\n        }\n        inputs = Array.isArray(inputs) ? inputs : [inputs];\n        if (inputs.length !== this.inputNodes.length) {\n            throw new Error('Input tensor count mismatch,' +\n                (\"the graph model has \" + this.inputNodes.length + \" placeholders, \") +\n                (\"while there are \" + inputs.length + \" input tensors.\"));\n        }\n        return this.inputNodes.reduce(function (map, inputName, i) {\n            map[inputName] = inputs[i];\n            return map;\n        }, {});\n    };\n    GraphModel.prototype.normalizeOutputs = function (outputs) {\n        outputs = outputs || this.outputNodes;\n        return !Array.isArray(outputs) ? [outputs] : outputs;\n    };\n    /**\n     * Executes inference for the model for given input tensors.\n     * @param inputs tensor, tensor array or tensor map of the inputs for the\n     * model, keyed by the input node names.\n     * @param outputs output node name from the Tensorflow model, if no\n     * outputs are specified, the default outputs of the model would be used.\n     * You can inspect intermediate nodes of the model by adding them to the\n     * outputs array.\n     *\n     * @returns A single tensor if provided with a single output or no outputs\n     * are provided and there is only one default output, otherwise return a\n     * tensor array. The order of the tensor array is the same as the outputs\n     * if provided, otherwise the order of outputNodes attribute of the model.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    GraphModel.prototype.execute = function (inputs, outputs) {\n        inputs = this.normalizeInputs(inputs);\n        outputs = this.normalizeOutputs(outputs);\n        var result = this.executor.execute(inputs, outputs);\n        return result.length > 1 ? result : result[0];\n    };\n    /**\n     * Executes inference for the model for given input tensors in async\n     * fashion, use this method when your model contains control flow ops.\n     * @param inputs tensor, tensor array or tensor map of the inputs for the\n     * model, keyed by the input node names.\n     * @param outputs output node name from the Tensorflow model, if no outputs\n     * are specified, the default outputs of the model would be used. You can\n     * inspect intermediate nodes of the model by adding them to the outputs\n     * array.\n     *\n     * @returns A Promise of single tensor if provided with a single output or\n     * no outputs are provided and there is only one default output, otherwise\n     * return a tensor map.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    GraphModel.prototype.executeAsync = function (inputs, outputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        inputs = this.normalizeInputs(inputs);\n                        outputs = this.normalizeOutputs(outputs);\n                        return [4 /*yield*/, this.executor.executeAsync(inputs, outputs)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, result.length > 1 ? result : result[0]];\n                }\n            });\n        });\n    };\n    GraphModel.prototype.convertTensorMapToTensorsMap = function (map) {\n        return Object.keys(map).reduce(function (newMap, key) {\n            newMap[key] = [map[key]];\n            return newMap;\n        }, {});\n    };\n    /**\n     * Releases the memory used by the weight tensors and resourceManager.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    GraphModel.prototype.dispose = function () {\n        this.executor.dispose();\n        if (this.initializer) {\n            this.initializer.dispose();\n        }\n        this.resourceManager.dispose();\n    };\n    return GraphModel;\n}());\n/**\n * Load a graph model given a URL to the model definition.\n *\n * Example of loading MobileNetV2 from a URL and making a prediction with a\n * zeros input:\n *\n * ```js\n * const modelUrl =\n *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';\n * const model = await tf.loadGraphModel(modelUrl);\n * const zeros = tf.zeros([1, 224, 224, 3]);\n * model.predict(zeros).print();\n * ```\n *\n * Example of loading MobileNetV2 from a TF Hub URL and making a prediction with\n * a zeros input:\n *\n * ```js\n * const modelUrl =\n *    'https://tfhub.dev/google/imagenet/mobilenet_v2_140_224/classification/2';\n * const model = await tf.loadGraphModel(modelUrl, {fromTFHub: true});\n * const zeros = tf.zeros([1, 224, 224, 3]);\n * model.predict(zeros).print();\n * ```\n * @param modelUrl The url or an `io.IOHandler` that loads the model.\n * @param options Options for the HTTP request, which allows to send credentials\n *    and custom headers.\n *\n * @doc {heading: 'Models', subheading: 'Loading'}\n */\nfunction loadGraphModel(modelUrl, options) {\n    if (options === void 0) { options = {}; }\n    return __awaiter(this, void 0, void 0, function () {\n        var model;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (modelUrl == null) {\n                        throw new Error('modelUrl in loadGraphModel() cannot be null. Please provide a url ' +\n                            'or an IOHandler that loads the model');\n                    }\n                    if (options == null) {\n                        options = {};\n                    }\n                    if (options.fromTFHub) {\n                        if (modelUrl.load == null) {\n                            if (!modelUrl.endsWith('/')) {\n                                modelUrl = modelUrl + '/';\n                            }\n                            modelUrl = \"\" + modelUrl + DEFAULT_MODEL_NAME + TFHUB_SEARCH_PARAM;\n                        }\n                    }\n                    model = new GraphModel(modelUrl, options);\n                    return [4 /*yield*/, model.load()];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/, model];\n            }\n        });\n    });\n}\n\n/** @license See the LICENSE file. */\n// This code is auto-generated, do not modify this file!\nvar version = '2.8.6';\n\nexports.GraphModel = GraphModel;\nexports.deregisterOp = deregisterOp;\nexports.loadGraphModel = loadGraphModel;\nexports.registerOp = registerOp;\nexports.version_converter = version;\n//# sourceMappingURL=tf-converter.node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRlbnNvcmZsb3crdGZqcy1jb252ZXJ0ZXJAMi44LjZfQHRlbnNvcmZsb3crdGZqcy1jb3JlQDIuOC42L25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L3RmLWNvbnZlcnRlci5ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxZQUFZLG1CQUFPLENBQUMsNklBQXVCOztBQUUzQztBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQyxpRUFBaUUsd0JBQXdCO0FBQ3pIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztB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QUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RCxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pELGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RCxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RCxjQUFjLHNEQUFzRDtBQUNwRSxjQUFjLHNEQUFzRDtBQUNwRTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBOEM7QUFDNUQsY0FBYyw4Q0FBOEM7QUFDNUQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYyx1RUFBdUU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjLHVFQUF1RTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RCxjQUFjLCtDQUErQztBQUM3RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxtRkFBbUYsdUZBQXVGO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDJCQUEyQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG1CQUFtQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsbUJBQW1CO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsMkRBQTJEO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUNBQWlDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseUJBQXlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UseUJBQXlCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQSxrREFBa0Q7QUFDbEQsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0JBQWtCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw2Q0FBNkM7QUFDN0Y7QUFDQSxnREFBZ0QsK0NBQStDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwrQ0FBK0M7QUFDL0Y7QUFDQSxnREFBZ0QsK0NBQStDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwrQ0FBK0M7QUFDL0Y7QUFDQSxnREFBZ0QsK0NBQStDO0FBQy9GO0FB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SztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw4QkFBOEI7QUFDcEY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0VBQXdFLDhDQUE4QyxtQkFBbUIsSUFBSTtBQUM3STtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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dUQ7QUFDdkQ7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL21vbW9uZ2FoLmdpdGh1Yi5pby8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVuc29yZmxvdyt0ZmpzLWNvbnZlcnRlckAyLjguNl9AdGVuc29yZmxvdyt0ZmpzLWNvcmVAMi44LjYvbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3QvdGYtY29udmVydGVyLm5vZGUuanM/MGZmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0Zk9wcyA9IHJlcXVpcmUoJ0B0ZW5zb3JmbG93L3RmanMtY29yZScpO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxudmFyIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKiogRGF0YVR5cGUgZW51bS4gKi9cbnZhciBEYXRhVHlwZTtcbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX0lOVkFMSURcIl0gPSAwXSA9IFwiRFRfSU5WQUxJRFwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiRFRfRkxPQVRcIl0gPSAxXSA9IFwiRFRfRkxPQVRcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX0RPVUJMRVwiXSA9IDJdID0gXCJEVF9ET1VCTEVcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX0lOVDMyXCJdID0gM10gPSBcIkRUX0lOVDMyXCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJEVF9VSU5UOFwiXSA9IDRdID0gXCJEVF9VSU5UOFwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiRFRfSU5UMTZcIl0gPSA1XSA9IFwiRFRfSU5UMTZcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX0lOVDhcIl0gPSA2XSA9IFwiRFRfSU5UOFwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiRFRfU1RSSU5HXCJdID0gN10gPSBcIkRUX1NUUklOR1wiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiRFRfQ09NUExFWDY0XCJdID0gOF0gPSBcIkRUX0NPTVBMRVg2NFwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiRFRfSU5UNjRcIl0gPSA5XSA9IFwiRFRfSU5UNjRcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX0JPT0xcIl0gPSAxMF0gPSBcIkRUX0JPT0xcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX1FJTlQ4XCJdID0gMTFdID0gXCJEVF9RSU5UOFwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiRFRfUVVJTlQ4XCJdID0gMTJdID0gXCJEVF9RVUlOVDhcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX1FJTlQzMlwiXSA9IDEzXSA9IFwiRFRfUUlOVDMyXCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJEVF9CRkxPQVQxNlwiXSA9IDE0XSA9IFwiRFRfQkZMT0FUMTZcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX0ZMT0FUX1JFRlwiXSA9IDEwMV0gPSBcIkRUX0ZMT0FUX1JFRlwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiRFRfRE9VQkxFX1JFRlwiXSA9IDEwMl0gPSBcIkRUX0RPVUJMRV9SRUZcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX0lOVDMyX1JFRlwiXSA9IDEwM10gPSBcIkRUX0lOVDMyX1JFRlwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiRFRfVUlOVDhfUkVGXCJdID0gMTA0XSA9IFwiRFRfVUlOVDhfUkVGXCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJEVF9JTlQxNl9SRUZcIl0gPSAxMDVdID0gXCJEVF9JTlQxNl9SRUZcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX0lOVDhfUkVGXCJdID0gMTA2XSA9IFwiRFRfSU5UOF9SRUZcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX1NUUklOR19SRUZcIl0gPSAxMDddID0gXCJEVF9TVFJJTkdfUkVGXCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJEVF9DT01QTEVYNjRfUkVGXCJdID0gMTA4XSA9IFwiRFRfQ09NUExFWDY0X1JFRlwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiRFRfSU5UNjRfUkVGXCJdID0gMTA5XSA9IFwiRFRfSU5UNjRfUkVGXCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJEVF9CT09MX1JFRlwiXSA9IDExMF0gPSBcIkRUX0JPT0xfUkVGXCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJEVF9RSU5UOF9SRUZcIl0gPSAxMTFdID0gXCJEVF9RSU5UOF9SRUZcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRUX1FVSU5UOF9SRUZcIl0gPSAxMTJdID0gXCJEVF9RVUlOVDhfUkVGXCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJEVF9RSU5UMzJfUkVGXCJdID0gMTEzXSA9IFwiRFRfUUlOVDMyX1JFRlwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiRFRfQkZMT0FUMTZfUkVGXCJdID0gMTE0XSA9IFwiRFRfQkZMT0FUMTZfUkVGXCI7XG59KShEYXRhVHlwZSB8fCAoRGF0YVR5cGUgPSB7fSkpO1xudmFyIFNhdmVyRGVmO1xuKGZ1bmN0aW9uIChTYXZlckRlZikge1xuICAgIC8qKiBDaGVja3BvaW50Rm9ybWF0VmVyc2lvbiBlbnVtLiAqL1xuICAgIHZhciBDaGVja3BvaW50Rm9ybWF0VmVyc2lvbjtcbiAgICAoZnVuY3Rpb24gKENoZWNrcG9pbnRGb3JtYXRWZXJzaW9uKSB7XG4gICAgICAgIENoZWNrcG9pbnRGb3JtYXRWZXJzaW9uW0NoZWNrcG9pbnRGb3JtYXRWZXJzaW9uW1wiTEVHQUNZXCJdID0gMF0gPSBcIkxFR0FDWVwiO1xuICAgICAgICBDaGVja3BvaW50Rm9ybWF0VmVyc2lvbltDaGVja3BvaW50Rm9ybWF0VmVyc2lvbltcIlYxXCJdID0gMV0gPSBcIlYxXCI7XG4gICAgICAgIENoZWNrcG9pbnRGb3JtYXRWZXJzaW9uW0NoZWNrcG9pbnRGb3JtYXRWZXJzaW9uW1wiVjJcIl0gPSAyXSA9IFwiVjJcIjtcbiAgICB9KShDaGVja3BvaW50Rm9ybWF0VmVyc2lvbiA9IFNhdmVyRGVmLkNoZWNrcG9pbnRGb3JtYXRWZXJzaW9uIHx8IChTYXZlckRlZi5DaGVja3BvaW50Rm9ybWF0VmVyc2lvbiA9IHt9KSk7XG59KShTYXZlckRlZiB8fCAoU2F2ZXJEZWYgPSB7fSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgQ1VTVE9NX09QUyA9IHt9O1xuLyoqXG4gKiBSZWdpc3RlciBhbiBPcCBmb3IgZ3JhcGggbW9kZWwgZXhlY3V0b3IuIFRoaXMgYWxsb3cgeW91IHRvIHJlZ2lzdGVyXG4gKiBUZW5zb3JGbG93IGN1c3RvbSBvcCBvciBvdmVycmlkZSBleGlzdGluZyBvcC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgcmVnaXN0ZXJpbmcgYSBuZXcgTWF0TXVsIE9wLlxuICogYGBganNcbiAqIGNvbnN0IGN1c3RvbU1hdG11bCA9IChub2RlKSA9PlxuICogICAgdGYubWF0TXVsKFxuICogICAgICAgIG5vZGUuaW5wdXRzWzBdLCBub2RlLmlucHV0c1sxXSxcbiAqICAgICAgICBub2RlLmF0dHJzWyd0cmFuc3Bvc2VfYSddLCBub2RlLmF0dHJzWyd0cmFuc3Bvc2VfYiddKTtcbiAqXG4gKiB0Zi5yZWdpc3Rlck9wKCdNYXRNdWwnLCBjdXN0b21NYXRtdWwpO1xuICogYGBgXG4gKiBUaGUgaW5wdXRzIGFuZCBhdHRycyBvZiB0aGUgbm9kZSBvYmplY3QgaXMgYmFzZWQgb24gdGhlIFRlbnNvckZsb3cgb3BcbiAqIHJlZ2lzdHJ5LlxuICpcbiAqIEBwYXJhbSBuYW1lIFRoZSBUZW5zb3JmbG93IE9wIG5hbWUuXG4gKiBAcGFyYW0gb3BGdW5jIEFuIG9wIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBjdXJyZW50IGdyYXBoIG5vZGVcbiAqIGR1cmluZyBleGVjdXRpb24gYW5kIG5lZWRzIHRvIHJldHVybiBhIHRlbnNvciBvciBhIGxpc3Qgb2YgdGVuc29ycy4gVGhlIG5vZGVcbiAqIGhhcyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKiAgICAtIGF0dHI6IEEgbWFwIGZyb20gYXR0cmlidXRlIG5hbWUgdG8gaXRzIHZhbHVlXG4gKiAgICAtIGlucHV0czogQSBsaXN0IG9mIGlucHV0IHRlbnNvcnNcbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ09wIFJlZ2lzdHJ5J31cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJPcChuYW1lLCBvcEZ1bmMpIHtcbiAgICB2YXIgb3BNYXBwZXIgPSB7XG4gICAgICAgIHRmT3BOYW1lOiBuYW1lLFxuICAgICAgICBjYXRlZ29yeTogJ2N1c3RvbScsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgY3VzdG9tRXhlY3V0b3I6IG9wRnVuY1xuICAgIH07XG4gICAgQ1VTVE9NX09QU1tuYW1lXSA9IG9wTWFwcGVyO1xufVxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgT3BNYXBwZXIgb2JqZWN0IGZvciB0aGUgcmVnaXN0ZXJlZCBvcC5cbiAqXG4gKiBAcGFyYW0gbmFtZSBUaGUgVGVuc29yZmxvdyBPcCBuYW1lLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnT3AgUmVnaXN0cnknfVxuICovXG5mdW5jdGlvbiBnZXRSZWdpc3RlcmVkT3AobmFtZSkge1xuICAgIHJldHVybiBDVVNUT01fT1BTW25hbWVdO1xufVxuLyoqXG4gKiBEZXJlZ2lzdGVyIHRoZSBPcCBmb3IgZ3JhcGggbW9kZWwgZXhlY3V0b3IuXG4gKlxuICogQHBhcmFtIG5hbWUgVGhlIFRlbnNvcmZsb3cgT3AgbmFtZS5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ09wIFJlZ2lzdHJ5J31cbiAqL1xuZnVuY3Rpb24gZGVyZWdpc3Rlck9wKG5hbWUpIHtcbiAgICBkZWxldGUgQ1VTVE9NX09QU1tuYW1lXTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyYW1WYWx1ZShwYXJhbU5hbWUsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCwgcmVzb3VyY2VNYW5hZ2VyKSB7XG4gICAgdmFyIGlucHV0UGFyYW0gPSBub2RlLmlucHV0UGFyYW1zW3BhcmFtTmFtZV07XG4gICAgaWYgKGlucHV0UGFyYW0gJiYgaW5wdXRQYXJhbS5pbnB1dEluZGV4U3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBpbnB1dFBhcmFtLmlucHV0SW5kZXhTdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IGlucHV0UGFyYW0uaW5wdXRJbmRleEVuZCA9PT0gMCA/XG4gICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgKGlucHV0UGFyYW0uaW5wdXRJbmRleEVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgKyAxIDpcbiAgICAgICAgICAgICAgICBpbnB1dFBhcmFtLmlucHV0SW5kZXhFbmQpO1xuICAgICAgICBpZiAoaW5wdXRQYXJhbS50eXBlID09PSAndGVuc29yJykge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbnNvcihub2RlLmlucHV0TmFtZXNbaW5wdXRQYXJhbS5pbnB1dEluZGV4U3RhcnRdLCB0ZW5zb3JNYXAsIGNvbnRleHQsIHJlc291cmNlTWFuYWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0UGFyYW0udHlwZSA9PT0gJ3RlbnNvcnMnKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRzID0gbm9kZS5pbnB1dE5hbWVzLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0cy5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGdldFRlbnNvcihuYW1lLCB0ZW5zb3JNYXAsIGNvbnRleHQsIHJlc291cmNlTWFuYWdlcik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW5zb3IgPSBnZXRUZW5zb3Iobm9kZS5pbnB1dE5hbWVzLnNsaWNlKHN0YXJ0KVswXSwgdGVuc29yTWFwLCBjb250ZXh0LCByZXNvdXJjZU1hbmFnZXIpO1xuICAgICAgICB2YXIgZGF0YSA9IHRlbnNvci5kYXRhU3luYygpO1xuICAgICAgICByZXR1cm4gaW5wdXRQYXJhbS50eXBlID09PSAnbnVtYmVyJyA/XG4gICAgICAgICAgICBkYXRhWzBdIDpcbiAgICAgICAgICAgIHRmT3BzLnV0aWwudG9OZXN0ZWRBcnJheSh0ZW5zb3Iuc2hhcGUsIGRhdGEpO1xuICAgIH1cbiAgICB2YXIgYXR0clBhcmFtID0gbm9kZS5hdHRyUGFyYW1zW3BhcmFtTmFtZV07XG4gICAgcmV0dXJuIGF0dHJQYXJhbSAmJiBhdHRyUGFyYW0udmFsdWU7XG59XG4vKipcbiAqIFJldHJpZXZlIHRoZSB0ZW5zb3IgZnJvbSB0ZW5zb3JzTWFwIGJhc2VkIG9uIGlucHV0IG5hbWUuXG4gKiBAcGFyYW0gbmFtZSBOb2RlIGlucHV0IG5hbWVcbiAqIEBwYXJhbSB0ZW5zb3JzTWFwIFRlbnNvcnMgbWFwIGtleWVkIGJ5IHRoZSBub2RlXG4gKiBAcGFyYW0gY29udGV4dCBjb250YWlucyB0ZW5zb3JzIGFuZCBpbmZvcm1hdGlvbiBmb3IgcnVubmluZyB0aGUgY3VycmVudCBub2RlLlxuICogQHBhcmFtIHJlc291cmNlTWFuYWdlciBPcHRpb25hbC4gQ29udGFpbnMgZ2xvYmFsIHJlc291cmNlcyBvZiB0aGUgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIGdldFRlbnNvcihuYW1lLCB0ZW5zb3JzTWFwLCBjb250ZXh0LCByZXNvdXJjZU1hbmFnZXIpIHtcbiAgICB2YXIgX2EgPSBfX3JlYWQocGFyc2VOb2RlTmFtZShuYW1lKSwgMiksIG5vZGVOYW1lID0gX2FbMF0sIGluZGV4ID0gX2FbMV07XG4gICAgaWYgKHJlc291cmNlTWFuYWdlciAhPSBudWxsKSB7XG4gICAgICAgIHZhciB0ZW5zb3IgPSByZXNvdXJjZU1hbmFnZXIuZ2V0SGFzaFRhYmxlSGFuZGxlQnlOYW1lKG5vZGVOYW1lKTtcbiAgICAgICAgaWYgKHRlbnNvciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVuc29yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjb250ZXh0SWQgPSBjb250ZXh0LmN1cnJlbnRDb250ZXh0SWRzLmZpbmQoZnVuY3Rpb24gKGNvbnRleHRJZCkge1xuICAgICAgICByZXR1cm4gISF0ZW5zb3JzTWFwW2dldE5vZGVOYW1lV2l0aENvbnRleHRJZChub2RlTmFtZSwgY29udGV4dElkKV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRleHRJZCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgdGVuc29yc01hcFtnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQobm9kZU5hbWUsIGNvbnRleHRJZCldW2luZGV4XSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogUmV0cmlldmUgdGhlIHRlbnNvcnMgYmFzZWQgb24gaW5wdXQgbmFtZSBmb3IgY3VycmVudCBjb250ZXh0LlxuICogQHBhcmFtIG5hbWUgTm9kZSBpbnB1dCBuYW1lXG4gKiBAcGFyYW0gdGVuc29yc01hcCBUZW5zb3JzIG1hcCBrZXllZCBieSB0aGUgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRUZW5zb3JzRm9yQ3VycmVudENvbnRlbnh0KG5hbWUsIHRlbnNvcnNNYXAsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGVuc29yc01hcFtnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQobmFtZSwgY29udGV4dC5jdXJyZW50Q29udGV4dElkKV07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUgbmFtZSBhbmQgaW5kZXggZnJvbSB0aGUgTm9kZSBpbnB1dCBuYW1lLlxuICogQHBhcmFtIGlucHV0TmFtZSBUaGUgaW5wdXQgbmFtZSBvZiB0aGUgbm9kZSwgaW4gZm9ybWF0IG9mXG4gKiBub2RlX25hbWU6b3V0cHV0X2luZGV4LCBpLmUuIE1hdE11bDowLCBpZiB0aGUgb3V0cHV0X2luZGV4IGlzIG5vdCBzZXQsIGl0IGlzXG4gKiBkZWZhdWx0IHRvIDAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lQW5kSW5kZXgoaW5wdXROYW1lLCBjb250ZXh0KSB7XG4gICAgdmFyIF9hID0gX19yZWFkKHBhcnNlTm9kZU5hbWUoaW5wdXROYW1lKSwgMiksIG5vZGVOYW1lID0gX2FbMF0sIGluZGV4ID0gX2FbMV07XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKG5vZGVOYW1lLCBjb250ZXh0ICYmIGNvbnRleHQuY3VycmVudENvbnRleHRJZCksXG4gICAgICAgIGluZGV4XG4gICAgXTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVOYW1lV2l0aENvbnRleHRJZChuYW1lLCBjb250ZXh0SWQpIHtcbiAgICByZXR1cm4gISFjb250ZXh0SWQgPyBuYW1lICsgXCItXCIgKyBjb250ZXh0SWQgOiBuYW1lO1xufVxuZnVuY3Rpb24gcGFyc2VOb2RlTmFtZShuYW1lKSB7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnOicpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCAwXTtcbiAgICB9XG4gICAgdmFyIG5vZGVOYW1lID0gcGFydHNbMF07XG4gICAgcmV0dXJuIFtub2RlTmFtZSwgTnVtYmVyKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdKV07XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHZhciBwYWQgPSBnZXRQYXJhbVZhbHVlKCdwYWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgIGlmIChwYWQgPT09ICdleHBsaWNpdCcpIHtcbiAgICAgICAgLy8gVGhpcyBpcyAxZCBhcnJheSwgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIDJkIGFycmF5XG4gICAgICAgIHBhZCA9IGdldFBhcmFtVmFsdWUoJ2V4cGxpY2l0UGFkZGluZ3MnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICB2YXIgZXhwbGljaXRQYWRkaW5nID0gW1swLCAwXSwgWzAsIDBdLCBbMCwgMF0sIFswLCAwXV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBleHBsaWNpdFBhZGRpbmdbaV1bMF0gPSBwYWRbaSAqIDJdO1xuICAgICAgICAgICAgZXhwbGljaXRQYWRkaW5nW2ldWzFdID0gcGFkW2kgKiAyICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGxpY2l0UGFkZGluZztcbiAgICB9XG4gICAgcmV0dXJuIHBhZDtcbn1cbi8qKlxuICogIFJldXNlIHRoZSB0ZW5zb3IgaWYgaXQgaXMgbWFya2VkIGFzIGtlZXAsIG90aGVyd2lzZSBjbG9uZSB0aGUgdGVuc29yIHRvXG4gKiAgYXZvaWQgZGlzcG9zYWwuIFRoaXMgaXMgaW1wb3J0YW50IGZvciBUZW5zb3JBcnJheSBhbmQgVGVuc29yTGlzdCBvcHMsIHNpbmNlXG4gKiAgaW50ZXJuYWxseSB0aGV5IHVzZSBhIHRlbnNvciBhcyB0aGUgaWQgZm9yIFRlbnNvckFycmF5IGFuZCBUZW5zb3JMaXN0LCBhbmRcbiAqIHRvIHNpbXBsaWZ5IGxvb2t1cCwgdGhleSBhbHNvIHVzZSBUZW5zb3IuaWQgYXMgdGhlIGtleSB0byB0aGUgaW50ZXJuYWwgbWFwLlxuICogVGhlc2UgaWQgdGVuc29ycyBoYXZlIGJlZW4gbWFya2VkIGFzIGtlcHQgaW4gdGhlIGJhY2tlbmQsIHdlIG5lZWQgYXZvaWQgY2xvbmVcbiAqIHRoZW0gaW4gb3JkZXIgdG8gY3JlYXRlIG5ldyBUZW5zb3IuaWQuXG4gKiBAcGFyYW0gdGVuc29yXG4gKi9cbmZ1bmN0aW9uIGNsb25lVGVuc29yKHRlbnNvcikge1xuICAgIHJldHVybiB0ZW5zb3Iua2VwdCA/IHRlbnNvciA6IHRmT3BzLmNsb25lKHRlbnNvcik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBqc29uID0gW1xuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0FkZCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdhcml0aG1ldGljJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdBZGRWMicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdhcml0aG1ldGljJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdBZGROJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2FyaXRobWV0aWMnLFxuICAgICAgICAnaW5wdXRzJzogW3sgJ3N0YXJ0JzogMCwgJ2VuZCc6IDAsICduYW1lJzogJ3RlbnNvcnMnLCAndHlwZSc6ICd0ZW5zb3JzJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnQmlhc0FkZCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdhcml0aG1ldGljJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZGF0YV9mb3JtYXQnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2RhdGFGb3JtYXQnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnU3ViJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2FyaXRobWV0aWMnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdhJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdiJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1JlYWxEaXYnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYXJpdGhtZXRpYycsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2EnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnRGl2JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2FyaXRobWV0aWMnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdhJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdiJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0Rpdk5vTmFuJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2FyaXRobWV0aWMnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdhJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdiJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0Zsb29yRGl2JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2FyaXRobWV0aWMnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdhJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdiJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ011bCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdhcml0aG1ldGljJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdNYXhpbXVtJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2FyaXRobWV0aWMnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdhJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdiJywgJ3R5cGUnOiAndGVuc29yJyB9XG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTWluaW11bScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdhcml0aG1ldGljJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfVxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1BvdycsXG4gICAgICAgICdjYXRlZ29yeSc6ICdhcml0aG1ldGljJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTcXVhcmVkRGlmZmVyZW5jZScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdhcml0aG1ldGljJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdNb2QnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYXJpdGhtZXRpYycsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2EnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnRmxvb3JNb2QnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYXJpdGhtZXRpYycsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2EnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFt7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdUJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdkdHlwZScsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnZHR5cGUnLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9XVxuICAgIH1cbl07XG5cbnZhciBhcml0aG1ldGljID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBqc29uOiBqc29uXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIganNvbiQxID0gW1xuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0FicycsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdBY29zJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0FzaW4nLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnQXRhbicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdBdGFuMicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAneScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdDZWlsJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0NsaXBCeVZhbHVlJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdjbGlwVmFsdWVNaW4nLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ2NsaXBWYWx1ZU1heCcsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdDb21wbGV4JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdyZWFsJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdpbWFnJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0NvbXBsZXhBYnMnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnQ29zJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0Nvc2gnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnRWx1JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0V4cCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdGbG9vcicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdMb2cnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnSW1hZycsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnVG91dCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnb3V0cHV0VHlwZScsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnZHR5cGUnLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ05lZycsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdSZWFsJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9LCB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdUb3V0JyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdvdXRwdXRUeXBlJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdkdHlwZScsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnUHJlbHUnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2FscGhhJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1JlbHUnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnUmVsdTYnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnU2VsdScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTaWdtb2lkJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1NpbicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTaW5oJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1NxcnQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnUnNxcnQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnU3F1YXJlJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1RhbicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdUYW5oJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1NpZ24nLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnUm91bmQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnRXhwbTEnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTG9nMXAnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnUmVjaXByb2NhbCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTb2Z0cGx1cycsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdBc2luaCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdBY29zaCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdBdGFuaCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdFcmYnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnYmFzaWNfbWF0aCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnUHJvZCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdiYXNpY19tYXRoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYXhlcycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdrZWVwX2RpbXMnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2tlZXBEaW1zJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sJyxcbiAgICAgICAgICAgICAgICAnbm90U3VwcG9ydGVkJzogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTGVha3lSZWx1JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2Jhc2ljX21hdGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdhbHBoYScsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnYWxwaGEnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IDAuMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ1QnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2R0eXBlJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdkdHlwZScsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH1cbl07XG5cbnZhciBiYXNpY01hdGggPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGpzb246IGpzb24kMVxufTtcblxudmFyIGpzb24kMiA9IFtcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdFbXB0eVRlbnNvckxpc3QnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2VsZW1lbnRTaGFwZScsICd0eXBlJzogJ3NoYXBlJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdtYXhOdW1FbGVtZW50cycsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3sgJ3RmTmFtZSc6ICdlbGVtZW50X2R0eXBlJywgJ25hbWUnOiAnZWxlbWVudERUeXBlJywgJ3R5cGUnOiAnZHR5cGUnIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdMb29wQ29uZCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb250cm9sJyxcbiAgICAgICAgJ2lucHV0cyc6IFt7ICdzdGFydCc6IDAsICduYW1lJzogJ3ByZWQnLCAndHlwZSc6ICd0ZW5zb3InIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTd2l0Y2gnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2RhdGEnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ3ByZWQnLCAndHlwZSc6ICd0ZW5zb3InIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTWVyZ2UnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbeyAnc3RhcnQnOiAwLCAnZW5kJzogMCwgJ25hbWUnOiAndGVuc29ycycsICd0eXBlJzogJ3RlbnNvcnMnIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdFbnRlcicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb250cm9sJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAndGVuc29yJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2ZyYW1lX25hbWUnLCAnbmFtZSc6ICdmcmFtZU5hbWUnLCAndHlwZSc6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnaXNfY29uc3RhbnQnLCAnbmFtZSc6ICdpc0NvbnN0YW50JywgJ3R5cGUnOiAnYm9vbCcgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdFeGl0JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NvbnRyb2wnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd0ZW5zb3InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTmV4dEl0ZXJhdGlvbicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb250cm9sJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAndGVuc29yJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1RlbnNvckFycmF5VjMnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3NpemUnLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdkdHlwZScsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnZWxlbWVudF9zaGFwZScsICduYW1lJzogJ2VsZW1lbnRTaGFwZScsICd0eXBlJzogJ3NoYXBlJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2R5bmFtaWNfc2l6ZScsICduYW1lJzogJ2R5bmFtaWNTaXplJywgJ3R5cGUnOiAnYm9vbCcgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdjbGVhcl9hZnRlcl9yZWFkJywgJ25hbWUnOiAnY2xlYXJBZnRlclJlYWQnLCAndHlwZSc6ICdib29sJyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnaWRlbnRpY2FsX2VsZW1lbnRfc2hhcGVzJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdpZGVudGljYWxFbGVtZW50U2hhcGVzJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICd0ZW5zb3JfYXJyYXlfbmFtZScsICduYW1lJzogJ25hbWUnLCAndHlwZSc6ICdzdHJpbmcnIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVGVuc29yQXJyYXlXcml0ZVYzJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NvbnRyb2wnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd0ZW5zb3JBcnJheUlkJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdpbmRleCcsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMiwgJ25hbWUnOiAndGVuc29yJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAzLCAnbmFtZSc6ICdmbG93SW4nLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVGVuc29yQXJyYXlSZWFkVjMnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3RlbnNvckFycmF5SWQnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2luZGV4JywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICdmbG93SW4nLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFt7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdkdHlwZScsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZHR5cGUnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2R0eXBlJyxcbiAgICAgICAgICAgICAgICAnbm90U3VwcG9ydGVkJzogdHJ1ZVxuICAgICAgICAgICAgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1RlbnNvckFycmF5R2F0aGVyVjMnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3RlbnNvckFycmF5SWQnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2luZGljZXMnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMiwgJ25hbWUnOiAnZmxvd0luJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnZHR5cGUnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2VsZW1lbnRfc2hhcGUnLCAnbmFtZSc6ICdlbGVtZW50U2hhcGUnLCAndHlwZSc6ICdzaGFwZScgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdUZW5zb3JBcnJheVNjYXR0ZXJWMycsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb250cm9sJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAndGVuc29yQXJyYXlJZCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnaW5kaWNlcycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICd0ZW5zb3InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDMsICduYW1lJzogJ2Zsb3dJbicsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3sgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1RlbnNvckFycmF5Q29uY2F0VjMnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3RlbnNvckFycmF5SWQnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2Zsb3dJbicsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2R0eXBlJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZWxlbWVudF9zaGFwZV9leGNlcHQwJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdlbGVtZW50U2hhcGVFeGNlcHQwJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdzaGFwZScsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVGVuc29yQXJyYXlTcGxpdFYzJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NvbnRyb2wnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd0ZW5zb3JBcnJheUlkJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICd0ZW5zb3InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ2xlbmd0aHMnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMywgJ25hbWUnOiAnZmxvd0luJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVGVuc29yQXJyYXlTaXplVjMnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3RlbnNvckFycmF5SWQnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2Zsb3dJbicsICd0eXBlJzogJ251bWJlcicgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdUZW5zb3JBcnJheUNsb3NlVjMnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd0ZW5zb3JBcnJheUlkJywgJ3R5cGUnOiAndGVuc29yJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnU3RhdGVsZXNzSWYnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2NvbmQnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICdlbmQnOiAwLCAnbmFtZSc6ICdhcmdzJywgJ3R5cGUnOiAndGVuc29ycycgfVxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAndGhlbl9icmFuY2gnLCAnbmFtZSc6ICd0aGVuQnJhbmNoJywgJ3R5cGUnOiAnZnVuYycgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdlbHNlX2JyYW5jaCcsICduYW1lJzogJ2Vsc2VCcmFuY2gnLCAndHlwZSc6ICdmdW5jJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0lmJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NvbnRyb2wnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdjb25kJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnZW5kJzogMCwgJ25hbWUnOiAnYXJncycsICd0eXBlJzogJ3RlbnNvcnMnIH1cbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3RoZW5fYnJhbmNoJywgJ25hbWUnOiAndGhlbkJyYW5jaCcsICd0eXBlJzogJ2Z1bmMnIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnZWxzZV9icmFuY2gnLCAnbmFtZSc6ICdlbHNlQnJhbmNoJywgJ3R5cGUnOiAnZnVuYycgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTdGF0ZWxlc3NXaGlsZScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb250cm9sJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ2VuZCc6IDAsICduYW1lJzogJ2FyZ3MnLCAndHlwZSc6ICd0ZW5zb3JzJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnY29uZCcsICduYW1lJzogJ2NvbmQnLCAndHlwZSc6ICdmdW5jJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2JvZHknLCAnbmFtZSc6ICdib2R5JywgJ3R5cGUnOiAnZnVuYycgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdXaGlsZScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb250cm9sJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ2VuZCc6IDAsICduYW1lJzogJ2FyZ3MnLCAndHlwZSc6ICd0ZW5zb3JzJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnY29uZCcsICduYW1lJzogJ2NvbmQnLCAndHlwZSc6ICdmdW5jJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2JvZHknLCAnbmFtZSc6ICdib2R5JywgJ3R5cGUnOiAnZnVuYycgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdUZW5zb3JMaXN0U2NhdHRlcicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb250cm9sJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAndGVuc29yJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdpbmRpY2VzJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ2VsZW1lbnRTaGFwZScsICd0eXBlJzogJ3NoYXBlJyB9XG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFt7ICd0Zk5hbWUnOiAnZWxlbWVudF9kdHlwZScsICduYW1lJzogJ2VsZW1lbnREVHlwZScsICd0eXBlJzogJ2R0eXBlJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVGVuc29yTGlzdFNjYXR0ZXJWMicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb250cm9sJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAndGVuc29yJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdpbmRpY2VzJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ2VsZW1lbnRTaGFwZScsICd0eXBlJzogJ3NoYXBlJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAzLCAnbmFtZSc6ICdudW1FbGVtZW50cycsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3sgJ3RmTmFtZSc6ICdlbGVtZW50X2R0eXBlJywgJ25hbWUnOiAnZWxlbWVudERUeXBlJywgJ3R5cGUnOiAnZHR5cGUnIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdUZW5zb3JMaXN0R2F0aGVyJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NvbnRyb2wnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd0ZW5zb3JMaXN0SWQnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2luZGljZXMnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMiwgJ25hbWUnOiAnZWxlbWVudFNoYXBlJywgJ3R5cGUnOiAnc2hhcGUnIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFt7ICd0Zk5hbWUnOiAnZWxlbWVudF9kdHlwZScsICduYW1lJzogJ2VsZW1lbnREVHlwZScsICd0eXBlJzogJ2R0eXBlJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVGVuc29yTGlzdEdldEl0ZW0nLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3RlbnNvckxpc3RJZCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnaW5kZXgnLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ2VsZW1lbnRTaGFwZScsICd0eXBlJzogJ3NoYXBlJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ2VsZW1lbnRfZHR5cGUnLCAnbmFtZSc6ICdlbGVtZW50RFR5cGUnLCAndHlwZSc6ICdkdHlwZScgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1RlbnNvckxpc3RTZXRJdGVtJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NvbnRyb2wnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd0ZW5zb3JMaXN0SWQnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2luZGV4JywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICd0ZW5zb3InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFt7ICd0Zk5hbWUnOiAnZWxlbWVudF9kdHlwZScsICduYW1lJzogJ2VsZW1lbnREVHlwZScsICd0eXBlJzogJ2R0eXBlJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVGVuc29yTGlzdFJlc2VydmUnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2VsZW1lbnRTaGFwZScsICd0eXBlJzogJ3NoYXBlJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdudW1FbGVtZW50cycsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3sgJ3RmTmFtZSc6ICdlbGVtZW50X2R0eXBlJywgJ25hbWUnOiAnZWxlbWVudERUeXBlJywgJ3R5cGUnOiAnZHR5cGUnIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdUZW5zb3JMaXN0RnJvbVRlbnNvcicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb250cm9sJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAndGVuc29yJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdlbGVtZW50U2hhcGUnLCAndHlwZSc6ICdzaGFwZScgfVxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ2VsZW1lbnRfZHR5cGUnLCAnbmFtZSc6ICdlbGVtZW50RFR5cGUnLCAndHlwZSc6ICdkdHlwZScgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1RlbnNvckxpc3RTdGFjaycsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb250cm9sJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAndGVuc29yTGlzdElkJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdlbGVtZW50U2hhcGUnLCAndHlwZSc6ICdzaGFwZScgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2VsZW1lbnRfZHR5cGUnLCAnbmFtZSc6ICdlbGVtZW50RFR5cGUnLCAndHlwZSc6ICdkdHlwZScgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdudW1fZWxlbWVudHMnLCAnbmFtZSc6ICdudW1FbGVtZW50cycsICd0eXBlJzogJ2R0eXBlJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1RlbnNvckxpc3RTcGxpdCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb250cm9sJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAndGVuc29yJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdlbGVtZW50U2hhcGUnLCAndHlwZSc6ICdzaGFwZScgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMiwgJ25hbWUnOiAnbGVuZ3RocycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ2VsZW1lbnRfZHR5cGUnLCAnbmFtZSc6ICdlbGVtZW50RFR5cGUnLCAndHlwZSc6ICdkdHlwZScgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1RlbnNvckxpc3RDb25jYXQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3RlbnNvckxpc3RJZCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2VsZW1lbnRfc2hhcGUnLCAnbmFtZSc6ICdlbGVtZW50U2hhcGUnLCAndHlwZSc6ICdzaGFwZScgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdlbGVtZW50X2R0eXBlJywgJ25hbWUnOiAnZWxlbWVudERUeXBlJywgJ3R5cGUnOiAnZHR5cGUnIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVGVuc29yTGlzdFBvcEJhY2snLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udHJvbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3RlbnNvckxpc3RJZCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnZWxlbWVudFNoYXBlJywgJ3R5cGUnOiAnc2hhcGUnIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFt7ICd0Zk5hbWUnOiAnZWxlbWVudF9kdHlwZScsICduYW1lJzogJ2VsZW1lbnREVHlwZScsICd0eXBlJzogJ2R0eXBlJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVGVuc29yTGlzdFB1c2hCYWNrJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NvbnRyb2wnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd0ZW5zb3JMaXN0SWQnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ3RlbnNvcicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2VsZW1lbnRfZHR5cGUnLCAnbmFtZSc6ICdlbGVtZW50RFR5cGUnLCAndHlwZSc6ICdkdHlwZScgfVxuICAgICAgICBdXG4gICAgfVxuXTtcblxudmFyIGNvbnRyb2wgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGpzb246IGpzb24kMlxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGpzb24kMyA9IFtcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdBdmdQb29sJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NvbnZvbHV0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3N0cmlkZXMnLCAnbmFtZSc6ICdzdHJpZGVzJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAncGFkZGluZycsICduYW1lJzogJ3BhZCcsICd0eXBlJzogJ3N0cmluZycgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZGF0YV9mb3JtYXQnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2RhdGFGb3JtYXQnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAna3NpemUnLCAnbmFtZSc6ICdrZXJuZWxTaXplJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ01heFBvb2wnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udm9sdXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnc3RyaWRlcycsICduYW1lJzogJ3N0cmlkZXMnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdwYWRkaW5nJywgJ25hbWUnOiAncGFkJywgJ3R5cGUnOiAnc3RyaW5nJyB9LCB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdkYXRhX2Zvcm1hdCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZGF0YUZvcm1hdCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAnbm90U3VwcG9ydGVkJzogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdrc2l6ZScsICduYW1lJzogJ2tlcm5lbFNpemUnLCAndHlwZSc6ICdudW1iZXJbXScgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZXhwbGljaXRfcGFkZGluZ3MnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2V4cGxpY2l0UGFkZGluZ3MnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcltdJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogW10sXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ01heFBvb2xXaXRoQXJnbWF4JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NvbnZvbHV0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3N0cmlkZXMnLCAnbmFtZSc6ICdzdHJpZGVzJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAncGFkZGluZycsICduYW1lJzogJ3BhZCcsICd0eXBlJzogJ3N0cmluZycgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdrc2l6ZScsICduYW1lJzogJ2tlcm5lbFNpemUnLCAndHlwZSc6ICdudW1iZXJbXScgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnaW5jbHVkZV9iYXRjaF9pbl9pbmRleCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnaW5jbHVkZUJhdGNoSW5JbmRleCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0F2Z1Bvb2wzRCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb252b2x1dGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdzdHJpZGVzJywgJ25hbWUnOiAnc3RyaWRlcycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3BhZGRpbmcnLCAnbmFtZSc6ICdwYWQnLCAndHlwZSc6ICdzdHJpbmcnIH0sIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2RhdGFfZm9ybWF0JyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdkYXRhRm9ybWF0JyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2tzaXplJywgJ25hbWUnOiAna2VybmVsU2l6ZScsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdNYXhQb29sM0QnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udm9sdXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnc3RyaWRlcycsICduYW1lJzogJ3N0cmlkZXMnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdwYWRkaW5nJywgJ25hbWUnOiAncGFkJywgJ3R5cGUnOiAnc3RyaW5nJyB9LCB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdkYXRhX2Zvcm1hdCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZGF0YUZvcm1hdCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAnbm90U3VwcG9ydGVkJzogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdrc2l6ZScsICduYW1lJzogJ2tlcm5lbFNpemUnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnQ29udjFEJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NvbnZvbHV0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnZmlsdGVyJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnc3RyaWRlJywgJ25hbWUnOiAnc3RyaWRlJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3BhZGRpbmcnLCAnbmFtZSc6ICdwYWQnLCAndHlwZSc6ICdzdHJpbmcnIH0sIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2RhdGFfZm9ybWF0JyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdkYXRhRm9ybWF0JyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiAnTldDJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH0sIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2RpbGF0aW9uJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdkaWxhdGlvbicsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogMVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdDb252MkQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udm9sdXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdmaWx0ZXInLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnc3RyaWRlcycsICduYW1lJzogJ3N0cmlkZXMnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdwYWRkaW5nJywgJ25hbWUnOiAncGFkJywgJ3R5cGUnOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3VzZUN1ZG5uT25HcHUnLCAnbmFtZSc6ICd1c2VDdWRubk9uR3B1JywgJ3R5cGUnOiAnYm9vbCcgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZGF0YV9mb3JtYXQnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2RhdGFGb3JtYXQnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6ICdOSFdDJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2V4cGxpY2l0X3BhZGRpbmdzJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdleHBsaWNpdFBhZGRpbmdzJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXJbXScsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2RpbGF0aW9ucycsICduYW1lJzogJ2RpbGF0aW9ucycsICd0eXBlJzogJ251bWJlcltdJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ19GdXNlZENvbnYyRCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb252b2x1dGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2ZpbHRlcicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMiwgZW5kOiAwLCAnbmFtZSc6ICdhcmdzJywgJ3R5cGUnOiAndGVuc29ycycgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ251bV9hcmdzJywgJ25hbWUnOiAnbnVtQXJncycsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnc3RyaWRlcycsICduYW1lJzogJ3N0cmlkZXMnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdwYWRkaW5nJywgJ25hbWUnOiAncGFkJywgJ3R5cGUnOiAnc3RyaW5nJyB9LCB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdleHBsaWNpdF9wYWRkaW5ncycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZXhwbGljaXRQYWRkaW5ncycsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyW10nLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ3VzZV9jdWRubl9vbl9ncHUnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ3VzZUN1ZG5uT25HcHUnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZGF0YV9mb3JtYXQnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2RhdGFGb3JtYXQnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6ICdOSFdDJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2RpbGF0aW9ucycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZGlsYXRpb25zJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXJbXScsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IFsxLCAxLCAxLCAxXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2Z1c2VkX29wcycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZnVzZWRPcHMnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZ1tdJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdlcHNpbG9uJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdlcHNpbG9uJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiAwLjAwMDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdsZWFreXJlbHVfYWxwaGEnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2xlYWt5cmVsdUFscGhhJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0NvbnYyREJhY2twcm9wSW5wdXQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udm9sdXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdmaWx0ZXInLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ291dHB1dFNoYXBlJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdzdHJpZGVzJywgJ25hbWUnOiAnc3RyaWRlcycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3BhZGRpbmcnLCAnbmFtZSc6ICdwYWQnLCAndHlwZSc6ICdzdHJpbmcnIH0sIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2RhdGFfZm9ybWF0JyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdkYXRhRm9ybWF0JyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZXhwbGljaXRfcGFkZGluZ3MnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2V4cGxpY2l0UGFkZGluZ3MnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcltdJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdkaWxhdGlvbnMnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2RpbGF0aW9ucycsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyW10nLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0RlcHRod2lzZUNvbnYyZCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjb252b2x1dGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2lucHV0JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdmaWx0ZXInLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdzdHJpZGVzJywgJ25hbWUnOiAnc3RyaWRlcycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3BhZGRpbmcnLCAnbmFtZSc6ICdwYWQnLCAndHlwZSc6ICdzdHJpbmcnIH0sIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2RhdGFfZm9ybWF0JyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdkYXRhRm9ybWF0JyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiAnTkhXQydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdleHBsaWNpdF9wYWRkaW5ncycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZXhwbGljaXRQYWRkaW5ncycsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyW10nLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdkaWxhdGlvbnMnLCAnbmFtZSc6ICdkaWxhdGlvbnMnLCAndHlwZSc6ICdudW1iZXJbXScgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdEZXB0aHdpc2VDb252MmROYXRpdmUnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udm9sdXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdpbnB1dCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnZmlsdGVyJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnc3RyaWRlcycsICduYW1lJzogJ3N0cmlkZXMnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdwYWRkaW5nJywgJ25hbWUnOiAncGFkJywgJ3R5cGUnOiAnc3RyaW5nJyB9LCB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdkYXRhX2Zvcm1hdCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZGF0YUZvcm1hdCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogJ05IV0MnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZXhwbGljaXRfcGFkZGluZ3MnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2V4cGxpY2l0UGFkZGluZ3MnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcltdJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnZGlsYXRpb25zJywgJ25hbWUnOiAnZGlsYXRpb25zJywgJ3R5cGUnOiAnbnVtYmVyW10nIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnRnVzZWREZXB0aHdpc2VDb252MmROYXRpdmUnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udm9sdXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdmaWx0ZXInLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsIGVuZDogMCwgJ25hbWUnOiAnYXJncycsICd0eXBlJzogJ3RlbnNvcnMnIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdudW1fYXJncycsICduYW1lJzogJ251bUFyZ3MnLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3N0cmlkZXMnLCAnbmFtZSc6ICdzdHJpZGVzJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAncGFkZGluZycsICduYW1lJzogJ3BhZCcsICd0eXBlJzogJ3N0cmluZycgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZGF0YV9mb3JtYXQnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2RhdGFGb3JtYXQnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6ICdOSFdDJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2RpbGF0aW9ucycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZGlsYXRpb25zJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXJbXScsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IFsxLCAxLCAxLCAxXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2Z1c2VkX29wcycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZnVzZWRPcHMnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZ1tdJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdleHBsaWNpdF9wYWRkaW5ncycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZXhwbGljaXRQYWRkaW5ncycsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyW10nLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdDb252M0QnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udm9sdXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdmaWx0ZXInLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdzdHJpZGVzJywgJ25hbWUnOiAnc3RyaWRlcycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3BhZGRpbmcnLCAnbmFtZSc6ICdwYWQnLCAndHlwZSc6ICdzdHJpbmcnIH0sIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2RhdGFfZm9ybWF0JyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdkYXRhRm9ybWF0JyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiAnTkhXQydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnZGlsYXRpb25zJywgJ25hbWUnOiAnZGlsYXRpb25zJywgJ3R5cGUnOiAnbnVtYmVyW10nIH1cbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0RpbGF0aW9uMkQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY29udm9sdXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdmaWx0ZXInLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdzdHJpZGVzJywgJ25hbWUnOiAnc3RyaWRlcycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3JhdGVzJywgJ25hbWUnOiAnZGlsYXRpb25zJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAncGFkZGluZycsICduYW1lJzogJ3BhZCcsICd0eXBlJzogJ3N0cmluZycgfVxuICAgICAgICBdXG4gICAgfVxuXTtcblxudmFyIGNvbnZvbHV0aW9uID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBqc29uOiBqc29uJDNcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBqc29uJDQgPSBbXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnRmlsbCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjcmVhdGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3NoYXBlJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ3ZhbHVlJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTGluU3BhY2UnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnY3JlYXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdzdGFydCcsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnc3RvcCcsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMiwgJ25hbWUnOiAnbnVtJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ09uZUhvdCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjcmVhdGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2luZGljZXMnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2RlcHRoJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICdvblZhbHVlJywgJ3R5cGUnOiAnbnVtYmVyJywgJ2RlZmF1bHRWYWx1ZSc6IDEgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMywgJ25hbWUnOiAnb2ZmVmFsdWUnLCAndHlwZSc6ICdudW1iZXInLCAnZGVmYXVsdFZhbHVlJzogMCB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdPbmVzJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NyZWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnc2hhcGUnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3sgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ09uZXNMaWtlJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NyZWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3sgJ3RmTmFtZSc6ICdkdHlwZScsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdSYW5kb21Vbmlmb3JtJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NyZWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnc2hhcGUnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnbWludmFsJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdtaW52YWwnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdtYXh2YWwnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ21heHZhbCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdkdHlwZScsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnc2VlZCcsICduYW1lJzogJ3NlZWQnLCAndHlwZSc6ICdudW1iZXInLCAnZGVmYXVsdFZhbHVlJzogMCB9LCB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdzZWVkMicsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnc2VlZDInLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IDAsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ1QnLCAndHlwZSc6ICdudW1iZXInLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1JhbmdlJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NyZWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnc3RhcnQnLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ3N0b3AnLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ3N0ZXAnLCAndHlwZSc6ICdudW1iZXInLCAnZGVmYXVsdFZhbHVlJzogMCB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ1RpZHgnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVHJ1bmNhdGVkTm9ybWFsJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NyZWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnc2hhcGUnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnbWVhbnMnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ21lYW4nLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IDAuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ3N0ZGRldicsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnc3RkRGV2JyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnc2VlZCcsICduYW1lJzogJ3NlZWQnLCAndHlwZSc6ICdudW1iZXInIH0sIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ3NlZWQyJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdzZWVkMicsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogMCxcbiAgICAgICAgICAgICAgICAnbm90U3VwcG9ydGVkJzogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdkdHlwZScsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ1QnLCAndHlwZSc6ICdudW1iZXInLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1plcm9zJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2NyZWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnc2hhcGUnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3sgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1plcm9zTGlrZScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjcmVhdGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFt7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdNdWx0aW5vbWlhbCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdjcmVhdGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2xvZ2l0cycsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnbnVtU2FtcGxlcycsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3NlZWQnLCAnbmFtZSc6ICdzZWVkJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ3NlZWQyJywgJ25hbWUnOiAnc2VlZDInLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnb3V0cHV0X2R0eXBlJywgJ25hbWUnOiAnb3V0cHV0X2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnIH1cbiAgICAgICAgXVxuICAgIH1cbl07XG5cbnZhciBjcmVhdGlvbiA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAganNvbjoganNvbiQ0XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIganNvbiQ1ID0gW1xuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ05vbk1heFN1cHByZXNzaW9uVjInLFxuICAgICAgICAnY2F0ZWdvcnknOiAnZHluYW1pYycsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2JveGVzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdzY29yZXMnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ21heE91dHB1dFNpemUnLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDMsICduYW1lJzogJ2lvdVRocmVzaG9sZCcsICd0eXBlJzogJ251bWJlcicgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdOb25NYXhTdXBwcmVzc2lvblYzJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2R5bmFtaWMnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdib3hlcycsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnc2NvcmVzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICdtYXhPdXRwdXRTaXplJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAzLCAnbmFtZSc6ICdpb3VUaHJlc2hvbGQnLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDQsICduYW1lJzogJ3Njb3JlVGhyZXNob2xkJywgJ3R5cGUnOiAnbnVtYmVyJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ05vbk1heFN1cHByZXNzaW9uVjQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnZHluYW1pYycsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2JveGVzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdzY29yZXMnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ21heE91dHB1dFNpemUnLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDMsICduYW1lJzogJ2lvdVRocmVzaG9sZCcsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogNCwgJ25hbWUnOiAnc2NvcmVUaHJlc2hvbGQnLCAndHlwZSc6ICdudW1iZXInIH1cbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnVF90aHJlc2hvbGQnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ3RocmVzaG9sZCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnZHR5cGUnLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAncGFkX3RvX21heF9vdXRwdXRfc2l6ZScsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAncGFkVG9NYXhPdXRwdXRTaXplJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdOb25NYXhTdXBwcmVzc2lvblY1JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2R5bmFtaWMnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdib3hlcycsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnc2NvcmVzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICdtYXhPdXRwdXRTaXplJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAzLCAnbmFtZSc6ICdpb3VUaHJlc2hvbGQnLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDQsICduYW1lJzogJ3Njb3JlVGhyZXNob2xkJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiA1LCAnbmFtZSc6ICdzb2Z0Tm1zU2lnbWEnLCAndHlwZSc6ICdudW1iZXInIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnV2hlcmUnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnZHluYW1pYycsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2NvbmRpdGlvbicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdMaXN0RGlmZicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdkeW5hbWljJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAneScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3tcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ1QnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2R0eXBlJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdkdHlwZScsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1dXG4gICAgfVxuXTtcblxudmFyIGR5bmFtaWMgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGpzb246IGpzb24kNVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGpzb24kNiA9IFtcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdUb3BLVjInLFxuICAgICAgICAnY2F0ZWdvcnknOiAnZXZhbHVhdGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2snLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFt7ICd0Zk5hbWUnOiAnc29ydGVkJywgJ25hbWUnOiAnc29ydGVkJywgJ3R5cGUnOiAnYm9vbCcgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1VuaXF1ZScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdldmFsdWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1VuaXF1ZVYyJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2V2YWx1YXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdheGlzJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICBdLFxuICAgIH0sXG5dO1xuXG52YXIgZXZhbHVhdGlvbiA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAganNvbjoganNvbiQ2XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIganNvbiQ3ID0gW1xuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1BsYWNlaG9sZGVyV2l0aERlZmF1bHQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnZ3JhcGgnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdkZWZhdWx0JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnc2hhcGUnLCAnbmFtZSc6ICdzaGFwZScsICd0eXBlJzogJ3NoYXBlJyB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2R0eXBlJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdQbGFjZWhvbGRlcicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdncmFwaCcsXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdzaGFwZScsICduYW1lJzogJ3NoYXBlJywgJ3R5cGUnOiAnc2hhcGUnIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnZHR5cGUnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHsgJ3RmT3BOYW1lJzogJ0NvbnN0JywgJ2NhdGVnb3J5JzogJ2dyYXBoJyB9LCB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdJZGVudGl0eScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdncmFwaCcsXG4gICAgICAgICdpbnB1dHMnOiBbeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnSWRlbnRpdHlOJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2dyYXBoJyxcbiAgICAgICAgJ2lucHV0cyc6IFt7ICdzdGFydCc6IDAsICdlbmQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29ycycgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1NuYXBzaG90JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2dyYXBoJyxcbiAgICAgICAgJ2lucHV0cyc6IFt7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdSYW5rJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2dyYXBoJyxcbiAgICAgICAgJ2lucHV0cyc6IFt7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTaXplJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2dyYXBoJyxcbiAgICAgICAgJ2lucHV0cyc6IFt7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTaGFwZScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdncmFwaCcsXG4gICAgICAgICdpbnB1dHMnOiBbeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnU2hhcGVOJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2dyYXBoJyxcbiAgICAgICAgJ2lucHV0cyc6IFt7ICdzdGFydCc6IDAsICdlbmQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29ycycgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1ByaW50JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2dyYXBoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnZGF0YScsICd0eXBlJzogJ3RlbnNvcnMnIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdtZXNzYWdlJywgJ25hbWUnOiAnbWVzc2FnZScsICd0eXBlJzogJ3N0cmluZycgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZmlyc3RfbicsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZmlyc3ROJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnc3VtbWFyaXplJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdzdW1tYXJpemUnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IDNcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgeyAndGZPcE5hbWUnOiAnTm9PcCcsICdjYXRlZ29yeSc6ICdncmFwaCcsICdpbnB1dHMnOiBbXSB9LCB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTdG9wR3JhZGllbnQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnZ3JhcGgnLFxuICAgICAgICAnaW5wdXRzJzogW3sgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0Zha2VRdWFudFdpdGhNaW5NYXhWYXJzJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2dyYXBoJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ21pbicsICduYW1lJzogJ21pbicsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdtYXgnLCAnbmFtZSc6ICdtYXgnLCAndHlwZSc6ICdudW1iZXInIH1cbiAgICAgICAgXVxuICAgIH1cbl07XG5cbnZhciBncmFwaCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAganNvbjoganNvbiQ3XG59O1xuXG52YXIganNvbiQ4ID0gW1xuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0hhc2hUYWJsZScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdoYXNoX3RhYmxlJyxcbiAgICAgICAgJ2lucHV0cyc6IFtdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnc2hhcmVkX25hbWUnLCAnbmFtZSc6ICdzaGFyZWROYW1lJywgJ3R5cGUnOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAndXNlX25vZGVfbmFtZV9zaGFyaW5nJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICd1c2VOb2RlTmFtZVNoYXJpbmcnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2wnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2tleV9kdHlwZScsICduYW1lJzogJ2tleURUeXBlJywgJ3R5cGUnOiAnZHR5cGUnIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAndmFsdWVfZHR5cGUnLCAnbmFtZSc6ICd2YWx1ZURUeXBlJywgJ3R5cGUnOiAnZHR5cGUnIH0sXG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0hhc2hUYWJsZVYyJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2hhc2hfdGFibGUnLFxuICAgICAgICAnaW5wdXRzJzogW10sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdzaGFyZWRfbmFtZScsICduYW1lJzogJ3NoYXJlZE5hbWUnLCAndHlwZSc6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICd1c2Vfbm9kZV9uYW1lX3NoYXJpbmcnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ3VzZU5vZGVOYW1lU2hhcmluZycsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAna2V5X2R0eXBlJywgJ25hbWUnOiAna2V5RFR5cGUnLCAndHlwZSc6ICdkdHlwZScgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICd2YWx1ZV9kdHlwZScsICduYW1lJzogJ3ZhbHVlRFR5cGUnLCAndHlwZSc6ICdkdHlwZScgfSxcbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTG9va3VwVGFibGVJbXBvcnQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnaGFzaF90YWJsZScsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3RhYmxlSGFuZGxlJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdrZXlzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICd2YWx1ZXMnLCAndHlwZSc6ICd0ZW5zb3InIH1cbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1RpbicsICduYW1lJzogJ3RJbicsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnVG91dCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAndE91dCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnZHR5cGUnLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0xvb2t1cFRhYmxlSW1wb3J0VjInLFxuICAgICAgICAnY2F0ZWdvcnknOiAnaGFzaF90YWJsZScsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3RhYmxlSGFuZGxlJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdrZXlzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICd2YWx1ZXMnLCAndHlwZSc6ICd0ZW5zb3InIH1cbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1RpbicsICduYW1lJzogJ3RJbicsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnVG91dCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAndE91dCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnZHR5cGUnLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0xvb2t1cFRhYmxlRmluZCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdoYXNoX3RhYmxlJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAndGFibGVIYW5kbGUnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2tleXMnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ2RlZmF1bHRWYWx1ZScsICd0eXBlJzogJ3RlbnNvcicgfVxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVGluJywgJ25hbWUnOiAndEluJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9LCB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdUb3V0JyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICd0T3V0JyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdkdHlwZScsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTG9va3VwVGFibGVGaW5kVjInLFxuICAgICAgICAnY2F0ZWdvcnknOiAnaGFzaF90YWJsZScsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3RhYmxlSGFuZGxlJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdrZXlzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICdkZWZhdWx0VmFsdWUnLCAndHlwZSc6ICd0ZW5zb3InIH1cbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1RpbicsICduYW1lJzogJ3RJbicsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfSwge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnVG91dCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAndE91dCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnZHR5cGUnLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9XG5dO1xuXG52YXIgaGFzaFRhYmxlID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBqc29uOiBqc29uJDhcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBqc29uJDkgPSBbXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnUmVzaXplQmlsaW5lYXInLFxuICAgICAgICAnY2F0ZWdvcnknOiAnaW1hZ2UnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdpbWFnZXMnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ3NpemUnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2FsaWduX2Nvcm5lcnMnLCAnbmFtZSc6ICdhbGlnbkNvcm5lcnMnLCAndHlwZSc6ICdib29sJyB9LCB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdoYWxmX3BpeGVsX2NlbnRlcnMnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2hhbGZQaXhlbENlbnRlcnMnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2wnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdSZXNpemVOZWFyZXN0TmVpZ2hib3InLFxuICAgICAgICAnY2F0ZWdvcnknOiAnaW1hZ2UnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdpbWFnZXMnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ3NpemUnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2FsaWduX2Nvcm5lcnMnLCAnbmFtZSc6ICdhbGlnbkNvcm5lcnMnLCAndHlwZSc6ICdib29sJyB9LCB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdoYWxmX3BpeGVsX2NlbnRlcnMnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2hhbGZQaXhlbENlbnRlcnMnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2wnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdDcm9wQW5kUmVzaXplJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2ltYWdlJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnaW1hZ2UnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2JveGVzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICdib3hJbmQnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDMsICduYW1lJzogJ2Nyb3BTaXplJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdtZXRob2QnLCAnbmFtZSc6ICdtZXRob2QnLCAndHlwZSc6ICdzdHJpbmcnIH0sIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2V4dHJhcG9sYXRpb25fdmFsdWUnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2V4dHJhcG9sYXRpb25WYWx1ZScsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxuXTtcblxudmFyIGltYWdlID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBqc29uOiBqc29uJDlcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBqc29uJGEgPSBbXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnRXF1YWwnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnbG9naWNhbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2EnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTm90RXF1YWwnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnbG9naWNhbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2EnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnR3JlYXRlcicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdsb2dpY2FsJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdHcmVhdGVyRXF1YWwnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnbG9naWNhbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2EnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTGVzcycsXG4gICAgICAgICdjYXRlZ29yeSc6ICdsb2dpY2FsJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdMZXNzRXF1YWwnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnbG9naWNhbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2EnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTG9naWNhbEFuZCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdsb2dpY2FsJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdMb2dpY2FsTm90JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ2xvZ2ljYWwnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdhJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0xvZ2ljYWxPcicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdsb2dpY2FsJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTZWxlY3QnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnbG9naWNhbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2NvbmRpdGlvbicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMiwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ1QnLCAnbmFtZSc6ICdkdHlwZScsICd0eXBlJzogJ2R0eXBlJywgJ25vdFN1cHBvcnRlZCc6IHRydWUgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTZWxlY3RWMicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdsb2dpY2FsJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnY29uZGl0aW9uJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdhJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICdiJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbe1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnVCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZHR5cGUnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2R0eXBlJyxcbiAgICAgICAgICAgICAgICAnbm90U3VwcG9ydGVkJzogdHJ1ZVxuICAgICAgICAgICAgfV1cbiAgICB9XG5dO1xuXG52YXIgbG9naWNhbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAganNvbjoganNvbiRhXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIganNvbiRiID0gW1xuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ19GdXNlZE1hdE11bCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdtYXRyaWNlcycsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ2EnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsIGVuZDogMCwgJ25hbWUnOiAnYXJncycsICd0eXBlJzogJ3RlbnNvcnMnIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdudW1fYXJncycsICduYW1lJzogJ251bUFyZ3MnLCAndHlwZSc6ICdudW1iZXInIH0sIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2Z1c2VkX29wcycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZnVzZWRPcHMnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZ1tdJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdlcHNpbG9uJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdlcHNpbG9uJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiAwLjAwMDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICd0cmFuc3Bvc2VfYScsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAndHJhbnNwb3NlQScsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAndHJhbnNwb3NlX2InLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ3RyYW5zcG9zZUInLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTWF0TXVsJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ21hdHJpY2VzJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAndHJhbnNwb3NlX2EnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ3RyYW5zcG9zZUEnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ3RyYW5zcG9zZV9iJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICd0cmFuc3Bvc2VCJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0JhdGNoTWF0TXVsJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ21hdHJpY2VzJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnYWRqX3gnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ3RyYW5zcG9zZUEnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2Fkal95JyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICd0cmFuc3Bvc2VCJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnVCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnLCAnbm90U3VwcG9ydGVkJzogdHJ1ZSB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0JhdGNoTWF0TXVsVjInLFxuICAgICAgICAnY2F0ZWdvcnknOiAnbWF0cmljZXMnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdhJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdiJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdhZGpfeCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAndHJhbnNwb3NlQScsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnYWRqX3knLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ3RyYW5zcG9zZUInLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdUJywgJ25hbWUnOiAnZHR5cGUnLCAndHlwZSc6ICdkdHlwZScsICdub3RTdXBwb3J0ZWQnOiB0cnVlIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVHJhbnNwb3NlJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ21hdHJpY2VzJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAncGVybScsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbe1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnVCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnZHR5cGUnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2R0eXBlJyxcbiAgICAgICAgICAgICAgICAnbm90U3VwcG9ydGVkJzogdHJ1ZVxuICAgICAgICAgICAgfV1cbiAgICB9XG5dO1xuXG52YXIgbWF0cmljZXMgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGpzb246IGpzb24kYlxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGpzb24kYyA9IFtcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdGdXNlZEJhdGNoTm9ybScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnc2NhbGUnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ29mZnNldCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMywgJ25hbWUnOiAnbWVhbicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogNCwgJ25hbWUnOiAndmFyaWFuY2UnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2Vwc2lsb24nLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2Vwc2lsb24nLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IDAuMDAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZGF0YV9mb3JtYXQnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2RhdGFGb3JtYXQnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnRnVzZWRCYXRjaE5vcm1WMicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnc2NhbGUnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ29mZnNldCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMywgJ25hbWUnOiAnbWVhbicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogNCwgJ25hbWUnOiAndmFyaWFuY2UnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2Vwc2lsb24nLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2Vwc2lsb24nLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IDAuMDAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZGF0YV9mb3JtYXQnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2RhdGFGb3JtYXQnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnRnVzZWRCYXRjaE5vcm1WMycsXG4gICAgICAgICdjYXRlZ29yeSc6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnc2NhbGUnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ29mZnNldCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMywgJ25hbWUnOiAnbWVhbicsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogNCwgJ25hbWUnOiAndmFyaWFuY2UnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2Vwc2lsb24nLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2Vwc2lsb24nLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IDAuMDAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnZGF0YV9mb3JtYXQnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2RhdGFGb3JtYXQnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTFJOJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ25vcm1hbGl6YXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdkZXB0aF9yYWRpdXMnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ3JhZGl1cycsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdiaWFzJywgJ25hbWUnOiAnYmlhcycsICd0eXBlJzogJ251bWJlcicsICdkZWZhdWx0VmFsdWUnOiAxLjAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2FscGhhJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdhbHBoYScsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnYmV0YScsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnYmV0YScsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogMC41XG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1NvZnRtYXgnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnbm9ybWFsaXphdGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTG9nU29mdG1heCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFt7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTcGFyc2VUb0RlbnNlJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ25vcm1hbGl6YXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICdzcGFyc2VJbmRpY2VzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdvdXRwdXRTaGFwZScsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICdzcGFyc2VWYWx1ZXMnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDMsICduYW1lJzogJ2RlZmF1bHRWYWx1ZScsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3tcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ3ZhbGlkYXRlX2luZGljZXMnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ3ZhbGlkYXRlSW5kaWNlcycsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1dXG4gICAgfVxuXTtcblxudmFyIG5vcm1hbGl6YXRpb24gPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGpzb246IGpzb24kY1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGpzb24kZCA9IFtcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdCaW5jb3VudCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdyZWR1Y3Rpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdzaXplJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICd3ZWlnaHRzJywgJ3R5cGUnOiAndGVuc29yJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0RlbnNlQmluY291bnQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAncmVkdWN0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnc2l6ZScsICd0eXBlJzogJ251bWJlcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMiwgJ25hbWUnOiAnd2VpZ2h0cycsICd0eXBlJzogJ3RlbnNvcicgfVxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ2JpbmFyeV9vdXRwdXQnLCAnbmFtZSc6ICdiaW5hcnlPdXRwdXQnLCAndHlwZSc6ICdib29sJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTWF4JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3JlZHVjdGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2F4aXMnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3sgJ3RmTmFtZSc6ICdrZWVwX2RpbXMnLCAnbmFtZSc6ICdrZWVwRGltcycsICd0eXBlJzogJ2Jvb2wnIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdNZWFuJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3JlZHVjdGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2F4aXMnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3sgJ3RmTmFtZSc6ICdrZWVwX2RpbXMnLCAnbmFtZSc6ICdrZWVwRGltcycsICd0eXBlJzogJ2Jvb2wnIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdNaW4nLFxuICAgICAgICAnY2F0ZWdvcnknOiAncmVkdWN0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYXhpcycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ2tlZXBfZGltcycsICduYW1lJzogJ2tlZXBEaW1zJywgJ3R5cGUnOiAnYm9vbCcgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1N1bScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdyZWR1Y3Rpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdheGlzJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFt7ICd0Zk5hbWUnOiAna2VlcF9kaW1zJywgJ25hbWUnOiAna2VlcERpbXMnLCAndHlwZSc6ICdib29sJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnQWxsJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3JlZHVjdGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2F4aXMnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3sgJ3RmTmFtZSc6ICdrZWVwX2RpbXMnLCAnbmFtZSc6ICdrZWVwRGltcycsICd0eXBlJzogJ2Jvb2wnIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdBbnknLFxuICAgICAgICAnY2F0ZWdvcnknOiAncmVkdWN0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYXhpcycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ2tlZXBfZGltcycsICduYW1lJzogJ2tlZXBEaW1zJywgJ3R5cGUnOiAnYm9vbCcgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0FyZ01heCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdyZWR1Y3Rpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdheGlzJywgJ3R5cGUnOiAnbnVtYmVyJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0FyZ01pbicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdyZWR1Y3Rpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdheGlzJywgJ3R5cGUnOiAnbnVtYmVyJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1Byb2QnLFxuICAgICAgICAnY2F0ZWdvcnknOiAncmVkdWN0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnYXhpcycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ2tlZXBfZGltcycsICduYW1lJzogJ2tlZXBEaW1zJywgJ3R5cGUnOiAnYm9vbCcgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0N1bXN1bScsXG4gICAgICAgICdjYXRlZ29yeSc6ICdyZWR1Y3Rpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdheGlzJywgJ3R5cGUnOiAnbnVtYmVyJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnZXhjbHVzaXZlJywgJ25hbWUnOiAnZXhjbHVzaXZlJywgJ3R5cGUnOiAnYm9vbCcgfSxcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdyZXZlcnNlJywgJ25hbWUnOiAncmV2ZXJzZScsICd0eXBlJzogJ2Jvb2wnIH1cbiAgICAgICAgXVxuICAgIH1cbl07XG5cbnZhciByZWR1Y3Rpb24gPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGpzb246IGpzb24kZFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGpzb24kZSA9IFtcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdDb25jYXRWMicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdzbGljZV9qb2luJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ2VuZCc6IC0xLCAnbmFtZSc6ICd0ZW5zb3JzJywgJ3R5cGUnOiAndGVuc29ycycgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogLTEsICduYW1lJzogJ2F4aXMnLCAndHlwZSc6ICdudW1iZXInIH1cbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3sgJ3RmTmFtZSc6ICdOJywgJ25hbWUnOiAnbicsICd0eXBlJzogJ251bWJlcicsICdkZWZhdWx0VmFsdWUnOiAyIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdDb25jYXQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnc2xpY2Vfam9pbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICdlbmQnOiAwLCAnbmFtZSc6ICd0ZW5zb3JzJywgJ3R5cGUnOiAndGVuc29ycycgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYXhpcycsICd0eXBlJzogJ251bWJlcicgfVxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ04nLCAnbmFtZSc6ICduJywgJ3R5cGUnOiAnbnVtYmVyJywgJ2RlZmF1bHRWYWx1ZSc6IDIgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0dhdGhlclYyJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3NsaWNlX2pvaW4nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdpbmRpY2VzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICdheGlzJywgJ3R5cGUnOiAnbnVtYmVyJywgJ2RlZmF1bHRWYWx1ZSc6IDAgfVxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbe1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnYmF0Y2hfZGltcycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnYmF0Y2hEaW1zJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiAwXG4gICAgICAgICAgICB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnR2F0aGVyJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3NsaWNlX2pvaW4nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdpbmRpY2VzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbe1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAndmFsaWRhdGVfaW5kaWNlcycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAndmFsaWRhdGVJbmRpY2VzJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sJyxcbiAgICAgICAgICAgICAgICAnbm90U3VwcG9ydGVkJzogdHJ1ZVxuICAgICAgICAgICAgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1JldmVyc2UnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnc2xpY2Vfam9pbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2RpbXMnLCAndHlwZSc6ICdib29sW10nIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnUmV2ZXJzZVYyJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3NsaWNlX2pvaW4nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdheGlzJywgJ3R5cGUnOiAnbnVtYmVyW10nIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnU2xpY2UnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnc2xpY2Vfam9pbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2JlZ2luJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ3NpemUnLCAndHlwZSc6ICdudW1iZXJbXScgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTdHJpZGVkU2xpY2UnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnc2xpY2Vfam9pbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2JlZ2luJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ2VuZCcsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAzLCAnbmFtZSc6ICdzdHJpZGVzJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2JlZ2luX21hc2snLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2JlZ2luTWFzaycsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2VuZF9tYXNrJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdlbmRNYXNrJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnbmV3X2F4aXNfbWFzaycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnbmV3QXhpc01hc2snLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdlbGxpcHNpc19tYXNrJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdlbGxpcHNpc01hc2snLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdzaHJpbmtfYXhpc19tYXNrJyxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdzaHJpbmtBeGlzTWFzaycsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogMFxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdQYWNrJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3NsaWNlX2pvaW4nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnZW5kJzogMCwgJ25hbWUnOiAndGVuc29ycycsICd0eXBlJzogJ3RlbnNvcnMnIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdheGlzJywgJ25hbWUnOiAnYXhpcycsICd0eXBlJzogJ251bWJlcicsICdkZWZhdWx0VmFsdWUnOiAwIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnVW5wYWNrJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3NsaWNlX2pvaW4nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd0ZW5zb3InLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFtcbiAgICAgICAgICAgIHsgJ3RmTmFtZSc6ICdheGlzJywgJ25hbWUnOiAnYXhpcycsICd0eXBlJzogJ251bWJlcicsICdkZWZhdWx0VmFsdWUnOiAwIH0sIHtcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ251bScsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnbnVtJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICdkZWZhdWx0VmFsdWUnOiAwLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1RpbGUnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnc2xpY2Vfam9pbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ3JlcHMnLCAndHlwZSc6ICdudW1iZXJbXScgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTcGxpdCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdzbGljZV9qb2luJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnYXhpcycsICd0eXBlJzogJ251bWJlcicsICdkZWZhdWx0VmFsdWUnOiAwIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgIF0sXG4gICAgICAgICdhdHRycyc6IFt7XG4gICAgICAgICAgICAgICAgJ3RmTmFtZSc6ICdudW1fc3BsaXQnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ251bU9yU2l6ZVNwbGl0cycsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogMVxuICAgICAgICAgICAgfV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1NwbGl0VicsXG4gICAgICAgICdjYXRlZ29yeSc6ICdzbGljZV9qb2luJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnbnVtT3JTaXplU3BsaXRzJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ2F4aXMnLCAndHlwZSc6ICdudW1iZXInLCAnZGVmYXVsdFZhbHVlJzogMCB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1NjYXR0ZXJOZCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdzbGljZV9qb2luJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAnaW5kaWNlcycsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAndmFsdWVzJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAyLCAnbmFtZSc6ICdzaGFwZScsICd0eXBlJzogJ251bWJlcltdJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0dhdGhlck5kJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3NsaWNlX2pvaW4nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdpbmRpY2VzJywgJ3R5cGUnOiAndGVuc29yJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ1NwYXJzZVRvRGVuc2UnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnc2xpY2Vfam9pbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3NwYXJzZUluZGljZXMnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ291dHB1dFNoYXBlJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ3NwYXJzZVZhbHVlcycsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMywgJ25hbWUnOiAnZGVmYXVsdFZhbHVlJywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbe1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAndmFsaWRhdGVfaW5kaWNlcycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAndmFsaWRhdGVJbmRpY2VzJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1dXG4gICAgfVxuXTtcblxudmFyIHNsaWNlSm9pbiA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAganNvbjoganNvbiRlXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIganNvbiRmID0gW1xuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0ZGVCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdzcGVjdHJhbCcsXG4gICAgICAgICdpbnB1dHMnOiBbeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnSUZGVCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdzcGVjdHJhbCcsXG4gICAgICAgICdpbnB1dHMnOiBbeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnUkZGVCcsXG4gICAgICAgICdjYXRlZ29yeSc6ICdzcGVjdHJhbCcsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sIHtcbiAgICAgICAgICAgICAgICAnc3RhcnQnOiAxLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2ZmdF9sZW5ndGgnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnSVJGRlQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAnc3BlY3RyYWwnLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LCB7XG4gICAgICAgICAgICAgICAgJ3N0YXJ0JzogMSxcbiAgICAgICAgICAgICAgICAnbmFtZSc6ICdmZnRfbGVuZ3RoJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICdub3RTdXBwb3J0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9XG5dO1xuXG52YXIgc3BlY3RyYWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGpzb246IGpzb24kZlxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGpzb24kZyA9IFtcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdDYXN0JyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3RyYW5zZm9ybWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnU3JjVCcsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnc2R0eXBlJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdkdHlwZScsXG4gICAgICAgICAgICAgICAgJ25vdFN1cHBvcnRlZCc6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnRHN0VCcsICduYW1lJzogJ2R0eXBlJywgJ3R5cGUnOiAnZHR5cGUnIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnRXhwYW5kRGltcycsXG4gICAgICAgICdjYXRlZ29yeSc6ICd0cmFuc2Zvcm1hdGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ2F4aXMnLCAndHlwZSc6ICdudW1iZXInIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnTWlycm9yUGFkJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3RyYW5zZm9ybWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAncGFkZGluZycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbeyAndGZOYW1lJzogJ21vZGUnLCAnbmFtZSc6ICdtb2RlJywgJ3R5cGUnOiAnc3RyaW5nJyB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnUGFkJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3RyYW5zZm9ybWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAncGFkZGluZycsICd0eXBlJzogJ251bWJlcltdJyB9LFxuICAgICAgICBdLFxuICAgICAgICAnYXR0cnMnOiBbe1xuICAgICAgICAgICAgICAgICd0Zk5hbWUnOiAnY29uc3RhbnRfdmFsdWUnLFxuICAgICAgICAgICAgICAgICduYW1lJzogJ2NvbnN0YW50VmFsdWUnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IDBcbiAgICAgICAgICAgIH1dXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdQYWRWMicsXG4gICAgICAgICdjYXRlZ29yeSc6ICd0cmFuc2Zvcm1hdGlvbicsXG4gICAgICAgICdpbnB1dHMnOiBbXG4gICAgICAgICAgICB7ICdzdGFydCc6IDAsICduYW1lJzogJ3gnLCAndHlwZSc6ICd0ZW5zb3InIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDEsICduYW1lJzogJ3BhZGRpbmcnLCAndHlwZSc6ICdudW1iZXJbXScgfSwge1xuICAgICAgICAgICAgICAgICdzdGFydCc6IDIsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnY29uc3RhbnRWYWx1ZScsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdFZhbHVlJzogMFxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdSZXNoYXBlJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3RyYW5zZm9ybWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnc2hhcGUnLCAndHlwZSc6ICdudW1iZXJbXScgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgICd0Zk9wTmFtZSc6ICdTcXVlZXplJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3RyYW5zZm9ybWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW3tcbiAgICAgICAgICAgICAgICAndGZOYW1lJzogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICd0ZkRlcHJlY2F0ZWROYW1lJzogJ3NxdWVlemVfZGltcycsXG4gICAgICAgICAgICAgICAgJ25hbWUnOiAnYXhpcycsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyW10nXG4gICAgICAgICAgICB9XVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnU3BhY2VUb0JhdGNoTkQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAndHJhbnNmb3JtYXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdibG9ja1NoYXBlJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ3BhZGRpbmdzJywgJ3R5cGUnOiAnbnVtYmVyW10nIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnQmF0Y2hUb1NwYWNlTkQnLFxuICAgICAgICAnY2F0ZWdvcnknOiAndHJhbnNmb3JtYXRpb24nLFxuICAgICAgICAnaW5wdXRzJzogW1xuICAgICAgICAgICAgeyAnc3RhcnQnOiAwLCAnbmFtZSc6ICd4JywgJ3R5cGUnOiAndGVuc29yJyB9LFxuICAgICAgICAgICAgeyAnc3RhcnQnOiAxLCAnbmFtZSc6ICdibG9ja1NoYXBlJywgJ3R5cGUnOiAnbnVtYmVyW10nIH0sXG4gICAgICAgICAgICB7ICdzdGFydCc6IDIsICduYW1lJzogJ2Nyb3BzJywgJ3R5cGUnOiAnbnVtYmVyW10nIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICAndGZPcE5hbWUnOiAnRGVwdGhUb1NwYWNlJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3RyYW5zZm9ybWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW1xuICAgICAgICAgICAgeyAndGZOYW1lJzogJ2Jsb2NrX3NpemUnLCAnbmFtZSc6ICdibG9ja1NpemUnLCAndHlwZSc6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7ICd0Zk5hbWUnOiAnZGF0YV9mb3JtYXQnLCAnbmFtZSc6ICdkYXRhRm9ybWF0JywgJ3R5cGUnOiAnc3RyaW5nJyB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgJ3RmT3BOYW1lJzogJ0Jyb2FkY2FzdFRvJyxcbiAgICAgICAgJ2NhdGVnb3J5JzogJ3RyYW5zZm9ybWF0aW9uJyxcbiAgICAgICAgJ2lucHV0cyc6IFtcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMCwgJ25hbWUnOiAneCcsICd0eXBlJzogJ3RlbnNvcicgfSxcbiAgICAgICAgICAgIHsgJ3N0YXJ0JzogMSwgJ25hbWUnOiAnc2hhcGUnLCAndHlwZSc6ICdudW1iZXJbXScgfSxcbiAgICAgICAgXSxcbiAgICAgICAgJ2F0dHJzJzogW11cbiAgICB9XG5dO1xuXG52YXIgdHJhbnNmb3JtYXRpb24gPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGpzb246IGpzb24kZ1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIE9wZXJhdGlvbk1hcHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBMb2FkcyB0aGUgb3AgbWFwcGluZyBmcm9tIHRoZSBKU09OIGZpbGUuXG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uTWFwcGVyKCkge1xuICAgICAgICB2YXIgb3BzID0gW1xuICAgICAgICAgICAgYXJpdGhtZXRpYywgYmFzaWNNYXRoLCBjb250cm9sLCBjb252b2x1dGlvbiwgY3JlYXRpb24sIGR5bmFtaWMsXG4gICAgICAgICAgICBldmFsdWF0aW9uLCBsb2dpY2FsLCBpbWFnZSwgZ3JhcGgsIG1hdHJpY2VzLCBub3JtYWxpemF0aW9uLCByZWR1Y3Rpb24sXG4gICAgICAgICAgICBzbGljZUpvaW4sIHNwZWN0cmFsLCB0cmFuc2Zvcm1hdGlvbiwgaGFzaFRhYmxlXG4gICAgICAgIF07XG4gICAgICAgIHZhciBtYXBwZXJzSnNvbiA9IFtdLmNvbmNhdC5hcHBseShbXSwgX19zcHJlYWQob3BzLm1hcChmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLmpzb247IH0pKSk7XG4gICAgICAgIHRoaXMub3BNYXBwZXJzID0gbWFwcGVyc0pzb24ucmVkdWNlKGZ1bmN0aW9uIChtYXAsIG1hcHBlcikge1xuICAgICAgICAgICAgbWFwW21hcHBlci50Zk9wTmFtZV0gPSBtYXBwZXI7XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcGVyYXRpb25NYXBwZXIsIFwiSW5zdGFuY2VcIiwge1xuICAgICAgICAvLyBTaW5nbGV0b24gaW5zdGFuY2UgZm9yIHRoZSBtYXBwZXJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgfHwgKHRoaXMuX2luc3RhbmNlID0gbmV3IHRoaXMoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIENvbnZlcnRzIHRoZSBtb2RlbCBpbmZlcmVuY2UgZ3JhcGggZnJvbSBUZW5zb3JmbG93IEdyYXBoRGVmIHRvIGxvY2FsXG4gICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIFRlbnNvckZsb3cuanMgQVBJXG4gICAgT3BlcmF0aW9uTWFwcGVyLnByb3RvdHlwZS50cmFuc2Zvcm1HcmFwaCA9IGZ1bmN0aW9uIChncmFwaCwgc2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzaWduYXR1cmUgPT09IHZvaWQgMCkgeyBzaWduYXR1cmUgPSB7fTsgfVxuICAgICAgICB2YXIgdGZOb2RlcyA9IGdyYXBoLm5vZGU7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlcnMgPSBbXTtcbiAgICAgICAgdmFyIHdlaWdodHMgPSBbXTtcbiAgICAgICAgdmFyIGluaXROb2RlcyA9IFtdO1xuICAgICAgICB2YXIgbm9kZXMgPSB0Zk5vZGVzLnJlZHVjZShmdW5jdGlvbiAobWFwLCBub2RlKSB7XG4gICAgICAgICAgICBtYXBbbm9kZS5uYW1lXSA9IF90aGlzLm1hcE5vZGUobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5vcC5zdGFydHNXaXRoKCdQbGFjZWhvbGRlcicpKSB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJzLnB1c2gobWFwW25vZGUubmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5vcCA9PT0gJ0NvbnN0Jykge1xuICAgICAgICAgICAgICAgIHdlaWdodHMucHVzaChtYXBbbm9kZS5uYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmlucHV0ID09IG51bGwgfHwgbm9kZS5pbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbml0Tm9kZXMucHVzaChtYXBbbm9kZS5uYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHZhciBpbnB1dHMgPSBbXTtcbiAgICAgICAgdmFyIG91dHB1dHMgPSBbXTtcbiAgICAgICAgdmFyIGlucHV0Tm9kZU5hbWVUb0tleSA9IHt9O1xuICAgICAgICB2YXIgb3V0cHV0Tm9kZU5hbWVUb0tleSA9IHt9O1xuICAgICAgICBpZiAoc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0Tm9kZU5hbWVUb0tleSA9IHRoaXMubWFwU2lnbmF0dXJlRW50cmllcyhzaWduYXR1cmUuaW5wdXRzKTtcbiAgICAgICAgICAgIG91dHB1dE5vZGVOYW1lVG9LZXkgPSB0aGlzLm1hcFNpZ25hdHVyZUVudHJpZXMoc2lnbmF0dXJlLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGxOb2RlcyA9IE9iamVjdC5rZXlzKG5vZGVzKTtcbiAgICAgICAgYWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2tleV07XG4gICAgICAgICAgICBub2RlLmlucHV0TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChnZXROb2RlTmFtZUFuZEluZGV4KG5hbWUpLCAxKSwgbm9kZU5hbWUgPSBfYVswXTtcbiAgICAgICAgICAgICAgICBub2RlLmlucHV0cy5wdXNoKG5vZGVzW25vZGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgbm9kZXNbbm9kZU5hbWVdLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIHNpZ25hdHVyZSBoYXMgbm90IG91dHB1dHMgc2V0LCBhZGQgYW55IG5vZGUgdGhhdCBkb2VzIG5vdCBoYXZlXG4gICAgICAgIC8vIG91dHB1dHMuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhvdXRwdXROb2RlTmFtZVRvS2V5KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGFsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMob3V0cHV0Tm9kZU5hbWVUb0tleSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChnZXROb2RlTmFtZUFuZEluZGV4KG5hbWUpLCAxKSwgbm9kZU5hbWUgPSBfYVswXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW25vZGVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2lnbmF0dXJlS2V5ID0gb3V0cHV0Tm9kZU5hbWVUb0tleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhpbnB1dE5vZGVOYW1lVG9LZXkpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGlucHV0Tm9kZU5hbWVUb0tleSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChnZXROb2RlTmFtZUFuZEluZGV4KG5hbWUpLCAxKSwgbm9kZU5hbWUgPSBfYVswXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW25vZGVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNpZ25hdHVyZUtleSA9IGlucHV0Tm9kZU5hbWVUb0tleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBwbGFjZWhvbGRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoZ3JhcGgubGlicmFyeSAhPSBudWxsICYmIGdyYXBoLmxpYnJhcnkuZnVuY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgZnVuY3Rpb25zID0gZ3JhcGgubGlicmFyeS5mdW5jdGlvbi5yZWR1Y2UoZnVuY3Rpb24gKGZ1bmN0aW9ucywgZnVuYykge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uc1tmdW5jLnNpZ25hdHVyZS5uYW1lXSA9IF90aGlzLm1hcEZ1bmN0aW9uKGZ1bmMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbnM7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgbm9kZXM6IG5vZGVzLCBpbnB1dHM6IGlucHV0cywgb3V0cHV0czogb3V0cHV0cywgd2VpZ2h0czogd2VpZ2h0cywgcGxhY2Vob2xkZXJzOiBwbGFjZWhvbGRlcnMsIHNpZ25hdHVyZTogc2lnbmF0dXJlLCBmdW5jdGlvbnM6IGZ1bmN0aW9ucyB9O1xuICAgICAgICBpZiAoaW5pdE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5pbml0Tm9kZXMgPSBpbml0Tm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE9wZXJhdGlvbk1hcHBlci5wcm90b3R5cGUubWFwU2lnbmF0dXJlRW50cmllcyA9IGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlbnRyaWVzIHx8IHt9KVxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xuICAgICAgICAgICAgcHJldltlbnRyaWVzW2N1cnJdLm5hbWVdID0gY3VycjtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICBPcGVyYXRpb25NYXBwZXIucHJvdG90eXBlLm1hcE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvLyBVbnN1cHBvcnRlZCBvcHMgd2lsbCBjYXVzZSBhbiBlcnJvciBhdCBydW4tdGltZSAobm90IHBhcnNlIHRpbWUpLCBzaW5jZVxuICAgICAgICAvLyB0aGV5IG1heSBub3QgYmUgdXNlZCBieSB0aGUgYWN0dWFsIGV4ZWN1dGlvbiBzdWJncmFwaC5cbiAgICAgICAgdmFyIG1hcHBlciA9IGdldFJlZ2lzdGVyZWRPcChub2RlLm9wKSB8fCB0aGlzLm9wTWFwcGVyc1tub2RlLm9wXSB8fCB7fTtcbiAgICAgICAgaWYgKG5vZGUuYXR0ciA9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmF0dHIgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgIG9wOiBub2RlLm9wLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IG1hcHBlci5jYXRlZ29yeSxcbiAgICAgICAgICAgIGlucHV0TmFtZXM6IChub2RlLmlucHV0IHx8XG4gICAgICAgICAgICAgICAgW10pLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIGlucHV0LnN0YXJ0c1dpdGgoJ14nKSA/IGlucHV0LnN1YnN0cigxKSA6IGlucHV0OyB9KSxcbiAgICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBpbnB1dFBhcmFtczoge30sXG4gICAgICAgICAgICBhdHRyUGFyYW1zOiB7fSxcbiAgICAgICAgICAgIHJhd0F0dHJzOiBub2RlLmF0dHJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hcHBlci5pbnB1dHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3Tm9kZS5pbnB1dFBhcmFtcyA9XG4gICAgICAgICAgICAgICAgbWFwcGVyLmlucHV0cy5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgcGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW3BhcmFtLm5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcGFyYW0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0SW5kZXhTdGFydDogcGFyYW0uc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEluZGV4RW5kOiBwYXJhbS5lbmRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcHBlci5hdHRycyAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXdOb2RlLmF0dHJQYXJhbXMgPVxuICAgICAgICAgICAgICAgIG1hcHBlci5hdHRycy5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgcGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBwYXJhbS50eXBlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldFN0cmluZ1BhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZOYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEhcGFyYW0udGZEZXByZWNhdGVkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldFN0cmluZ1BhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZEZXByZWNhdGVkTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmdbXSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRTdHJpbmdBcnJheVBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZOYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEhcGFyYW0udGZEZXByZWNhdGVkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldFN0cmluZ0FycmF5UGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZkRlcHJlY2F0ZWROYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXROdW1iZXJQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmTmFtZSwgKHBhcmFtLmRlZmF1bHRWYWx1ZSB8fCAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgISFwYXJhbS50ZkRlcHJlY2F0ZWROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0TnVtYmVyUGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZkRlcHJlY2F0ZWROYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcltdJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldE51bWVyaWNBcnJheVBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZOYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEhcGFyYW0udGZEZXByZWNhdGVkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldE51bWVyaWNBcnJheVBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZEZXByZWNhdGVkTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldEJvb2xQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhIXBhcmFtLnRmRGVwcmVjYXRlZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRCb29sUGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZkRlcHJlY2F0ZWROYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xbXSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRCb29sQXJyYXlQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhIXBhcmFtLnRmRGVwcmVjYXRlZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRCb29sQXJyYXlQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmRGVwcmVjYXRlZE5hbWUsIHBhcmFtLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2hhcGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0VGVuc29yU2hhcGVQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhIXBhcmFtLnRmRGVwcmVjYXRlZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRUZW5zb3JTaGFwZVBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZEZXByZWNhdGVkTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzaGFwZVtdJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldFRlbnNvclNoYXBlQXJyYXlQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhIXBhcmFtLnRmRGVwcmVjYXRlZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRUZW5zb3JTaGFwZUFycmF5UGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZkRlcHJlY2F0ZWROYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2R0eXBlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldER0eXBlUGFyYW0obm9kZS5hdHRyLCBwYXJhbS50Zk5hbWUsIHBhcmFtLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgISFwYXJhbS50ZkRlcHJlY2F0ZWROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0RHR5cGVQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmRGVwcmVjYXRlZE5hbWUsIHBhcmFtLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZHR5cGVbXSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXREdHlwZUFycmF5UGFyYW0obm9kZS5hdHRyLCBwYXJhbS50Zk5hbWUsIHBhcmFtLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgISFwYXJhbS50ZkRlcHJlY2F0ZWROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0RHR5cGVBcnJheVBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZEZXByZWNhdGVkTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldEZ1bmNQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhIXBhcmFtLnRmRGVwcmVjYXRlZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRGdW5jUGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZkRlcHJlY2F0ZWROYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RlbnNvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZW5zb3JzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcGFyYW0gdHlwZTogXCIgKyBwYXJhbS50eXBlICsgXCIgZm9yIG9wOiBcIiArIG5vZGUub3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hcFtwYXJhbS5uYW1lXSA9IHsgdmFsdWU6IHZhbHVlLCB0eXBlOiB0eXBlIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH07XG4gICAgLy8gbWFwIHRoZSBURnVuY3Rpb25EZWYgdG8gVEZKUyBncmFwaCBvYmplY3RcbiAgICBPcGVyYXRpb25NYXBwZXIucHJvdG90eXBlLm1hcEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmN0aW9uRGVmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0Zk5vZGVzID0gZnVuY3Rpb25EZWYubm9kZURlZjtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVycyA9IFtdO1xuICAgICAgICB2YXIgd2VpZ2h0cyA9IFtdO1xuICAgICAgICB2YXIgbm9kZXMgPSB7fTtcbiAgICAgICAgaWYgKHRmTm9kZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZXMgPSB0Zk5vZGVzLnJlZHVjZShmdW5jdGlvbiAobWFwLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgbWFwW25vZGUubmFtZV0gPSBfdGhpcy5tYXBOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm9wID09PSAnQ29uc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdlaWdodHMucHVzaChtYXBbbm9kZS5uYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0cyA9IFtdO1xuICAgICAgICB2YXIgb3V0cHV0cyA9IFtdO1xuICAgICAgICBmdW5jdGlvbkRlZi5zaWduYXR1cmUuaW5wdXRBcmcuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZ2V0Tm9kZU5hbWVBbmRJbmRleChhcmcubmFtZSksIDEpLCBub2RlTmFtZSA9IF9hWzBdO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogbm9kZU5hbWUsXG4gICAgICAgICAgICAgICAgb3A6ICdQbGFjZWhvbGRlcicsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBpbnB1dE5hbWVzOiBbXSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogJ2dyYXBoJyxcbiAgICAgICAgICAgICAgICBpbnB1dFBhcmFtczoge30sXG4gICAgICAgICAgICAgICAgYXR0clBhcmFtczogeyBkdHlwZTogeyB2YWx1ZTogcGFyc2VEdHlwZVBhcmFtKGFyZy50eXBlKSwgdHlwZTogJ2R0eXBlJyB9IH0sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbm9kZS5zaWduYXR1cmVLZXkgPSBhcmcubmFtZTtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgbm9kZXNbbm9kZU5hbWVdID0gbm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhbGxOb2RlcyA9IE9iamVjdC5rZXlzKG5vZGVzKTtcbiAgICAgICAgYWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2tleV07XG4gICAgICAgICAgICBub2RlLmlucHV0TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChnZXROb2RlTmFtZUFuZEluZGV4KG5hbWUpLCAxKSwgbm9kZU5hbWUgPSBfYVswXTtcbiAgICAgICAgICAgICAgICBub2RlLmlucHV0cy5wdXNoKG5vZGVzW25vZGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgbm9kZXNbbm9kZU5hbWVdLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZXR1cm5Ob2RlTWFwID0gZnVuY3Rpb25EZWYucmV0O1xuICAgICAgICBmdW5jdGlvbkRlZi5zaWduYXR1cmUub3V0cHV0QXJnLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKGdldE5vZGVOYW1lQW5kSW5kZXgocmV0dXJuTm9kZU1hcFtvdXRwdXQubmFtZV0pLCAyKSwgbm9kZU5hbWUgPSBfYVswXSwgaW5kZXggPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbbm9kZU5hbWVdO1xuICAgICAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5vZGUuZGVmYXVsdE91dHB1dCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLm1hcEFyZ3NUb1NpZ25hdHVyZShmdW5jdGlvbkRlZik7XG4gICAgICAgIHJldHVybiB7IG5vZGVzOiBub2RlcywgaW5wdXRzOiBpbnB1dHMsIG91dHB1dHM6IG91dHB1dHMsIHdlaWdodHM6IHdlaWdodHMsIHBsYWNlaG9sZGVyczogcGxhY2Vob2xkZXJzLCBzaWduYXR1cmU6IHNpZ25hdHVyZSB9O1xuICAgIH07XG4gICAgT3BlcmF0aW9uTWFwcGVyLnByb3RvdHlwZS5tYXBBcmdzVG9TaWduYXR1cmUgPSBmdW5jdGlvbiAoZnVuY3Rpb25EZWYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWU6IGZ1bmN0aW9uRGVmLnNpZ25hdHVyZS5uYW1lLFxuICAgICAgICAgICAgaW5wdXRzOiBmdW5jdGlvbkRlZi5zaWduYXR1cmUuaW5wdXRBcmcucmVkdWNlKGZ1bmN0aW9uIChtYXAsIGFyZykge1xuICAgICAgICAgICAgICAgIG1hcFthcmcubmFtZV0gPSBfdGhpcy5tYXBBcmdUb1RlbnNvckluZm8oYXJnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgb3V0cHV0czogZnVuY3Rpb25EZWYuc2lnbmF0dXJlLm91dHB1dEFyZy5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgYXJnKSB7XG4gICAgICAgICAgICAgICAgbWFwW2FyZy5uYW1lXSA9IF90aGlzLm1hcEFyZ1RvVGVuc29ySW5mbyhhcmcsIGZ1bmN0aW9uRGVmLnJldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgIH0sIHt9KSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9wZXJhdGlvbk1hcHBlci5wcm90b3R5cGUubWFwQXJnVG9UZW5zb3JJbmZvID0gZnVuY3Rpb24gKGFyZywgbmFtZU1hcCkge1xuICAgICAgICB2YXIgbmFtZSA9IGFyZy5uYW1lO1xuICAgICAgICBpZiAobmFtZU1hcCAhPSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBuYW1lOiBuYW1lLCBkdHlwZTogYXJnLnR5cGUgfTtcbiAgICB9O1xuICAgIHJldHVybiBPcGVyYXRpb25NYXBwZXI7XG59KCkpO1xuZnVuY3Rpb24gZGVjb2RlQmFzZTY0KHRleHQpIHtcbiAgICB2YXIgZ2xvYmFsID0gdGZPcHMuZW52KCkuZ2xvYmFsO1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmF0b2IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWwuYXRvYih0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodGV4dCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNvZGUgYmFzZTY0IGluIHRoaXMgZW52aXJvbm1lbnQuICcgK1xuICAgICAgICAgICAgJ01pc3NpbmcgYnVpbHQtaW4gYXRvYigpIG9yIEJ1ZmZlcigpJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmdQYXJhbShzLCBrZWVwQ2FzZSkge1xuICAgIHZhciB2YWx1ZSA9IEFycmF5LmlzQXJyYXkocykgPyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHMpIDogZGVjb2RlQmFzZTY0KHMpO1xuICAgIHJldHVybiBrZWVwQ2FzZSA/IHZhbHVlIDogdmFsdWUudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGdldFN0cmluZ1BhcmFtKGF0dHJzLCBuYW1lLCBkZWYsIGtlZXBDYXNlKSB7XG4gICAgaWYgKGtlZXBDYXNlID09PSB2b2lkIDApIHsga2VlcENhc2UgPSBmYWxzZTsgfVxuICAgIHZhciBwYXJhbSA9IGF0dHJzW25hbWVdO1xuICAgIGlmIChwYXJhbSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1BhcmFtKHBhcmFtLnMsIGtlZXBDYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGdldEJvb2xQYXJhbShhdHRycywgbmFtZSwgZGVmKSB7XG4gICAgdmFyIHBhcmFtID0gYXR0cnNbbmFtZV07XG4gICAgcmV0dXJuIHBhcmFtID8gcGFyYW0uYiA6IGRlZjtcbn1cbmZ1bmN0aW9uIGdldE51bWJlclBhcmFtKGF0dHJzLCBuYW1lLCBkZWYpIHtcbiAgICB2YXIgcGFyYW0gPSBhdHRyc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgdmFsdWUgPSBwYXJhbVsnaSddICE9IG51bGwgPyBwYXJhbVsnaSddIDogKHBhcmFtWydmJ10gIT0gbnVsbCA/IHBhcmFtWydmJ10gOiBkZWYpO1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgPyB2YWx1ZSA6IHBhcnNlSW50KHZhbHVlLCAxMCk7XG59XG5mdW5jdGlvbiBwYXJzZUR0eXBlUGFyYW0odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgdmFsdWUgPSBEYXRhVHlwZVt2YWx1ZV07XG4gICAgfVxuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSBEYXRhVHlwZS5EVF9GTE9BVDpcbiAgICAgICAgICAgIHJldHVybiAnZmxvYXQzMic7XG4gICAgICAgIGNhc2UgRGF0YVR5cGUuRFRfSU5UMzI6XG4gICAgICAgIGNhc2UgRGF0YVR5cGUuRFRfSU5UNjQ6XG4gICAgICAgIGNhc2UgRGF0YVR5cGUuRFRfSU5UODpcbiAgICAgICAgY2FzZSBEYXRhVHlwZS5EVF9VSU5UODpcbiAgICAgICAgICAgIHJldHVybiAnaW50MzInO1xuICAgICAgICBjYXNlIERhdGFUeXBlLkRUX0JPT0w6XG4gICAgICAgICAgICByZXR1cm4gJ2Jvb2wnO1xuICAgICAgICBjYXNlIERhdGFUeXBlLkRUX0RPVUJMRTpcbiAgICAgICAgICAgIHJldHVybiAnZmxvYXQzMic7XG4gICAgICAgIGNhc2UgRGF0YVR5cGUuRFRfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gVW5rbm93biBkdHlwZSBlcnJvciB3aWxsIGhhcHBlbiBhdCBydW50aW1lIChpbnN0ZWFkIG9mIHBhcnNlIHRpbWUpLFxuICAgICAgICAgICAgLy8gc2luY2UgdGhlc2Ugbm9kZXMgbWlnaHQgbm90IGJlIHVzZWQgYnkgdGhlIGFjdHVhbCBzdWJncmFwaCBleGVjdXRpb24uXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRGdW5jUGFyYW0oYXR0cnMsIG5hbWUsIGRlZikge1xuICAgIHZhciBwYXJhbSA9IGF0dHJzW25hbWVdO1xuICAgIGlmIChwYXJhbSAmJiBwYXJhbS5mdW5jKSB7XG4gICAgICAgIHJldHVybiBwYXJhbS5mdW5jLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBnZXREdHlwZVBhcmFtKGF0dHJzLCBuYW1lLCBkZWYpIHtcbiAgICB2YXIgcGFyYW0gPSBhdHRyc1tuYW1lXTtcbiAgICBpZiAocGFyYW0gJiYgcGFyYW0udHlwZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VEdHlwZVBhcmFtKHBhcmFtLnR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gZ2V0RHR5cGVBcnJheVBhcmFtKGF0dHJzLCBuYW1lLCBkZWYpIHtcbiAgICB2YXIgcGFyYW0gPSBhdHRyc1tuYW1lXTtcbiAgICBpZiAocGFyYW0gJiYgcGFyYW0ubGlzdCAmJiBwYXJhbS5saXN0LnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLmxpc3QudHlwZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHBhcnNlRHR5cGVQYXJhbSh2KTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBwYXJzZVRlbnNvclNoYXBlUGFyYW0oc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUudW5rbm93blJhbmspIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHNoYXBlLmRpbSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzaGFwZS5kaW0ubWFwKGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGRpbS5zaXplID09PSAnbnVtYmVyJykgPyBkaW0uc2l6ZSA6IHBhcnNlSW50KGRpbS5zaXplLCAxMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBnZXRUZW5zb3JTaGFwZVBhcmFtKGF0dHJzLCBuYW1lLCBkZWYpIHtcbiAgICB2YXIgcGFyYW0gPSBhdHRyc1tuYW1lXTtcbiAgICBpZiAocGFyYW0gJiYgcGFyYW0uc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVGVuc29yU2hhcGVQYXJhbShwYXJhbS5zaGFwZSk7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBnZXROdW1lcmljQXJyYXlQYXJhbShhdHRycywgbmFtZSwgZGVmKSB7XG4gICAgdmFyIHBhcmFtID0gYXR0cnNbbmFtZV07XG4gICAgaWYgKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiAoKHBhcmFtLmxpc3QuZiAmJiBwYXJhbS5saXN0LmYubGVuZ3RoID8gcGFyYW0ubGlzdC5mIDpcbiAgICAgICAgICAgIHBhcmFtLmxpc3QuaSkgfHxcbiAgICAgICAgICAgIFtdKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gKHR5cGVvZiB2ID09PSAnbnVtYmVyJykgPyB2IDogcGFyc2VJbnQodiwgMTApOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGdldFN0cmluZ0FycmF5UGFyYW0oYXR0cnMsIG5hbWUsIGRlZiwga2VlcENhc2UpIHtcbiAgICBpZiAoa2VlcENhc2UgPT09IHZvaWQgMCkgeyBrZWVwQ2FzZSA9IGZhbHNlOyB9XG4gICAgdmFyIHBhcmFtID0gYXR0cnNbbmFtZV07XG4gICAgaWYgKHBhcmFtICYmIHBhcmFtLmxpc3QgJiYgcGFyYW0ubGlzdC5zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbS5saXN0LnMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmdQYXJhbSh2LCBrZWVwQ2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gZ2V0VGVuc29yU2hhcGVBcnJheVBhcmFtKGF0dHJzLCBuYW1lLCBkZWYpIHtcbiAgICB2YXIgcGFyYW0gPSBhdHRyc1tuYW1lXTtcbiAgICBpZiAocGFyYW0gJiYgcGFyYW0ubGlzdCAmJiBwYXJhbS5saXN0LnNoYXBlKSB7XG4gICAgICAgIHJldHVybiBwYXJhbS5saXN0LnNoYXBlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVGVuc29yU2hhcGVQYXJhbSh2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBnZXRCb29sQXJyYXlQYXJhbShhdHRycywgbmFtZSwgZGVmKSB7XG4gICAgdmFyIHBhcmFtID0gYXR0cnNbbmFtZV07XG4gICAgaWYgKHBhcmFtICYmIHBhcmFtLmxpc3QgJiYgcGFyYW0ubGlzdC5iKSB7XG4gICAgICAgIHJldHVybiBwYXJhbS5saXN0LmI7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogSGVscGVyIGNsYXNzIGZvciBsb29rdXAgaW5wdXRzIGFuZCBwYXJhbXMgZm9yIG5vZGVzIGluIHRoZSBtb2RlbCBncmFwaC5cbiAqL1xudmFyIE5vZGVWYWx1ZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZVZhbHVlSW1wbChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy50ZW5zb3JNYXAgPSB0ZW5zb3JNYXA7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBub2RlLmlucHV0TmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5nZXRJbnB1dChuYW1lKTsgfSk7XG4gICAgICAgIGlmIChub2RlLnJhd0F0dHJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBPYmplY3Qua2V5cyhub2RlLnJhd0F0dHJzKVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGF0dHJzLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gX3RoaXMuZ2V0QXR0cihrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgb3IgaW5wdXQgcGFyYW0uXG4gICAgICogQHBhcmFtIG5hbWUgU3RyaW5nOiBuYW1lIG9mIGF0dHJpYnV0ZSBvciBpbnB1dCBwYXJhbS5cbiAgICAgKi9cbiAgICBOb2RlVmFsdWVJbXBsLnByb3RvdHlwZS5nZXRJbnB1dCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBnZXRUZW5zb3IobmFtZSwgdGhpcy50ZW5zb3JNYXAsIHRoaXMuY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgb3IgaW5wdXQgcGFyYW0uXG4gICAgICogQHBhcmFtIG5hbWUgU3RyaW5nOiBuYW1lIG9mIGF0dHJpYnV0ZSBvciBpbnB1dCBwYXJhbS5cbiAgICAgKi9cbiAgICBOb2RlVmFsdWVJbXBsLnByb3RvdHlwZS5nZXRBdHRyID0gZnVuY3Rpb24gKG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm5vZGUucmF3QXR0cnNbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZS50ZW5zb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbnNvcihuYW1lLCB0aGlzLnRlbnNvck1hcCwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuaSAhPSBudWxsIHx8IHZhbHVlLmYgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlclBhcmFtKHRoaXMubm9kZS5yYXdBdHRycywgbmFtZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUucyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nUGFyYW0odGhpcy5ub2RlLnJhd0F0dHJzLCBuYW1lLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5iICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCb29sUGFyYW0odGhpcy5ub2RlLnJhd0F0dHJzLCBuYW1lLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5zaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VGVuc29yU2hhcGVQYXJhbSh0aGlzLm5vZGUucmF3QXR0cnMsIG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldER0eXBlUGFyYW0odGhpcy5ub2RlLnJhd0F0dHJzLCBuYW1lLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5saXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5saXN0LmkgIT0gbnVsbCB8fCB2YWx1ZS5saXN0LmYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXROdW1lcmljQXJyYXlQYXJhbSh0aGlzLm5vZGUucmF3QXR0cnMsIG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGlzdC5zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nQXJyYXlQYXJhbSh0aGlzLm5vZGUucmF3QXR0cnMsIG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGlzdC5zaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFRlbnNvclNoYXBlQXJyYXlQYXJhbSh0aGlzLm5vZGUucmF3QXR0cnMsIG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGlzdC5iICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qm9vbEFycmF5UGFyYW0odGhpcy5ub2RlLnJhd0F0dHJzLCBuYW1lLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLmxpc3QudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldER0eXBlQXJyYXlQYXJhbSh0aGlzLm5vZGUucmF3QXR0cnMsIG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlVmFsdWVJbXBsO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGV4ZWN1dGVPcCA9IGZ1bmN0aW9uIChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSAnQmlhc0FkZCc6XG4gICAgICAgIGNhc2UgJ0FkZFYyJzpcbiAgICAgICAgY2FzZSAnQWRkJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5hZGQoZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQWRkTic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuYWRkTihnZXRQYXJhbVZhbHVlKCd0ZW5zb3JzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0Zsb29yTW9kJzpcbiAgICAgICAgY2FzZSAnTW9kJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMubW9kKGdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdNdWwnOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5tdWwoZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ1JlYWxEaXYnOlxuICAgICAgICBjYXNlICdEaXYnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmRpdihnZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdEaXZOb05hbic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuZGl2Tm9OYW4oZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnRmxvb3JEaXYnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmZsb29yRGl2KGdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1N1Yic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuc3ViKGdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ01pbmltdW0nOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLm1pbmltdW0oZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnTWF4aW11bSc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMubWF4aW11bShnZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdQb3cnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnBvdyhnZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdTcXVhcmVkRGlmZmVyZW5jZSc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuc3F1YXJlZERpZmZlcmVuY2UoZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGV4ZWN1dGVPcCQxID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdBYnMnOlxuICAgICAgICBjYXNlICdDb21wbGV4QWJzJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuYWJzKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ0Fjb3MnOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5hY29zKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ0Fjb3NoJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuYWNvc2goZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnQXNpbic6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmFzaW4oZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnQXNpbmgnOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5hc2luaChnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdBdGFuJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuYXRhbihnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdBdGFuMic6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmF0YW4yKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCd5Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdBdGFuaCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmF0YW5oKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ0NlaWwnOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5jZWlsKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ0NvbXBsZXgnOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5jb21wbGV4KGdldFBhcmFtVmFsdWUoJ3JlYWwnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdpbWFnJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdDb3MnOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5jb3MoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnQ29zaCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmNvc2goZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnRWx1JzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuZWx1KGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ0VyZic6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmVyZihnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdFeHAnOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5leHAoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnRXhwbTEnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmV4cG0xKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnRmxvb3InOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5mbG9vcihnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdMb2cnOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5sb2coZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnTG9nMXAnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmxvZzFwKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSW1hZyc6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmltYWcoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnTmVnJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMubmVnKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ1JlY2lwcm9jYWwnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnJlY2lwcm9jYWwoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdSZWFsJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMucmVhbChnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdSZWx1JzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMucmVsdShnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdSb3VuZCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMucm91bmQoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdTZWx1JzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuc2VsdShnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdTaWdtb2lkJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuc2lnbW9pZChnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdTaW4nOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5zaW4oZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnU2lnbic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuc2lnbihnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1NpbmgnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnNpbmgoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdTb2Z0cGx1cyc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuc29mdHBsdXMoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdTcXJ0Jzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5zcXJ0KGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnU3F1YXJlJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5zcXVhcmUoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdUYW5oJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy50YW5oKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnVGFuJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMudGFuKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ0NsaXBCeVZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuY2xpcEJ5VmFsdWUoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2NsaXBWYWx1ZU1pbicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2NsaXBWYWx1ZU1heCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnUmVsdTYnOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5yZWx1NihnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdSc3FydCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnJzcXJ0KGdldFRlbnNvcihub2RlLmlucHV0TmFtZXNbMF0sIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnUHJvZCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnByb2QoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2F4ZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ0xlYWt5UmVsdSc6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmxlYWt5UmVsdShnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnYWxwaGEnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ1ByZWx1JzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMucHJlbHUoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2FscGhhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBhc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZShzaGFwZUEsIHNoYXBlQiwgZXJyb3JNZXNzYWdlUHJlZml4KSB7XG4gICAgaWYgKGVycm9yTWVzc2FnZVByZWZpeCA9PT0gdm9pZCAwKSB7IGVycm9yTWVzc2FnZVByZWZpeCA9ICcnOyB9XG4gICAgdGZPcHMudXRpbC5hc3NlcnQoc2hhcGVzRXF1YWxBbGxvd1VuZGVmaW5lZFNpemUoc2hhcGVBLCBzaGFwZUIpLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvck1lc3NhZ2VQcmVmaXggKyAoXCIgU2hhcGVzIFwiICsgc2hhcGVBICsgXCIgYW5kIFwiICsgc2hhcGVCICsgXCIgbXVzdCBtYXRjaFwiKTsgfSk7XG59XG5mdW5jdGlvbiBzaGFwZXNFcXVhbEFsbG93VW5kZWZpbmVkU2l6ZShuMSwgbjIpIHtcbiAgICBpZiAobjEubGVuZ3RoICE9PSBuMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4xLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChuMVtpXSAhPT0gLTEgJiYgbjJbaV0gIT09IC0xICYmIG4xW2ldICE9PSBuMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIFRoZSBUZW5zb3JBcnJheSBvYmplY3Qga2VlcHMgYW4gYXJyYXkgb2YgVGVuc29ycy4gIEl0XG4gKiBhbGxvd3MgcmVhZGluZyBmcm9tIHRoZSBhcnJheSBhbmQgd3JpdGluZyB0byB0aGUgYXJyYXkuXG4gKi9cbnZhciBUZW5zb3JBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW5zb3JBcnJheShuYW1lLCBkdHlwZSwgbWF4U2l6ZSwgZWxlbWVudFNoYXBlLCBpZGVudGljYWxFbGVtZW50U2hhcGVzLCBkeW5hbWljU2l6ZSwgY2xlYXJBZnRlclJlYWQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5kdHlwZSA9IGR0eXBlO1xuICAgICAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplO1xuICAgICAgICB0aGlzLmVsZW1lbnRTaGFwZSA9IGVsZW1lbnRTaGFwZTtcbiAgICAgICAgdGhpcy5pZGVudGljYWxFbGVtZW50U2hhcGVzID0gaWRlbnRpY2FsRWxlbWVudFNoYXBlcztcbiAgICAgICAgdGhpcy5keW5hbWljU2l6ZSA9IGR5bmFtaWNTaXplO1xuICAgICAgICB0aGlzLmNsZWFyQWZ0ZXJSZWFkID0gY2xlYXJBZnRlclJlYWQ7XG4gICAgICAgIHRoaXMudGVuc29ycyA9IFtdO1xuICAgICAgICB0aGlzLmNsb3NlZF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZFRlbnNvciA9IHRmT3BzLnNjYWxhcigwKTtcbiAgICAgICAgdGZPcHMua2VlcCh0aGlzLmlkVGVuc29yKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbnNvckFycmF5LnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRUZW5zb3IuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZW5zb3JBcnJheS5wcm90b3R5cGUsIFwiY2xvc2VkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZWRfO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHRoZSB0ZW5zb3JzIGFuZCBpZFRlbnNvciBhbmQgbWFyayB0aGUgVGVuc29yeUFycmF5IGFzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBUZW5zb3JBcnJheS5wcm90b3R5cGUuY2xlYXJBbmRDbG9zZSA9IGZ1bmN0aW9uIChrZWVwSWRzKSB7XG4gICAgICAgIHRoaXMudGVuc29ycy5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgICAgIGlmIChrZWVwSWRzID09IG51bGwgfHwgIWtlZXBJZHMuaGFzKHRlbnNvci50ZW5zb3IuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGVuc29yLnRlbnNvci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRlbnNvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jbG9zZWRfID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pZFRlbnNvci5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBUZW5zb3JBcnJheS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVuc29ycy5sZW5ndGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSB2YWx1ZSBhdCBsb2NhdGlvbiBpbmRleCBpbiB0aGUgVGVuc29yQXJyYXkuXG4gICAgICogQHBhcmFtIGluZGV4IE51bWJlciB0aGUgaW5kZXggdG8gcmVhZCBmcm9tLlxuICAgICAqL1xuICAgIFRlbnNvckFycmF5LnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZF8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiICsgdGhpcy5uYW1lICsgXCIgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5zaXplKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIHJlYWQgZnJvbSBpbmRleCBcIiArIGluZGV4ICsgXCIsIGJ1dCBhcnJheSBzaXplIGlzOiBcIiArIHRoaXMuc2l6ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGVuc29yV2l0aFN0YXRlID0gdGhpcy50ZW5zb3JzW2luZGV4XTtcbiAgICAgICAgaWYgKHRlbnNvcldpdGhTdGF0ZS5jbGVhcmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIiArIHRoaXMubmFtZSArIFwiOiBDb3VsZCBub3QgcmVhZCBpbmRleCBcIiArIGluZGV4ICsgXCIgdHdpY2UgYmVjYXVzZSBpdCB3YXMgY2xlYXJlZCBhZnRlciBhIHByZXZpb3VzIHJlYWQgXCIgK1xuICAgICAgICAgICAgICAgIFwiKHBlcmhhcHMgdHJ5IHNldHRpbmcgY2xlYXJfYWZ0ZXJfcmVhZCA9IGZhbHNlPykuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNsZWFyQWZ0ZXJSZWFkKSB7XG4gICAgICAgICAgICB0ZW5zb3JXaXRoU3RhdGUuY2xlYXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGVuc29yV2l0aFN0YXRlLnJlYWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGVuc29yV2l0aFN0YXRlLnRlbnNvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcmVhZCBtdWx0aXBsZSB0ZW5zb3JzIGZyb20gdGhlIHNwZWNpZmllZCBpbmRpY2VzLlxuICAgICAqL1xuICAgIFRlbnNvckFycmF5LnByb3RvdHlwZS5yZWFkTWFueSA9IGZ1bmN0aW9uIChpbmRpY2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBpbmRpY2VzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIF90aGlzLnJlYWQoaW5kZXgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyaXRlIHZhbHVlIGludG8gdGhlIGluZGV4IG9mIHRoZSBUZW5zb3JBcnJheS5cbiAgICAgKiBAcGFyYW0gaW5kZXggbnVtYmVyIHRoZSBpbmRleCB0byB3cml0ZSB0by5cbiAgICAgKiBAcGFyYW0gdGVuc29yXG4gICAgICovXG4gICAgVGVuc29yQXJyYXkucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGluZGV4LCB0ZW5zb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkXykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIgKyB0aGlzLm5hbWUgKyBcIiBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCAhdGhpcy5keW5hbWljU2l6ZSAmJiBpbmRleCA+PSB0aGlzLm1heFNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIHdyaXRlIHRvIGluZGV4IFwiICsgaW5kZXggKyBcIiwgYnV0IGFycmF5IGlzIG5vdCByZXNpemVhYmxlIGFuZCBzaXplIGlzOiBcIiArIHRoaXMubWF4U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSB0aGlzLnRlbnNvcnNbaW5kZXhdIHx8IHt9O1xuICAgICAgICBpZiAodGVuc29yLmR0eXBlICE9PSB0aGlzLmR0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIiArIHRoaXMubmFtZSArIFwiOiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggXCIgKyBpbmRleCArIFwiLFxcbiAgICAgICAgICBiZWNhdXNlIHRoZSB2YWx1ZSBkdHlwZSBpcyBcIiArIHRlbnNvci5kdHlwZSArIFwiLCBidXQgVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIgKyB0aGlzLmR0eXBlICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgc2hhcGUgZm9yIHRoZSBmaXJzdCB0aW1lIHdyaXRlIHRvIHVua25vdyBzaGFwZSB0ZW5zb3IgYXJyYXlcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSgpID09PSAwICYmXG4gICAgICAgICAgICAodGhpcy5lbGVtZW50U2hhcGUgPT0gbnVsbCB8fCB0aGlzLmVsZW1lbnRTaGFwZS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRTaGFwZSA9IHRlbnNvci5zaGFwZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZSh0aGlzLmVsZW1lbnRTaGFwZSwgdGVuc29yLnNoYXBlLCBcIlRlbnNvckFycmF5IFwiICsgdGhpcy5uYW1lICsgXCI6IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCBcIiArIGluZGV4ICsgXCIuXCIpO1xuICAgICAgICBpZiAodC5yZWFkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIiArIHRoaXMubmFtZSArIFwiOiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggXCIgKyBpbmRleCArIFwiLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gcmVhZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQud3JpdHRlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIgKyB0aGlzLm5hbWUgKyBcIjogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4IFwiICsgaW5kZXggKyBcIiwgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHdyaXR0ZW4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHQudGVuc29yID0gdGVuc29yO1xuICAgICAgICB0Zk9wcy5rZWVwKHRlbnNvcik7XG4gICAgICAgIHQud3JpdHRlbiA9IHRydWU7XG4gICAgICAgIHRoaXMudGVuc29yc1tpbmRleF0gPSB0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byB3cml0ZSBtdWx0aXBsZSB0ZW5zb3JzIHRvIHRoZSBzcGVjaWZpZWQgaW5kaWNlcy5cbiAgICAgKi9cbiAgICBUZW5zb3JBcnJheS5wcm90b3R5cGUud3JpdGVNYW55ID0gZnVuY3Rpb24gKGluZGljZXMsIHRlbnNvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoICE9PSB0ZW5zb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIgKyB0aGlzLm5hbWUgKyBcIjogY291bGQgbm90IHdyaXRlIG11bHRpcGxlIHRlbnNvcnMsXCIgK1xuICAgICAgICAgICAgICAgIChcImJlY2F1c2UgdGhlIGluZGV4IHNpemU6IFwiICsgaW5kaWNlcy5sZW5ndGggKyBcIiBpcyBub3QgdGhlIHNhbWUgYXMgdGVuc29ycyBzaXplOiBcIiArIHRlbnNvcnMubGVuZ3RoICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKGksIGluZGV4KSB7IHJldHVybiBfdGhpcy53cml0ZShpLCB0ZW5zb3JzW2luZGV4XSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHNlbGVjdGVkIHZhbHVlcyBpbiB0aGUgVGVuc29yQXJyYXkgYXMgYSBwYWNrZWQgVGVuc29yLiBBbGwgb2ZcbiAgICAgKiBzZWxlY3RlZCB2YWx1ZXMgbXVzdCBoYXZlIGJlZW4gd3JpdHRlbiBhbmQgdGhlaXIgc2hhcGVzIG11c3QgYWxsIG1hdGNoLlxuICAgICAqIEBwYXJhbSBbaW5kaWNlc10gbnVtYmVyW10gT3B0aW9uYWwuIFRha2luZyB2YWx1ZXMgaW4gWzAsIG1heF92YWx1ZSkuIElmIHRoZVxuICAgICAqICAgIFRlbnNvckFycmF5IGlzIG5vdCBkeW5hbWljLCBtYXhfdmFsdWU9c2l6ZSgpLiBJZiBub3Qgc3BlY2lmaWVkIHJldHVybnNcbiAgICAgKiAgICBhbGwgdGVuc29ycyBpbiB0aGUgb3JpZ2luYWwgb3JkZXIuXG4gICAgICogQHBhcmFtIFtkdHlwZV1cbiAgICAgKi9cbiAgICBUZW5zb3JBcnJheS5wcm90b3R5cGUuZ2F0aGVyID0gZnVuY3Rpb24gKGluZGljZXMsIGR0eXBlKSB7XG4gICAgICAgIGlmICghIWR0eXBlICYmIGR0eXBlICE9PSB0aGlzLmR0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBkdHlwZSBpcyBcIiArIHRoaXMuZHR5cGUgKyBcIiBidXQgZ2F0aGVyIHJlcXVlc3RlZCBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluZGljZXMpIHtcbiAgICAgICAgICAgIGluZGljZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGljZXMgPSBpbmRpY2VzLnNsaWNlKDAsIHRoaXMuc2l6ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0Zk9wcy50ZW5zb3IoW10sIFswXS5jb25jYXQodGhpcy5lbGVtZW50U2hhcGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWFkIGFsbCB0aGUgUGVyc2lzdGVudFRlbnNvcnMgaW50byBhIHZlY3RvciB0byBrZWVwIHRyYWNrIG9mXG4gICAgICAgIC8vIHRoZWlyIG1lbW9yeS5cbiAgICAgICAgdmFyIHRlbnNvcnMgPSB0aGlzLnJlYWRNYW55KGluZGljZXMpO1xuICAgICAgICBhc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZSh0aGlzLmVsZW1lbnRTaGFwZSwgdGVuc29yc1swXS5zaGFwZSwgJ1RlbnNvckFycmF5IHNoYXBlIG1pc21hdGNoOiAnKTtcbiAgICAgICAgcmV0dXJuIHRmT3BzLnN0YWNrKHRlbnNvcnMsIDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZXMgaW4gdGhlIFRlbnNvckFycmF5IGFzIGEgY29uY2F0ZW5hdGVkIFRlbnNvci5cbiAgICAgKi9cbiAgICBUZW5zb3JBcnJheS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKGR0eXBlKSB7XG4gICAgICAgIGlmICghIWR0eXBlICYmIGR0eXBlICE9PSB0aGlzLmR0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBkdHlwZSBpcyBcIiArIHRoaXMuZHR5cGUgKyBcIiBidXQgY29uY2F0IHJlcXVlc3RlZCBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0Zk9wcy50ZW5zb3IoW10sIFswXS5jb25jYXQodGhpcy5lbGVtZW50U2hhcGUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb2xsZWN0IGFsbCB0aGUgdGVuc29ycyBmcm9tIHRoZSB0ZW5zb3JzIGFycmF5LlxuICAgICAgICB2YXIgdGVuc29ycyA9IHRoaXMucmVhZE1hbnkoaW5kaWNlcyk7XG4gICAgICAgIGFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKHRoaXMuZWxlbWVudFNoYXBlLCB0ZW5zb3JzWzBdLnNoYXBlLCBcIlRlbnNvckFycmF5IHNoYXBlIG1pc21hdGNoOiB0ZW5zb3IgYXJyYXkgc2hhcGUgKFwiICsgdGhpcy5lbGVtZW50U2hhcGUgKyBcIikgdnMgZmlyc3QgdGVuc29yIHNoYXBlIChcIiArIHRlbnNvcnNbMF0uc2hhcGUgKyBcIilcIik7XG4gICAgICAgIHJldHVybiB0Zk9wcy5jb25jYXQodGVuc29ycywgMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTY2F0dGVyIHRoZSB2YWx1ZXMgb2YgYSBUZW5zb3IgaW4gc3BlY2lmaWMgaW5kaWNlcyBvZiBhIFRlbnNvckFycmF5LlxuICAgICAqIEBwYXJhbSBpbmRpY2VzIG51bW1iZXJbXSB2YWx1ZXMgaW4gWzAsIG1heF92YWx1ZSkuIElmIHRoZVxuICAgICAqICAgIFRlbnNvckFycmF5IGlzIG5vdCBkeW5hbWljLCBtYXhfdmFsdWU9c2l6ZSgpLlxuICAgICAqIEBwYXJhbSB0ZW5zb3IgVGVuc29yIGlucHV0IHRlbnNvci5cbiAgICAgKi9cbiAgICBUZW5zb3JBcnJheS5wcm90b3R5cGUuc2NhdHRlciA9IGZ1bmN0aW9uIChpbmRpY2VzLCB0ZW5zb3IpIHtcbiAgICAgICAgaWYgKHRlbnNvci5kdHlwZSAhPT0gdGhpcy5kdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIgKyB0aGlzLmR0eXBlICsgXCIgYnV0IHRlbnNvciBoYXMgZHR5cGUgXCIgKyB0ZW5zb3IuZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRpY2VzLmxlbmd0aCAhPT0gdGVuc29yLnNoYXBlWzBdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBsZW4oaW5kaWNlcykgPT0gdGVuc29yLnNoYXBlWzBdLCBidXQgc2F3OiBcIiArIGluZGljZXMubGVuZ3RoICsgXCIgdnMuIFwiICsgdGVuc29yLnNoYXBlWzBdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4SW5kZXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfX3NwcmVhZChpbmRpY2VzKSk7XG4gICAgICAgIGlmICghdGhpcy5keW5hbWljU2l6ZSAmJiBtYXhJbmRleCA+PSB0aGlzLm1heFNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1heCBpbmRleCBtdXN0IGJlIDwgYXJyYXkgc2l6ZSAoXCIgKyBtYXhJbmRleCArIFwiICB2cy4gXCIgKyB0aGlzLm1heFNpemUgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZU1hbnkoaW5kaWNlcywgdGZPcHMudW5zdGFjayh0ZW5zb3IsIDApKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNwbGl0IHRoZSB2YWx1ZXMgb2YgYSBUZW5zb3IgaW50byB0aGUgVGVuc29yQXJyYXkuXG4gICAgICogQHBhcmFtIGxlbmd0aCBudW1iZXJbXSB3aXRoIHRoZSBsZW5ndGhzIHRvIHVzZSB3aGVuIHNwbGl0dGluZyB2YWx1ZSBhbG9uZ1xuICAgICAqICAgIGl0cyBmaXJzdCBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIHRlbnNvciBUZW5zb3IsIHRoZSB0ZW5zb3IgdG8gc3BsaXQuXG4gICAgICovXG4gICAgVGVuc29yQXJyYXkucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKGxlbmd0aCwgdGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0ZW5zb3IuZHR5cGUgIT09IHRoaXMuZHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IGR0eXBlIGlzIFwiICsgdGhpcy5kdHlwZSArIFwiIGJ1dCB0ZW5zb3IgaGFzIGR0eXBlIFwiICsgdGVuc29yLmR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG90YWxMZW5ndGggPSAwO1xuICAgICAgICB2YXIgY3VtdWxhdGl2ZUxlbmd0aHMgPSBsZW5ndGgubWFwKGZ1bmN0aW9uIChsZW4pIHtcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGxlbjtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbExlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0b3RhbExlbmd0aCAhPT0gdGVuc29yLnNoYXBlWzBdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzdW0gb2YgbGVuZ3RocyB0byBiZSBlcXVhbCB0b1xcbiAgICAgICAgICB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzdW0gb2YgbGVuZ3RocyBpc1xcbiAgICAgICAgXCIgKyB0b3RhbExlbmd0aCArIFwiLCBhbmQgdGVuc29yJ3Mgc2hhcGUgaXM6IFwiICsgdGVuc29yLnNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZHluYW1pY1NpemUgJiYgbGVuZ3RoLmxlbmd0aCAhPT0gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSdzIHNpemUgaXMgbm90IGVxdWFsIHRvIHRoZSBzaXplIG9mIGxlbmd0aHMgKFwiICsgdGhpcy5tYXhTaXplICsgXCIgdnMuIFwiICsgbGVuZ3RoLmxlbmd0aCArIFwiKSwgXCIgK1xuICAgICAgICAgICAgICAgICdhbmQgdGhlIFRlbnNvckFycmF5IGlzIG5vdCBtYXJrZWQgYXMgZHluYW1pY2FsbHkgcmVzaXplYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50UGVyUm93ID0gdG90YWxMZW5ndGggPT09IDAgPyAwIDogdGVuc29yLnNpemUgLyB0b3RhbExlbmd0aDtcbiAgICAgICAgdmFyIHRlbnNvcnMgPSBbXTtcbiAgICAgICAgdGZPcHMudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0ZW5zb3IgPSB0Zk9wcy5yZXNoYXBlKHRlbnNvciwgWzEsIHRvdGFsTGVuZ3RoLCBlbGVtZW50UGVyUm93XSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0xlbmd0aCA9IChpID09PSAwKSA/IDAgOiBjdW11bGF0aXZlTGVuZ3Roc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXNfMSA9IFswLCBwcmV2aW91c0xlbmd0aCwgMF07XG4gICAgICAgICAgICAgICAgdmFyIHNpemVzID0gWzEsIGxlbmd0aFtpXSwgZWxlbWVudFBlclJvd107XG4gICAgICAgICAgICAgICAgdGVuc29yc1tpXSA9IHRmT3BzLnJlc2hhcGUodGZPcHMuc2xpY2UodGVuc29yLCBpbmRpY2VzXzEsIHNpemVzKSwgX3RoaXMuZWxlbWVudFNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JzO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGluZGljZXNbaV0gPSBpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVNYW55KGluZGljZXMsIHRlbnNvcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbnNvckFycmF5O1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBUZW5zb3JMaXN0IHN0b3JlcyBhIGNvbnRhaW5lciBvZiBgdGYuVGVuc29yYCBvYmplY3RzLCB3aGljaCBhcmUgYWNjZXNzaWJsZVxuICogdmlhIHRlbnNvcnMgZmllbGQuXG4gKlxuICogSW4gb3JkZXIgdG8gZ2V0IGEgY29weSBvZiB0aGUgdW5kZXJseWluZyBsaXN0LCB1c2UgdGhlIGNvcHkgbWV0aG9kOlxuICogYGBgXG4gKiAgICBUZW5zb3JMaXN0IGIgPSBhLmNvcHkoKTtcbiAqICAgIGIudGVuc29ycygpLnB1c2hCYWNrKHQpOyAgLy8gVGhpcyBkb2VzIG5vdCBtb2RpZnkgYS50ZW5zb3JzKCkuXG4gKiBgYGBcbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBpcyBub3QgYSBkZWVwIGNvcHk6IHRoZSBtZW1vcnkgbG9jYXRpb25zIG9mIHRoZSB1bmRlcmx5aW5nXG4gKiB0ZW5zb3JzIHdpbGwgc3RpbGwgcG9pbnQgdG8gdGhlIHNhbWUgbG9jYXRpb25zIG9mIHRoZSBjb3JyZXNwb25kaW5nIHRlbnNvcnNcbiAqIGluIHRoZSBvcmlnaW5hbC5cbiAqL1xudmFyIFRlbnNvckxpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVuc29ycyBsaXN0IG9mIHRlbnNvcnNcbiAgICAgKiBAcGFyYW0gZWxlbWVudFNoYXBlIHNoYXBlIG9mIGVhY2ggdGVuc29yXG4gICAgICogQHBhcmFtIGVsZW1lbnREdHlwZSBkYXRhIHR5cGUgb2YgZWFjaCB0ZW5zb3JcbiAgICAgKiBAcGFyYW0gbWF4TnVtRWxlbWVudHMgVGhlIG1heGltdW0gYWxsb3dlZCBzaXplIG9mIGB0ZW5zb3JzYC4gRGVmYXVsdHMgdG8gLTFcbiAgICAgKiAgIG1lYW5pbmcgdGhhdCB0aGUgc2l6ZSBvZiBgdGVuc29yc2AgaXMgdW5ib3VuZGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbnNvckxpc3QodGVuc29ycywgZWxlbWVudFNoYXBlLCBlbGVtZW50RHR5cGUsIG1heE51bUVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChtYXhOdW1FbGVtZW50cyA9PT0gdm9pZCAwKSB7IG1heE51bUVsZW1lbnRzID0gLTE7IH1cbiAgICAgICAgdGhpcy50ZW5zb3JzID0gdGVuc29ycztcbiAgICAgICAgdGhpcy5lbGVtZW50U2hhcGUgPSBlbGVtZW50U2hhcGU7XG4gICAgICAgIHRoaXMuZWxlbWVudER0eXBlID0gZWxlbWVudER0eXBlO1xuICAgICAgICBpZiAodGVuc29ycyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0ZW5zb3JzLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50RHR5cGUgIT09IHRlbnNvci5kdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzIFwiICsgZWxlbWVudER0eXBlICsgXCIsIGJ1dCBsaXN0IGVsZW1lbnRzIFwiICsgdGVuc29yLmR0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUoZWxlbWVudFNoYXBlLCB0ZW5zb3Iuc2hhcGUsICdUZW5zb3JMaXN0IHNoYXBlIG1pc21hdGNoOiAnKTtcbiAgICAgICAgICAgICAgICB0Zk9wcy5rZWVwKHRlbnNvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkVGVuc29yID0gdGZPcHMuc2NhbGFyKDApO1xuICAgICAgICB0aGlzLm1heE51bUVsZW1lbnRzID0gbWF4TnVtRWxlbWVudHM7XG4gICAgICAgIHRmT3BzLmtlZXAodGhpcy5pZFRlbnNvcik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZW5zb3JMaXN0LnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRUZW5zb3IuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEdldCBhIG5ldyBUZW5zb3JMaXN0IGNvbnRhaW5pbmcgYSBjb3B5IG9mIHRoZSB1bmRlcmx5aW5nIHRlbnNvciBjb250YWluZXIuXG4gICAgICovXG4gICAgVGVuc29yTGlzdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3JMaXN0KF9fc3ByZWFkKHRoaXMudGVuc29ycyksIHRoaXMuZWxlbWVudFNoYXBlLCB0aGlzLmVsZW1lbnREdHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHRoZSB0ZW5zb3JzIGFuZCBpZFRlbnNvciBhbmQgY2xlYXIgdGhlIHRlbnNvciBsaXN0LlxuICAgICAqL1xuICAgIFRlbnNvckxpc3QucHJvdG90eXBlLmNsZWFyQW5kQ2xvc2UgPSBmdW5jdGlvbiAoa2VlcElkcykge1xuICAgICAgICB0aGlzLnRlbnNvcnMuZm9yRWFjaChmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgICAgICBpZiAoa2VlcElkcyA9PSBudWxsIHx8ICFrZWVwSWRzLmhhcyh0ZW5zb3IuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGVuc29yLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGVuc29ycy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmlkVGVuc29yLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSB0ZW5zb3JzIGluIHRoZSB0ZW5zb3IgbGlzdC5cbiAgICAgKi9cbiAgICBUZW5zb3JMaXN0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZW5zb3JzLmxlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHRlbnNvciB0aGF0IHN0YWNrcyBhIGxpc3Qgb2YgcmFuay1SIHRmLlRlbnNvcnMgaW50byBvbmUgcmFuay0oUisxKVxuICAgICAqIHRmLlRlbnNvci5cbiAgICAgKiBAcGFyYW0gZWxlbWVudFNoYXBlIHNoYXBlIG9mIGVhY2ggdGVuc29yXG4gICAgICogQHBhcmFtIGVsZW1lbnREdHlwZSBkYXRhIHR5cGUgb2YgZWFjaCB0ZW5zb3JcbiAgICAgKiBAcGFyYW0gbnVtRWxlbWVudHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzdGFja1xuICAgICAqL1xuICAgIFRlbnNvckxpc3QucHJvdG90eXBlLnN0YWNrID0gZnVuY3Rpb24gKGVsZW1lbnRTaGFwZSwgZWxlbWVudER0eXBlLCBudW1FbGVtZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobnVtRWxlbWVudHMgPT09IHZvaWQgMCkgeyBudW1FbGVtZW50cyA9IC0xOyB9XG4gICAgICAgIGlmIChlbGVtZW50RHR5cGUgIT09IHRoaXMuZWxlbWVudER0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzIFwiICsgZWxlbWVudER0eXBlICsgXCIsIGJ1dCBsaXN0IGVsZW1lbnRzIFwiICsgdGhpcy5lbGVtZW50RHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1FbGVtZW50cyAhPT0gLTEgJiYgdGhpcy50ZW5zb3JzLmxlbmd0aCAhPT0gbnVtRWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wZXJhdGlvbiBleHBlY3RlZCBhIGxpc3Qgd2l0aCBcIiArIG51bUVsZW1lbnRzICsgXCIgZWxlbWVudHMgYnV0IGdvdCBhIGxpc3Qgd2l0aCBcIiArIHRoaXMudGVuc29ycy5sZW5ndGggKyBcIiBlbGVtZW50cy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUoZWxlbWVudFNoYXBlLCB0aGlzLmVsZW1lbnRTaGFwZSwgJ1RlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6ICcpO1xuICAgICAgICByZXR1cm4gdGZPcHMudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzaGFwZWRUZW5zb3JzID0gX3RoaXMudGVuc29ycy5tYXAoZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGZPcHMucmVzaGFwZSh0ZW5zb3IsIGVsZW1lbnRTaGFwZSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRmT3BzLnN0YWNrKHJlc2hhcGVkVGVuc29ycywgMCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUG9wIGEgdGVuc29yIGZyb20gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgKiBAcGFyYW0gZWxlbWVudFNoYXBlIHNoYXBlIG9mIHRoZSB0ZW5zb3JcbiAgICAgKiBAcGFyYW0gZWxlbWVudER0eXBlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yXG4gICAgICovXG4gICAgVGVuc29yTGlzdC5wcm90b3R5cGUucG9wQmFjayA9IGZ1bmN0aW9uIChlbGVtZW50U2hhcGUsIGVsZW1lbnREdHlwZSkge1xuICAgICAgICBpZiAoZWxlbWVudER0eXBlICE9PSB0aGlzLmVsZW1lbnREdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVzOyBvcCBlbGVtZW50cyBcIiArIGVsZW1lbnREdHlwZSArIFwiLCBidXQgbGlzdCBlbGVtZW50cyBcIiArIHRoaXMuZWxlbWVudER0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHBvcCBmcm9tIGFuIGVtcHR5IGxpc3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlbnNvciA9IHRoaXMudGVuc29ycy5wb3AoKTtcbiAgICAgICAgYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUodGVuc29yLnNoYXBlLCBlbGVtZW50U2hhcGUsICdUZW5zb3JMaXN0IHNoYXBlIG1pc21hdGNoOiAnKTtcbiAgICAgICAgcmV0dXJuIHRmT3BzLnJlc2hhcGUodGVuc29yLCBlbGVtZW50U2hhcGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaCBhIHRlbnNvciB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB0ZW5zb3IgVGVuc29yIHRvIGJlIHB1c2hlZC5cbiAgICAgKi9cbiAgICBUZW5zb3JMaXN0LnByb3RvdHlwZS5wdXNoQmFjayA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgaWYgKHRlbnNvci5kdHlwZSAhPT0gdGhpcy5lbGVtZW50RHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgXCIgKyB0ZW5zb3IuZHR5cGUgKyBcIiwgYnV0IGxpc3QgZWxlbWVudHMgXCIgKyB0aGlzLmVsZW1lbnREdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUodGVuc29yLnNoYXBlLCB0aGlzLmVsZW1lbnRTaGFwZSwgJ1RlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6ICcpO1xuICAgICAgICBpZiAodGhpcy5tYXhOdW1FbGVtZW50cyA9PT0gdGhpcy5zaXplKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byBwdXNoIGVsZW1lbnQgaW50byBhIGZ1bGwgbGlzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGZPcHMua2VlcCh0ZW5zb3IpO1xuICAgICAgICB0aGlzLnRlbnNvcnMucHVzaCh0ZW5zb3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzaXplIG9mIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSBzaXplIHRoZSBuZXcgc2l6ZSBvZiB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBUZW5zb3JMaXN0LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvckxpc3RSZXNpemUgZXhwZWN0cyBzaXplIHRvIGJlIG5vbi1uZWdhdGl2ZS4gR290OiBcIiArIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1heE51bUVsZW1lbnRzICE9PSAtMSAmJiBzaXplID4gdGhpcy5tYXhOdW1FbGVtZW50cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yTGlzdFJlc2l6ZSBpbnB1dCBzaXplIFwiICsgc2l6ZSArIFwiIGlzIGdyZWF0ZXIgbWF4TnVtRWxlbWVudCBcIiArIHRoaXMubWF4TnVtRWxlbWVudHMgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW5zb3JzLmxlbmd0aCA9IHNpemU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXhcbiAgICAgKiBAcGFyYW0gZWxlbWVudFNoYXBlIHNoYXBlIG9mIHRoZSB0ZW5zb3JcbiAgICAgKiBAcGFyYW0gZWxlbWVudER0eXBlIGR0eXBlIG9mIHRoZSB0ZW5zb3JcbiAgICAgKiBAcGFyYW0gZWxlbWVudEluZGV4IGluZGV4IG9mIHRoZSB0ZW5zb3JcbiAgICAgKi9cbiAgICBUZW5zb3JMaXN0LnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gKGVsZW1lbnRJbmRleCwgZWxlbWVudFNoYXBlLCBlbGVtZW50RHR5cGUpIHtcbiAgICAgICAgaWYgKGVsZW1lbnREdHlwZSAhPT0gdGhpcy5lbGVtZW50RHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgXCIgKyBlbGVtZW50RHR5cGUgKyBcIiwgYnV0IGxpc3QgZWxlbWVudHMgXCIgKyB0aGlzLmVsZW1lbnREdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRJbmRleCA8IDAgfHwgZWxlbWVudEluZGV4ID4gdGhpcy50ZW5zb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBlbGVtZW50IFwiICsgZWxlbWVudEluZGV4ICsgXCIgaW4gYSBsaXN0IHdpdGggXCIgKyB0aGlzLnRlbnNvcnMubGVuZ3RoICsgXCIgZWxlbWVudHMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRlbnNvcnNbZWxlbWVudEluZGV4XSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbGVtZW50IGF0IGluZGV4IFwiICsgZWxlbWVudEluZGV4ICsgXCIgaXMgbnVsbC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUodGhpcy50ZW5zb3JzW2VsZW1lbnRJbmRleF0uc2hhcGUsIGVsZW1lbnRTaGFwZSwgJ1RlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6ICcpO1xuICAgICAgICByZXR1cm4gdGhpcy50ZW5zb3JzW2VsZW1lbnRJbmRleF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRlbnNvciBhdCB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0gZWxlbWVudEluZGV4IGluZGV4IG9mIHRoZSB0ZW5zb3JcbiAgICAgKiBAcGFyYW0gdGVuc29yIHRoZSB0ZW5zb3IgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgbGlzdFxuICAgICAqL1xuICAgIFRlbnNvckxpc3QucHJvdG90eXBlLnNldEl0ZW0gPSBmdW5jdGlvbiAoZWxlbWVudEluZGV4LCB0ZW5zb3IpIHtcbiAgICAgICAgaWYgKHRlbnNvci5kdHlwZSAhPT0gdGhpcy5lbGVtZW50RHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgXCIgKyB0ZW5zb3IuZHR5cGUgKyBcIiwgYnV0IGxpc3QgZWxlbWVudHMgXCIgKyB0aGlzLmVsZW1lbnREdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRJbmRleCA8IDAgfHxcbiAgICAgICAgICAgIHRoaXMubWF4TnVtRWxlbWVudHMgIT09IC0xICYmIGVsZW1lbnRJbmRleCA+PSB0aGlzLm1heE51bUVsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gc2V0IGVsZW1lbnQgXCIgKyBlbGVtZW50SW5kZXggKyBcIiBpbiBhIGxpc3Qgd2l0aCBtYXggXCIgKyB0aGlzLm1heE51bUVsZW1lbnRzICsgXCIgZWxlbWVudHMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKHRoaXMuZWxlbWVudFNoYXBlLCB0ZW5zb3Iuc2hhcGUsICdUZW5zb3JMaXN0IHNoYXBlIG1pc21hdGNoOiAnKTtcbiAgICAgICAgdGZPcHMua2VlcCh0ZW5zb3IpO1xuICAgICAgICB0aGlzLnRlbnNvcnNbZWxlbWVudEluZGV4XSA9IHRlbnNvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBzZWxlY3RlZCB2YWx1ZXMgaW4gdGhlIFRlbnNvckxpc3QgYXMgYSBzdGFja2VkIFRlbnNvci4gQWxsIG9mXG4gICAgICogc2VsZWN0ZWQgdmFsdWVzIG11c3QgaGF2ZSBiZWVuIHdyaXR0ZW4gYW5kIHRoZWlyIHNoYXBlcyBtdXN0IGFsbCBtYXRjaC5cbiAgICAgKiBAcGFyYW0gaW5kaWNlcyBpbmRpY2VzIG9mIHRlbnNvcnMgdG8gZ2F0aGVyXG4gICAgICogQHBhcmFtIGVsZW1lbnREdHlwZSBvdXRwdXQgdGVuc29yIGR0eXBlXG4gICAgICogQHBhcmFtIGVsZW1lbnRTaGFwZSBvdXRwdXQgdGVuc29yIGVsZW1lbnQgc2hhcGVcbiAgICAgKi9cbiAgICBUZW5zb3JMaXN0LnByb3RvdHlwZS5nYXRoZXIgPSBmdW5jdGlvbiAoaW5kaWNlcywgZWxlbWVudER0eXBlLCBlbGVtZW50U2hhcGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGVsZW1lbnREdHlwZSAhPT0gdGhpcy5lbGVtZW50RHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgXCIgKyBlbGVtZW50RHR5cGUgKyBcIiwgYnV0IGxpc3QgZWxlbWVudHMgXCIgKyB0aGlzLmVsZW1lbnREdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUodGhpcy5lbGVtZW50U2hhcGUsIGVsZW1lbnRTaGFwZSwgJ1RlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6ICcpO1xuICAgICAgICAvLyBXaGVuIGluZGljZXMgaXMgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBsaXN0LCBpbmRpY2VzIGJleW9uZCB0aGVcbiAgICAgICAgLy8gc2l6ZSBvZiB0aGUgbGlzdCBhcmUgaWdub3JlZC5cbiAgICAgICAgaW5kaWNlcyA9IGluZGljZXMuc2xpY2UoMCwgdGhpcy5zaXplKCkpO1xuICAgICAgICBpZiAoaW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0Zk9wcy50ZW5zb3IoW10sIFswXS5jb25jYXQodGhpcy5lbGVtZW50U2hhcGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGZPcHMudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGVuc29ycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiB0Zk9wcy5yZXNoYXBlKF90aGlzLnRlbnNvcnNbaV0sIGVsZW1lbnRTaGFwZSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRmT3BzLnN0YWNrKHRlbnNvcnMsIDApO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWVzIGluIHRoZSBUZW5zb3JMaXN0IGFzIGEgY29uY2F0ZW5hdGVkIFRlbnNvci5cbiAgICAgKiBAcGFyYW0gZWxlbWVudER0eXBlIG91dHB1dCB0ZW5zb3IgZHR5cGVcbiAgICAgKiBAcGFyYW0gZWxlbWVudFNoYXBlIG91dHB1dCB0ZW5zb3IgZWxlbWVudCBzaGFwZVxuICAgICAqL1xuICAgIFRlbnNvckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChlbGVtZW50RHR5cGUsIGVsZW1lbnRTaGFwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoISFlbGVtZW50RHR5cGUgJiYgZWxlbWVudER0eXBlICE9PSB0aGlzLmVsZW1lbnREdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yTGlzdCBkdHlwZSBpcyBcIiArIHRoaXMuZWxlbWVudER0eXBlICsgXCIgYnV0IGNvbmNhdCByZXF1ZXN0ZWQgZHR5cGUgXCIgKyBlbGVtZW50RHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKHRoaXMuZWxlbWVudFNoYXBlLCBlbGVtZW50U2hhcGUsICdUZW5zb3JMaXN0IHNoYXBlIG1pc21hdGNoOiAnKTtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGZPcHMudGVuc29yKFtdLCBbMF0uY29uY2F0KHRoaXMuZWxlbWVudFNoYXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRmT3BzLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRlbnNvcnMgPSBfdGhpcy50ZW5zb3JzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdGZPcHMucmVzaGFwZSh0LCBlbGVtZW50U2hhcGUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiB0Zk9wcy5jb25jYXQodGVuc29ycywgMCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbnNvckxpc3Q7XG59KCkpO1xuLyoqXG4gKiBDcmVhdGVzIGEgVGVuc29yTGlzdCB3aGljaCwgd2hlbiBzdGFja2VkLCBoYXMgdGhlIHZhbHVlIG9mIHRlbnNvci5cbiAqIEBwYXJhbSB0ZW5zb3IgZnJvbSB0ZW5zb3JcbiAqIEBwYXJhbSBlbGVtZW50U2hhcGUgb3V0cHV0IHRlbnNvciBlbGVtZW50IHNoYXBlXG4gKi9cbmZ1bmN0aW9uIGZyb21UZW5zb3IodGVuc29yLCBlbGVtZW50U2hhcGUsIGVsZW1lbnREdHlwZSkge1xuICAgIHZhciBkdHlwZSA9IHRlbnNvci5kdHlwZTtcbiAgICBpZiAodGVuc29yLnNoYXBlLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIG11c3QgYmUgYXQgbGVhc3QgYSB2ZWN0b3IsIGJ1dCBzYXcgc2hhcGU6IFwiICsgdGVuc29yLnNoYXBlKTtcbiAgICB9XG4gICAgaWYgKHRlbnNvci5kdHlwZSAhPT0gZWxlbWVudER0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgXCIgKyB0ZW5zb3IuZHR5cGUgKyBcIiwgYnV0IGxpc3QgZWxlbWVudHMgXCIgKyBlbGVtZW50RHR5cGUpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0U2hhcGUgPSB0ZW5zb3Iuc2hhcGUuc2xpY2UoMSk7XG4gICAgYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUob3V0cHV0U2hhcGUsIGVsZW1lbnRTaGFwZSwgJ1RlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6ICcpO1xuICAgIHZhciB0ZW5zb3JMaXN0ID0gdGZPcHMudW5zdGFjayh0ZW5zb3IpO1xuICAgIHJldHVybiBuZXcgVGVuc29yTGlzdCh0ZW5zb3JMaXN0LCBlbGVtZW50U2hhcGUsIGR0eXBlKTtcbn1cbi8qKlxuICogUmV0dXJuIGEgVGVuc29yTGlzdCBvZiB0aGUgZ2l2ZW4gc2l6ZSB3aXRoIGVtcHR5IGVsZW1lbnRzLlxuICogQHBhcmFtIGVsZW1lbnRTaGFwZSB0aGUgc2hhcGUgb2YgdGhlIGZ1dHVyZSBlbGVtZW50cyBvZiB0aGUgbGlzdFxuICogQHBhcmFtIGVsZW1lbnREdHlwZSB0aGUgZGVzaXJlZCB0eXBlIG9mIGVsZW1lbnRzIGluIHRoZSBsaXN0XG4gKiBAcGFyYW0gbnVtRWxlbWVudHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXNlcnZlXG4gKi9cbmZ1bmN0aW9uIHJlc2VydmUoZWxlbWVudFNoYXBlLCBlbGVtZW50RHR5cGUsIG51bUVsZW1lbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBUZW5zb3JMaXN0KFtdLCBlbGVtZW50U2hhcGUsIGVsZW1lbnREdHlwZSwgbnVtRWxlbWVudHMpO1xufVxuLyoqXG4gKiBQdXQgdGVuc29ycyBhdCBzcGVjaWZpYyBpbmRpY2VzIG9mIGEgc3RhY2tlZCB0ZW5zb3IgaW50byBhIFRlbnNvckxpc3QuXG4gKiBAcGFyYW0gaW5kaWNlcyBsaXN0IG9mIGluZGljZXMgb24gaG93IHRvIHNjYXR0ZXIgdGhlIHRlbnNvci5cbiAqIEBwYXJhbSB0ZW5zb3IgaW5wdXQgdGVuc29yLlxuICogQHBhcmFtIGVsZW1lbnRTaGFwZSB0aGUgc2hhcGUgb2YgdGhlIGZ1dHVyZSBlbGVtZW50cyBvZiB0aGUgbGlzdFxuICogQHBhcmFtIG51bUVsZW1lbnRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2NhdHRlclxuICovXG5mdW5jdGlvbiBzY2F0dGVyKHRlbnNvciwgaW5kaWNlcywgZWxlbWVudFNoYXBlLCBudW1FbGVtZW50cykge1xuICAgIGlmIChpbmRpY2VzLmxlbmd0aCAhPT0gdGVuc29yLnNoYXBlWzBdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGxlbihpbmRpY2VzKSA9PSB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzYXc6IFwiICsgaW5kaWNlcy5sZW5ndGggKyBcIiB2cy4gXCIgKyB0ZW5zb3Iuc2hhcGVbMF0pO1xuICAgIH1cbiAgICB2YXIgbWF4SW5kZXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfX3NwcmVhZChpbmRpY2VzKSk7XG4gICAgaWYgKG51bUVsZW1lbnRzICE9IG51bGwgJiYgbnVtRWxlbWVudHMgIT09IC0xICYmIG1heEluZGV4ID49IG51bUVsZW1lbnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1heCBpbmRleCBtdXN0IGJlIDwgYXJyYXkgc2l6ZSAoXCIgKyBtYXhJbmRleCArIFwiICB2cy4gXCIgKyBudW1FbGVtZW50cyArIFwiKVwiKTtcbiAgICB9XG4gICAgdmFyIGxpc3QgPSBuZXcgVGVuc29yTGlzdChbXSwgZWxlbWVudFNoYXBlLCB0ZW5zb3IuZHR5cGUsIG51bUVsZW1lbnRzKTtcbiAgICB2YXIgdGVuc29ycyA9IHRmT3BzLnVuc3RhY2sodGVuc29yLCAwKTtcbiAgICBpbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICBsaXN0LnNldEl0ZW0odmFsdWUsIHRlbnNvcnNbaW5kZXhdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogU3BsaXQgdGhlIHZhbHVlcyBvZiBhIFRlbnNvciBpbnRvIGEgVGVuc29yTGlzdC5cbiAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aHMgdG8gdXNlIHdoZW4gc3BsaXR0aW5nIHZhbHVlIGFsb25nXG4gKiAgICBpdHMgZmlyc3QgZGltZW5zaW9uLlxuICogQHBhcmFtIHRlbnNvciB0aGUgdGVuc29yIHRvIHNwbGl0LlxuICogQHBhcmFtIGVsZW1lbnRTaGFwZSB0aGUgc2hhcGUgb2YgdGhlIGZ1dHVyZSBlbGVtZW50cyBvZiB0aGUgbGlzdFxuICovXG5mdW5jdGlvbiBzcGxpdCh0ZW5zb3IsIGxlbmd0aCwgZWxlbWVudFNoYXBlKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gMDtcbiAgICB2YXIgY3VtdWxhdGl2ZUxlbmd0aHMgPSBsZW5ndGgubWFwKGZ1bmN0aW9uIChsZW4pIHtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gbGVuO1xuICAgICAgICByZXR1cm4gdG90YWxMZW5ndGg7XG4gICAgfSk7XG4gICAgaWYgKHRvdGFsTGVuZ3RoICE9PSB0ZW5zb3Iuc2hhcGVbMF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3VtIG9mIGxlbmd0aHMgdG8gYmUgZXF1YWwgdG9cXG4gICAgICAgICAgdGVuc29yLnNoYXBlWzBdLCBidXQgc3VtIG9mIGxlbmd0aHMgaXNcXG4gICAgICAgIFwiICsgdG90YWxMZW5ndGggKyBcIiwgYW5kIHRlbnNvcidzIHNoYXBlIGlzOiBcIiArIHRlbnNvci5zaGFwZSk7XG4gICAgfVxuICAgIHZhciBlbGVtZW50UGVyUm93ID0gdG90YWxMZW5ndGggPT09IDAgPyAwIDogdGVuc29yLnNpemUgLyB0b3RhbExlbmd0aDtcbiAgICB2YXIgdGVuc29ycyA9IHRmT3BzLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGVuc29ycyA9IFtdO1xuICAgICAgICB0ZW5zb3IgPSB0Zk9wcy5yZXNoYXBlKHRlbnNvciwgWzEsIHRvdGFsTGVuZ3RoLCBlbGVtZW50UGVyUm93XSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNMZW5ndGggPSAoaSA9PT0gMCkgPyAwIDogY3VtdWxhdGl2ZUxlbmd0aHNbaSAtIDFdO1xuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbMCwgcHJldmlvdXNMZW5ndGgsIDBdO1xuICAgICAgICAgICAgdmFyIHNpemVzID0gWzEsIGxlbmd0aFtpXSwgZWxlbWVudFBlclJvd107XG4gICAgICAgICAgICB0ZW5zb3JzW2ldID0gdGZPcHMucmVzaGFwZSh0Zk9wcy5zbGljZSh0ZW5zb3IsIGluZGljZXMsIHNpemVzKSwgZWxlbWVudFNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW5zb3IuZGlzcG9zZSgpO1xuICAgICAgICByZXR1cm4gdGVuc29ycztcbiAgICB9KTtcbiAgICB2YXIgbGlzdCA9IG5ldyBUZW5zb3JMaXN0KFtdLCBlbGVtZW50U2hhcGUsIHRlbnNvci5kdHlwZSwgbGVuZ3RoLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW5zb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3Quc2V0SXRlbShpLCB0ZW5zb3JzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBfdGhpcyA9IHVuZGVmaW5lZDtcbnZhciBleGVjdXRlT3AkMiA9IGZ1bmN0aW9uIChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EsIHRoZW5GdW5jLCBlbHNlRnVuYywgY29uZCwgYXJncywgY29uZFZhbHVlLCBib2R5RnVuYywgY29uZEZ1bmMsIGFyZ3MsIGNvbmRSZXN1bHQsIGFyZ0lkc18xLCBjb25kVmFsdWUsIHJlc3VsdCwgX2xvb3BfMSwgcHJlZCwgcHJlZCwgZGF0YSwgaW5wdXROYW1lLCBkYXRhLCBmcmFtZUlkLCBkYXRhLCBkYXRhLCBkYXRhLCBzaXplLCBkdHlwZSwgZWxlbWVudFNoYXBlLCBkeW5hbWljU2l6ZSwgY2xlYXJBZnRlclJlYWQsIGlkZW50aWNhbEVsZW1lbnRTaGFwZXMsIG5hbWVfMSwgdGVuc29yQXJyYXksIGlkLCBpbmRleCwgd3JpdGVUZW5zb3IsIHdyaXRlVGVuc29yQXJyYXksIHJlYWRJZCwgcmVhZEluZGV4LCByZWFkVGVuc29yQXJyYXksIGdhdGhlcklkLCBnYXRoZXJJbmRpY2VzLCBnYXRoZXJEdHlwZSwgZ2F0aGVyVGVuc29yQXJyYXksIHNjYXR0ZXJJZCwgc2NhdHRlckluZGljZXMsIHNjYXR0ZXJUZW5zb3IsIHNjYXR0ZXJUZW5zb3JBcnJheSwgY29uY2F0SWQsIGNvbmNhdFRlbnNvckFycmF5LCBjb25jYXREdHlwZSwgc3BsaXRJZCwgc3BsaXRUZW5zb3IsIGxlbmd0aHMsIHNwbGl0VGVuc29yQXJyYXksIHNpemVJZCwgc2l6ZVRlbnNvckFycmF5LCBjbG9zZUlkLCBjbG9zZVRlbnNvckFycmF5LCBpZFRlbnNvciwgaW5kZXgsIHdyaXRlVGVuc29yLCB0ZW5zb3JMaXN0LCBpZFRlbnNvciwgcmVhZEluZGV4LCBlbGVtZW50U2hhcGUsIGVsZW1lbnREVHlwZSwgdGVuc29yTGlzdCwgc2NhdHRlckluZGljZXMsIHNjYXR0ZXJUZW5zb3IsIGVsZW1lbnRTaGFwZSwgbnVtRWxlbWVudHMsIHRlbnNvckxpc3QsIGVsZW1lbnRTaGFwZSwgZWxlbWVudER0eXBlLCBudW1FbGVtZW50c1BhcmFtLCBudW1FbGVtZW50cywgdGVuc29yTGlzdCwgZ2F0aGVySWQsIGdhdGhlckluZGljZXMsIGVsZW1lbnRTaGFwZSwgZWxlbWVudER0eXBlLCB0ZW5zb3JMaXN0LCBpZFRlbnNvciwgZWxlbWVudFNoYXBlLCBlbGVtZW50RHR5cGUsIG51bUVsZW1lbnRzLCB0ZW5zb3JMaXN0LCB0ZW5zb3IsIGVsZW1lbnRTaGFwZSwgZWxlbWVudER0eXBlLCB0ZW5zb3JMaXN0LCBjb25jYXRJZCwgdGVuc29yTGlzdCwgY29uY2F0RHR5cGUsIGVsZW1lbnRTaGFwZSwgaWRUZW5zb3IsIHdyaXRlVGVuc29yLCB0ZW5zb3JMaXN0LCBpZFRlbnNvciwgZWxlbWVudFNoYXBlLCBlbGVtZW50RFR5cGUsIHRlbnNvckxpc3QsIHNwbGl0VGVuc29yLCBlbGVtZW50U2hhcGUsIGxlbmd0aHMsIHRlbnNvckxpc3Q7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2EgPSBub2RlLm9wO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSWYnOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU3RhdGVsZXNzSWYnOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnV2hpbGUnOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU3RhdGVsZXNzV2hpbGUnOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTG9vcENvbmQnOiByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU3dpdGNoJzogcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNZXJnZSc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRW50ZXInOiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0V4aXQnOiByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05leHRJdGVyYXRpb24nOiByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckFycmF5VjMnOiByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckFycmF5V3JpdGVWMyc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVGVuc29yQXJyYXlSZWFkVjMnOiByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckFycmF5R2F0aGVyVjMnOiByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckFycmF5U2NhdHRlclYzJzogcmV0dXJuIFszIC8qYnJlYWsqLywgMjBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUZW5zb3JBcnJheUNvbmNhdFYzJzogcmV0dXJuIFszIC8qYnJlYWsqLywgMjFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUZW5zb3JBcnJheVNwbGl0VjMnOiByZXR1cm4gWzMgLypicmVhayovLCAyMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckFycmF5U2l6ZVYzJzogcmV0dXJuIFszIC8qYnJlYWsqLywgMjNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUZW5zb3JBcnJheUNsb3NlVjMnOiByZXR1cm4gWzMgLypicmVhayovLCAyNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckxpc3RTZXRJdGVtJzogcmV0dXJuIFszIC8qYnJlYWsqLywgMjVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUZW5zb3JMaXN0R2V0SXRlbSc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDI2XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVGVuc29yTGlzdFNjYXR0ZXJWMic6IHJldHVybiBbMyAvKmJyZWFrKi8sIDI3XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVGVuc29yTGlzdFNjYXR0ZXInOiByZXR1cm4gWzMgLypicmVhayovLCAyN107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckxpc3RSZXNlcnZlJzogcmV0dXJuIFszIC8qYnJlYWsqLywgMjhdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdFbXB0eVRlbnNvckxpc3QnOiByZXR1cm4gWzMgLypicmVhayovLCAyOF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckxpc3RHYXRoZXInOiByZXR1cm4gWzMgLypicmVhayovLCAyOV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckxpc3RTdGFjayc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDMwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVGVuc29yTGlzdEZyb21UZW5zb3InOiByZXR1cm4gWzMgLypicmVhayovLCAzMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckxpc3RDb25jYXQnOiByZXR1cm4gWzMgLypicmVhayovLCAzMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckxpc3RQdXNoQmFjayc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDMzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVGVuc29yTGlzdFBvcEJhY2snOiByZXR1cm4gWzMgLypicmVhayovLCAzNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RlbnNvckxpc3RTcGxpdCc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDM1XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMzZdO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRoZW5GdW5jID0gZ2V0UGFyYW1WYWx1ZSgndGhlbkJyYW5jaCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgZWxzZUZ1bmMgPSBnZXRQYXJhbVZhbHVlKCdlbHNlQnJhbmNoJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBjb25kID0gZ2V0UGFyYW1WYWx1ZSgnY29uZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgYXJncyA9IGdldFBhcmFtVmFsdWUoJ2FyZ3MnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNvbmQuZGF0YSgpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjb25kVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmRWYWx1ZVswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY29udGV4dC5mdW5jdGlvbk1hcFt0aGVuRnVuY10uZXhlY3V0ZUZ1bmN0aW9uQXN5bmMoYXJncywgY29udGV4dC50ZW5zb3JBcnJheU1hcCwgY29udGV4dC50ZW5zb3JMaXN0TWFwKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY29udGV4dC5mdW5jdGlvbk1hcFtlbHNlRnVuY10uZXhlY3V0ZUZ1bmN0aW9uQXN5bmMoYXJncywgY29udGV4dC50ZW5zb3JBcnJheU1hcCwgY29udGV4dC50ZW5zb3JMaXN0TWFwKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGJvZHlGdW5jID0gZ2V0UGFyYW1WYWx1ZSgnYm9keScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29uZEZ1bmMgPSBnZXRQYXJhbVZhbHVlKCdjb25kJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBhcmdzID0gZ2V0UGFyYW1WYWx1ZSgnYXJncycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29udGV4dC5mdW5jdGlvbk1hcFtjb25kRnVuY10uZXhlY3V0ZUZ1bmN0aW9uQXN5bmMoYXJncywgY29udGV4dC50ZW5zb3JBcnJheU1hcCwgY29udGV4dC50ZW5zb3JMaXN0TWFwKV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY29uZFJlc3VsdCA9IChfYi5zZW50KCkpO1xuICAgICAgICAgICAgICAgIGFyZ0lkc18xID0gYXJncy5tYXAoZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGVuc29yLmlkOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb25kUmVzdWx0WzBdLmRhdGEoKV07XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgY29uZFZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIC8vIERpc3Bvc2UgdGhlIGludGVybWVkaWF0ZSB0ZW5zb3JzIGZvciBjb25kaXRpb24gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBjb25kUmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRlbnNvci5rZXB0ICYmIGFyZ0lkc18xLmluZGV4T2YodGVuc29yLmlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhcmdzO1xuICAgICAgICAgICAgICAgIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnUmVzdWx0LCByZXN1bHRJZHMsIGNvbmRSZXN1bHRfMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ1Jlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29udGV4dC5mdW5jdGlvbk1hcFtib2R5RnVuY10uZXhlY3V0ZUZ1bmN0aW9uQXN5bmMocmVzdWx0LCBjb250ZXh0LnRlbnNvckFycmF5TWFwLCBjb250ZXh0LnRlbnNvckxpc3RNYXApXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGlvbiB0aGUgYm9keSBvZiB0aGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdElkcyA9IHJlc3VsdC5tYXAoZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGVuc29yLmlkOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzcG9zZSB0aGUgaW50ZXJtZWRpYXRlIHRlbnNvciBmb3IgYm9keSBmdW5jdGlvbiB0aGF0IGlzIG5vdCBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2VwdCwgbm90IGlucHV0L291dHB1dCBvZiB0aGUgYm9keSBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnUmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZW5zb3Iua2VwdCAmJiBhcmdJZHNfMS5pbmRleE9mKHRlbnNvci5pZCkgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0SWRzLmluZGV4T2YodGVuc29yLmlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3IuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29udGV4dC5mdW5jdGlvbk1hcFtjb25kRnVuY10uZXhlY3V0ZUZ1bmN0aW9uQXN5bmMocmVzdWx0LCBjb250ZXh0LnRlbnNvckFycmF5TWFwLCBjb250ZXh0LnRlbnNvckxpc3RNYXApXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRSZXN1bHRfMSA9IChfYS5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb25kUmVzdWx0XzFbMF0uZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRWYWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzcG9zZSB0aGUgaW50ZXJtZWRpYXRlIHRlbnNvcnMgZm9yIGNvbmRpdGlvbiBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kUmVzdWx0XzEuZm9yRWFjaChmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlbnNvci5rZXB0ICYmIGFyZ0lkc18xLmluZGV4T2YodGVuc29yLmlkKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRJZHMuaW5kZXhPZih0ZW5zb3IuaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2IubGFiZWwgPSA2O1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGlmICghY29uZFZhbHVlWzBdKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzUgLyp5aWVsZCoqLywgX2xvb3BfMSgpXTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZCA9IGdldFBhcmFtVmFsdWUoJ3ByZWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW2Nsb25lVGVuc29yKHByZWQpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBwcmVkID0gZ2V0UGFyYW1WYWx1ZSgncHJlZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldFBhcmFtVmFsdWUoJ2RhdGEnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YS5rZXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBjbG9uZVRlbnNvcihkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcHJlZC5kYXRhKCldO1xuICAgICAgICAgICAgY2FzZSAxMTogXG4gICAgICAgICAgICAvLyBPdXRwdXRzIG5vZGVzIDowID0+IGZhbHNlLCA6MSA9PiB0cnVlXG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9iLnNlbnQoKSlbMF0gPyBbdW5kZWZpbmVkLCBkYXRhXSA6IFtkYXRhLCB1bmRlZmluZWRdXTtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dE5hbWUgPSBub2RlLmlucHV0TmFtZXMuZmluZChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2V0VGVuc29yKG5hbWUsIHRlbnNvck1hcCwgY29udGV4dCkgIT09IHVuZGVmaW5lZDsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBnZXRUZW5zb3IoaW5wdXROYW1lLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtjbG9uZVRlbnNvcihkYXRhKV1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUlkID0gZ2V0UGFyYW1WYWx1ZSgnZnJhbWVOYW1lJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGdldFBhcmFtVmFsdWUoJ3RlbnNvcicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZW50ZXJGcmFtZShmcmFtZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtjbG9uZVRlbnNvcihkYXRhKV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZ2V0UGFyYW1WYWx1ZSgndGVuc29yJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5leGl0RnJhbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtjbG9uZVRlbnNvcihkYXRhKV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZ2V0UGFyYW1WYWx1ZSgndGVuc29yJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5uZXh0SXRlcmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbY2xvbmVUZW5zb3IoZGF0YSldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IGdldFBhcmFtVmFsdWUoJ3NpemUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBkdHlwZSA9IGdldFBhcmFtVmFsdWUoJ2R0eXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNoYXBlID0gZ2V0UGFyYW1WYWx1ZSgnZWxlbWVudFNoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1NpemUgPSBnZXRQYXJhbVZhbHVlKCdkeW5hbWljU2l6ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQWZ0ZXJSZWFkID0gZ2V0UGFyYW1WYWx1ZSgnY2xlYXJBZnRlclJlYWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZGVudGljYWxFbGVtZW50U2hhcGVzID0gZ2V0UGFyYW1WYWx1ZSgnaWRlbnRpY2FsRWxlbWVudFNoYXBlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVfMSA9IGdldFBhcmFtVmFsdWUoJ25hbWUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JBcnJheSA9IG5ldyBUZW5zb3JBcnJheShuYW1lXzEsIGR0eXBlLCBzaXplLCBlbGVtZW50U2hhcGUsIGlkZW50aWNhbEVsZW1lbnRTaGFwZXMsIGR5bmFtaWNTaXplLCBjbGVhckFmdGVyUmVhZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYWRkVGVuc29yQXJyYXkodGVuc29yQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW3RlbnNvckFycmF5LmlkVGVuc29yLCB0Zk9wcy5zY2FsYXIoMS4wKV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IGdldFBhcmFtVmFsdWUoJ3RlbnNvckFycmF5SWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGdldFBhcmFtVmFsdWUoJ2luZGV4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVUZW5zb3IgPSBnZXRQYXJhbVZhbHVlKCd0ZW5zb3InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZVRlbnNvckFycmF5ID0gY29udGV4dC5nZXRUZW5zb3JBcnJheShpZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVGVuc29yQXJyYXkud3JpdGUoaW5kZXgsIHdyaXRlVGVuc29yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFt3cml0ZVRlbnNvckFycmF5LmlkVGVuc29yXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRJZCA9IGdldFBhcmFtVmFsdWUoJ3RlbnNvckFycmF5SWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZWFkSW5kZXggPSBnZXRQYXJhbVZhbHVlKCdpbmRleCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRUZW5zb3JBcnJheSA9IGNvbnRleHQuZ2V0VGVuc29yQXJyYXkocmVhZElkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtyZWFkVGVuc29yQXJyYXkucmVhZChyZWFkSW5kZXgpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGdhdGhlcklkID0gZ2V0UGFyYW1WYWx1ZSgndGVuc29yQXJyYXlJZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGdhdGhlckluZGljZXMgPSBnZXRQYXJhbVZhbHVlKCdpbmRpY2VzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgZ2F0aGVyRHR5cGUgPSBnZXRQYXJhbVZhbHVlKCdkdHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGdhdGhlclRlbnNvckFycmF5ID0gY29udGV4dC5nZXRUZW5zb3JBcnJheShnYXRoZXJJZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbZ2F0aGVyVGVuc29yQXJyYXkuZ2F0aGVyKGdhdGhlckluZGljZXMsIGdhdGhlckR0eXBlKV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzY2F0dGVySWQgPSBnZXRQYXJhbVZhbHVlKCd0ZW5zb3JBcnJheUlkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgc2NhdHRlckluZGljZXMgPSBnZXRQYXJhbVZhbHVlKCdpbmRpY2VzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgc2NhdHRlclRlbnNvciA9IGdldFBhcmFtVmFsdWUoJ3RlbnNvcicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHNjYXR0ZXJUZW5zb3JBcnJheSA9IGNvbnRleHQuZ2V0VGVuc29yQXJyYXkoc2NhdHRlcklkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgc2NhdHRlclRlbnNvckFycmF5LnNjYXR0ZXIoc2NhdHRlckluZGljZXMsIHNjYXR0ZXJUZW5zb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW3NjYXR0ZXJUZW5zb3JBcnJheS5pZFRlbnNvcl1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25jYXRJZCA9IGdldFBhcmFtVmFsdWUoJ3RlbnNvckFycmF5SWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25jYXRUZW5zb3JBcnJheSA9IGNvbnRleHQuZ2V0VGVuc29yQXJyYXkoY29uY2F0SWQuaWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25jYXREdHlwZSA9IGdldFBhcmFtVmFsdWUoJ2R0eXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtjb25jYXRUZW5zb3JBcnJheS5jb25jYXQoY29uY2F0RHR5cGUpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0SWQgPSBnZXRQYXJhbVZhbHVlKCd0ZW5zb3JBcnJheUlkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRUZW5zb3IgPSBnZXRQYXJhbVZhbHVlKCd0ZW5zb3InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhzID0gZ2V0UGFyYW1WYWx1ZSgnbGVuZ3RocycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0VGVuc29yQXJyYXkgPSBjb250ZXh0LmdldFRlbnNvckFycmF5KHNwbGl0SWQuaWQpO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFRlbnNvckFycmF5LnNwbGl0KGxlbmd0aHMsIHNwbGl0VGVuc29yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtzcGxpdFRlbnNvckFycmF5LmlkVGVuc29yXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVJZCA9IGdldFBhcmFtVmFsdWUoJ3RlbnNvckFycmF5SWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBzaXplVGVuc29yQXJyYXkgPSBjb250ZXh0LmdldFRlbnNvckFycmF5KHNpemVJZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbdGZPcHMuc2NhbGFyKHNpemVUZW5zb3JBcnJheS5zaXplKCksICdpbnQzMicpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlSWQgPSBnZXRQYXJhbVZhbHVlKCd0ZW5zb3JBcnJheUlkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VUZW5zb3JBcnJheSA9IGNvbnRleHQuZ2V0VGVuc29yQXJyYXkoY2xvc2VJZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlVGVuc29yQXJyYXkuY2xlYXJBbmRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW2Nsb3NlVGVuc29yQXJyYXkuaWRUZW5zb3JdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWRUZW5zb3IgPSBnZXRQYXJhbVZhbHVlKCd0ZW5zb3JMaXN0SWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGdldFBhcmFtVmFsdWUoJ2luZGV4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVUZW5zb3IgPSBnZXRQYXJhbVZhbHVlKCd0ZW5zb3InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JMaXN0ID0gY29udGV4dC5nZXRUZW5zb3JMaXN0KGlkVGVuc29yLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yTGlzdC5zZXRJdGVtKGluZGV4LCB3cml0ZVRlbnNvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbdGVuc29yTGlzdC5pZFRlbnNvcl1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZFRlbnNvciA9IGdldFBhcmFtVmFsdWUoJ3RlbnNvckxpc3RJZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRJbmRleCA9IGdldFBhcmFtVmFsdWUoJ2luZGV4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNoYXBlID0gZ2V0UGFyYW1WYWx1ZSgnZWxlbWVudFNoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudERUeXBlID0gZ2V0UGFyYW1WYWx1ZSgnZWxlbWVudERUeXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yTGlzdCA9IGNvbnRleHQuZ2V0VGVuc29yTGlzdChpZFRlbnNvci5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbdGVuc29yTGlzdC5nZXRJdGVtKHJlYWRJbmRleCwgZWxlbWVudFNoYXBlLCBlbGVtZW50RFR5cGUpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNjYXR0ZXJJbmRpY2VzID0gZ2V0UGFyYW1WYWx1ZSgnaW5kaWNlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHNjYXR0ZXJUZW5zb3IgPSBnZXRQYXJhbVZhbHVlKCd0ZW5zb3InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2hhcGUgPSBnZXRQYXJhbVZhbHVlKCdlbGVtZW50U2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBudW1FbGVtZW50cyA9IGdldFBhcmFtVmFsdWUoJ251bUVsZW1lbnRzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yTGlzdCA9IHNjYXR0ZXIoc2NhdHRlclRlbnNvciwgc2NhdHRlckluZGljZXMsIGVsZW1lbnRTaGFwZSwgbnVtRWxlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFkZFRlbnNvckxpc3QodGVuc29yTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbdGVuc29yTGlzdC5pZFRlbnNvcl1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2hhcGUgPSBnZXRQYXJhbVZhbHVlKCdlbGVtZW50U2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50RHR5cGUgPSBnZXRQYXJhbVZhbHVlKCdlbGVtZW50RFR5cGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBudW1FbGVtZW50c1BhcmFtID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vcCA9PT0gJ1RlbnNvckxpc3RSZXNlcnZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtRWxlbWVudHNQYXJhbSA9ICdudW1FbGVtZW50cyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1FbGVtZW50c1BhcmFtID0gJ21heE51bUVsZW1lbnRzJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBudW1FbGVtZW50cyA9IGdldFBhcmFtVmFsdWUobnVtRWxlbWVudHNQYXJhbSwgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yTGlzdCA9IHJlc2VydmUoZWxlbWVudFNoYXBlLCBlbGVtZW50RHR5cGUsIG51bUVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hZGRUZW5zb3JMaXN0KHRlbnNvckxpc3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW3RlbnNvckxpc3QuaWRUZW5zb3JdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZ2F0aGVySWQgPSBnZXRQYXJhbVZhbHVlKCd0ZW5zb3JMaXN0SWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBnYXRoZXJJbmRpY2VzID0gZ2V0UGFyYW1WYWx1ZSgnaW5kaWNlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTaGFwZSA9IGdldFBhcmFtVmFsdWUoJ2VsZW1lbnRTaGFwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnREdHlwZSA9IGdldFBhcmFtVmFsdWUoJ2VsZW1lbnREVHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckxpc3QgPSBjb250ZXh0LmdldFRlbnNvckxpc3QoZ2F0aGVySWQuaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW3RlbnNvckxpc3QuZ2F0aGVyKGdhdGhlckluZGljZXMsIGVsZW1lbnREdHlwZSwgZWxlbWVudFNoYXBlKV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZFRlbnNvciA9IGdldFBhcmFtVmFsdWUoJ3RlbnNvckxpc3RJZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTaGFwZSA9IGdldFBhcmFtVmFsdWUoJ2VsZW1lbnRTaGFwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnREdHlwZSA9IGdldFBhcmFtVmFsdWUoJ2VsZW1lbnREVHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG51bUVsZW1lbnRzID0gZ2V0UGFyYW1WYWx1ZSgnbnVtRWxlbWVudHMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JMaXN0ID0gY29udGV4dC5nZXRUZW5zb3JMaXN0KGlkVGVuc29yLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFt0ZW5zb3JMaXN0LnN0YWNrKGVsZW1lbnRTaGFwZSwgZWxlbWVudER0eXBlLCBudW1FbGVtZW50cyldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yID0gZ2V0UGFyYW1WYWx1ZSgndGVuc29yJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNoYXBlID0gZ2V0UGFyYW1WYWx1ZSgnZWxlbWVudFNoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudER0eXBlID0gZ2V0UGFyYW1WYWx1ZSgnZWxlbWVudERUeXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yTGlzdCA9IGZyb21UZW5zb3IodGVuc29yLCBlbGVtZW50U2hhcGUsIGVsZW1lbnREdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYWRkVGVuc29yTGlzdCh0ZW5zb3JMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFt0ZW5zb3JMaXN0LmlkVGVuc29yXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmNhdElkID0gZ2V0UGFyYW1WYWx1ZSgndGVuc29yTGlzdElkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yTGlzdCA9IGNvbnRleHQuZ2V0VGVuc29yTGlzdChjb25jYXRJZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmNhdER0eXBlID0gZ2V0UGFyYW1WYWx1ZSgnZHR5cGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2hhcGUgPSBnZXRQYXJhbVZhbHVlKCdlbGVtZW50U2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW3RlbnNvckxpc3QuY29uY2F0KGNvbmNhdER0eXBlLCBlbGVtZW50U2hhcGUpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkVGVuc29yID0gZ2V0UGFyYW1WYWx1ZSgndGVuc29yTGlzdElkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVUZW5zb3IgPSBnZXRQYXJhbVZhbHVlKCd0ZW5zb3InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JMaXN0ID0gY29udGV4dC5nZXRUZW5zb3JMaXN0KGlkVGVuc29yLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yTGlzdC5wdXNoQmFjayh3cml0ZVRlbnNvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbdGVuc29yTGlzdC5pZFRlbnNvcl1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZFRlbnNvciA9IGdldFBhcmFtVmFsdWUoJ3RlbnNvckxpc3RJZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTaGFwZSA9IGdldFBhcmFtVmFsdWUoJ2VsZW1lbnRTaGFwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnREVHlwZSA9IGdldFBhcmFtVmFsdWUoJ2VsZW1lbnREVHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckxpc3QgPSBjb250ZXh0LmdldFRlbnNvckxpc3QoaWRUZW5zb3IuaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW3RlbnNvckxpc3QucG9wQmFjayhlbGVtZW50U2hhcGUsIGVsZW1lbnREVHlwZSldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRUZW5zb3IgPSBnZXRQYXJhbVZhbHVlKCd0ZW5zb3InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2hhcGUgPSBnZXRQYXJhbVZhbHVlKCdlbGVtZW50U2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhzID0gZ2V0UGFyYW1WYWx1ZSgnbGVuZ3RocycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckxpc3QgPSBzcGxpdChzcGxpdFRlbnNvciwgbGVuZ3RocywgZWxlbWVudFNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hZGRUZW5zb3JMaXN0KHRlbnNvckxpc3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW3RlbnNvckxpc3QuaWRUZW5zb3JdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDM2OiB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZnVzZWRDb252QW5kRGVwdGhXaXNlUGFyYW1zKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHZhciBfYSA9IF9fcmVhZChnZXRQYXJhbVZhbHVlKCdmdXNlZE9wcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIDIpLCBleHRyYU9wID0gX2FbMF0sIGFjdGl2YXRpb25GdW5jID0gX2FbMV07XG4gICAgdmFyIGlzQmlhc0FkZCA9IGV4dHJhT3AgPT09ICdiaWFzYWRkJztcbiAgICB2YXIgaXNQcmVsdSA9IGFjdGl2YXRpb25GdW5jID09PSAncHJlbHUnO1xuICAgIHZhciBpc0JhdGNoTm9ybSA9IGV4dHJhT3AgPT09ICdmdXNlZGJhdGNobm9ybSc7XG4gICAgdmFyIG51bUFyZ3MgPSBnZXRQYXJhbVZhbHVlKCdudW1BcmdzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICBpZiAoaXNCaWFzQWRkKSB7XG4gICAgICAgIGlmIChpc1ByZWx1ICYmIG51bUFyZ3MgIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVzZWRDb252MmQgYW5kIERlcHRod2lzZUNvbnYyZCB3aXRoIEJpYXNBZGQgYW5kIFByZWx1ICcgK1xuICAgICAgICAgICAgICAgICdtdXN0IGhhdmUgdHdvIGV4dHJhIGFyZ3VtZW50czogYmlhcyBhbmQgYWxwaGEuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ByZWx1ICYmIG51bUFyZ3MgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVzZWRDb252MmQgYW5kIERlcHRod2lzZUNvbnYyZCB3aXRoIEJpYXNBZGQgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgICAgICdvbmUgZXh0cmEgYXJndW1lbnQ6IGJpYXMuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQmF0Y2hOb3JtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnVzZWRDb252MmQgYW5kIERlcHRod2lzZUNvbnYyZCB3aXRoIEZ1c2VkQmF0Y2hOb3JtIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIHZhciBzdHJpZGUgPSBnZXRQYXJhbVZhbHVlKCdzdHJpZGVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICB2YXIgcGFkID0gZ2V0UGFkZGluZyhub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgIHZhciBkYXRhRm9ybWF0ID0gZ2V0UGFyYW1WYWx1ZSgnZGF0YUZvcm1hdCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dClcbiAgICAgICAgLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIGRpbGF0aW9ucyA9IGdldFBhcmFtVmFsdWUoJ2RpbGF0aW9ucycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgdmFyIF9iID0gX19yZWFkKGdldFBhcmFtVmFsdWUoJ2FyZ3MnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCAyKSwgYmlhc0FyZyA9IF9iWzBdLCBwcmVsdUFyZyA9IF9iWzFdO1xuICAgIHZhciBsZWFreXJlbHVBbHBoYSA9IGdldFBhcmFtVmFsdWUoJ2xlYWt5cmVsdUFscGhhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHJpZGU6IHN0cmlkZSxcbiAgICAgICAgcGFkOiBwYWQsXG4gICAgICAgIGRhdGFGb3JtYXQ6IGRhdGFGb3JtYXQsXG4gICAgICAgIGRpbGF0aW9uczogZGlsYXRpb25zLFxuICAgICAgICBiaWFzQXJnOiBiaWFzQXJnLFxuICAgICAgICBwcmVsdUFyZzogcHJlbHVBcmcsXG4gICAgICAgIGFjdGl2YXRpb25GdW5jOiBhY3RpdmF0aW9uRnVuYyxcbiAgICAgICAgbGVha3lyZWx1QWxwaGE6IGxlYWt5cmVsdUFscGhhXG4gICAgfTtcbn1cbnZhciBleGVjdXRlT3AkMyA9IGZ1bmN0aW9uIChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSAnQ29udjFEJzoge1xuICAgICAgICAgICAgdmFyIHN0cmlkZSA9IGdldFBhcmFtVmFsdWUoJ3N0cmlkZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFkID0gZ2V0UGFyYW1WYWx1ZSgncGFkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBkYXRhRm9ybWF0ID0gZ2V0UGFyYW1WYWx1ZSgnZGF0YUZvcm1hdCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dClcbiAgICAgICAgICAgICAgICAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBkaWxhdGlvbiA9IGdldFBhcmFtVmFsdWUoJ2RpbGF0aW9uJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuY29udjFkKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdmaWx0ZXInLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBzdHJpZGUsIHBhZCwgZGF0YUZvcm1hdCwgZGlsYXRpb24pXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdDb252MkQnOiB7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gZ2V0UGFyYW1WYWx1ZSgnc3RyaWRlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFkID0gZ2V0UGFkZGluZyhub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGRhdGFGb3JtYXQgPSBnZXRQYXJhbVZhbHVlKCdkYXRhRm9ybWF0Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIGRpbGF0aW9ucyA9IGdldFBhcmFtVmFsdWUoJ2RpbGF0aW9ucycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmNvbnYyZChnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnZmlsdGVyJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgW3N0cmlkZVsxXSwgc3RyaWRlWzJdXSwgcGFkLCBkYXRhRm9ybWF0LCBbZGlsYXRpb25zWzFdLCBkaWxhdGlvbnNbMl1dKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnX0Z1c2VkQ29udjJEJzoge1xuICAgICAgICAgICAgdmFyIF9hID0gZnVzZWRDb252QW5kRGVwdGhXaXNlUGFyYW1zKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHN0cmlkZSA9IF9hLnN0cmlkZSwgcGFkID0gX2EucGFkLCBkYXRhRm9ybWF0ID0gX2EuZGF0YUZvcm1hdCwgZGlsYXRpb25zID0gX2EuZGlsYXRpb25zLCBiaWFzQXJnID0gX2EuYmlhc0FyZywgcHJlbHVBcmcgPSBfYS5wcmVsdUFyZywgYWN0aXZhdGlvbkZ1bmMgPSBfYS5hY3RpdmF0aW9uRnVuYywgbGVha3lyZWx1QWxwaGEgPSBfYS5sZWFreXJlbHVBbHBoYTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuZnVzZWQuY29udjJkKHtcbiAgICAgICAgICAgICAgICAgICAgeDogZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZ2V0UGFyYW1WYWx1ZSgnZmlsdGVyJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgc3RyaWRlczogW3N0cmlkZVsxXSwgc3RyaWRlWzJdXSxcbiAgICAgICAgICAgICAgICAgICAgcGFkOiBwYWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFGb3JtYXQ6IGRhdGFGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIGRpbGF0aW9uczogW2RpbGF0aW9uc1sxXSwgZGlsYXRpb25zWzJdXSxcbiAgICAgICAgICAgICAgICAgICAgYmlhczogYmlhc0FyZyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZhdGlvbjogYWN0aXZhdGlvbkZ1bmMsXG4gICAgICAgICAgICAgICAgICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHM6IHByZWx1QXJnLFxuICAgICAgICAgICAgICAgICAgICBsZWFreXJlbHVBbHBoYTogbGVha3lyZWx1QWxwaGFcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnRnVzZWREZXB0aHdpc2VDb252MmROYXRpdmUnOiB7XG4gICAgICAgICAgICB2YXIgX2IgPSBmdXNlZENvbnZBbmREZXB0aFdpc2VQYXJhbXMobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgc3RyaWRlID0gX2Iuc3RyaWRlLCBwYWQgPSBfYi5wYWQsIGRhdGFGb3JtYXQgPSBfYi5kYXRhRm9ybWF0LCBkaWxhdGlvbnMgPSBfYi5kaWxhdGlvbnMsIGJpYXNBcmcgPSBfYi5iaWFzQXJnLCBwcmVsdUFyZyA9IF9iLnByZWx1QXJnLCBhY3RpdmF0aW9uRnVuYyA9IF9iLmFjdGl2YXRpb25GdW5jLCBsZWFreXJlbHVBbHBoYSA9IF9iLmxlYWt5cmVsdUFscGhhO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5mdXNlZC5kZXB0aHdpc2VDb252MmQoe1xuICAgICAgICAgICAgICAgICAgICB4OiBnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBnZXRQYXJhbVZhbHVlKCdmaWx0ZXInLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLFxuICAgICAgICAgICAgICAgICAgICBzdHJpZGVzOiBbc3RyaWRlWzFdLCBzdHJpZGVbMl1dLFxuICAgICAgICAgICAgICAgICAgICBwYWQ6IHBhZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUZvcm1hdDogZGF0YUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgZGlsYXRpb25zOiBbZGlsYXRpb25zWzFdLCBkaWxhdGlvbnNbMl1dLFxuICAgICAgICAgICAgICAgICAgICBiaWFzOiBiaWFzQXJnLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmF0aW9uOiBhY3RpdmF0aW9uRnVuYyxcbiAgICAgICAgICAgICAgICAgICAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0czogcHJlbHVBcmcsXG4gICAgICAgICAgICAgICAgICAgIGxlYWt5cmVsdUFscGhhOiBsZWFreXJlbHVBbHBoYVxuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdDb252MkRCYWNrcHJvcElucHV0JzpcbiAgICAgICAgY2FzZSAnQ29udjJkVHJhbnNwb3NlJzoge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gZ2V0UGFyYW1WYWx1ZSgnb3V0cHV0U2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHN0cmlkZSA9IGdldFBhcmFtVmFsdWUoJ3N0cmlkZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHBhZCA9IGdldFBhZGRpbmcobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuY29udjJkVHJhbnNwb3NlKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdmaWx0ZXInLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBzaGFwZSwgW3N0cmlkZVsxXSwgc3RyaWRlWzJdXSwgcGFkKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnRGVwdGh3aXNlQ29udjJkTmF0aXZlJzpcbiAgICAgICAgY2FzZSAnRGVwdGh3aXNlQ29udjJkJzoge1xuICAgICAgICAgICAgdmFyIHN0cmlkZSA9IGdldFBhcmFtVmFsdWUoJ3N0cmlkZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHBhZCA9IGdldFBhZGRpbmcobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBkaWxhdGlvbnMgPSBnZXRQYXJhbVZhbHVlKCdkaWxhdGlvbnMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGRhdGFGb3JtYXQgPSBnZXRQYXJhbVZhbHVlKCdkYXRhRm9ybWF0Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5kZXB0aHdpc2VDb252MmQoZ2V0UGFyYW1WYWx1ZSgnaW5wdXQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdmaWx0ZXInLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBbc3RyaWRlWzFdLCBzdHJpZGVbMl1dLCBwYWQsIGRhdGFGb3JtYXQsIFtkaWxhdGlvbnNbMV0sIGRpbGF0aW9uc1syXV0pXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdDb252M0QnOiB7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gZ2V0UGFyYW1WYWx1ZSgnc3RyaWRlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFkID0gZ2V0UGFyYW1WYWx1ZSgncGFkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBkYXRhRm9ybWF0ID0gZ2V0UGFyYW1WYWx1ZSgnZGF0YUZvcm1hdCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dClcbiAgICAgICAgICAgICAgICAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBkaWxhdGlvbnMgPSBnZXRQYXJhbVZhbHVlKCdkaWxhdGlvbnMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5jb252M2QoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2ZpbHRlcicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIFtzdHJpZGVbMV0sIHN0cmlkZVsyXSwgc3RyaWRlWzNdXSwgcGFkLCBkYXRhRm9ybWF0LCBbZGlsYXRpb25zWzFdLCBkaWxhdGlvbnNbMl0sIGRpbGF0aW9uc1szXV0pXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdBdmdQb29sJzoge1xuICAgICAgICAgICAgdmFyIHN0cmlkZSA9IGdldFBhcmFtVmFsdWUoJ3N0cmlkZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHBhZCA9IGdldFBhcmFtVmFsdWUoJ3BhZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIga2VybmVsU2l6ZSA9IGdldFBhcmFtVmFsdWUoJ2tlcm5lbFNpemUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5hdmdQb29sKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBba2VybmVsU2l6ZVsxXSwga2VybmVsU2l6ZVsyXV0sIFtzdHJpZGVbMV0sIHN0cmlkZVsyXV0sIHBhZCldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ01heFBvb2wnOiB7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gZ2V0UGFyYW1WYWx1ZSgnc3RyaWRlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFkID0gZ2V0UGFyYW1WYWx1ZSgncGFkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBrZXJuZWxTaXplID0gZ2V0UGFyYW1WYWx1ZSgna2VybmVsU2l6ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLm1heFBvb2woZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIFtrZXJuZWxTaXplWzFdLCBrZXJuZWxTaXplWzJdXSwgW3N0cmlkZVsxXSwgc3RyaWRlWzJdXSwgcGFkKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnTWF4UG9vbFdpdGhBcmdtYXgnOiB7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gZ2V0UGFyYW1WYWx1ZSgnc3RyaWRlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFkID0gZ2V0UGFyYW1WYWx1ZSgncGFkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBrZXJuZWxTaXplID0gZ2V0UGFyYW1WYWx1ZSgna2VybmVsU2l6ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgaW5jbHVkZUJhdGNoSW5JbmRleCA9IGdldFBhcmFtVmFsdWUoJ2luY2x1ZGVCYXRjaEluSW5kZXgnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIF9jID0gdGZPcHMubWF4UG9vbFdpdGhBcmdtYXgoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIFtrZXJuZWxTaXplWzFdLCBrZXJuZWxTaXplWzJdXSwgW3N0cmlkZVsxXSwgc3RyaWRlWzJdXSwgcGFkLCBpbmNsdWRlQmF0Y2hJbkluZGV4KSwgcmVzdWx0ID0gX2MucmVzdWx0LCBpbmRleGVzID0gX2MuaW5kZXhlcztcbiAgICAgICAgICAgIHJldHVybiBbcmVzdWx0LCBpbmRleGVzXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdBdmdQb29sM0QnOiB7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gZ2V0UGFyYW1WYWx1ZSgnc3RyaWRlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFkID0gZ2V0UGFyYW1WYWx1ZSgncGFkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBrZXJuZWxTaXplID0gZ2V0UGFyYW1WYWx1ZSgna2VybmVsU2l6ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmF2Z1Bvb2wzZChnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgW2tlcm5lbFNpemVbMV0sIGtlcm5lbFNpemVbMl0sIGtlcm5lbFNpemVbM11dLCBbc3RyaWRlWzFdLCBzdHJpZGVbMl0sIHN0cmlkZVszXV0sIHBhZCldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ01heFBvb2wzRCc6IHtcbiAgICAgICAgICAgIHZhciBzdHJpZGUgPSBnZXRQYXJhbVZhbHVlKCdzdHJpZGVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBwYWQgPSBnZXRQYXJhbVZhbHVlKCdwYWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGtlcm5lbFNpemUgPSBnZXRQYXJhbVZhbHVlKCdrZXJuZWxTaXplJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMubWF4UG9vbDNkKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBba2VybmVsU2l6ZVsxXSwga2VybmVsU2l6ZVsyXSwga2VybmVsU2l6ZVszXV0sIFtzdHJpZGVbMV0sIHN0cmlkZVsyXSwgc3RyaWRlWzNdXSwgcGFkKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnRGlsYXRpb24yRCc6IHtcbiAgICAgICAgICAgIHZhciBzdHJpZGVzID0gZ2V0UGFyYW1WYWx1ZSgnc3RyaWRlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFkID0gZ2V0UGFyYW1WYWx1ZSgncGFkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBkaWxhdGlvbnMgPSBnZXRQYXJhbVZhbHVlKCdkaWxhdGlvbnMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgLy8gc3RyaWRlczogWzEsIHN0cmlkZV9oZWlnaHQsIHN0cmlkZV93aWR0aCwgMV0uXG4gICAgICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gc3RyaWRlc1sxXTtcbiAgICAgICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IHN0cmlkZXNbMl07XG4gICAgICAgICAgICAvLyBkaWxhdGlvbnM6IFsxLCBkaWxhdGlvbl9oZWlnaHQsIGRpbGF0aW9uX3dpZHRoLCAxXS5cbiAgICAgICAgICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgIHZhciBkaWxhdGlvbldpZHRoID0gZGlsYXRpb25zWzJdO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5kaWxhdGlvbjJkKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdmaWx0ZXInLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBbc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aF0sIHBhZCwgW2RpbGF0aW9uSGVpZ2h0LCBkaWxhdGlvbldpZHRoXSwgJ05IV0MnIC8qIGRhdGFGb3JtYXQgKi8pXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZXhlY3V0ZU9wJDQgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ0ZpbGwnOiB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBnZXRQYXJhbVZhbHVlKCdzaGFwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgZHR5cGUgPSBnZXRQYXJhbVZhbHVlKCdkdHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRQYXJhbVZhbHVlKCd2YWx1ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmZpbGwoc2hhcGUsIHZhbHVlLCBkdHlwZSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0xpblNwYWNlJzoge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0UGFyYW1WYWx1ZSgnc3RhcnQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHN0b3BfMSA9IGdldFBhcmFtVmFsdWUoJ3N0b3AnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIG51bSA9IGdldFBhcmFtVmFsdWUoJ251bScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmxpbnNwYWNlKHN0YXJ0LCBzdG9wXzEsIG51bSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ011bHRpbm9taWFsJzoge1xuICAgICAgICAgICAgdmFyIGxvZ2l0cyA9IGdldFBhcmFtVmFsdWUoJ2xvZ2l0cycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgbnVtU2FtcGxlcyA9IGdldFBhcmFtVmFsdWUoJ251bVNhbXBsZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHNlZWQgPSBnZXRQYXJhbVZhbHVlKCdzZWVkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMubXVsdGlub21pYWwobG9naXRzLCBudW1TYW1wbGVzLCBzZWVkKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnT25lSG90Jzoge1xuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBnZXRQYXJhbVZhbHVlKCdpbmRpY2VzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IGdldFBhcmFtVmFsdWUoJ2RlcHRoJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBvblZhbHVlID0gZ2V0UGFyYW1WYWx1ZSgnb25WYWx1ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgb2ZmVmFsdWUgPSBnZXRQYXJhbVZhbHVlKCdvZmZWYWx1ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLm9uZUhvdChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdPbmVzJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5vbmVzKGdldFBhcmFtVmFsdWUoJ3NoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnZHR5cGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnT25lc0xpa2UnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLm9uZXNMaWtlKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnUmFuZG9tVW5pZm9ybSc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMucmFuZG9tVW5pZm9ybShcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgICAgICAgICAgZ2V0UGFyYW1WYWx1ZSgnc2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdtaW52YWwnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdtYXh2YWwnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdkdHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdSYW5nZSc6IHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGdldFBhcmFtVmFsdWUoJ3N0YXJ0Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzdG9wXzIgPSBnZXRQYXJhbVZhbHVlKCdzdG9wJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzdGVwID0gZ2V0UGFyYW1WYWx1ZSgnc3RlcCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnJhbmdlKHN0YXJ0LCBzdG9wXzIsIHN0ZXAsIGdldFBhcmFtVmFsdWUoJ2R0eXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1RydW5jYXRlZE5vcm1hbCc6IHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGdldFBhcmFtVmFsdWUoJ3NoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBtZWFuID0gZ2V0UGFyYW1WYWx1ZSgnbWVhbicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc3RkRGV2ID0gZ2V0UGFyYW1WYWx1ZSgnc3RkRGV2Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzZWVkID0gZ2V0UGFyYW1WYWx1ZSgnc2VlZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnRydW5jYXRlZE5vcm1hbChzaGFwZSwgbWVhbiwgc3RkRGV2LCBnZXRQYXJhbVZhbHVlKCdkdHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHNlZWQpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdaZXJvcyc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuemVyb3MoZ2V0UGFyYW1WYWx1ZSgnc2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdkdHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdaZXJvc0xpa2UnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnplcm9zTGlrZShnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBfdGhpcyQxID0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gbm1zUGFyYW1zKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHZhciBib3hlcyA9IGdldFBhcmFtVmFsdWUoJ2JveGVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICB2YXIgc2NvcmVzID0gZ2V0UGFyYW1WYWx1ZSgnc2NvcmVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICB2YXIgbWF4T3V0cHV0U2l6ZSA9IGdldFBhcmFtVmFsdWUoJ21heE91dHB1dFNpemUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgIHZhciBpb3VUaHJlc2hvbGQgPSBnZXRQYXJhbVZhbHVlKCdpb3VUaHJlc2hvbGQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgIHZhciBzY29yZVRocmVzaG9sZCA9IGdldFBhcmFtVmFsdWUoJ3Njb3JlVGhyZXNob2xkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICB2YXIgc29mdE5tc1NpZ21hID0gZ2V0UGFyYW1WYWx1ZSgnc29mdE5tc1NpZ21hJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBib3hlczogYm94ZXMsXG4gICAgICAgIHNjb3Jlczogc2NvcmVzLFxuICAgICAgICBtYXhPdXRwdXRTaXplOiBtYXhPdXRwdXRTaXplLFxuICAgICAgICBpb3VUaHJlc2hvbGQ6IGlvdVRocmVzaG9sZCxcbiAgICAgICAgc2NvcmVUaHJlc2hvbGQ6IHNjb3JlVGhyZXNob2xkLFxuICAgICAgICBzb2Z0Tm1zU2lnbWE6IHNvZnRObXNTaWdtYVxuICAgIH07XG59XG52YXIgZXhlY3V0ZU9wJDUgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMkMSwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EsIF9iLCBib3hlcywgc2NvcmVzLCBtYXhPdXRwdXRTaXplLCBpb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkLCBzb2Z0Tm1zU2lnbWEsIHJlc3VsdCwgX2MsIGJveGVzLCBzY29yZXMsIG1heE91dHB1dFNpemUsIGlvdVRocmVzaG9sZCwgc2NvcmVUaHJlc2hvbGQsIHBhZFRvTWF4T3V0cHV0U2l6ZSwgcmVzdWx0LCBfZCwgYm94ZXMsIHNjb3JlcywgbWF4T3V0cHV0U2l6ZSwgaW91VGhyZXNob2xkLCBzY29yZVRocmVzaG9sZCwgY29uZGl0aW9uLCByZXN1bHQ7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2EgPSBub2RlLm9wO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTm9uTWF4U3VwcHJlc3Npb25WNSc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdOb25NYXhTdXBwcmVzc2lvblY0JzogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05vbk1heFN1cHByZXNzaW9uVjMnOiByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTm9uTWF4U3VwcHJlc3Npb25WMic6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdXaGVyZSc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMaXN0RGlmZic6IHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2IgPSBubXNQYXJhbXMobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYm94ZXMgPSBfYi5ib3hlcywgc2NvcmVzID0gX2Iuc2NvcmVzLCBtYXhPdXRwdXRTaXplID0gX2IubWF4T3V0cHV0U2l6ZSwgaW91VGhyZXNob2xkID0gX2IuaW91VGhyZXNob2xkLCBzY29yZVRocmVzaG9sZCA9IF9iLnNjb3JlVGhyZXNob2xkLCBzb2Z0Tm1zU2lnbWEgPSBfYi5zb2Z0Tm1zU2lnbWE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGZPcHMuaW1hZ2Uubm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmVBc3luYyhib3hlcywgc2NvcmVzLCBtYXhPdXRwdXRTaXplLCBpb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkLCBzb2Z0Tm1zU2lnbWEpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtyZXN1bHQuc2VsZWN0ZWRJbmRpY2VzLCByZXN1bHQuc2VsZWN0ZWRTY29yZXNdXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBfYyA9IG5tc1BhcmFtcyhub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBib3hlcyA9IF9jLmJveGVzLCBzY29yZXMgPSBfYy5zY29yZXMsIG1heE91dHB1dFNpemUgPSBfYy5tYXhPdXRwdXRTaXplLCBpb3VUaHJlc2hvbGQgPSBfYy5pb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkID0gX2Muc2NvcmVUaHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgcGFkVG9NYXhPdXRwdXRTaXplID0gZ2V0UGFyYW1WYWx1ZSgncGFkVG9NYXhPdXRwdXRTaXplJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0Zk9wcy5pbWFnZS5ub25NYXhTdXBwcmVzc2lvblBhZGRlZEFzeW5jKGJveGVzLCBzY29yZXMsIG1heE91dHB1dFNpemUsIGlvdVRocmVzaG9sZCwgc2NvcmVUaHJlc2hvbGQsIHBhZFRvTWF4T3V0cHV0U2l6ZSldO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgW3Jlc3VsdC5zZWxlY3RlZEluZGljZXMsIHJlc3VsdC52YWxpZE91dHB1dHNdXTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBfZCA9IG5tc1BhcmFtcyhub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBib3hlcyA9IF9kLmJveGVzLCBzY29yZXMgPSBfZC5zY29yZXMsIG1heE91dHB1dFNpemUgPSBfZC5tYXhPdXRwdXRTaXplLCBpb3VUaHJlc2hvbGQgPSBfZC5pb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkID0gX2Quc2NvcmVUaHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGZPcHMuaW1hZ2Uubm9uTWF4U3VwcHJlc3Npb25Bc3luYyhib3hlcywgc2NvcmVzLCBtYXhPdXRwdXRTaXplLCBpb3VUaHJlc2hvbGQsIHNjb3JlVGhyZXNob2xkKV07XG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovLCBbX2Uuc2VudCgpXV07XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uID0gdGZPcHMuY2FzdChnZXRQYXJhbVZhbHVlKCdjb25kaXRpb24nLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCAnYm9vbCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRmT3BzLndoZXJlQXN5bmMoY29uZGl0aW9uKV07XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW19lLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0Zk9wcy5zZXRkaWZmMWRBc3luYyhnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgneScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEwOiB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGV4ZWN1dGVPcCQ2ID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdUb3BLVjInOiB7XG4gICAgICAgICAgICB2YXIgeCA9IGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGsgPSBnZXRQYXJhbVZhbHVlKCdrJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzb3J0ZWQgPSBnZXRQYXJhbVZhbHVlKCdzb3J0ZWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRmT3BzLnRvcGsoeCwgaywgc29ydGVkKTtcbiAgICAgICAgICAgIHJldHVybiBbcmVzdWx0LnZhbHVlcywgcmVzdWx0LmluZGljZXNdO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1VuaXF1ZSc6IHtcbiAgICAgICAgICAgIHZhciB4ID0gZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGZPcHMudW5pcXVlKHgpO1xuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHQudmFsdWVzLCByZXN1bHQuaW5kaWNlc107XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnVW5pcXVlVjInOiB7XG4gICAgICAgICAgICB2YXIgeCA9IGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBnZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0Zk9wcy51bmlxdWUoeCwgYXhpcyk7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdC52YWx1ZXMsIHJlc3VsdC5pbmRpY2VzXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZXhlY3V0ZU9wJDcgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ0NvbnN0Jzoge1xuICAgICAgICAgICAgcmV0dXJuIHRlbnNvck1hcFtub2RlLm5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1BsYWNlaG9sZGVyV2l0aERlZmF1bHQnOlxuICAgICAgICAgICAgdmFyIGRlZiA9IGdldFBhcmFtVmFsdWUoJ2RlZmF1bHQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFtnZXRUZW5zb3Iobm9kZS5uYW1lLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHx8IGRlZl07XG4gICAgICAgIGNhc2UgJ1BsYWNlaG9sZGVyJzpcbiAgICAgICAgICAgIHJldHVybiBbZ2V0VGVuc29yKG5vZGUubmFtZSwgdGVuc29yTWFwLCBjb250ZXh0KV07XG4gICAgICAgIGNhc2UgJ0lkZW50aXR5JzpcbiAgICAgICAgY2FzZSAnU3RvcEdyYWRpZW50JzpcbiAgICAgICAgY2FzZSAnRmFrZVF1YW50V2l0aE1pbk1heFZhcnMnOiB7IC8vIFRoaXMgb3AgaXMgY3VycmVudGx5IGlnbm9yZWQuXG4gICAgICAgICAgICB2YXIgZGF0YV8xID0gZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW2Nsb25lVGVuc29yKGRhdGFfMSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lkZW50aXR5Tic6XG4gICAgICAgICAgICByZXR1cm4gZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dClcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBjbG9uZVRlbnNvcih0KTsgfSk7XG4gICAgICAgIGNhc2UgJ1NuYXBzaG90JzpcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFtjbG9uZVRlbnNvcihzbmFwc2hvdCldO1xuICAgICAgICBjYXNlICdTaGFwZSc6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnRlbnNvcjFkKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLnNoYXBlLCAnaW50MzInKV07XG4gICAgICAgIGNhc2UgJ1NoYXBlTic6XG4gICAgICAgICAgICByZXR1cm4gZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dClcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0Zk9wcy50ZW5zb3IxZCh0LnNoYXBlKTsgfSk7XG4gICAgICAgIGNhc2UgJ1NpemUnOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5zY2FsYXIoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkuc2l6ZSwgJ2ludDMyJyldO1xuICAgICAgICBjYXNlICdSYW5rJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuc2NhbGFyKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLnJhbmssICdpbnQzMicpXTtcbiAgICAgICAgY2FzZSAnTm9PcCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnNjYWxhcigxKV07XG4gICAgICAgIGNhc2UgJ1ByaW50JzpcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBnZXRQYXJhbVZhbHVlKCdkYXRhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZ2V0UGFyYW1WYWx1ZSgnbWVzc2FnZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc3VtbWFyaXplID0gZ2V0UGFyYW1WYWx1ZSgnc3VtbWFyaXplJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIGdyYXBoIGhhcyBhIHRmLnByaW50KCkgb3BlcmF0aW9uLCcgK1xuICAgICAgICAgICAgICAgICd1c3VhbGx5IHVzZWQgZm9yIGRlYnVnZ2luZywgd2hpY2ggc2xvd3MgZG93biBwZXJmb3JtYW5jZS4nKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YVtpXS5kYXRhU3luYygpKVxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgc3VtbWFyaXplKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2lucHV0XTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIYXNodGFibGUgY29udGFpbnMgYSBzZXQgb2YgdGVuc29ycywgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIGJ5IGtleS5cbiAqL1xudmFyIEhhc2hUYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBvZiBIYXNoVGFibGUuIENyZWF0ZXMgYSBoYXNoIHRhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleURUeXBlIGBkdHlwZWAgb2YgdGhlIHRhYmxlIGtleXMuXG4gICAgICogQHBhcmFtIHZhbHVlRFR5cGUgYGR0eXBlYCBvZiB0aGUgdGFibGUgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhhc2hUYWJsZShrZXlEVHlwZSwgdmFsdWVEVHlwZSkge1xuICAgICAgICB0aGlzLmtleURUeXBlID0ga2V5RFR5cGU7XG4gICAgICAgIHRoaXMudmFsdWVEVHlwZSA9IHZhbHVlRFR5cGU7XG4gICAgICAgIHRoaXMuaGFuZGxlID0gdGZPcHMuc2NhbGFyKDApO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueVxuICAgICAgICB0aGlzLnRlbnNvck1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGZPcHMua2VlcCh0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIYXNoVGFibGUucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGUuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgdGhlIHRlbnNvcnMgYW5kIGhhbmRsZSBhbmQgY2xlYXIgdGhlIGhhc2h0YWJsZS5cbiAgICAgKi9cbiAgICBIYXNoVGFibGUucHJvdG90eXBlLmNsZWFyQW5kQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGVuc29yTWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB0aGlzLnRlbnNvck1hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLmhhbmRsZS5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBoYXNoIHRhYmxlLlxuICAgICAqL1xuICAgIEhhc2hUYWJsZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVuc29yTWFwLnNpemU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyB0aGUgY29udGVudHMgb2YgdGhlIHRhYmxlIHdpdGggdGhlIHNwZWNpZmllZCBrZXlzIGFuZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIGtleXMgS2V5cyB0byBzdG9yZSBpbiB0aGUgaGFzaHRhYmxlLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgVmFsdWVzIHRvIHN0b3JlIGluIHRoZSBoYXNodGFibGUuXG4gICAgICovXG4gICAgSGFzaFRhYmxlLnByb3RvdHlwZS5pbXBvcnQgPSBmdW5jdGlvbiAoa2V5cywgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAka2V5cztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrS2V5QW5kVmFsdWVUZW5zb3Ioa2V5cywgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGtleXMuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgJGtleXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgaGFzaFRhYmxlIGJlZm9yZSBpbnNlcnRpbmcgbmV3IHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGVuc29yTWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZW5zb3JNYXAuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0Zk9wcy50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICR2YWx1ZXMgPSB0Zk9wcy51bnN0YWNrKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzTGVuZ3RoID0gJGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzTGVuZ3RoID0gJHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmT3BzLnV0aWwuYXNzZXJ0KGtleXNMZW5ndGggPT09IHZhbHVlc0xlbmd0aCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGRvZXNuJ3QgbWF0Y2gsIGtleXMgaGFzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChrZXlzTGVuZ3RoICsgXCIgZWxlbWVudHMsIHRoZSB2YWx1ZXMgaGFzIFwiICsgdmFsdWVzTGVuZ3RoICsgXCIgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZWxlbWVudHMuXCI7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9ICRrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmT3BzLmtlZXAodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVuc29yTWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBrZXlzIGluIGEgaGFzaCB0YWJsZSwgb3V0cHV0cyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBQZXJmb3JtcyBiYXRjaCBsb29rdXBzLCBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUga2V5IHRlbnNvciwgYGZpbmRgXG4gICAgICogc3RhY2tzIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGludG8gdGhlIHJldHVybiB0ZW5zb3IuXG4gICAgICpcbiAgICAgKiBJZiBhbiBlbGVtZW50IGlzIG5vdCBwcmVzZW50IGluIHRoZSB0YWJsZSwgdGhlIGdpdmVuIGBkZWZhdWx0VmFsdWVgIGlzXG4gICAgICogdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlzIEtleXMgdG8gbG9vayB1cC4gTXVzdCBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGtleXMgb2YgdGhlXG4gICAgICogICAgIHRhYmxlLlxuICAgICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgVGhlIHNjYWxhciBgZGVmYXVsdFZhbHVlYCBpcyB0aGUgdmFsdWUgb3V0cHV0IGZvciBrZXlzXG4gICAgICogICAgIG5vdCBwcmVzZW50IGluIHRoZSB0YWJsZS4gSXQgbXVzdCBhbHNvIGJlIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlXG4gICAgICogICAgIHRhYmxlIHZhbHVlcy5cbiAgICAgKi9cbiAgICBIYXNoVGFibGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5cywgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAka2V5cztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrS2V5QW5kVmFsdWVUZW5zb3Ioa2V5cywgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGtleXMuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgJGtleXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGZPcHMudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAka2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9ICRrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMuZmluZFdpdGhEZWZhdWx0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGZPcHMuc3RhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1hbnlcbiAgICBIYXNoVGFibGUucHJvdG90eXBlLmZpbmRXaXRoRGVmYXVsdCA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy50ZW5zb3JNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9O1xuICAgIEhhc2hUYWJsZS5wcm90b3R5cGUuY2hlY2tLZXlBbmRWYWx1ZVRlbnNvciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkuZHR5cGUgIT09IHRoaXMua2V5RFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdCBrZXkgZHR5cGUgXCIgKyB0aGlzLmtleURUeXBlICsgXCIsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgICAgIChcIlwiICsga2V5LmR0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmR0eXBlICE9PSB0aGlzLnZhbHVlRFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdCB2YWx1ZSBkdHlwZSBcIiArIHRoaXMudmFsdWVEVHlwZSArIFwiLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgICAgICAoXCJcIiArIHZhbHVlLmR0eXBlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBIYXNoVGFibGU7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgX3RoaXMkMiA9IHVuZGVmaW5lZDtcbnZhciBleGVjdXRlT3AkOCA9IGZ1bmN0aW9uIChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQsIHJlc291cmNlTWFuYWdlcikgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzJDIsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hLCBrZXlEVHlwZSwgdmFsdWVEVHlwZSwgaGFzaFRhYmxlLCBoYW5kbGUsIGtleXMsIHZhbHVlcywgaGFzaFRhYmxlLCBoYW5kbGUsIGtleXMsIGRlZmF1bHRWYWx1ZSwgaGFzaFRhYmxlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9hID0gbm9kZS5vcDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0hhc2hUYWJsZSc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdIYXNoVGFibGVWMic6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMb29rdXBUYWJsZUltcG9ydCc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMb29rdXBUYWJsZUltcG9ydFYyJzogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0xvb2t1cFRhYmxlRmluZCc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMb29rdXBUYWJsZUZpbmRWMic6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleURUeXBlID0gZ2V0UGFyYW1WYWx1ZSgna2V5RFR5cGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZURUeXBlID0gZ2V0UGFyYW1WYWx1ZSgndmFsdWVEVHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hUYWJsZSA9IG5ldyBIYXNoVGFibGUoa2V5RFR5cGUsIHZhbHVlRFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZU1hbmFnZXIuYWRkSGFzaFRhYmxlKG5vZGUubmFtZSwgaGFzaFRhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtoYXNoVGFibGUuaGFuZGxlXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IGdldFBhcmFtVmFsdWUoJ3RhYmxlSGFuZGxlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0LCByZXNvdXJjZU1hbmFnZXIpO1xuICAgICAgICAgICAgICAgIGtleXMgPSBnZXRQYXJhbVZhbHVlKCdrZXlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBnZXRQYXJhbVZhbHVlKCd2YWx1ZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGhhc2hUYWJsZSA9IHJlc291cmNlTWFuYWdlci5nZXRIYXNoVGFibGVCeUlkKGhhbmRsZS5pZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgaGFzaFRhYmxlLmltcG9ydChrZXlzLCB2YWx1ZXMpXTtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtfYi5zZW50KCldXTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBnZXRQYXJhbVZhbHVlKCd0YWJsZUhhbmRsZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCwgcmVzb3VyY2VNYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICBrZXlzID0gZ2V0UGFyYW1WYWx1ZSgna2V5cycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gZ2V0UGFyYW1WYWx1ZSgnZGVmYXVsdFZhbHVlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBoYXNoVGFibGUgPSByZXNvdXJjZU1hbmFnZXIuZ2V0SGFzaFRhYmxlQnlJZChoYW5kbGUuaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGhhc2hUYWJsZS5maW5kKGtleXMsIGRlZmF1bHRWYWx1ZSldO1xuICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qLywgW19iLnNlbnQoKV1dO1xuICAgICAgICAgICAgY2FzZSA2OiB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGV4ZWN1dGVPcCQ5ID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdSZXNpemVCaWxpbmVhcic6IHtcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSBnZXRQYXJhbVZhbHVlKCdpbWFnZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSBnZXRQYXJhbVZhbHVlKCdzaXplJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBhbGlnbkNvcm5lcnMgPSBnZXRQYXJhbVZhbHVlKCdhbGlnbkNvcm5lcnMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGhhbGZQaXhlbENlbnRlcnMgPSBnZXRQYXJhbVZhbHVlKCdoYWxmUGl4ZWxDZW50ZXJzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuaW1hZ2UucmVzaXplQmlsaW5lYXIoaW1hZ2VzLCBbc2l6ZVswXSwgc2l6ZVsxXV0sIGFsaWduQ29ybmVycywgaGFsZlBpeGVsQ2VudGVycyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1Jlc2l6ZU5lYXJlc3ROZWlnaGJvcic6IHtcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSBnZXRQYXJhbVZhbHVlKCdpbWFnZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSBnZXRQYXJhbVZhbHVlKCdzaXplJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBhbGlnbkNvcm5lcnMgPSBnZXRQYXJhbVZhbHVlKCdhbGlnbkNvcm5lcnMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGhhbGZQaXhlbENlbnRlcnMgPSBnZXRQYXJhbVZhbHVlKCdoYWxmUGl4ZWxDZW50ZXJzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuaW1hZ2UucmVzaXplTmVhcmVzdE5laWdoYm9yKGltYWdlcywgW3NpemVbMF0sIHNpemVbMV1dLCBhbGlnbkNvcm5lcnMsIGhhbGZQaXhlbENlbnRlcnMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdDcm9wQW5kUmVzaXplJzoge1xuICAgICAgICAgICAgdmFyIGltYWdlID0gZ2V0UGFyYW1WYWx1ZSgnaW1hZ2UnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGJveGVzID0gZ2V0UGFyYW1WYWx1ZSgnYm94ZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGJveEluZCA9IGdldFBhcmFtVmFsdWUoJ2JveEluZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgY3JvcFNpemUgPSBnZXRQYXJhbVZhbHVlKCdjcm9wU2l6ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gZ2V0UGFyYW1WYWx1ZSgnbWV0aG9kJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBleHRyYXBvbGF0aW9uVmFsdWUgPSBnZXRQYXJhbVZhbHVlKCdleHRyYXBvbGF0aW9uVmFsdWUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5pbWFnZS5jcm9wQW5kUmVzaXplKGltYWdlLCBib3hlcywgYm94SW5kLCBjcm9wU2l6ZSwgbWV0aG9kLCBleHRyYXBvbGF0aW9uVmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZXhlY3V0ZU9wJGEgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ0VxdWFsJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5lcXVhbChnZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdOb3RFcXVhbCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMubm90RXF1YWwoZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnR3JlYXRlcic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuZ3JlYXRlcihnZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdHcmVhdGVyRXF1YWwnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmdyZWF0ZXJFcXVhbChnZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdMZXNzJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5sZXNzKGdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0xlc3NFcXVhbCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMubGVzc0VxdWFsKGdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0xvZ2ljYWxBbmQnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmxvZ2ljYWxBbmQoZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnTG9naWNhbE5vdCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMubG9naWNhbE5vdChnZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0xvZ2ljYWxPcic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMubG9naWNhbE9yKGdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1NlbGVjdCc6XG4gICAgICAgIGNhc2UgJ1NlbGVjdFYyJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy53aGVyZShnZXRQYXJhbVZhbHVlKCdjb25kaXRpb24nLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZXhlY3V0ZU9wJGIgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ0JhdGNoTWF0TXVsJzpcbiAgICAgICAgY2FzZSAnQmF0Y2hNYXRNdWxWMic6XG4gICAgICAgIGNhc2UgJ01hdE11bCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLm1hdE11bChnZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ3RyYW5zcG9zZUEnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCd0cmFuc3Bvc2VCJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdUcmFuc3Bvc2UnOlxuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy50cmFuc3Bvc2UoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ3Blcm0nLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ19GdXNlZE1hdE11bCc6XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZ2V0UGFyYW1WYWx1ZSgnZnVzZWRPcHMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCAyKSwgZXh0cmFPcCA9IF9hWzBdLCBhY3RpdmF0aW9uRnVuYyA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIGlzQmlhc0FkZCA9IGV4dHJhT3AgPT09ICdiaWFzYWRkJztcbiAgICAgICAgICAgIHZhciBpc1ByZWx1ID0gYWN0aXZhdGlvbkZ1bmMgPT09ICdwcmVsdSc7XG4gICAgICAgICAgICB2YXIgbnVtQXJncyA9IGdldFBhcmFtVmFsdWUoJ251bUFyZ3MnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGxlYWt5cmVsdUFscGhhID0gZ2V0UGFyYW1WYWx1ZSgnbGVha3lyZWx1QWxwaGEnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGlzQmlhc0FkZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZWx1ICYmIG51bUFyZ3MgIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdXNlZCBNYXRNdWwgd2l0aCBCaWFzQWRkIGFuZCBQcmVsdSBtdXN0IGhhdmUgdHdvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4dHJhIGFyZ3VtZW50czogYmlhcyBhbmQgYWxwaGEuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNQcmVsdSAmJiBudW1BcmdzICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVzZWQgTWF0TXVsIHdpdGggQmlhc0FkZCBtdXN0IGhhdmUgb25lIGV4dHJhIGFyZ3VtZW50OiBiaWFzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChnZXRQYXJhbVZhbHVlKCdhcmdzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgMiksIGJpYXNBcmcgPSBfYlswXSwgcHJlbHVBcmcgPSBfYlsxXTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuZnVzZWQubWF0TXVsKHtcbiAgICAgICAgICAgICAgICAgICAgYTogZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksXG4gICAgICAgICAgICAgICAgICAgIGI6IGdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3Bvc2VBOiBnZXRQYXJhbVZhbHVlKCd0cmFuc3Bvc2VBJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3NlQjogZ2V0UGFyYW1WYWx1ZSgndHJhbnNwb3NlQicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksXG4gICAgICAgICAgICAgICAgICAgIGJpYXM6IGJpYXNBcmcsXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2YXRpb246IGFjdGl2YXRpb25GdW5jLFxuICAgICAgICAgICAgICAgICAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzOiBwcmVsdUFyZyxcbiAgICAgICAgICAgICAgICAgICAgbGVha3lyZWx1QWxwaGE6IGxlYWt5cmVsdUFscGhhXG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZXhlY3V0ZU9wJGMgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ0Z1c2VkQmF0Y2hOb3JtJzpcbiAgICAgICAgY2FzZSAnRnVzZWRCYXRjaE5vcm1WMic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuYmF0Y2hOb3JtKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdtZWFuJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgndmFyaWFuY2UnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdvZmZzZXQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdzY2FsZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2Vwc2lsb24nLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnRnVzZWRCYXRjaE5vcm1WMyc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuYmF0Y2hOb3JtKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdtZWFuJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgndmFyaWFuY2UnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdvZmZzZXQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdzY2FsZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2Vwc2lsb24nLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnTFJOJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbihnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgncmFkaXVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnYmlhcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2FscGhhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnYmV0YScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdTb2Z0bWF4Jzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5zb2Z0bWF4KGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnTG9nU29mdG1heCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMubG9nU29mdG1heChnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1NwYXJzZVRvRGVuc2UnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnNwYXJzZVRvRGVuc2UoZ2V0UGFyYW1WYWx1ZSgnc3BhcnNlSW5kaWNlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ291dHB1dFNoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnc3BhcnNlVmFsdWVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnZGVmYXVsdFZhbHVlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBleGVjdXRlT3AkZCA9IGZ1bmN0aW9uIChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSAnTWF4Jzoge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBnZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBrZWVwRGltcyA9IGdldFBhcmFtVmFsdWUoJ2tlZXBEaW1zJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMubWF4KGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBheGlzLCBrZWVwRGltcyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ01lYW4nOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGtlZXBEaW1zID0gZ2V0UGFyYW1WYWx1ZSgna2VlcERpbXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5tZWFuKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBheGlzLCBrZWVwRGltcyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ01pbic6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gZ2V0UGFyYW1WYWx1ZSgnYXhpcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIga2VlcERpbXMgPSBnZXRQYXJhbVZhbHVlKCdrZWVwRGltcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLm1pbihnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYXhpcywga2VlcERpbXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdTdW0nOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGtlZXBEaW1zID0gZ2V0UGFyYW1WYWx1ZSgna2VlcERpbXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5zdW0oZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGF4aXMsIGtlZXBEaW1zKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQWxsJzoge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBnZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBrZWVwRGltcyA9IGdldFBhcmFtVmFsdWUoJ2tlZXBEaW1zJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuYWxsKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBheGlzLCBrZWVwRGltcyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0FueSc6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gZ2V0UGFyYW1WYWx1ZSgnYXhpcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIga2VlcERpbXMgPSBnZXRQYXJhbVZhbHVlKCdrZWVwRGltcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmFueShnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYXhpcywga2VlcERpbXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdBcmdNYXgnOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5hcmdNYXgoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGF4aXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdBcmdNaW4nOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5hcmdNaW4oZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGF4aXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdQcm9kJzoge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBnZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBrZWVwRGltcyA9IGdldFBhcmFtVmFsdWUoJ2tlZXBEaW1zJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMucHJvZChnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYXhpcywga2VlcERpbXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdDdW1zdW0nOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGV4Y2x1c2l2ZSA9IGdldFBhcmFtVmFsdWUoJ2V4Y2x1c2l2ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcmV2ZXJzZSA9IGdldFBhcmFtVmFsdWUoJ3JldmVyc2UnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5jdW1zdW0oZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGF4aXMsIGV4Y2x1c2l2ZSwgcmV2ZXJzZSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0JpbmNvdW50JzpcbiAgICAgICAgICAgIHZhciB4ID0gZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgd2VpZ2h0cyA9IGdldFBhcmFtVmFsdWUoJ3dlaWdodHMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSBnZXRQYXJhbVZhbHVlKCdzaXplJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuYmluY291bnQoeCwgd2VpZ2h0cywgc2l6ZSldO1xuICAgICAgICBjYXNlICdEZW5zZUJpbmNvdW50Jzoge1xuICAgICAgICAgICAgdmFyIHhfMSA9IGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHdlaWdodHNfMSA9IGdldFBhcmFtVmFsdWUoJ3dlaWdodHMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHNpemVfMSA9IGdldFBhcmFtVmFsdWUoJ3NpemUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGJpbmFyeU91dHB1dCA9IGdldFBhcmFtVmFsdWUoJ2JpbmFyeU91dHB1dCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmRlbnNlQmluY291bnQoeF8xLCB3ZWlnaHRzXzEsIHNpemVfMSwgYmluYXJ5T3V0cHV0KV07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIGV4ZWN1dGVPcCRlID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdDb25jYXRWMic6XG4gICAgICAgIGNhc2UgJ0NvbmNhdCc6IHtcbiAgICAgICAgICAgIHZhciBuID0gZ2V0UGFyYW1WYWx1ZSgnbicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGlucHV0cyA9IGdldFBhcmFtVmFsdWUoJ3RlbnNvcnMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgaW5wdXRzID0gaW5wdXRzLnNsaWNlKDAsIG4pO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5jb25jYXQoaW5wdXRzLCBheGlzKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnR2F0aGVyJzoge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IGdldFBhcmFtVmFsdWUoJ2luZGljZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5nYXRoZXIoaW5wdXQsIHRmT3BzLmNhc3QoaW5kaWNlcywgJ2ludDMyJyksIDApXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdHYXRoZXJWMic6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gZ2V0UGFyYW1WYWx1ZSgnYXhpcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgYmF0Y2hEaW1zID0gZ2V0UGFyYW1WYWx1ZSgnYmF0Y2hEaW1zJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBnZXRQYXJhbVZhbHVlKCdpbmRpY2VzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuZ2F0aGVyKGlucHV0LCB0Zk9wcy5jYXN0KGluZGljZXMsICdpbnQzMicpLCBheGlzLCBiYXRjaERpbXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdSZXZlcnNlJzoge1xuICAgICAgICAgICAgdmFyIGRpbXMgPSBnZXRQYXJhbVZhbHVlKCdkaW1zJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBheGlzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZGltc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBheGlzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnJldmVyc2UoaW5wdXQsIGF4aXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdSZXZlcnNlVjInOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnJldmVyc2UoaW5wdXQsIGF4aXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdTbGljZSc6IHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IGdldFBhcmFtVmFsdWUoJ2JlZ2luJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgICAgIHZhciBzaXplID0gZ2V0UGFyYW1WYWx1ZSgnc2l6ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnNsaWNlKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBiZWdpbiwgc2l6ZSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1N0cmlkZWRTbGljZSc6IHtcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IGdldFBhcmFtVmFsdWUoJ2JlZ2luJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBnZXRQYXJhbVZhbHVlKCdlbmQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHN0cmlkZXMgPSBnZXRQYXJhbVZhbHVlKCdzdHJpZGVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBiZWdpbk1hc2sgPSBnZXRQYXJhbVZhbHVlKCdiZWdpbk1hc2snLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGVuZE1hc2sgPSBnZXRQYXJhbVZhbHVlKCdlbmRNYXNrJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBlbGxpcHNpc01hc2sgPSBnZXRQYXJhbVZhbHVlKCdlbGxpcHNpc01hc2snLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIG5ld0F4aXNNYXNrID0gZ2V0UGFyYW1WYWx1ZSgnbmV3QXhpc01hc2snLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHNocmlua0F4aXNNYXNrID0gZ2V0UGFyYW1WYWx1ZSgnc2hyaW5rQXhpc01hc2snLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHRlbnNvciA9IGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5zdHJpZGVkU2xpY2UodGVuc29yLCBiZWdpbiwgZW5kLCBzdHJpZGVzLCBiZWdpbk1hc2ssIGVuZE1hc2ssIGVsbGlwc2lzTWFzaywgbmV3QXhpc01hc2ssIHNocmlua0F4aXNNYXNrKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnUGFjayc6IHtcbiAgICAgICAgICAgIHJldHVybiB0Zk9wcy50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IGdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHZhciB0ZW5zb3JzID0gZ2V0UGFyYW1WYWx1ZSgndGVuc29ycycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgLy8gUmVzaGFwZSB0aGUgdGVuc29ycyB0byB0aGUgZmlyc3QgdGVuc29yJ3Mgc2hhcGUgaWYgdGhleSBkb24ndFxuICAgICAgICAgICAgICAgIC8vIG1hdGNoLlxuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHRlbnNvcnNbMF0uc2hhcGU7XG4gICAgICAgICAgICAgICAgdmFyIHNxdWVlemVkU2hhcGUgPSB0Zk9wcy5zcXVlZXplKHRlbnNvcnNbMF0pLnNoYXBlO1xuICAgICAgICAgICAgICAgIHZhciBtYXBwZWQgPSB0ZW5zb3JzLm1hcChmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYW1lU2hhcGUgPSB0Zk9wcy51dGlsLmFycmF5c0VxdWFsKHRlbnNvci5zaGFwZSwgc2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVTaGFwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRmT3BzLnV0aWwuYXJyYXlzRXF1YWwodGZPcHMuc3F1ZWV6ZSh0ZW5zb3IpLnNoYXBlLCBzcXVlZXplZFNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgaW5wdXQgdGVuc29ycyBzaGFwZSBkb2VzIG5vdCBtYXRjaCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzYW1lU2hhcGUgPyB0ZW5zb3IgOiB0Zk9wcy5yZXNoYXBlKHRlbnNvciwgc2hhcGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGZPcHMuc3RhY2sobWFwcGVkLCBheGlzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdVbnBhY2snOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHRlbnNvciA9IGdldFBhcmFtVmFsdWUoJ3RlbnNvcicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdGZPcHMudW5zdGFjayh0ZW5zb3IsIGF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1RpbGUnOiB7XG4gICAgICAgICAgICB2YXIgcmVwcyA9IGdldFBhcmFtVmFsdWUoJ3JlcHMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy50aWxlKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCByZXBzKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnU3BsaXQnOlxuICAgICAgICBjYXNlICdTcGxpdFYnOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIG51bU9yU2l6ZVNwbGl0cyA9IGdldFBhcmFtVmFsdWUoJ251bU9yU2l6ZVNwbGl0cycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgdGVuc29yID0gZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdGZPcHMuc3BsaXQodGVuc29yLCBudW1PclNpemVTcGxpdHMsIGF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1NjYXR0ZXJOZCc6IHtcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gZ2V0UGFyYW1WYWx1ZSgnaW5kaWNlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gZ2V0UGFyYW1WYWx1ZSgndmFsdWVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGdldFBhcmFtVmFsdWUoJ3NoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuc2NhdHRlck5EKGluZGljZXMsIHZhbHVlcywgc2hhcGUpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdHYXRoZXJOZCc6IHtcbiAgICAgICAgICAgIHZhciB4ID0gZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IGdldFBhcmFtVmFsdWUoJ2luZGljZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5nYXRoZXJORCh4LCBpbmRpY2VzKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnU3BhcnNlVG9EZW5zZSc6IHtcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gZ2V0UGFyYW1WYWx1ZSgnc3BhcnNlSW5kaWNlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBnZXRQYXJhbVZhbHVlKCdvdXRwdXRTaGFwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc3BhcnNlVmFsdWVzID0gZ2V0UGFyYW1WYWx1ZSgnc3BhcnNlVmFsdWVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBnZXRQYXJhbVZhbHVlKCdkZWZhdWx0VmFsdWUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5zcGFyc2VUb0RlbnNlKGluZGljZXMsIHNwYXJzZVZhbHVlcywgc2hhcGUsIHNwYXJzZVZhbHVlcy5kdHlwZSA9PT0gZGVmYXVsdFZhbHVlLmR0eXBlID9cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgdGZPcHMuY2FzdChkZWZhdWx0VmFsdWUsIHNwYXJzZVZhbHVlcy5kdHlwZSkpXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZXhlY3V0ZU9wJGYgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ0ZGVCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuZmZ0KGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSUZGVCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuaWZmdChnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1JGRlQnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnJmZnQoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdJUkZGVCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZPcHMuaXJmZnQoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgZXhlY3V0ZU9wJGcgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ0Nhc3QnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmNhc3QoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2R0eXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0V4cGFuZERpbXMnOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5leHBhbmREaW1zKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBheGlzKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnU3F1ZWV6ZSc6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gZ2V0UGFyYW1WYWx1ZSgnYXhpcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnNxdWVlemUoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGF4aXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdSZXNoYXBlJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5yZXNoYXBlKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBnZXRQYXJhbVZhbHVlKCdzaGFwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdNaXJyb3JQYWQnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLm1pcnJvclBhZChnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgncGFkZGluZycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ21vZGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnUGFkVjInOlxuICAgICAgICBjYXNlICdQYWQnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLnBhZChnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgncGFkZGluZycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGdldFBhcmFtVmFsdWUoJ2NvbnN0YW50VmFsdWUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnU3BhY2VUb0JhdGNoTkQnOiB7XG4gICAgICAgICAgICB2YXIgYmxvY2tTaGFwZSA9IGdldFBhcmFtVmFsdWUoJ2Jsb2NrU2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdzID0gZ2V0UGFyYW1WYWx1ZSgncGFkZGluZ3MnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5zcGFjZVRvQmF0Y2hORChnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYmxvY2tTaGFwZSwgcGFkZGluZ3MpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdCYXRjaFRvU3BhY2VORCc6IHtcbiAgICAgICAgICAgIHZhciBibG9ja1NoYXBlID0gZ2V0UGFyYW1WYWx1ZSgnYmxvY2tTaGFwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgY3JvcHMgPSBnZXRQYXJhbVZhbHVlKCdjcm9wcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmT3BzLmJhdGNoVG9TcGFjZU5EKGdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBibG9ja1NoYXBlLCBjcm9wcyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0RlcHRoVG9TcGFjZSc6IHtcbiAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBnZXRQYXJhbVZhbHVlKCdibG9ja1NpemUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGRhdGFGb3JtYXQgPSBnZXRQYXJhbVZhbHVlKCdkYXRhRm9ybWF0Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5kZXB0aFRvU3BhY2UoZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGJsb2NrU2l6ZSwgZGF0YUZvcm1hdCldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0Jyb2FkY2FzdFRvJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0Zk9wcy5icm9hZGNhc3RUbyhnZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgZ2V0UGFyYW1WYWx1ZSgnc2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBFeGVjdXRlcyB0aGUgb3AgZGVmaW5lZCBieSB0aGUgbm9kZSBvYmplY3QuXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIHRlbnNvck1hcCBjb250YWlucyB0ZW5zb3JzIGZvciBleGVjdXRlZCBub2RlcyBhbmQgd2VpZ2h0c1xuICogQHBhcmFtIGNvbnRleHQgY29udGFpbnMgdGVuc29ycyBhbmQgaW5mb3JtYXRpb24gZm9yIHJ1bm5pbmcgdGhlIGN1cnJlbnQgbm9kZS5cbiAqIEBwYXJhbSByZXNvdXJjZU1hbmFnZXIgT3B0aW9uYWwuIENvbnRhaW5zIGdsb2JhbCByZXNvdXJjZXMgb2YgdGhlIG1vZGVsLlxuICovXG5mdW5jdGlvbiBleGVjdXRlT3AkaChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQsIHJlc291cmNlTWFuYWdlcikge1xuICAgIHZhciB2YWx1ZSA9IChmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS5jYXRlZ29yeSkge1xuICAgICAgICAgICAgY2FzZSAnYXJpdGhtZXRpYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmT3BzLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhlY3V0ZU9wKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7IH0pO1xuICAgICAgICAgICAgY2FzZSAnYmFzaWNfbWF0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmT3BzLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhlY3V0ZU9wJDEobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgICBjYXNlICdjb250cm9sJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZU9wJDIobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNhc2UgJ2NvbnZvbHV0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZPcHMudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiBleGVjdXRlT3AkMyhub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICAgIGNhc2UgJ2NyZWF0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZPcHMudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiBleGVjdXRlT3AkNChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICAgIGNhc2UgJ2R5bmFtaWMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBleGVjdXRlT3AkNShub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgY2FzZSAnZXZhbHVhdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmT3BzLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhlY3V0ZU9wJDYobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmT3BzLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhlY3V0ZU9wJDkobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgICBjYXNlICdncmFwaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmT3BzLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhlY3V0ZU9wJDcobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgICBjYXNlICdsb2dpY2FsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZPcHMudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiBleGVjdXRlT3AkYShub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICAgIGNhc2UgJ21hdHJpY2VzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZPcHMudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiBleGVjdXRlT3AkYihub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICAgIGNhc2UgJ25vcm1hbGl6YXRpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0Zk9wcy50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4ZWN1dGVPcCRjKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7IH0pO1xuICAgICAgICAgICAgY2FzZSAncmVkdWN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZPcHMudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiBleGVjdXRlT3AkZChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICAgIGNhc2UgJ3NsaWNlX2pvaW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0Zk9wcy50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4ZWN1dGVPcCRlKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7IH0pO1xuICAgICAgICAgICAgY2FzZSAnc3BlY3RyYWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0Zk9wcy50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4ZWN1dGVPcCRmKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7IH0pO1xuICAgICAgICAgICAgY2FzZSAndHJhbnNmb3JtYXRpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0Zk9wcy50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4ZWN1dGVPcCRnKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7IH0pO1xuICAgICAgICAgICAgY2FzZSAnaGFzaF90YWJsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVPcCQ4KG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCwgcmVzb3VyY2VNYW5hZ2VyKTtcbiAgICAgICAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgICAgICAgICAgdmFyIG9wTWFwcGVyID0gZ2V0UmVnaXN0ZXJlZE9wKG5vZGUub3ApO1xuICAgICAgICAgICAgICAgIGlmIChvcE1hcHBlciAmJiBvcE1hcHBlci5jdXN0b21FeGVjdXRvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BNYXBwZXIuY3VzdG9tRXhlY3V0b3IobmV3IE5vZGVWYWx1ZUltcGwobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJDdXN0b20gb3AgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IHJlZ2lzdGVyZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiVW5rbm93biBvcCAnXCIgKyBub2RlLm9wICsgXCInLiBGaWxlIGFuIGlzc3VlIGF0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2lzc3VlcyBzbyB3ZSBjYW4gYWRkIGl0XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiwgb3IgcmVnaXN0ZXIgYSBjdXN0b20gZXhlY3V0aW9uIHdpdGggdGYucmVnaXN0ZXJPcCgpXCIpO1xuICAgICAgICB9XG4gICAgfSkobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICBpZiAodGZPcHMudXRpbC5pc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBbXS5jb25jYXQoZGF0YSk7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gW10uY29uY2F0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb25Db250ZXh0IGNhcHR1cmVzIHRoZSBydW50aW1lIGVudmlyb25tZW50IG9mIHRoZSBub2RlLiBJdCBrZWVwc1xuICogdHJhY2sgb2YgdGhlIGN1cnJlbnQgZnJhbWUgYW5kIGl0ZXJhdGlvbiBmb3IgdGhlIGNvbnRyb2wgZmxvdyBvcHMuXG4gKlxuICogRm9yIGV4YW1wbGUsIHR5cGljYWwgRHluYW1pYyBSTk4gbW9kZWwgbWF5IGNvbnRhaW4gbG9vcHMsIGZvciB3aGljaFxuICogVGVuc29yRmxvdyB3aWxsIGdlbmVyYXRlIGdyYXBocyB3aXRoIEVudGVyL0V4aXQgbm9kZXMgdG8gY29udHJvbCB0aGVcbiAqIGN1cnJlbnQgZXhlY3V0aW9uIGZyYW1lLCBhbmQgTmV4dEl0ZXJhdGlvbiBOb2RlcyBmb3IgaXRlcmF0aW9uIGlkIGluY3JlbWVudC5cbiAqIEZvciBtb2RlbCB3aXRoIGJyYW5jaCBsb2dpYywgVGVuc29yRkxvdyB3aWxsIGdlbmVyYXRlIFN3aXRjaC9NZXJnZSBvcHMuXG4gKi9cbnZhciBFeGVjdXRpb25Db250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4ZWN1dGlvbkNvbnRleHQod2VpZ2h0TWFwLCB0ZW5zb3JBcnJheU1hcCwgdGVuc29yTGlzdE1hcCwgZnVuY3Rpb25NYXApIHtcbiAgICAgICAgaWYgKHdlaWdodE1hcCA9PT0gdm9pZCAwKSB7IHdlaWdodE1hcCA9IHt9OyB9XG4gICAgICAgIGlmICh0ZW5zb3JBcnJheU1hcCA9PT0gdm9pZCAwKSB7IHRlbnNvckFycmF5TWFwID0ge307IH1cbiAgICAgICAgaWYgKHRlbnNvckxpc3RNYXAgPT09IHZvaWQgMCkgeyB0ZW5zb3JMaXN0TWFwID0ge307IH1cbiAgICAgICAgaWYgKGZ1bmN0aW9uTWFwID09PSB2b2lkIDApIHsgZnVuY3Rpb25NYXAgPSB7fTsgfVxuICAgICAgICB0aGlzLndlaWdodE1hcCA9IHdlaWdodE1hcDtcbiAgICAgICAgdGhpcy50ZW5zb3JBcnJheU1hcCA9IHRlbnNvckFycmF5TWFwO1xuICAgICAgICB0aGlzLnRlbnNvckxpc3RNYXAgPSB0ZW5zb3JMaXN0TWFwO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTWFwID0gZnVuY3Rpb25NYXA7XG4gICAgICAgIHRoaXMucm9vdENvbnRleHQgPSB7IGlkOiAwLCBmcmFtZU5hbWU6ICcnLCBpdGVyYXRpb25JZDogMCB9O1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gW3RoaXMucm9vdENvbnRleHRdO1xuICAgICAgICB0aGlzLmxhc3RJZCA9IDA7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpO1xuICAgIH1cbiAgICBFeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZS5uZXdGcmFtZSA9IGZ1bmN0aW9uIChpZCwgZnJhbWVOYW1lKSB7XG4gICAgICAgIHJldHVybiB7IGlkOiBpZCwgZnJhbWVOYW1lOiBmcmFtZU5hbWUsIGl0ZXJhdGlvbklkOiAwIH07XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwiY3VycmVudENvbnRleHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIGNvbnRleHRzOiBFeGVjdXRpb25Db250ZXh0SW5mb1tdIHRoZSBjdXJyZW50IHBhdGggb2YgZXhlY3V0aW9uXG4gICAgICAgICAqIGZyYW1lc1xuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoY29udGV4dHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHRzICE9PSBjb250ZXh0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dHMgPSBjb250ZXh0cztcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlQ3VycmVudENvbnRleHRJZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLCBcImN1cnJlbnRDb250ZXh0SWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBjb250ZXh0IGluIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q29udGV4dElkc1swXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLCBcImN1cnJlbnRDb250ZXh0SWRzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgY29udGV4dCBhbmQgYWxsIHBhcmVudCBjb250ZXh0cyBpbiBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgKiBUaGlzIGFsbG93IGFjY2VzcyB0byB0aGUgbm9kZXMgaW4gdGhlIGN1cnJlbnQgYW5kIHBhcmVudCBmcmFtZXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q29udGV4dElkcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHMuc2xpY2UoMCwgdGhpcy5jb250ZXh0cy5sZW5ndGggLSBpKTtcbiAgICAgICAgICAgIG5hbWVzLnB1c2godGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyhjb250ZXh0cykpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzLnB1c2goJycpO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q29udGV4dElkcyA9IG5hbWVzO1xuICAgIH07XG4gICAgRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuY29udGV4dElkZm9yQ29udGV4dHMgPSBmdW5jdGlvbiAoY29udGV4dHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRzID9cbiAgICAgICAgICAgIGNvbnRleHRzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gKGNvbnRleHQuaWQgPT09IDAgJiYgY29udGV4dC5pdGVyYXRpb25JZCA9PT0gMCkgP1xuICAgICAgICAgICAgICAgICcnIDpcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZyYW1lTmFtZSArIFwiLVwiICsgY29udGV4dC5pdGVyYXRpb25JZDsgfSlcbiAgICAgICAgICAgICAgICAuam9pbignLycpIDpcbiAgICAgICAgICAgICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW50ZXIgYSBuZXcgZnJhbWUsIGEgbmV3IGNvbnRleHQgaXMgcHVzaGVkIG9uIHRoZSBjdXJyZW50IGNvbnRleHQgbGlzdC5cbiAgICAgKiBAcGFyYW0gZnJhbWVJZCBuZXcgZnJhbWUgaWRcbiAgICAgKi9cbiAgICBFeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZS5lbnRlckZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSWQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dHMpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdElkKys7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzID0gdGhpcy5jb250ZXh0cy5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5wdXNoKHRoaXMubmV3RnJhbWUodGhpcy5sYXN0SWQsIGZyYW1lSWQpKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzLnVuc2hpZnQodGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyh0aGlzLmNvbnRleHRzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4aXQgdGhlIGN1cnJlbnQgZnJhbWUsIHRoZSBsYXN0IGNvbnRleHQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBjdXJyZW50XG4gICAgICogY29udGV4dCBsaXN0LlxuICAgICAqL1xuICAgIEV4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLmV4aXRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dHMgJiYgdGhpcy5jb250ZXh0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzID0gdGhpcy5jb250ZXh0cy5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5zcGxpY2UoLTEpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29udGV4dElkcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZXhpdCBmcmFtZSwgdGhlIGNvbnRleHQgaXMgZW1wdHknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRW50ZXIgdGhlIG5leHQgaXRlcmF0aW9uIG9mIGEgbG9vcCwgdGhlIGl0ZXJhdGlvbiBpZCBvZiBsYXN0IGNvbnRleHQgaXNcbiAgICAgKiBpbmNyZWFzZWQuXG4gICAgICovXG4gICAgRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUubmV4dEl0ZXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dHMgJiYgdGhpcy5jb250ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzID0gdGhpcy5jb250ZXh0cy5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5sYXN0SWQrKztcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuaXRlcmF0aW9uSWQgKz0gMTtcbiAgICAgICAgICAgIGNvbnRleHQuaWQgPSB0aGlzLmxhc3RJZDtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMuc3BsaWNlKC0xLCAxLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzLnNwbGljZSgwLCAxLCB0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKHRoaXMuY29udGV4dHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGluY3JlYXNlIGZyYW1lIGl0ZXJhdGlvbiwgdGhlIGNvbnRleHQgaXMgZW1wdHknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuZ2V0V2VpZ2h0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2VpZ2h0TWFwW25hbWVdO1xuICAgIH07XG4gICAgRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuYWRkVGVuc29yQXJyYXkgPSBmdW5jdGlvbiAodGVuc29yQXJyYXkpIHtcbiAgICAgICAgdGhpcy50ZW5zb3JBcnJheU1hcFt0ZW5zb3JBcnJheS5pZF0gPSB0ZW5zb3JBcnJheTtcbiAgICB9O1xuICAgIEV4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLmdldFRlbnNvckFycmF5ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlbnNvckFycmF5TWFwW2lkXTtcbiAgICB9O1xuICAgIEV4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLmFkZFRlbnNvckxpc3QgPSBmdW5jdGlvbiAodGVuc29yTGlzdCkge1xuICAgICAgICB0aGlzLnRlbnNvckxpc3RNYXBbdGVuc29yTGlzdC5pZF0gPSB0ZW5zb3JMaXN0O1xuICAgIH07XG4gICAgRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuZ2V0VGVuc29yTGlzdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZW5zb3JMaXN0TWFwW2lkXTtcbiAgICB9O1xuICAgIEV4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoa2VlcElkcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy50ZW5zb3JBcnJheU1hcCkge1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JBcnJheU1hcFtrZXldLmNsZWFyQW5kQ2xvc2Uoa2VlcElkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMudGVuc29yTGlzdE1hcCkge1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JMaXN0TWFwW2tleV0uY2xlYXJBbmRDbG9zZShrZWVwSWRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEV4ZWN1dGlvbkNvbnRleHQ7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEdpdmVuIGdyYXBoIGlucHV0cyBhbmQgZGVzaXJlZCBvdXRwdXRzLCBmaW5kIHRoZSBtaW5pbWFsIHNldCBvZiBub2Rlc1xuICogdG8gZXhlY3V0ZSBpbiBvcmRlciB0byBjb21wdXRlIHRoZSBvdXRwdXRzLiBJbiBhZGRpdGlvbiByZXR1cm4gb3RoZXIgdXNlZnVsXG4gKiBpbmZvIHN1Y2g6XG4gKiAtIE1pc3NpbmcgaW5wdXRzIG5lZWRlZCB0byBjb21wdXRlIHRoZSBvdXRwdXQuXG4gKiAtIFdoZXRoZXIgdGhlIHN1YmdyYXBoIGNvbnRhaW5zIGR5bmFtaWMgb3BzIChjb250cm9sIGZsb3csIGR5bmFtaWMgc2hhcGUpLlxuICogLSBBbHRlcm5hdGl2ZSBpbnB1dHMgaW4gb3JkZXIgdG8gYXZvaWQgYXN5bmMgKGR5bmFtaWMgb3ApIGV4ZWN1dGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0RXhlY3V0aW9uU3ViZ3JhcGgoaW5wdXRzLCBvdXRwdXRzLCB3ZWlnaHRNYXAsIGluaXROb2Rlcykge1xuICAgIHZhciB1c2VkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIG1pc3NpbmdJbnB1dHMgPSBbXTtcbiAgICB2YXIgZHluYW1pY05vZGUgPSBudWxsO1xuICAgIHZhciBzeW5jSW5wdXRzID0gbnVsbDtcbiAgICAvLyBTdGFydCB3aXRoIHRoZSBvdXRwdXRzLCBnb2luZyBiYWNrd2FyZHMgYW5kIGZpbmQgYWxsIHRoZSBub2RlcyB0aGF0IGFyZVxuICAgIC8vIG5lZWRlZCB0byBjb21wdXRlIHRob3NlIG91dHB1dHMuXG4gICAgdmFyIHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgdmFyIGlucHV0Tm9kZU5hbWVzID0gT2JqZWN0LmtleXMoaW5wdXRzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHBhcnNlTm9kZU5hbWUobmFtZSlbMF07IH0pO1xuICAgIHZhciBpbml0Tm9kZU5hbWVzID0gW107XG4gICAgaWYgKGluaXROb2RlcyAhPSBudWxsKSB7XG4gICAgICAgIGluaXROb2RlTmFtZXMgPSBpbml0Tm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBwYXJzZU5vZGVOYW1lKG5vZGUubmFtZSlbMF07IH0pO1xuICAgIH1cbiAgICB2YXIgZnJvbnRpZXIgPSBfX3NwcmVhZChvdXRwdXRzKTtcbiAgICB3aGlsZSAoZnJvbnRpZXIubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbm9kZSA9IGZyb250aWVyLnBvcCgpO1xuICAgICAgICBpZiAoaXNDb250cm9sRmxvdyhub2RlKSB8fCBpc0R5bmFtaWNTaGFwZShub2RlKSB8fCBpc0hhc2hUYWJsZShub2RlKSkge1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNOb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgc3luY0lucHV0cyA9IGR5bmFtaWNOb2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLm5hbWU7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHVzZWROb2Rlcy5oYXMobmFtZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVzZWROb2Rlcy5hZGQobm9kZS5uYW1lKTtcbiAgICAgICAgLy8gV2VpZ2h0cyBhcmUgZGVhZCBlbmQgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIHRoZWlyIHZhbHVlcy5cbiAgICAgICAgaWYgKHdlaWdodE1hcFtub2RlLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgbm9kZSBpcyBhIGRlYWQgZW5kIHNpbmNlIGl0J3Mgb25lIG9mIHRoZSB1c2VyLXByb3ZpZGVkIGlucHV0cy5cbiAgICAgICAgaWYgKGlucHV0Tm9kZU5hbWVzLmluZGV4T2Yobm9kZS5uYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgbm9kZSBpcyBhIGRlYWQgZW5kIHNpbmNlIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgaW5wdXRzLlxuICAgICAgICBpZiAoaW5pdE5vZGVOYW1lcy5pbmRleE9mKG5vZGUubmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5pbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtaXNzaW5nSW5wdXRzLnB1c2gobm9kZS5uYW1lKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGZyb250aWVyIGlmIGl0IGlzIGFscmVhZHkgdGhlcmUuXG4gICAgICAgICAgICBpZiAoc2Vlbi5oYXMoaW5wdXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuLmFkZChpbnB1dC5uYW1lKTtcbiAgICAgICAgICAgIGZyb250aWVyLnB1c2goaW5wdXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5wdXRzOiBpbnB1dHMsIG91dHB1dHM6IG91dHB1dHMsIHVzZWROb2RlczogdXNlZE5vZGVzLCBtaXNzaW5nSW5wdXRzOiBtaXNzaW5nSW5wdXRzLCBkeW5hbWljTm9kZTogZHluYW1pY05vZGUsIHN5bmNJbnB1dHM6IHN5bmNJbnB1dHMgfTtcbn1cbi8qKlxuICogR2l2ZW4gdGhlIGV4ZWN1dGlvbiBpbmZvLCByZXR1cm4gYSBsaXN0IG9mIG5vZGVzIGluIHRvcG9sb2dpY2FsIG9yZGVyIHRoYXRcbiAqIG5lZWQgdG8gYmUgZXhlY3V0ZWQgdG8gY29tcHV0ZSB0aGUgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBnZXROb2Rlc0luVG9wb2xvZ2ljYWxPcmRlcihncmFwaCwgd2VpZ2h0TWFwLCBleGVjdXRpb25JbmZvKSB7XG4gICAgdmFyIHVzZWROb2RlcyA9IGV4ZWN1dGlvbkluZm8udXNlZE5vZGVzLCBpbnB1dHMgPSBleGVjdXRpb25JbmZvLmlucHV0cztcbiAgICB2YXIgZnJvbnRpZXIgPSBbXTtcbiAgICB2YXIgaW5wdXROb2RlcyA9IE9iamVjdC5rZXlzKGlucHV0cylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcGFyc2VOb2RlTmFtZShuYW1lKVswXTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ3JhcGgubm9kZXNbbmFtZV07IH0pO1xuICAgIHZhciBpbml0Tm9kZXMgPSBncmFwaC5pbml0Tm9kZXM7XG4gICAgaW5wdXROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodXNlZE5vZGVzLmhhcyhpbnB1dC5uYW1lKSkge1xuICAgICAgICAgICAgZnJvbnRpZXIucHVzaChpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBncmFwaC53ZWlnaHRzLmZvckVhY2goZnVuY3Rpb24gKHdlaWdodCkge1xuICAgICAgICBpZiAodXNlZE5vZGVzLmhhcyh3ZWlnaHQubmFtZSkpIHtcbiAgICAgICAgICAgIGZyb250aWVyLnB1c2god2VpZ2h0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChpbml0Tm9kZXMgIT0gbnVsbCkge1xuICAgICAgICBpbml0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKHVzZWROb2Rlcy5oYXMobm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGZyb250aWVyLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB2YXIgb3JkZXJlZE5vZGVzID0gW107XG4gICAgd2hpbGUgKGZyb250aWVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG5vZGUgPSBmcm9udGllci5wb3AoKTtcbiAgICAgICAgc2Vlbi5hZGQobm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKCF3ZWlnaHRNYXBbbm9kZS5uYW1lXSkge1xuICAgICAgICAgICAgb3JkZXJlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhjaGlsZC5uYW1lKSAmJiB1c2VkTm9kZXMuaGFzKGNoaWxkLm5hbWUpICYmXG4gICAgICAgICAgICAgICAgY2hpbGQuaW5wdXRzLmV2ZXJ5KGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gc2Vlbi5oYXMoaW5wdXQubmFtZSk7IH0pKSB7XG4gICAgICAgICAgICAgICAgZnJvbnRpZXIucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JkZXJlZE5vZGVzO1xufVxudmFyIENPTlRST0xfRkxPV19PUFMgPSBbXG4gICAgJ1N3aXRjaCcsICdNZXJnZScsICdFbnRlcicsICdFeGl0JywgJ05leHRJdGVyYXRpb24nLCAnU3RhdGVsZXNzSWYnLFxuICAgICdTdGF0ZWxlc3NXaGlsZScsICdpZicsICdXaGlsZSdcbl07XG52YXIgRFlOQU1JQ19TSEFQRV9PUFMgPSBbXG4gICAgJ05vbk1heFN1cHByZXNzaW9uVjInLCAnTm9uTWF4U3VwcHJlc3Npb25WMycsICdOb25NYXhTdXBwcmVzc2lvblY1JywgJ1doZXJlJ1xuXTtcbnZhciBIQVNIX1RBQkxFX09QUyA9IFtcbiAgICAnSGFzaFRhYmxlJywgJ0hhc2hUYWJsZVYyJywgJ0xvb2t1cFRhYmxlSW1wb3J0JywgJ0xvb2t1cFRhYmxlSW1wb3J0VjInLFxuICAgICdMb29rdXBUYWJsZUZpbmQnLCAnTG9va3VwVGFibGVGaW5kVjInXG5dO1xuZnVuY3Rpb24gaXNDb250cm9sRmxvdyhub2RlKSB7XG4gICAgcmV0dXJuIENPTlRST0xfRkxPV19PUFMuaW5kZXhPZihub2RlLm9wKSA+PSAwO1xufVxuZnVuY3Rpb24gaXNEeW5hbWljU2hhcGUobm9kZSkge1xuICAgIHJldHVybiBEWU5BTUlDX1NIQVBFX09QUy5pbmRleE9mKG5vZGUub3ApID49IDA7XG59XG5mdW5jdGlvbiBpc0hhc2hUYWJsZShub2RlKSB7XG4gICAgcmV0dXJuIEhBU0hfVEFCTEVfT1BTLmluZGV4T2Yobm9kZS5vcCkgPj0gMDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIEdyYXBoRXhlY3V0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JhcGggR3JhcGggdGhlIG1vZGVsIG9yIGZ1bmN0aW9uIGdyYXBoIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSBwYXJlbnQgV2hlbiBidWlsZGluZyBmdW5jdGlvbiBleGVjdG9yIHlvdSBuZWVkIHRvIHNldCB0aGUgcGFyZW50XG4gICAgICogZXhlY3V0b3IuIFNpbmNlIHRoZSB3ZWlnaHRzIGFuZCBmdW5jdGlvbiBleGVjdXRvciBtYXBzIGFyZSBzZXQgYXQgcGFyYW50XG4gICAgICogbGV2ZWwsIHRoYXQgZnVuY3Rpb24gZXhlY3V0b3IgY2FuIGFjY2VzcyB0aGUgZnVuY3Rpb24gbWFwcyBhbmQgd2VpZ2h0IG1hcHNcbiAgICAgKiB0aHJvdWdoIHRoZSBwYXJlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gR3JhcGhFeGVjdXRvcihncmFwaCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuY29tcGlsZWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3dlaWdodE1hcCA9IHt9O1xuICAgICAgICB0aGlzLlNFUEVSQVRPUiA9ICcsJztcbiAgICAgICAgdGhpcy5fZnVuY3Rpb25zID0ge307XG4gICAgICAgIHRoaXMuX2Z1bmN0aW9uRXhlY3V0b3JNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5fb3V0cHV0cyA9IGdyYXBoLm91dHB1dHM7XG4gICAgICAgIHRoaXMuX2lucHV0cyA9IGdyYXBoLmlucHV0cztcbiAgICAgICAgdGhpcy5faW5pdE5vZGVzID0gZ3JhcGguaW5pdE5vZGVzO1xuICAgICAgICB0aGlzLl9zaWduYXR1cmUgPSBncmFwaC5zaWduYXR1cmU7XG4gICAgICAgIHRoaXMuX2Z1bmN0aW9ucyA9IGdyYXBoLmZ1bmN0aW9ucztcbiAgICAgICAgLy8gY3JlYXRlIHN1Yi1ncmFwaCBleGVjdXRvcnNcbiAgICAgICAgaWYgKGdyYXBoLmZ1bmN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhncmFwaC5mdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZnVuY3Rpb25FeGVjdXRvck1hcFtuYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgIG5ldyBHcmFwaEV4ZWN1dG9yKGdyYXBoLmZ1bmN0aW9uc1tuYW1lXSwgX3RoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLCBcIndlaWdodElkc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQud2VpZ2h0SWRzIDogdGhpcy5fd2VpZ2h0SWRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhFeGVjdXRvci5wcm90b3R5cGUsIFwiZnVuY3Rpb25FeGVjdXRvck1hcFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuZnVuY3Rpb25FeGVjdXRvck1hcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVuY3Rpb25FeGVjdXRvck1hcDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLCBcIndlaWdodE1hcFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQud2VpZ2h0TWFwIDogdGhpcy5fd2VpZ2h0TWFwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh3ZWlnaHRNYXApIHtcbiAgICAgICAgICAgIHZhciB3ZWlnaHRJZHMgPSBPYmplY3Qua2V5cyh3ZWlnaHRNYXApLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB3ZWlnaHRNYXBba2V5XS5tYXAoZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGVuc29yLmlkOyB9KTsgfSk7XG4gICAgICAgICAgICB0aGlzLl93ZWlnaHRJZHMgPSBbXS5jb25jYXQuYXBwbHkoW10sIF9fc3ByZWFkKHdlaWdodElkcykpO1xuICAgICAgICAgICAgdGhpcy5fd2VpZ2h0TWFwID0gd2VpZ2h0TWFwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhFeGVjdXRvci5wcm90b3R5cGUsIFwicmVzb3VyY2VNYW5hZ2VyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBgUmVzb3VyY2VNYW5hZ2VyYCBzaGFyZWQgYnkgZXhlY3V0b3JzIG9mIGEgbW9kZWwuXG4gICAgICAgICAqIEBwYXJhbSByZXNvdXJjZU1hbmFnZXI6IGBSZXNvdXJjZU1hbmFnZXJgIG9mIHRoZSBgR3JhcGhNb2RlbGAuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyZXNvdXJjZU1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc291cmNlTWFuYWdlciA9IHJlc291cmNlTWFuYWdlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLCBcImlucHV0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0cy5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBub2RlLmF0dHJQYXJhbXNbJ3NoYXBlJ10gP1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hdHRyUGFyYW1zWydzaGFwZSddLnZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZHR5cGU6IG5vZGUuYXR0clBhcmFtc1snZHR5cGUnXSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHJQYXJhbXNbJ2R0eXBlJ10udmFsdWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhFeGVjdXRvci5wcm90b3R5cGUsIFwib3V0cHV0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX291dHB1dHMubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzaGFwZTogbm9kZS5hdHRyUGFyYW1zWydzaGFwZSddID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0clBhcmFtc1snc2hhcGUnXS52YWx1ZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGR0eXBlOiBub2RlLmF0dHJQYXJhbXNbJ2R0eXBlJ10gP1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hdHRyUGFyYW1zWydkdHlwZSddLnZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLCBcImlucHV0Tm9kZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dHMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnNpZ25hdHVyZUtleSB8fCBub2RlLm5hbWU7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhFeGVjdXRvci5wcm90b3R5cGUsIFwib3V0cHV0Tm9kZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdXRwdXRzLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5zaWduYXR1cmVLZXkgfHwgbm9kZS5uYW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmRlZmF1bHRPdXRwdXQgPyAobmFtZSArIFwiOlwiICsgbm9kZS5kZWZhdWx0T3V0cHV0KSA6IG5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLCBcImZ1bmN0aW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9mdW5jdGlvbnMpLnJlZHVjZShmdW5jdGlvbiAobWFwLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBtYXBba2V5XSA9IF90aGlzLl9mdW5jdGlvbnNba2V5XS5zaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgR3JhcGhFeGVjdXRvci5wcm90b3R5cGUuZ2V0Q29tcGlsYXRpb25LZXkgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXRzKSB7XG4gICAgICAgIHZhciBzb3J0ZWRJbnB1dHMgPSBpbnB1dHMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5hbWU7IH0pLnNvcnQoKTtcbiAgICAgICAgdmFyIHNvcnRlZE91dHB1dHMgPSBvdXRwdXRzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5uYW1lOyB9KS5zb3J0KCk7XG4gICAgICAgIHJldHVybiBzb3J0ZWRJbnB1dHMuam9pbih0aGlzLlNFUEVSQVRPUikgKyAnLS0nICtcbiAgICAgICAgICAgIHNvcnRlZE91dHB1dHMuam9pbih0aGlzLlNFUEVSQVRPUik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21waWxlcyB0aGUgaW5mZXJlbmNlIGdyYXBoIGFuZCByZXR1cm5zIHRoZSBtaW5pbWFsIHNldCBvZiBub2RlcyB0aGF0IGFyZVxuICAgICAqIHJlcXVpcmVkIGZvciBleGVjdXRpb24sIGluIHRoZSBjb3JyZWN0IGV4ZWN1dGlvbiBvcmRlci5cbiAgICAgKi9cbiAgICBHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0cykge1xuICAgICAgICB2YXIgZXhlY3V0aW9uSW5mbyA9IGdldEV4ZWN1dGlvblN1YmdyYXBoKGlucHV0cywgb3V0cHV0cywgdGhpcy53ZWlnaHRNYXAsIHRoaXMuX2luaXROb2Rlcyk7XG4gICAgICAgIHZhciBtaXNzaW5nSW5wdXRzID0gZXhlY3V0aW9uSW5mby5taXNzaW5nSW5wdXRzLCBkeW5hbWljTm9kZSA9IGV4ZWN1dGlvbkluZm8uZHluYW1pY05vZGUsIHN5bmNJbnB1dHMgPSBleGVjdXRpb25JbmZvLnN5bmNJbnB1dHM7XG4gICAgICAgIGlmIChkeW5hbWljTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGV4ZWN1dGlvbiBjb250YWlucyB0aGUgbm9kZSAnXCIgKyBkeW5hbWljTm9kZS5uYW1lICsgXCInLCB3aGljaCBoYXMgXCIgK1xuICAgICAgICAgICAgICAgIChcInRoZSBkeW5hbWljIG9wICdcIiArIGR5bmFtaWNOb2RlLm9wICsgXCInLiBQbGVhc2UgdXNlIFwiKSArXG4gICAgICAgICAgICAgICAgXCJtb2RlbC5leGVjdXRlQXN5bmMoKSBpbnN0ZWFkLiBBbHRlcm5hdGl2ZWx5LCB0byBhdm9pZCB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIChcImR5bmFtaWMgb3BzLCBzcGVjaWZ5IHRoZSBpbnB1dHMgW1wiICsgc3luY0lucHV0cyArIFwiXVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pc3NpbmdJbnB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIG91dE5hbWVzID0gb3V0cHV0cy5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ubmFtZTsgfSk7XG4gICAgICAgICAgICB2YXIgaW5OYW1lcyA9IE9iamVjdC5rZXlzKGlucHV0cyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSB0aGUgb3V0cHV0cyBbXCIgKyBvdXROYW1lcyArIFwiXSBmcm9tIHRoZSBwcm92aWRlZCBpbnB1dHMgXCIgK1xuICAgICAgICAgICAgICAgIChcIltcIiArIGluTmFtZXMgKyBcIl0uIE1pc3NpbmcgdGhlIGZvbGxvd2luZyBpbnB1dHM6IFtcIiArIG1pc3NpbmdJbnB1dHMgKyBcIl1cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXROb2Rlc0luVG9wb2xvZ2ljYWxPcmRlcih0aGlzLmdyYXBoLCB0aGlzLndlaWdodE1hcCwgZXhlY3V0aW9uSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgaW5mZXJlbmNlIGZvciBnaXZlbiBpbnB1dCB0ZW5zb3JzLlxuICAgICAqIEBwYXJhbSBpbnB1dHMgVGVuc29yIG1hcCBmb3IgdGhlIG1vZGVsIGlucHV0cywga2V5ZWQgYnkgdGhlIGlucHV0IG5vZGVcbiAgICAgKiBuYW1lcy5cbiAgICAgKiBAcGFyYW0gb3V0cHV0cyBPcHRpb25hbC4gb3V0cHV0IG5vZGUgbmFtZSBmcm9tIHRoZSBUZW5zb3JmbG93IG1vZGVsLCBpZlxuICAgICAqIG5vIG91dHB1dHMgYXJlIHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgb3V0cHV0cyBvZiB0aGUgbW9kZWwgd291bGQgYmUgdXNlZC5cbiAgICAgKiBZb3UgY2FuIGluc3BlY3QgaW50ZXJtZWRpYXRlIG5vZGVzIG9mIHRoZSBtb2RlbCBieSBhZGRpbmcgdGhlbSB0byB0aGVcbiAgICAgKiBvdXRwdXRzIGFycmF5LlxuICAgICAqL1xuICAgIEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlucHV0cyA9IHRoaXMubWFwSW5wdXRzKGlucHV0cyk7XG4gICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGlucHV0cykuc29ydCgpO1xuICAgICAgICB0aGlzLmNoZWNrSW5wdXRzKGlucHV0cyk7XG4gICAgICAgIHRoaXMuY2hlY2tJbnB1dFNoYXBlQW5kVHlwZShpbnB1dHMpO1xuICAgICAgICBvdXRwdXRzID0gdGhpcy5tYXBPdXRwdXRzKG91dHB1dHMpO1xuICAgICAgICB0aGlzLmNoZWNrT3V0cHV0cyhvdXRwdXRzKTtcbiAgICAgICAgdmFyIGlucHV0Tm9kZXMgPSBuYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmdyYXBoLm5vZGVzW3BhcnNlTm9kZU5hbWUobmFtZSlbMF1dOyB9KTtcbiAgICAgICAgdmFyIG91dHB1dE5vZGVOYW1lcyA9IG91dHB1dHMubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBwYXJzZU5vZGVOYW1lKG5hbWUpWzBdOyB9KTtcbiAgICAgICAgdmFyIG91dHB1dE5vZGVzID0gb3V0cHV0Tm9kZU5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuZ3JhcGgubm9kZXNbbmFtZV07IH0pO1xuICAgICAgICAvLyBJZiBubyBvdXRwdXRzIGFyZSBzcGVjaWZpZWQsIHRoZW4gdXNlIHRoZSBkZWZhdWx0IG91dHB1dHMgb2YgdGhlIG1vZGVsLlxuICAgICAgICBpZiAob3V0cHV0Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBvdXRwdXROb2RlcyA9IHRoaXMuX291dHB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBpbGF0aW9uS2V5ID0gdGhpcy5nZXRDb21waWxhdGlvbktleShpbnB1dE5vZGVzLCBvdXRwdXROb2Rlcyk7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIGNvbXBpbGVkIGdyYXBoIGNhY2hlIGNvbnRhaW5zIHRoZSBpbnB1dC5cbiAgICAgICAgdmFyIG9yZGVyZWROb2RlcyA9IHRoaXMuY29tcGlsZWRNYXAuZ2V0KGNvbXBpbGF0aW9uS2V5KTtcbiAgICAgICAgaWYgKG9yZGVyZWROb2RlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcmRlcmVkTm9kZXMgPSB0aGlzLmNvbXBpbGUoaW5wdXRzLCBvdXRwdXROb2Rlcyk7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVkTWFwLnNldChjb21waWxhdGlvbktleSwgb3JkZXJlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGVuc29yQXJyYXlNYXAgPSB7fTtcbiAgICAgICAgdmFyIHRlbnNvckxpc3RNYXAgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRmT3BzLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgRXhlY3V0aW9uQ29udGV4dChfdGhpcy53ZWlnaHRNYXAsIHRlbnNvckFycmF5TWFwLCB0ZW5zb3JMaXN0TWFwLCBfdGhpcy5mdW5jdGlvbkV4ZWN1dG9yTWFwKTtcbiAgICAgICAgICAgIHZhciB0ZW5zb3JzTWFwID0gX19hc3NpZ24oe30sIF90aGlzLndlaWdodE1hcCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhpbnB1dHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQocGFyc2VOb2RlTmFtZShuYW1lKSwgMiksIG5vZGVOYW1lID0gX2FbMF0sIGluZGV4ID0gX2FbMV07XG4gICAgICAgICAgICAgICAgdmFyIHRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0ZW5zb3JzW2luZGV4XSA9IGlucHV0c1tuYW1lXTtcbiAgICAgICAgICAgICAgICB0ZW5zb3JzTWFwW25vZGVOYW1lXSA9IHRlbnNvcnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB0ZW5zb3JzVG9LZWVwID0gX3RoaXMuZ2V0RnJvemVuVGVuc29ySWRzKHRlbnNvcnNNYXApO1xuICAgICAgICAgICAgdmFyIGludGVybWVkaWF0ZVRlbnNvckNvbnN1bWVyQ291bnQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBvcmRlcmVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0ZW5zb3JzTWFwW25vZGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbnNvcnMgPSBleGVjdXRlT3AkaChub2RlLCB0ZW5zb3JzTWFwLCBjb250ZXh0LCBfdGhpcy5fcmVzb3VyY2VNYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRmT3BzLnV0aWwuaXNQcm9taXNlKHRlbnNvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZXhlY3V0aW9uIG9mIHRoZSBvcCAnXCIgKyBub2RlLm9wICsgXCInIHJldHVybmVkIGEgcHJvbWlzZS4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIHVzZSBtb2RlbC5leGVjdXRlQXN5bmMoKSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JzTWFwW25vZGUubmFtZV0gPSB0ZW5zb3JzO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGVja1RlbnNvckZvckRpc3Bvc2FsKG5vZGUubmFtZSwgbm9kZSwgdGVuc29yc01hcCwgY29udGV4dCwgdGVuc29yc1RvS2VlcCwgb3V0cHV0Tm9kZU5hbWVzLCBpbnRlcm1lZGlhdGVUZW5zb3JDb25zdW1lckNvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkaXNwb3NlIHRoZSBjb250ZXh0IGZvciB0aGUgcm9vdCBleGVjdXRvclxuICAgICAgICAgICAgaWYgKF90aGlzLnBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwb3NlKHRlbnNvcnNUb0tlZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHMubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBnZXRUZW5zb3IobmFtZSwgdGVuc29yc01hcCwgY29udGV4dCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLmdldEZyb3plblRlbnNvcklkcyA9IGZ1bmN0aW9uICh0ZW5zb3JNYXApIHtcbiAgICAgICAgdmFyIGlkcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgT2JqZWN0LmtleXModGVuc29yTWFwKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB0ZW5zb3JNYXBba2V5XTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHRlbnNvcnMpIHsgcmV0dXJuIHRlbnNvcnMubWFwKGZ1bmN0aW9uICh0ZW5zb3IpIHsgcmV0dXJuIHRlbnNvci5pZDsgfSk7IH0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoaWRzKTtcbiAgICB9O1xuICAgIEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLmNoZWNrVGVuc29yRm9yRGlzcG9zYWwgPSBmdW5jdGlvbiAobm9kZU5hbWUsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCwgdGVuc29yc1RvS2VlcCwgb3V0cHV0TmFtZXMsIGludGVybWVkaWF0ZVRlbnNvckNvbnN1bWVyQ291bnQpIHtcbiAgICAgICAgLy8gU2tpcCBvdXRwdXQgbm9kZXMgYW5kIGFueSBjb250cm9sIGZsb3cgbm9kZXMsIHNpbmNlIGl0cyBkZXBlbmRlbmN5IGlzXG4gICAgICAgIC8vIHRyaWNreSB0byB0cmFjayBjb3JyZWN0bHkuXG4gICAgICAgIGlmIChub2RlLmNhdGVnb3J5ID09PSAnY29udHJvbCcgfHwgb3V0cHV0TmFtZXMuaW5kZXhPZihub2RlTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGVuc29yTWFwW25vZGVOYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgICAgIGlmICh0ZW5zb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZVRlbnNvckNvbnN1bWVyQ291bnRbdGVuc29yLmlkXSA9XG4gICAgICAgICAgICAgICAgICAgIChpbnRlcm1lZGlhdGVUZW5zb3JDb25zdW1lckNvdW50W3RlbnNvci5pZF0gfHwgMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBub2RlLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgLy8gU2tpcCBhbnkgY29udHJvbCBmbG93IG5vZGVzLCBzaW5jZSBpdHMgZGVwZW5kZW5jeSBpcyB0cmlja3kgdG8gdHJhY2tcbiAgICAgICAgICAgIC8vIGNvcnJlY3RseS5cbiAgICAgICAgICAgIGlmIChpbnB1dC5jYXRlZ29yeSAhPT0gJ2NvbnRyb2wnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbnNvcnMgPSBnZXRUZW5zb3JzRm9yQ3VycmVudENvbnRlbnh0KGlucHV0Lm5hbWUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHRlbnNvcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JzLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbnNvciAmJiAhdGVuc29yc1RvS2VlcC5oYXModGVuc29yLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGludGVybWVkaWF0ZVRlbnNvckNvbnN1bWVyQ291bnRbdGVuc29yLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGludGVybWVkaWF0ZVRlbnNvckNvbnN1bWVyQ291bnRbdGVuc29yLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGludGVybWVkaWF0ZSBub2RlcyBoYXMgY291bnQgc2V0LCBpbnB1dHMgYW5kIHdlaWdodHMgYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlVGVuc29yQ29uc3VtZXJDb3VudFt0ZW5zb3IuaWRdLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGluZmVyZW5jZSBmb3IgZ2l2ZW4gaW5wdXQgdGVuc29ycyBpbiBBc3luYyBmYXNoaW9uLlxuICAgICAqIEBwYXJhbSBpbnB1dHMgVGVuc29yIG1hcCBmb3IgdGhlIG1vZGVsIGlucHV0cywga2V5ZWQgYnkgdGhlIGlucHV0IG5vZGVcbiAgICAgKiBuYW1lcy5cbiAgICAgKiBAcGFyYW0gb3V0cHV0cyBvdXRwdXQgbm9kZSBuYW1lIGZyb20gdGhlIFRlbnNvcmZsb3cgbW9kZWwsIGlmIG5vIG91dHB1dHNcbiAgICAgKiBhcmUgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBvdXRwdXRzIG9mIHRoZSBtb2RlbCB3b3VsZCBiZSB1c2VkLiBZb3UgY2FuXG4gICAgICogaW5zcGVjdCBpbnRlcm1lZGlhdGUgbm9kZXMgb2YgdGhlIG1vZGVsIGJ5IGFkZGluZyB0aGVtIHRvIHRoZSBvdXRwdXRzXG4gICAgICogYXJyYXkuXG4gICAgICovXG4gICAgR3JhcGhFeGVjdXRvci5wcm90b3R5cGUuZXhlY3V0ZUFzeW5jID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2V4ZWN1dGVBc3luYyhpbnB1dHMsIG91dHB1dHMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBpbmZlcmVuY2UgZm9yIGdpdmVuIGlucHV0IHRlbnNvcnMgaW4gQXN5bmMgZmFzaGlvbi5cbiAgICAgKiBAcGFyYW0gaW5wdXRzIFRlbnNvciBtYXAgZm9yIHRoZSBtb2RlbCBpbnB1dHMsIGtleWVkIGJ5IHRoZSBpbnB1dCBub2RlXG4gICAgICogbmFtZXMuXG4gICAgICogQHBhcmFtIG91dHB1dHMgT3B0aW9uYWwuIG91dHB1dCBub2RlIG5hbWUgZnJvbSB0aGUgVGVuc29yZmxvdyBtb2RlbCxcbiAgICAgKiBpZiBubyBvdXRwdXRzIGFyZSBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IG91dHB1dHMgb2YgdGhlIG1vZGVsIHdvdWxkIGJlXG4gICAgICogdXNlZC4gWW91IGNhbiBpbnNwZWN0IGludGVybWVkaWF0ZSBub2RlcyBvZiB0aGUgbW9kZWwgYnkgYWRkaW5nIHRoZW0gdG8gdGhlXG4gICAgICogb3V0cHV0cyBhcnJheS5cbiAgICAgKiBAcGFyYW0gaXNGdW5jdGlvbkV4ZWN1dGlvbiBPcHRpb25hbC4gRmxhZyBmb3IgZXhlY3V0aW5nIGEgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHRlbnNvckFycmF5TWFwIE9wdGlvbmFsLCBnbG9iYWwgVGVuc29yQXJyYXkgbWFwIGJ5IGlkLiBVc2VkIGZvclxuICAgICAqIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAgICAgKiBAcGFyYW0gdGVuc29yQXJyYXlNYXAgT3B0aW5hbCBnbG9iYWwgVGVuc29yTGlzdCBtYXAgYnkgaWQuIFVzZWQgZm9yXG4gICAgICogZnVuY3Rpb24gZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLl9leGVjdXRlQXN5bmMgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXRzLCBpc0Z1bmN0aW9uRXhlY3V0aW9uLCB0ZW5zb3JBcnJheU1hcCwgdGVuc29yTGlzdE1hcCkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbkV4ZWN1dGlvbiA9PT0gdm9pZCAwKSB7IGlzRnVuY3Rpb25FeGVjdXRpb24gPSBmYWxzZTsgfVxuICAgICAgICBpZiAodGVuc29yQXJyYXlNYXAgPT09IHZvaWQgMCkgeyB0ZW5zb3JBcnJheU1hcCA9IHt9OyB9XG4gICAgICAgIGlmICh0ZW5zb3JMaXN0TWFwID09PSB2b2lkIDApIHsgdGVuc29yTGlzdE1hcCA9IHt9OyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0LCB0ZW5zb3JNYXAsIHJlc3VsdHMsIG91dHB1dElkcywgaW5wdXRJZHMsIGtlZXBJZHM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRnVuY3Rpb25FeGVjdXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGlzLm1hcElucHV0cyhpbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tJbnB1dHMoaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrSW5wdXRTaGFwZUFuZFR5cGUoaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzID0gdGhpcy5tYXBPdXRwdXRzKG91dHB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tPdXRwdXRzKG91dHB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IG5ldyBFeGVjdXRpb25Db250ZXh0KHRoaXMud2VpZ2h0TWFwLCB0ZW5zb3JBcnJheU1hcCwgdGVuc29yTGlzdE1hcCwgdGhpcy5mdW5jdGlvbkV4ZWN1dG9yTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZXhlY3V0ZVdpdGhDb250cm9sRmxvdyhpbnB1dHMsIGNvbnRleHQsIG91dHB1dHMsIGlzRnVuY3Rpb25FeGVjdXRpb24pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yTWFwID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IG91dHB1dHMubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBnZXRUZW5zb3IobmFtZSwgdGVuc29yTWFwLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRJZHMgPSByZXN1bHRzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5pZDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dElkcyA9IE9iamVjdC5rZXlzKGlucHV0cykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpbnB1dHNbbmFtZV0uaWQ7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAga2VlcElkcyA9IG5ldyBTZXQoX19zcHJlYWQob3V0cHV0SWRzLCBpbnB1dElkcywgdGhpcy53ZWlnaHRJZHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRlbnNvck1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbnNvckFycmF5ID0gdGVuc29yTWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW5zb3IgJiYgIXRlbnNvci5pc0Rpc3Bvc2VkICYmICFrZWVwSWRzLmhhcyh0ZW5zb3IuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3IuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3Bvc2UgdGhlIGNvbnRleHQgZm9yIHRoZSByb290IGV4ZWN1dG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcG9zZShrZWVwSWRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZS5leGVjdXRlRnVuY3Rpb25Bc3luYyA9IGZ1bmN0aW9uIChpbnB1dHMsIHRlbnNvckFycmF5TWFwLCB0ZW5zb3JMaXN0TWFwKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXBwZWRJbnB1dHM7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIG1hcHBlZElucHV0cyA9IGlucHV0cy5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgdGVuc29yLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBbX3RoaXMuaW5wdXRzW2luZGV4XS5uYW1lXSA9IHRlbnNvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2V4ZWN1dGVBc3luYyhtYXBwZWRJbnB1dHMsIHRoaXMub3V0cHV0Tm9kZXMsIHRydWUsIHRlbnNvckFycmF5TWFwLCB0ZW5zb3JMaXN0TWFwKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZXJlIGFyZSBjb250cm9sIGZsb3cgbm9kZXMgaW4gdGhlIGdyYXBoLCB0aGUgZ3JhcGggZXhlY3V0aW9uIHVzZVxuICAgICAqIEV4ZWN1dGlvbkNvbnRleHQgdG8ga2VlcCB0cmFjayBvZiB0aGUgZnJhbWVzIGFuZCBsb29wIGl0ZXJhdG9ycy5cbiAgICAgKiBAcGFyYW0gaW5wdXRzIHBsYWNlaG9sZGVyIHRlbnNvcnMgZm9yIHRoZSBncmFwaC5cbiAgICAgKiBAcGFyYW0gY29udGV4dCB0aGUgZXhlY3V0aW9uIGNvbnRleHQgb2JqZWN0IGZvciBjdXJyZW50IGV4ZWN1dGlvbi5cbiAgICAgKiBAcGFyYW0gb3V0cHV0TmFtZXMgT3B0aW9uYWwuIG91dHB1dCBub2RlIG5hbWUgZnJvbSB0aGUgVGVuc29yZmxvdyBtb2RlbCxcbiAgICAgKiBpZiBubyBvdXRwdXRzIGFyZSBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IG91dHB1dHMgb2YgdGhlIG1vZGVsIHdvdWxkIGJlXG4gICAgICogdXNlZC4gWW91IGNhbiBpbnNwZWN0IGludGVybWVkaWF0ZSBub2RlcyBvZiB0aGUgbW9kZWwgYnkgYWRkaW5nIHRoZW0gdG8gdGhlXG4gICAgICogb3V0cHV0cyBhcnJheS5cbiAgICAgKiBAcGFyYW0gaXNGdW5jdGlvbkV4ZWN1dGlvbiBGbGFnIGZvciBleGVjdXRpbmcgYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZS5leGVjdXRlV2l0aENvbnRyb2xGbG93ID0gZnVuY3Rpb24gKGlucHV0cywgY29udGV4dCwgb3V0cHV0TmFtZXMsIGlzRnVuY3Rpb25FeGVjdXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5hbWVzLCBpbnB1dE5vZGVzLCBvdXRwdXROb2RlTmFtZXMsIG91dHB1dE5vZGVzLCBfYSwgdXNlZE5vZGVzLCBtaXNzaW5nSW5wdXRzLCBkeW5hbWljTm9kZSwgc3luY0lucHV0cywgc3RhY2ssIHRlbnNvcnNNYXAsIGludGVybWVkaWF0ZVRlbnNvckNvbnN1bWVyQ291bnQsIHRlbnNvcnNUb0tlZXAsIGFkZGVkLCBwcm9taXNlcywgbWlzc2luZ091dHB1dHMsIGFsdGVybmF0aXZlTXNnO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzID0gT2JqZWN0LmtleXMoaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Tm9kZXMgPSBuYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmdyYXBoLm5vZGVzW3BhcnNlTm9kZU5hbWUobmFtZSlbMF1dOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dE5vZGVOYW1lcyA9IG91dHB1dE5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcGFyc2VOb2RlTmFtZShuYW1lKVswXTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXROb2RlcyA9IG91dHB1dE5vZGVOYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmdyYXBoLm5vZGVzW25hbWVdOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIG91dHB1dHMgYXJlIHNwZWNpZmllZCwgdGhlbiB1c2UgdGhlIGRlZmF1bHQgb3V0cHV0cyBvZiB0aGUgbW9kZWwuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Tm9kZXMgPSB0aGlzLl9vdXRwdXRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBnZXRFeGVjdXRpb25TdWJncmFwaChpbnB1dHMsIG91dHB1dE5vZGVzLCB0aGlzLndlaWdodE1hcCwgdGhpcy5faW5pdE5vZGVzKSwgdXNlZE5vZGVzID0gX2EudXNlZE5vZGVzLCBtaXNzaW5nSW5wdXRzID0gX2EubWlzc2luZ0lucHV0cywgZHluYW1pY05vZGUgPSBfYS5keW5hbWljTm9kZSwgc3luY0lucHV0cyA9IF9hLnN5bmNJbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjayA9IF9fc3ByZWFkKGlucHV0Tm9kZXMsIHRoaXMuZ3JhcGgud2VpZ2h0cywgKHRoaXMuX2luaXROb2RlcyB8fCBbXSkpLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIGNvbnRleHRzOiBjb250ZXh0LmN1cnJlbnRDb250ZXh0IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvcnNNYXAgPSBfX2Fzc2lnbih7fSwgdGhpcy53ZWlnaHRNYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaW5wdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHBhcnNlTm9kZU5hbWUobmFtZSksIDIpLCBub2RlTmFtZSA9IF9hWzBdLCBpbmRleCA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW5zb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yc1tpbmRleF0gPSBpbnB1dHNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yc01hcFtub2RlTmFtZV0gPSB0ZW5zb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVUZW5zb3JDb25zdW1lckNvdW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JzVG9LZWVwID0gdGhpcy5nZXRGcm96ZW5UZW5zb3JJZHModGVuc29yc01hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRlZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGFjay5sZW5ndGggPiAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IHRoaXMucHJvY2Vzc1N0YWNrKGlucHV0Tm9kZXMsIHN0YWNrLCBjb250ZXh0LCB0ZW5zb3JzTWFwLCBhZGRlZCwgdGVuc29yc1RvS2VlcCwgb3V0cHV0Tm9kZU5hbWVzLCBpbnRlcm1lZGlhdGVUZW5zb3JDb25zdW1lckNvdW50LCB1c2VkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwocHJvbWlzZXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeW5hbWljTm9kZSA9PSBudWxsICYmICFpc0Z1bmN0aW9uRXhlY3V0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhpcyBtb2RlbCBleGVjdXRpb24gZGlkIG5vdCBjb250YWluIGFueSBub2RlcyB3aXRoIGNvbnRyb2wgZmxvdyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3IgZHluYW1pYyBvdXRwdXQgc2hhcGVzLiBZb3UgY2FuIHVzZSBtb2RlbC5leGVjdXRlKCkgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nT3V0cHV0cyA9IG91dHB1dE5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gIWlzQ29udHJvbEZsb3cobm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZ2V0VGVuc29yKG5vZGUubmFtZSwgdGVuc29yc01hcCwgY29udGV4dCk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5uYW1lOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nT3V0cHV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmVNc2cgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHluYW1pY05vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZU1zZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFsdGVybmF0aXZlbHksIHRvIGF2b2lkIHRoZSBkeW5hbWljIG9wcywgdXNlIG1vZGVsLmV4ZWN1dGUoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiYW5kIHNwZWNpZnkgdGhlIGlucHV0cyBbXCIgKyBzeW5jSW5wdXRzICsgXCJdXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSB0aGUgb3V0cHV0cyBbXCIgKyBtaXNzaW5nT3V0cHV0cyArIFwiXSBmcm9tIHRoZSBwcm92aWRlZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImlucHV0cyBbXCIgKyBuYW1lcyArIFwiXS4gQ29uc2lkZXIgcHJvdmlkaW5nIHRoZSBmb2xsb3dpbmcgaW5wdXRzOiBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJbXCIgKyBtaXNzaW5nSW5wdXRzICsgXCJdLiBcIiArIGFsdGVybmF0aXZlTXNnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGVuc29yc01hcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR3JhcGhFeGVjdXRvci5wcm90b3R5cGUucHJvY2Vzc1N0YWNrID0gZnVuY3Rpb24gKGlucHV0Tm9kZXMsIHN0YWNrLCBjb250ZXh0LCB0ZW5zb3JNYXAsIGFkZGVkLCB0ZW5zb3JzVG9LZWVwLCBvdXRwdXROYW1lcywgaW50ZXJtZWRpYXRlVGVuc29yQ29uc3VtZXJDb3VudCwgdXNlZE5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Q29udGV4dCA9IGl0ZW0uY29udGV4dHM7XG4gICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSAnJztcbiAgICAgICAgICAgIC8vIFRoZSB0ZW5zb3Igb2YgdGhlIEVudGVyIG9wIHdpdGggaXNDb25zdGFudCBzZXQgc2hvdWxkIGJlIHNldFxuICAgICAgICAgICAgLy8gaW4gdGhlIHBhcmVudCBzY29wZSwgc28gaXQgd2lsbCBiZSBhdmFpbGFibGUgYXMgY29uc3RhbnQgZm9yIHRoZVxuICAgICAgICAgICAgLy8gd2hvbGUgbG9vcC5cbiAgICAgICAgICAgIGlmIChpdGVtLm5vZGUub3AgPT09ICdFbnRlcicgJiZcbiAgICAgICAgICAgICAgICBnZXRQYXJhbVZhbHVlKCdpc0NvbnN0YW50JywgaXRlbS5ub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgX2EgPSBfX3JlYWQoZ2V0Tm9kZU5hbWVBbmRJbmRleChpdGVtLm5vZGUubmFtZSwgY29udGV4dCksIDEpLCBub2RlTmFtZSA9IF9hWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb25seSBwcm9jZXNzIG5vZGVzIHRoYXQgYXJlIG5vdCBpbiB0aGUgdGVuc29yTWFwIHlldCwgdGhpcyBpbmNsdWRlXG4gICAgICAgICAgICAvLyBpbnB1dE5vZGVzIGFuZCBpbnRlcm5hbCBpbml0Tm9kZXMuXG4gICAgICAgICAgICBpZiAodGVuc29yTWFwW2l0ZW0ubm9kZS5uYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbnNvcnMgPSBleGVjdXRlT3AkaChpdGVtLm5vZGUsIHRlbnNvck1hcCwgY29udGV4dCwgdGhpc18xLl9yZXNvdXJjZU1hbmFnZXIpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2IgPSBfX3JlYWQoZ2V0Tm9kZU5hbWVBbmRJbmRleChpdGVtLm5vZGUubmFtZSwgY29udGV4dCksIDEpLCBub2RlTmFtZSA9IF9iWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENvbnRleHRfMSA9IGNvbnRleHQuY3VycmVudENvbnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRmT3BzLnV0aWwuaXNQcm9taXNlKHRlbnNvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGVuc29ycy50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JNYXBbbm9kZU5hbWVdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudENvbnRleHQgPSBjdXJyZW50Q29udGV4dF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbChub2RlTmFtZSwgaXRlbS5ub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQsIHRlbnNvcnNUb0tlZXAsIG91dHB1dE5hbWVzLCBpbnRlcm1lZGlhdGVUZW5zb3JDb25zdW1lckNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb2Nlc3NDaGlsZE5vZGVzKGl0ZW0ubm9kZSwgc3RhY2ssIGNvbnRleHQsIHRlbnNvck1hcCwgYWRkZWQsIHVzZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yTWFwW25vZGVOYW1lXSA9IHRlbnNvcnM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jaGVja1RlbnNvckZvckRpc3Bvc2FsKG5vZGVOYW1lLCBpdGVtLm5vZGUsIHRlbnNvck1hcCwgY29udGV4dCwgdGVuc29yc1RvS2VlcCwgb3V0cHV0TmFtZXMsIGludGVybWVkaWF0ZVRlbnNvckNvbnN1bWVyQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEucHJvY2Vzc0NoaWxkTm9kZXMoaXRlbS5ub2RlLCBzdGFjaywgY29udGV4dCwgdGVuc29yTWFwLCBhZGRlZCwgdXNlZE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzXzEucHJvY2Vzc0NoaWxkTm9kZXMoaXRlbS5ub2RlLCBzdGFjaywgY29udGV4dCwgdGVuc29yTWFwLCBhZGRlZCwgdXNlZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgIH07XG4gICAgR3JhcGhFeGVjdXRvci5wcm90b3R5cGUucHJvY2Vzc0NoaWxkTm9kZXMgPSBmdW5jdGlvbiAobm9kZSwgc3RhY2ssIGNvbnRleHQsIHRlbnNvck1hcCwgYWRkZWQsIHVzZWROb2Rlcykge1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKGdldE5vZGVOYW1lQW5kSW5kZXgoY2hpbGROb2RlLm5hbWUsIGNvbnRleHQpLCAxKSwgbm9kZU5hbWUgPSBfYVswXTtcbiAgICAgICAgICAgIGlmIChhZGRlZFtub2RlTmFtZV0gfHwgIXVzZWROb2Rlcy5oYXMoY2hpbGROb2RlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWVyZ2Ugb3AgY2FuIGJlIHB1c2hlZCBpZiBhbnkgb2YgaXRzIGlucHV0cyBoYXMgdmFsdWUuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLm9wID09PSAnTWVyZ2UnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pbnB1dE5hbWVzLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZ2V0VGVuc29yKG5hbWUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRbbm9kZU5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7IGNvbnRleHRzOiBjb250ZXh0LmN1cnJlbnRDb250ZXh0LCBub2RlOiBjaGlsZE5vZGUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSAvLyBPdGhlcndpc2UgYWxsIGlucHV0cyBtdXN0IHRvIGhhdmUgdmFsdWUuXG4gICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pbnB1dE5hbWVzLmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhZ2V0VGVuc29yKG5hbWUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGFkZGVkW25vZGVOYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7IGNvbnRleHRzOiBjb250ZXh0LmN1cnJlbnRDb250ZXh0LCBub2RlOiBjaGlsZE5vZGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgdGhlIG1lbW9yeSB1c2VkIGJ5IHRoZSB3ZWlnaHQgdGVuc29ycy5cbiAgICAgKi9cbiAgICBHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLndlaWdodE1hcClcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIF90aGlzLndlaWdodE1hcFtrZXldLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGVuc29yLmRpc3Bvc2UoKTsgfSk7IH0pO1xuICAgIH07XG4gICAgR3JhcGhFeGVjdXRvci5wcm90b3R5cGUuY2hlY2tJbnB1dFNoYXBlQW5kVHlwZSA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXMoaW5wdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNbbmFtZV07XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQocGFyc2VOb2RlTmFtZShuYW1lKSwgMSksIG5vZGVOYW1lID0gX2FbMF07XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzLmdyYXBoLm5vZGVzW25vZGVOYW1lXTtcbiAgICAgICAgICAgIGlmIChub2RlLmF0dHJQYXJhbXNbJ3NoYXBlJ10gJiYgbm9kZS5hdHRyUGFyYW1zWydzaGFwZSddLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlXzEgPSBub2RlLmF0dHJQYXJhbXNbJ3NoYXBlJ10udmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gc2hhcGVfMS5sZW5ndGggPT09IGlucHV0LnNoYXBlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5zaGFwZS5ldmVyeShmdW5jdGlvbiAoZGltLCBpbmRleCkgeyByZXR1cm4gc2hhcGVfMVtpbmRleF0gPT09IC0xIHx8IHNoYXBlXzFbaW5kZXhdID09PSBkaW07IH0pO1xuICAgICAgICAgICAgICAgIHRmT3BzLnV0aWwuYXNzZXJ0KG1hdGNoLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlRoZSBzaGFwZSBvZiBkaWN0WydcIiArIG5vZGUubmFtZSArIFwiJ10gcHJvdmlkZWQgaW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJtb2RlbC5leGVjdXRlKGRpY3QpIG11c3QgYmUgW1wiICsgc2hhcGVfMSArIFwiXSwgYnV0IHdhcyBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoXCJbXCIgKyBpbnB1dC5zaGFwZSArIFwiXVwiKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5hdHRyUGFyYW1zWydkdHlwZSddICYmIG5vZGUuYXR0clBhcmFtc1snZHR5cGUnXS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRmT3BzLnV0aWwuYXNzZXJ0KGlucHV0LmR0eXBlID09PSBub2RlLmF0dHJQYXJhbXNbJ2R0eXBlJ10udmFsdWUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiVGhlIGR0eXBlIG9mIGRpY3RbJ1wiICsgbm9kZS5uYW1lICsgXCInXSBwcm92aWRlZCBpbiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwibW9kZWwuZXhlY3V0ZShkaWN0KSBtdXN0IGJlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKG5vZGUuYXR0clBhcmFtc1snZHR5cGUnXS52YWx1ZSArIFwiLCBidXQgd2FzIFwiICsgaW5wdXQuZHR5cGUpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZS5tYXBJbnB1dHMgPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaW5wdXROYW1lIGluIGlucHV0cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZSAhPSBudWxsICYmIHRoaXMuX3NpZ25hdHVyZS5pbnB1dHMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hdHVyZS5pbnB1dHNbaW5wdXROYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbnNvciA9IHRoaXMuX3NpZ25hdHVyZS5pbnB1dHNbaW5wdXROYW1lXTtcbiAgICAgICAgICAgICAgICByZXN1bHRbdGVuc29yLm5hbWVdID0gaW5wdXRzW2lucHV0TmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaW5wdXROYW1lXSA9IGlucHV0c1tpbnB1dE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZS5jaGVja0lucHV0cyA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vdEluR3JhcGggPSBPYmplY3Qua2V5cyhpbnB1dHMpLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHBhcnNlTm9kZU5hbWUobmFtZSksIDEpLCBub2RlTmFtZSA9IF9hWzBdO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdyYXBoLm5vZGVzW25vZGVOYW1lXSA9PSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vdEluR3JhcGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRpY3QgcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBoYXMgXCIgK1xuICAgICAgICAgICAgICAgIChcImtleXM6IFtcIiArIG5vdEluR3JhcGggKyBcIl0gdGhhdCBhcmUgbm90IHBhcnQgb2YgZ3JhcGhcIikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZS5tYXBPdXRwdXRzID0gZnVuY3Rpb24gKG91dHB1dHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG91dHB1dHMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3NpZ25hdHVyZSAhPSBudWxsICYmIF90aGlzLl9zaWduYXR1cmUub3V0cHV0cyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NpZ25hdHVyZS5vdXRwdXRzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVuc29yID0gX3RoaXMuX3NpZ25hdHVyZS5vdXRwdXRzW25hbWVdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW5zb3IubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICBHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZS5jaGVja091dHB1dHMgPSBmdW5jdGlvbiAob3V0cHV0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChwYXJzZU5vZGVOYW1lKG5hbWUpLCAxKSwgbm9ybWFsaXplZE5hbWUgPSBfYVswXTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuZ3JhcGgubm9kZXNbbm9ybWFsaXplZE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG91dHB1dCAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCBmb3VuZCBpbiB0aGUgZ3JhcGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEdyYXBoRXhlY3V0b3I7XG59KCkpO1xuXG4vKipcbiAqIENvbnRhaW5zIGdsb2JhbCByZXNvdXJjZXMgb2YgYSBtb2RlbC5cbiAqL1xudmFyIFJlc291cmNlTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvdXJjZU1hbmFnZXIoaGFzaFRhYmxlTmFtZVRvSGFuZGxlLCBoYXNoVGFibGVNYXApIHtcbiAgICAgICAgaWYgKGhhc2hUYWJsZU5hbWVUb0hhbmRsZSA9PT0gdm9pZCAwKSB7IGhhc2hUYWJsZU5hbWVUb0hhbmRsZSA9IHt9OyB9XG4gICAgICAgIGlmIChoYXNoVGFibGVNYXAgPT09IHZvaWQgMCkgeyBoYXNoVGFibGVNYXAgPSB7fTsgfVxuICAgICAgICB0aGlzLmhhc2hUYWJsZU5hbWVUb0hhbmRsZSA9IGhhc2hUYWJsZU5hbWVUb0hhbmRsZTtcbiAgICAgICAgdGhpcy5oYXNoVGFibGVNYXAgPSBoYXNoVGFibGVNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgYEhhc2hUYWJsZWAgaW4gdGhlIHJlc291cmNlIG1hbmFnZXIuXG4gICAgICpcbiAgICAgKiBUaGUgYEhhc2hUYWJsZWAgY2FuIGJlIHJldHJpZXZlZCBieSBgcmVzb3VyY2VNYW5hZ2VyLmdldEhhc2hUYWJsZUJ5SWRgLFxuICAgICAqIHdoZXJlIGlkIGlzIHRoZSB0YWJsZSBoYW5kbGUgdGVuc29yJ3MgaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBPcCBub2RlIG5hbWUgdGhhdCBjcmVhdGVzIHRoZSBgSGFzaFRhYmxlYC5cbiAgICAgKiBAcGFyYW0gaGFzaFRhYmxlIFRoZSBgSGFzaFRhYmxlYCB0byBiZSBhZGRlZCB0byByZXNvdXJjZSBtYW5hZ2VyLlxuICAgICAqL1xuICAgIFJlc291cmNlTWFuYWdlci5wcm90b3R5cGUuYWRkSGFzaFRhYmxlID0gZnVuY3Rpb24gKG5hbWUsIGhhc2hUYWJsZSkge1xuICAgICAgICB0aGlzLmhhc2hUYWJsZU5hbWVUb0hhbmRsZVtuYW1lXSA9IGhhc2hUYWJsZS5oYW5kbGU7XG4gICAgICAgIHRoaXMuaGFzaFRhYmxlTWFwW2hhc2hUYWJsZS5pZF0gPSBoYXNoVGFibGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRhYmxlIGhhbmRsZSBieSBub2RlIG5hbWUuXG4gICAgICogQHBhcmFtIG5hbWUgT3Agbm9kZSBuYW1lIHRoYXQgY3JlYXRlcyB0aGUgYEhhc2hUYWJsZWAuIFRoaXMgbmFtZSBpcyBhbHNvXG4gICAgICogICAgIHVzZWQgaW4gdGhlIGlucHV0cyBsaXN0IG9mIGxvb2t1cCBhbmQgaW1wb3J0IGBIYXNoVGFibGVgIG9wcy5cbiAgICAgKi9cbiAgICBSZXNvdXJjZU1hbmFnZXIucHJvdG90eXBlLmdldEhhc2hUYWJsZUhhbmRsZUJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hUYWJsZU5hbWVUb0hhbmRsZVtuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYWN0dWFsIGBIYXNoVGFibGVgIGJ5IGl0cyBoYW5kbGUgdGVuc29yJ3MgaWQuXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgaGFuZGxlIHRlbnNvci5cbiAgICAgKi9cbiAgICBSZXNvdXJjZU1hbmFnZXIucHJvdG90eXBlLmdldEhhc2hUYWJsZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaFRhYmxlTWFwW2lkXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgYFJlc291cmNlTWFuYWdlcmAsIGluY2x1ZGluZyBpdHMgaGFzaFRhYmxlcyBhbmQgdGVuc29ycyBpbiB0aGVtLlxuICAgICAqL1xuICAgIFJlc291cmNlTWFuYWdlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuaGFzaFRhYmxlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2hUYWJsZU1hcFtrZXldLmNsZWFyQW5kQ2xvc2UoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhhc2hUYWJsZU1hcFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiB0aGlzLmhhc2hUYWJsZU5hbWVUb0hhbmRsZSkge1xuICAgICAgICAgICAgdGhpcy5oYXNoVGFibGVOYW1lVG9IYW5kbGVbbmFtZV8xXS5kaXNwb3NlKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5oYXNoVGFibGVOYW1lVG9IYW5kbGVbbmFtZV8xXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlc291cmNlTWFuYWdlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBURkhVQl9TRUFSQ0hfUEFSQU0gPSAnP3RmanMtZm9ybWF0PWZpbGUnO1xudmFyIERFRkFVTFRfTU9ERUxfTkFNRSA9ICdtb2RlbC5qc29uJztcbi8qKlxuICogQSBgdGYuR3JhcGhNb2RlbGAgaXMgYSBkaXJlY3RlZCwgYWN5Y2xpYyBncmFwaCBidWlsdCBmcm9tIGFcbiAqIFNhdmVkTW9kZWwgR3JhcGhEZWYgYW5kIGFsbG93cyBpbmZlcmVuY2UgZXhlY3V0aW9uLlxuICpcbiAqIEEgYHRmLkdyYXBoTW9kZWxgIGNhbiBvbmx5IGJlIGNyZWF0ZWQgYnkgbG9hZGluZyBmcm9tIGEgbW9kZWwgY29udmVydGVkIGZyb21cbiAqIGEgW1RlbnNvckZsb3cgU2F2ZWRNb2RlbF0oaHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZ3VpZGUvc2F2ZWRfbW9kZWwpIHVzaW5nXG4gKiB0aGUgY29tbWFuZCBsaW5lIGNvbnZlcnRlciB0b29sIGFuZCBsb2FkZWQgdmlhIGB0Zi5sb2FkR3JhcGhNb2RlbGAuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAqL1xudmFyIEdyYXBoTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1vZGVsVXJsIHVybCBmb3IgdGhlIG1vZGVsLCBvciBhbiBgaW8uSU9IYW5kbGVyYC5cbiAgICAgKiBAcGFyYW0gd2VpZ2h0TWFuaWZlc3RVcmwgdXJsIGZvciB0aGUgd2VpZ2h0IGZpbGUgZ2VuZXJhdGVkIGJ5XG4gICAgICogc2NyaXB0cy9jb252ZXJ0LnB5IHNjcmlwdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdE9wdGlvbiBvcHRpb25zIGZvciBSZXF1ZXN0LCB3aGljaCBhbGxvd3MgdG8gc2VuZCBjcmVkZW50aWFsc1xuICAgICAqIGFuZCBjdXN0b20gaGVhZGVycy5cbiAgICAgKiBAcGFyYW0gb25Qcm9ncmVzcyBPcHRpb25hbCwgcHJvZ3Jlc3MgY2FsbGJhY2sgZnVuY3Rpb24sIGZpcmVkIHBlcmlvZGljYWxseVxuICAgICAqIGJlZm9yZSB0aGUgbG9hZCBpcyBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gR3JhcGhNb2RlbChtb2RlbFVybCwgbG9hZE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGxvYWRPcHRpb25zID09PSB2b2lkIDApIHsgbG9hZE9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLm1vZGVsVXJsID0gbW9kZWxVcmw7XG4gICAgICAgIHRoaXMubG9hZE9wdGlvbnMgPSBsb2FkT3B0aW9ucztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gJ24vYSc7XG4gICAgICAgIGlmIChsb2FkT3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRPcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBuZXcgUmVzb3VyY2VNYW5hZ2VyKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaE1vZGVsLnByb3RvdHlwZSwgXCJtb2RlbFZlcnNpb25cIiwge1xuICAgICAgICAvLyBSZXR1cm5zIHRoZSB2ZXJzaW9uIGluZm9ybWF0aW9uIGZvciB0aGUgdGVuc29yZmxvdyBtb2RlbCBHcmFwaERlZi5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhNb2RlbC5wcm90b3R5cGUsIFwiaW5wdXROb2Rlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0b3IuaW5wdXROb2RlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoTW9kZWwucHJvdG90eXBlLCBcIm91dHB1dE5vZGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRvci5vdXRwdXROb2RlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoTW9kZWwucHJvdG90eXBlLCBcImlucHV0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0b3IuaW5wdXRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhNb2RlbC5wcm90b3R5cGUsIFwib3V0cHV0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0b3Iub3V0cHV0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoTW9kZWwucHJvdG90eXBlLCBcIndlaWdodHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dG9yLndlaWdodE1hcDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoTW9kZWwucHJvdG90eXBlLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoTW9kZWwucHJvdG90eXBlLCBcIm1vZGVsU2lnbmF0dXJlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEdyYXBoTW9kZWwucHJvdG90eXBlLmZpbmRJT0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5tb2RlbFVybDtcbiAgICAgICAgaWYgKHBhdGgubG9hZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBQYXRoIGlzIGFuIElPIEhhbmRsZXIuXG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubG9hZE9wdGlvbnMucmVxdWVzdEluaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gdGZPcHMuaW8uYnJvd3NlckhUVFBSZXF1ZXN0KHBhdGgsIHRoaXMubG9hZE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gdGZPcHMuaW8uZ2V0TG9hZEhhbmRsZXJzKHBhdGgsIHRoaXMubG9hZE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBpZiBubyBsb2FkIGhhbmRsZXIgY2FuIGJlIGZvdW5kLFxuICAgICAgICAgICAgICAgIC8vIGFzc3VtZSBpdCBpcyBhIHJlbGF0aXZlIGh0dHAgcGF0aC5cbiAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKHRmT3BzLmlvLmJyb3dzZXJIVFRQUmVxdWVzdChwYXRoLCB0aGlzLmxvYWRPcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm91bmQgbW9yZSB0aGFuIG9uZSAoXCIgKyBoYW5kbGVycy5sZW5ndGggKyBcIikgbG9hZCBoYW5kbGVycyBmb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJVUkwgJ1wiICsgW3BhdGhdICsgXCInXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJzWzBdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgbW9kZWwgYW5kIHdlaWdodCBmaWxlcywgY29uc3RydWN0IHRoZSBpbiBtZW1vcnkgd2VpZ2h0IG1hcCBhbmRcbiAgICAgKiBjb21waWxlIHRoZSBpbmZlcmVuY2UgZ3JhcGguXG4gICAgICovXG4gICAgR3JhcGhNb2RlbC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFydGlmYWN0cztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZElPSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFuZGxlci5sb2FkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwcm9jZWVkIHdpdGggbW9kZWwgbG9hZGluZyBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkb2VzIG5vdCBoYXZlIHRoZSBgbG9hZGAgbWV0aG9kIGltcGxlbWVudGVkLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5oYW5kbGVyLmxvYWQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFydGlmYWN0cyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmxvYWRTeW5jKGFydGlmYWN0cyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzbHkgY29uc3RydWN0IHRoZSBpbiBtZW1vcnkgd2VpZ2h0IG1hcCBhbmRcbiAgICAgKiBjb21waWxlIHRoZSBpbmZlcmVuY2UgZ3JhcGguIEFsc28gaW5pdGlhbGl6ZSBoYXNodGFibGUgaWYgYW55LlxuICAgICAqXG4gICAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgaWdub3JlQ0k6IHRydWV9XG4gICAgICovXG4gICAgR3JhcGhNb2RlbC5wcm90b3R5cGUubG9hZFN5bmMgPSBmdW5jdGlvbiAoYXJ0aWZhY3RzKSB7XG4gICAgICAgIHRoaXMuYXJ0aWZhY3RzID0gYXJ0aWZhY3RzO1xuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLmFydGlmYWN0cy5tb2RlbFRvcG9sb2d5O1xuICAgICAgICB2YXIgc2lnbmF0dXJlO1xuICAgICAgICBpZiAodGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YSAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLmFydGlmYWN0cy51c2VyRGVmaW5lZE1ldGFkYXRhLnNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgICAgICAgICAgdGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YS5zaWduYXR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSB0aGlzLmFydGlmYWN0cy5zaWduYXR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IGdyYXBoLnZlcnNpb25zLnByb2R1Y2VyICsgXCIuXCIgKyBncmFwaC52ZXJzaW9ucy5taW5Db25zdW1lcjtcbiAgICAgICAgdmFyIHdlaWdodE1hcCA9IHRmT3BzLmlvLmRlY29kZVdlaWdodHModGhpcy5hcnRpZmFjdHMud2VpZ2h0RGF0YSwgdGhpcy5hcnRpZmFjdHMud2VpZ2h0U3BlY3MpO1xuICAgICAgICB0aGlzLmV4ZWN1dG9yID0gbmV3IEdyYXBoRXhlY3V0b3IoT3BlcmF0aW9uTWFwcGVyLkluc3RhbmNlLnRyYW5zZm9ybUdyYXBoKGdyYXBoLCB0aGlzLnNpZ25hdHVyZSkpO1xuICAgICAgICB0aGlzLmV4ZWN1dG9yLndlaWdodE1hcCA9IHRoaXMuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcCh3ZWlnaHRNYXApO1xuICAgICAgICAvLyBBdHRhY2ggYSBtb2RlbC1sZXZlbCByZXNvdXJjZU1hbmFnZXIgdG8gZWFjaCBleGVjdXRvciB0byBzaGFyZSByZXNvdXJjZXMsXG4gICAgICAgIC8vIHN1Y2ggYXMgYEhhc2hUYWJsZWAuXG4gICAgICAgIHRoaXMuZXhlY3V0b3IucmVzb3VyY2VNYW5hZ2VyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXI7XG4gICAgICAgIGlmIChhcnRpZmFjdHMubW9kZWxJbml0aWFsaXplciAhPSBudWxsICYmXG4gICAgICAgICAgICBhcnRpZmFjdHMubW9kZWxJbml0aWFsaXplci5ub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsaXplciA9IE9wZXJhdGlvbk1hcHBlci5JbnN0YW5jZS50cmFuc2Zvcm1HcmFwaChhcnRpZmFjdHMubW9kZWxJbml0aWFsaXplcik7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVyID0gbmV3IEdyYXBoRXhlY3V0b3IoaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplci53ZWlnaHRNYXAgPSB0aGlzLmV4ZWN1dG9yLndlaWdodE1hcDtcbiAgICAgICAgICAgIC8vIEF0dGFjaCBhIG1vZGVsLWxldmVsIHJlc291cmNlTWFuYWdlciB0byB0aGUgaW5pdGlhbGl6ZXIsIHRoZVxuICAgICAgICAgICAgLy8gaGFzaFRhYmxlcyBjcmVhdGVkIGZyb20gd2hlbiBleGVjdXRpbmcgdGhlIGluaXRpYWxpemVyIHdpbGwgYmUgc3RvcmVkXG4gICAgICAgICAgICAvLyBpbiB0aGUgcmVzb3VyY2VNYW5hZ2VyLlxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplci5yZXNvdXJjZU1hbmFnZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlcjtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZXIuZXhlY3V0ZUFzeW5jKHt9LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBjb25maWd1cmF0aW9uIGFuZC9vciB3ZWlnaHRzIG9mIHRoZSBHcmFwaE1vZGVsLlxuICAgICAqXG4gICAgICogQW4gYElPSGFuZGxlcmAgaXMgYW4gb2JqZWN0IHRoYXQgaGFzIGEgYHNhdmVgIG1ldGhvZCBvZiB0aGUgcHJvcGVyXG4gICAgICogc2lnbmF0dXJlIGRlZmluZWQuIFRoZSBgc2F2ZWAgbWV0aG9kIG1hbmFnZXMgdGhlIHN0b3Jpbmcgb3JcbiAgICAgKiB0cmFuc21pc3Npb24gb2Ygc2VyaWFsaXplZCBkYXRhIChcImFydGlmYWN0c1wiKSB0aGF0IHJlcHJlc2VudCB0aGVcbiAgICAgKiBtb2RlbCdzIHRvcG9sb2d5IGFuZCB3ZWlnaHRzIG9udG8gb3IgdmlhIGEgc3BlY2lmaWMgbWVkaXVtLCBzdWNoIGFzXG4gICAgICogZmlsZSBkb3dubG9hZHMsIGxvY2FsIHN0b3JhZ2UsIEluZGV4ZWREQiBpbiB0aGUgd2ViIGJyb3dzZXIgYW5kIEhUVFBcbiAgICAgKiByZXF1ZXN0cyB0byBhIHNlcnZlci4gVGVuc29yRmxvdy5qcyBwcm92aWRlcyBgSU9IYW5kbGVyYFxuICAgICAqIGltcGxlbWVudGF0aW9ucyBmb3IgYSBudW1iZXIgb2YgZnJlcXVlbnRseSB1c2VkIHNhdmluZyBtZWRpdW1zLCBzdWNoIGFzXG4gICAgICogYHRmLmlvLmJyb3dzZXJEb3dubG9hZHNgIGFuZCBgdGYuaW8uYnJvd3NlckxvY2FsU3RvcmFnZWAuIFNlZSBgdGYuaW9gXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsc28gYWxsb3dzIHlvdSB0byByZWZlciB0byBjZXJ0YWluIHR5cGVzIG9mIGBJT0hhbmRsZXJgc1xuICAgICAqIGFzIFVSTC1saWtlIHN0cmluZyBzaG9ydGN1dHMsIHN1Y2ggYXMgJ2xvY2Fsc3RvcmFnZTovLycgYW5kXG4gICAgICogJ2luZGV4ZWRkYjovLycuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIDE6IFNhdmUgYG1vZGVsYCdzIHRvcG9sb2d5IGFuZCB3ZWlnaHRzIHRvIGJyb3dzZXIgW2xvY2FsXG4gICAgICogc3RvcmFnZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9sb2NhbFN0b3JhZ2UpO1xuICAgICAqIHRoZW4gbG9hZCBpdCBiYWNrLlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBtb2RlbFVybCA9XG4gICAgICogICAgJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS90ZmpzLW1vZGVscy9zYXZlZG1vZGVsL21vYmlsZW5ldF92Ml8xLjBfMjI0L21vZGVsLmpzb24nO1xuICAgICAqIGNvbnN0IG1vZGVsID0gYXdhaXQgdGYubG9hZEdyYXBoTW9kZWwobW9kZWxVcmwpO1xuICAgICAqIGNvbnN0IHplcm9zID0gdGYuemVyb3MoWzEsIDIyNCwgMjI0LCAzXSk7XG4gICAgICogbW9kZWwucHJlZGljdCh6ZXJvcykucHJpbnQoKTtcbiAgICAgKlxuICAgICAqIGNvbnN0IHNhdmVSZXN1bHRzID0gYXdhaXQgbW9kZWwuc2F2ZSgnbG9jYWxzdG9yYWdlOi8vbXktbW9kZWwtMScpO1xuICAgICAqXG4gICAgICogY29uc3QgbG9hZGVkTW9kZWwgPSBhd2FpdCB0Zi5sb2FkR3JhcGhNb2RlbCgnbG9jYWxzdG9yYWdlOi8vbXktbW9kZWwtMScpO1xuICAgICAqIGNvbnNvbGUubG9nKCdQcmVkaWN0aW9uIGZyb20gbG9hZGVkIG1vZGVsOicpO1xuICAgICAqIG1vZGVsLnByZWRpY3QoemVyb3MpLnByaW50KCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFuZGxlck9yVVJMIEFuIGluc3RhbmNlIG9mIGBJT0hhbmRsZXJgIG9yIGEgVVJMLWxpa2UsXG4gICAgICogc2NoZW1lLWJhc2VkIHN0cmluZyBzaG9ydGN1dCBmb3IgYElPSGFuZGxlcmAuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25zIGZvciBzYXZpbmcgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgYFByb21pc2VgIG9mIGBTYXZlUmVzdWx0YCwgd2hpY2ggc3VtbWFyaXplcyB0aGUgcmVzdWx0IG9mXG4gICAgICogdGhlIHNhdmluZywgc3VjaCBhcyBieXRlIHNpemVzIG9mIHRoZSBzYXZlZCBhcnRpZmFjdHMgZm9yIHRoZSBtb2RlbCdzXG4gICAgICogICB0b3BvbG9neSBhbmQgd2VpZ2h0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIGlnbm9yZUNJOiB0cnVlfVxuICAgICAqL1xuICAgIEdyYXBoTW9kZWwucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoaGFuZGxlck9yVVJMLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlck9yVVJMID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycyA9IHRmT3BzLmlvLmdldFNhdmVIYW5kbGVycyhoYW5kbGVyT3JVUkwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhbnkgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICdcIiArIGhhbmRsZXJPclVSTCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3VuZCBtb3JlIHRoYW4gb25lIChcIiArIGhhbmRsZXJzLmxlbmd0aCArIFwiKSBzYXZlIGhhbmRsZXJzIGZvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiVVJMICdcIiArIGhhbmRsZXJPclVSTCArIFwiJ1wiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlck9yVVJMID0gaGFuZGxlcnNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyT3JVUkwuc2F2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR3JhcGhNb2RlbC5zYXZlKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSB0aGUgSU9IYW5kbGVyICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3ZpZGVkIGRvZXMgbm90IGhhdmUgdGhlIGBzYXZlYCBhdHRyaWJ1dGUgZGVmaW5lZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGhhbmRsZXJPclVSTC5zYXZlKHRoaXMuYXJ0aWZhY3RzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBpbmZlcmVuY2UgZm9yIHRoZSBpbnB1dCB0ZW5zb3JzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0ZW5zb3JzLCB3aGVuIHRoZXJlIGlzIHNpbmdsZSBpbnB1dCBmb3IgdGhlIG1vZGVsLFxuICAgICAqIGlucHV0cyBwYXJhbSBzaG91bGQgYmUgYSBgdGYuVGVuc29yYC4gRm9yIG1vZGVscyB3aXRoIG11dGxpcGxlIGlucHV0cyxcbiAgICAgKiBpbnB1dHMgcGFyYW1zIHNob3VsZCBiZSBpbiBlaXRoZXIgYHRmLlRlbnNvcmBbXSBpZiB0aGUgaW5wdXQgb3JkZXIgaXNcbiAgICAgKiBmaXhlZCwgb3Igb3RoZXJ3aXNlIE5hbWVkVGVuc29yTWFwIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEZvciBtb2RlbCB3aXRoIG11bHRpcGxlIGlucHV0cywgd2UgcmVjb21tZW5kIHlvdSB1c2UgTmFtZWRUZW5zb3JNYXAgYXMgdGhlXG4gICAgICogaW5wdXQgdHlwZSwgaWYgeW91IHVzZSBgdGYuVGVuc29yYFtdLCB0aGUgb3JkZXIgb2YgdGhlIGFycmF5IG5lZWRzIHRvXG4gICAgICogZm9sbG93IHRoZVxuICAgICAqIG9yZGVyIG9mIGlucHV0Tm9kZXMgYXJyYXkuIEBzZWUge0BsaW5rIEdyYXBoTW9kZWwuaW5wdXROb2Rlc31cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBmZWVkIGFueSBpbnRlcm1lZGlhdGUgbm9kZXMgdXNpbmcgdGhlIE5hbWVkVGVuc29yTWFwIGFzIHRoZVxuICAgICAqIGlucHV0IHR5cGUuIEZvciBleGFtcGxlLCBnaXZlbiB0aGUgZ3JhcGhcbiAgICAgKiAgICBJbnB1dE5vZGUgPT4gSW50ZXJtZWRpYXRlID0+IE91dHB1dE5vZGUsXG4gICAgICogeW91IGNhbiBleGVjdXRlIHRoZSBzdWJncmFwaCBJbnRlcm1lZGlhdGUgPT4gT3V0cHV0Tm9kZSBieSBjYWxsaW5nXG4gICAgICogICAgbW9kZWwuZXhlY3V0ZSgnSW50ZXJtZWRpYXRlTm9kZScgOiB0Zi50ZW5zb3IoLi4uKSk7XG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbW9kZWxzIHRoYXQgdXNlcyB0Zi5keW5hbWljX3Jubiwgd2hlcmUgdGhlIGludGVybWVkaWF0ZVxuICAgICAqIHN0YXRlIG5lZWRzIHRvIGJlIGZlZCBtYW51YWxseS5cbiAgICAgKlxuICAgICAqIEZvciBiYXRjaCBpbmZlcmVuY2UgZXhlY3V0aW9uLCB0aGUgdGVuc29ycyBmb3IgZWFjaCBpbnB1dCBuZWVkIHRvIGJlXG4gICAgICogY29uY2F0ZW5hdGVkIHRvZ2V0aGVyLiBGb3IgZXhhbXBsZSB3aXRoIG1vYmlsZW5ldCwgdGhlIHJlcXVpcmVkIGlucHV0IHNoYXBlXG4gICAgICogaXMgWzEsIDI0NCwgMjQ0LCAzXSwgd2hpY2ggcmVwcmVzZW50cyB0aGUgW2JhdGNoLCBoZWlnaHQsIHdpZHRoLCBjaGFubmVsXS5cbiAgICAgKiBJZiB3ZSBhcmUgcHJvdmlkZSBhIGJhdGNoZWQgZGF0YSBvZiAxMDAgaW1hZ2VzLCB0aGUgaW5wdXQgdGVuc29yIHNob3VsZCBiZVxuICAgICAqIGluIHRoZSBzaGFwZSBvZiBbMTAwLCAyNDQsIDI0NCwgM10uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIFByZWRpY3Rpb24gY29uZmlndXJhdGlvbiBmb3Igc3BlY2lmeWluZyB0aGUgYmF0Y2ggc2l6ZSBhbmRcbiAgICAgKiBvdXRwdXQgbm9kZSBuYW1lcy4gQ3VycmVudGx5IHRoZSBiYXRjaCBzaXplIG9wdGlvbiBpcyBpZ25vcmVkIGZvciBncmFwaFxuICAgICAqIG1vZGVsLlxuICAgICAqXG4gICAgICogQHJldHVybnMgSW5mZXJlbmNlIHJlc3VsdCB0ZW5zb3JzLiBUaGUgb3V0cHV0IHdvdWxkIGJlIHNpbmdsZSBgdGYuVGVuc29yYFxuICAgICAqIGlmIG1vZGVsIGhhcyBzaW5nbGUgb3V0cHV0IG5vZGUsIG90aGVyd2lzZSBUZW5zb3JbXSBvciBOYW1lZFRlbnNvck1hcFtdXG4gICAgICogd2lsbCBiZSByZXR1cm5lZCBmb3IgbW9kZWwgd2l0aCBtdWx0aXBsZSBvdXRwdXRzLlxuICAgICAqXG4gICAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICAgKi9cbiAgICBHcmFwaE1vZGVsLnByb3RvdHlwZS5wcmVkaWN0ID0gZnVuY3Rpb24gKGlucHV0cywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGUoaW5wdXRzLCB0aGlzLm91dHB1dE5vZGVzKTtcbiAgICB9O1xuICAgIEdyYXBoTW9kZWwucHJvdG90eXBlLm5vcm1hbGl6ZUlucHV0cyA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgaWYgKCEoaW5wdXRzIGluc3RhbmNlb2YgdGZPcHMuVGVuc29yKSAmJiAhQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICAgICAgICAvLyBUaGUgaW5wdXQgaXMgYWxyZWFkeSBhIE5hbWVkVGVuc29yTWFwLlxuICAgICAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICAgICAgfVxuICAgICAgICBpbnB1dHMgPSBBcnJheS5pc0FycmF5KGlucHV0cykgPyBpbnB1dHMgOiBbaW5wdXRzXTtcbiAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggIT09IHRoaXMuaW5wdXROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdGVuc29yIGNvdW50IG1pc21hdGNoLCcgK1xuICAgICAgICAgICAgICAgIChcInRoZSBncmFwaCBtb2RlbCBoYXMgXCIgKyB0aGlzLmlucHV0Tm9kZXMubGVuZ3RoICsgXCIgcGxhY2Vob2xkZXJzLCBcIikgK1xuICAgICAgICAgICAgICAgIChcIndoaWxlIHRoZXJlIGFyZSBcIiArIGlucHV0cy5sZW5ndGggKyBcIiBpbnB1dCB0ZW5zb3JzLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXROb2Rlcy5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgaW5wdXROYW1lLCBpKSB7XG4gICAgICAgICAgICBtYXBbaW5wdXROYW1lXSA9IGlucHV0c1tpXTtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIEdyYXBoTW9kZWwucHJvdG90eXBlLm5vcm1hbGl6ZU91dHB1dHMgPSBmdW5jdGlvbiAob3V0cHV0cykge1xuICAgICAgICBvdXRwdXRzID0gb3V0cHV0cyB8fCB0aGlzLm91dHB1dE5vZGVzO1xuICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkob3V0cHV0cykgPyBbb3V0cHV0c10gOiBvdXRwdXRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgaW5mZXJlbmNlIGZvciB0aGUgbW9kZWwgZm9yIGdpdmVuIGlucHV0IHRlbnNvcnMuXG4gICAgICogQHBhcmFtIGlucHV0cyB0ZW5zb3IsIHRlbnNvciBhcnJheSBvciB0ZW5zb3IgbWFwIG9mIHRoZSBpbnB1dHMgZm9yIHRoZVxuICAgICAqIG1vZGVsLCBrZXllZCBieSB0aGUgaW5wdXQgbm9kZSBuYW1lcy5cbiAgICAgKiBAcGFyYW0gb3V0cHV0cyBvdXRwdXQgbm9kZSBuYW1lIGZyb20gdGhlIFRlbnNvcmZsb3cgbW9kZWwsIGlmIG5vXG4gICAgICogb3V0cHV0cyBhcmUgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBvdXRwdXRzIG9mIHRoZSBtb2RlbCB3b3VsZCBiZSB1c2VkLlxuICAgICAqIFlvdSBjYW4gaW5zcGVjdCBpbnRlcm1lZGlhdGUgbm9kZXMgb2YgdGhlIG1vZGVsIGJ5IGFkZGluZyB0aGVtIHRvIHRoZVxuICAgICAqIG91dHB1dHMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHNpbmdsZSB0ZW5zb3IgaWYgcHJvdmlkZWQgd2l0aCBhIHNpbmdsZSBvdXRwdXQgb3Igbm8gb3V0cHV0c1xuICAgICAqIGFyZSBwcm92aWRlZCBhbmQgdGhlcmUgaXMgb25seSBvbmUgZGVmYXVsdCBvdXRwdXQsIG90aGVyd2lzZSByZXR1cm4gYVxuICAgICAqIHRlbnNvciBhcnJheS4gVGhlIG9yZGVyIG9mIHRoZSB0ZW5zb3IgYXJyYXkgaXMgdGhlIHNhbWUgYXMgdGhlIG91dHB1dHNcbiAgICAgKiBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHRoZSBvcmRlciBvZiBvdXRwdXROb2RlcyBhdHRyaWJ1dGUgb2YgdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICAgKi9cbiAgICBHcmFwaE1vZGVsLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0cykge1xuICAgICAgICBpbnB1dHMgPSB0aGlzLm5vcm1hbGl6ZUlucHV0cyhpbnB1dHMpO1xuICAgICAgICBvdXRwdXRzID0gdGhpcy5ub3JtYWxpemVPdXRwdXRzKG91dHB1dHMpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5leGVjdXRvci5leGVjdXRlKGlucHV0cywgb3V0cHV0cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID4gMSA/IHJlc3VsdCA6IHJlc3VsdFswXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGluZmVyZW5jZSBmb3IgdGhlIG1vZGVsIGZvciBnaXZlbiBpbnB1dCB0ZW5zb3JzIGluIGFzeW5jXG4gICAgICogZmFzaGlvbiwgdXNlIHRoaXMgbWV0aG9kIHdoZW4geW91ciBtb2RlbCBjb250YWlucyBjb250cm9sIGZsb3cgb3BzLlxuICAgICAqIEBwYXJhbSBpbnB1dHMgdGVuc29yLCB0ZW5zb3IgYXJyYXkgb3IgdGVuc29yIG1hcCBvZiB0aGUgaW5wdXRzIGZvciB0aGVcbiAgICAgKiBtb2RlbCwga2V5ZWQgYnkgdGhlIGlucHV0IG5vZGUgbmFtZXMuXG4gICAgICogQHBhcmFtIG91dHB1dHMgb3V0cHV0IG5vZGUgbmFtZSBmcm9tIHRoZSBUZW5zb3JmbG93IG1vZGVsLCBpZiBubyBvdXRwdXRzXG4gICAgICogYXJlIHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgb3V0cHV0cyBvZiB0aGUgbW9kZWwgd291bGQgYmUgdXNlZC4gWW91IGNhblxuICAgICAqIGluc3BlY3QgaW50ZXJtZWRpYXRlIG5vZGVzIG9mIHRoZSBtb2RlbCBieSBhZGRpbmcgdGhlbSB0byB0aGUgb3V0cHV0c1xuICAgICAqIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIG9mIHNpbmdsZSB0ZW5zb3IgaWYgcHJvdmlkZWQgd2l0aCBhIHNpbmdsZSBvdXRwdXQgb3JcbiAgICAgKiBubyBvdXRwdXRzIGFyZSBwcm92aWRlZCBhbmQgdGhlcmUgaXMgb25seSBvbmUgZGVmYXVsdCBvdXRwdXQsIG90aGVyd2lzZVxuICAgICAqIHJldHVybiBhIHRlbnNvciBtYXAuXG4gICAgICpcbiAgICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgICAqL1xuICAgIEdyYXBoTW9kZWwucHJvdG90eXBlLmV4ZWN1dGVBc3luYyA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0cyA9IHRoaXMubm9ybWFsaXplSW5wdXRzKGlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzID0gdGhpcy5ub3JtYWxpemVPdXRwdXRzKG91dHB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5leGVjdXRvci5leGVjdXRlQXN5bmMoaW5wdXRzLCBvdXRwdXRzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQubGVuZ3RoID4gMSA/IHJlc3VsdCA6IHJlc3VsdFswXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR3JhcGhNb2RlbC5wcm90b3R5cGUuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcCA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkucmVkdWNlKGZ1bmN0aW9uIChuZXdNYXAsIGtleSkge1xuICAgICAgICAgICAgbmV3TWFwW2tleV0gPSBbbWFwW2tleV1dO1xuICAgICAgICAgICAgcmV0dXJuIG5ld01hcDtcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgdGhlIG1lbW9yeSB1c2VkIGJ5IHRoZSB3ZWlnaHQgdGVuc29ycyBhbmQgcmVzb3VyY2VNYW5hZ2VyLlxuICAgICAqXG4gICAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICAgKi9cbiAgICBHcmFwaE1vZGVsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmV4ZWN1dG9yLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBHcmFwaE1vZGVsO1xufSgpKTtcbi8qKlxuICogTG9hZCBhIGdyYXBoIG1vZGVsIGdpdmVuIGEgVVJMIHRvIHRoZSBtb2RlbCBkZWZpbml0aW9uLlxuICpcbiAqIEV4YW1wbGUgb2YgbG9hZGluZyBNb2JpbGVOZXRWMiBmcm9tIGEgVVJMIGFuZCBtYWtpbmcgYSBwcmVkaWN0aW9uIHdpdGggYVxuICogemVyb3MgaW5wdXQ6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1vZGVsVXJsID1cbiAqICAgICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vdGZqcy1tb2RlbHMvc2F2ZWRtb2RlbC9tb2JpbGVuZXRfdjJfMS4wXzIyNC9tb2RlbC5qc29uJztcbiAqIGNvbnN0IG1vZGVsID0gYXdhaXQgdGYubG9hZEdyYXBoTW9kZWwobW9kZWxVcmwpO1xuICogY29uc3QgemVyb3MgPSB0Zi56ZXJvcyhbMSwgMjI0LCAyMjQsIDNdKTtcbiAqIG1vZGVsLnByZWRpY3QoemVyb3MpLnByaW50KCk7XG4gKiBgYGBcbiAqXG4gKiBFeGFtcGxlIG9mIGxvYWRpbmcgTW9iaWxlTmV0VjIgZnJvbSBhIFRGIEh1YiBVUkwgYW5kIG1ha2luZyBhIHByZWRpY3Rpb24gd2l0aFxuICogYSB6ZXJvcyBpbnB1dDpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbW9kZWxVcmwgPVxuICogICAgJ2h0dHBzOi8vdGZodWIuZGV2L2dvb2dsZS9pbWFnZW5ldC9tb2JpbGVuZXRfdjJfMTQwXzIyNC9jbGFzc2lmaWNhdGlvbi8yJztcbiAqIGNvbnN0IG1vZGVsID0gYXdhaXQgdGYubG9hZEdyYXBoTW9kZWwobW9kZWxVcmwsIHtmcm9tVEZIdWI6IHRydWV9KTtcbiAqIGNvbnN0IHplcm9zID0gdGYuemVyb3MoWzEsIDIyNCwgMjI0LCAzXSk7XG4gKiBtb2RlbC5wcmVkaWN0KHplcm9zKS5wcmludCgpO1xuICogYGBgXG4gKiBAcGFyYW0gbW9kZWxVcmwgVGhlIHVybCBvciBhbiBgaW8uSU9IYW5kbGVyYCB0aGF0IGxvYWRzIHRoZSBtb2RlbC5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBIVFRQIHJlcXVlc3QsIHdoaWNoIGFsbG93cyB0byBzZW5kIGNyZWRlbnRpYWxzXG4gKiAgICBhbmQgY3VzdG9tIGhlYWRlcnMuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdMb2FkaW5nJ31cbiAqL1xuZnVuY3Rpb24gbG9hZEdyYXBoTW9kZWwobW9kZWxVcmwsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vZGVsO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxVcmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbFVybCBpbiBsb2FkR3JhcGhNb2RlbCgpIGNhbm5vdCBiZSBudWxsLiBQbGVhc2UgcHJvdmlkZSBhIHVybCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3IgYW4gSU9IYW5kbGVyIHRoYXQgbG9hZHMgdGhlIG1vZGVsJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZyb21URkh1Yikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsVXJsLmxvYWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW9kZWxVcmwuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFVybCA9IG1vZGVsVXJsICsgJy8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFVybCA9IFwiXCIgKyBtb2RlbFVybCArIERFRkFVTFRfTU9ERUxfTkFNRSArIFRGSFVCX1NFQVJDSF9QQVJBTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlbCA9IG5ldyBHcmFwaE1vZGVsKG1vZGVsVXJsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbW9kZWwubG9hZCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG1vZGVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKiBAbGljZW5zZSBTZWUgdGhlIExJQ0VOU0UgZmlsZS4gKi9cbi8vIFRoaXMgY29kZSBpcyBhdXRvLWdlbmVyYXRlZCwgZG8gbm90IG1vZGlmeSB0aGlzIGZpbGUhXG52YXIgdmVyc2lvbiA9ICcyLjguNic7XG5cbmV4cG9ydHMuR3JhcGhNb2RlbCA9IEdyYXBoTW9kZWw7XG5leHBvcnRzLmRlcmVnaXN0ZXJPcCA9IGRlcmVnaXN0ZXJPcDtcbmV4cG9ydHMubG9hZEdyYXBoTW9kZWwgPSBsb2FkR3JhcGhNb2RlbDtcbmV4cG9ydHMucmVnaXN0ZXJPcCA9IHJlZ2lzdGVyT3A7XG5leHBvcnRzLnZlcnNpb25fY29udmVydGVyID0gdmVyc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmLWNvbnZlcnRlci5ub2RlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@tensorflow+tfjs-converter@2.8.6_@tensorflow+tfjs-core@2.8.6/node_modules/@tensorflow/tfjs-converter/dist/tf-converter.node.js\n");

/***/ })

};
;